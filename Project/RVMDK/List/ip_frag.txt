; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\ip_frag.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\ip_frag.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IC:\Users\Administrator\Desktop\lwip.practise\example6-1\Project\RVMDK\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\ip_frag.crf ..\..\lwip\src\core\ipv4\ip_frag.c]
                          THUMB

                          AREA ||i.ip_frag||, CODE, READONLY, ALIGN=2

                  ip_frag PROC
;;;666    err_t 
;;;667    ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;668    {
000004  b08c              SUB      sp,sp,#0x30
000006  4604              MOV      r4,r0
000008  4689              MOV      r9,r1
;;;669      struct pbuf *rambuf;
;;;670    #if IP_FRAG_USES_STATIC_BUF
;;;671      struct pbuf *header;
;;;672    #else
;;;673    #if !LWIP_NETIF_TX_SINGLE_PBUF
;;;674      struct pbuf *newpbuf;
;;;675    #endif
;;;676      struct ip_hdr *original_iphdr;
;;;677    #endif
;;;678      struct ip_hdr *iphdr;
;;;679      u16_t nfb;
;;;680      u16_t left, cop;
;;;681      u16_t mtu = netif->mtu;
00000a  f8b90020          LDRH     r0,[r9,#0x20]
00000e  9008              STR      r0,[sp,#0x20]
;;;682      u16_t ofo, omf;
;;;683      u16_t last;
;;;684      u16_t poff = IP_HLEN;
000010  2014              MOVS     r0,#0x14
000012  9004              STR      r0,[sp,#0x10]
;;;685      u16_t tmp;
;;;686    #if !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF
;;;687      u16_t newpbuflen = 0;
000014  f04f0800          MOV      r8,#0
;;;688      u16_t left_to_copy;
;;;689    #endif
;;;690    
;;;691      /* Get a RAM based MTU sized pbuf */
;;;692    #if IP_FRAG_USES_STATIC_BUF
;;;693      /* When using a static buffer, we use a PBUF_REF, which we will
;;;694       * use to reference the packet (without link header).
;;;695       * Layer and length is irrelevant.
;;;696       */
;;;697      rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
;;;698      if (rambuf == NULL) {
;;;699        LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
;;;700        return ERR_MEM;
;;;701      }
;;;702      rambuf->tot_len = rambuf->len = mtu;
;;;703      rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
;;;704    
;;;705      /* Copy the IP header in it */
;;;706      iphdr = (struct ip_hdr *)rambuf->payload;
;;;707      SMEMCPY(iphdr, p->payload, IP_HLEN);
;;;708    #else /* IP_FRAG_USES_STATIC_BUF */
;;;709      original_iphdr = (struct ip_hdr *)p->payload;
000018  6860              LDR      r0,[r4,#4]
00001a  900b              STR      r0,[sp,#0x2c]
;;;710      iphdr = original_iphdr;
00001c  9e0b              LDR      r6,[sp,#0x2c]
;;;711    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;712    
;;;713      /* Save original offset */
;;;714      tmp = ntohs(IPH_OFFSET(iphdr));
00001e  88f0              LDRH     r0,[r6,#6]
000020  f7fffffe          BL       lwip_ntohs
000024  9003              STR      r0,[sp,#0xc]
;;;715      ofo = tmp & IP_OFFMASK;
000026  9803              LDR      r0,[sp,#0xc]
000028  f3c0000c          UBFX     r0,r0,#0,#13
00002c  9007              STR      r0,[sp,#0x1c]
;;;716      omf = tmp & IP_MF;
00002e  9803              LDR      r0,[sp,#0xc]
000030  f4005000          AND      r0,r0,#0x2000
000034  9006              STR      r0,[sp,#0x18]
;;;717    
;;;718      left = p->tot_len - IP_HLEN;
000036  8920              LDRH     r0,[r4,#8]
000038  3814              SUBS     r0,r0,#0x14
00003a  b280              UXTH     r0,r0
00003c  9009              STR      r0,[sp,#0x24]
;;;719    
;;;720      nfb = (mtu - IP_HLEN) / 8;
00003e  9908              LDR      r1,[sp,#0x20]
000040  f1a10014          SUB      r0,r1,#0x14
000044  17c1              ASRS     r1,r0,#31
000046  eb007151          ADD      r1,r0,r1,LSR #29
00004a  f3c101cf          UBFX     r1,r1,#3,#16
00004e  910a              STR      r1,[sp,#0x28]
;;;721    
;;;722      while (left) {
000050  e0b1              B        |L1.438|
                  |L1.82|
;;;723        last = (left <= mtu - IP_HLEN);
000052  9808              LDR      r0,[sp,#0x20]
000054  3814              SUBS     r0,r0,#0x14
000056  9909              LDR      r1,[sp,#0x24]
000058  4288              CMP      r0,r1
00005a  db01              BLT      |L1.96|
00005c  2001              MOVS     r0,#1
00005e  e000              B        |L1.98|
                  |L1.96|
000060  2000              MOVS     r0,#0
                  |L1.98|
000062  9005              STR      r0,[sp,#0x14]
;;;724    
;;;725        /* Set new offset and MF flag */
;;;726        tmp = omf | (IP_OFFMASK & (ofo));
000064  9807              LDR      r0,[sp,#0x1c]
000066  f3c0000c          UBFX     r0,r0,#0,#13
00006a  9906              LDR      r1,[sp,#0x18]
00006c  4308              ORRS     r0,r0,r1
00006e  9003              STR      r0,[sp,#0xc]
;;;727        if (!last) {
000070  9805              LDR      r0,[sp,#0x14]
000072  b918              CBNZ     r0,|L1.124|
;;;728          tmp = tmp | IP_MF;
000074  9803              LDR      r0,[sp,#0xc]
000076  f4405000          ORR      r0,r0,#0x2000
00007a  9003              STR      r0,[sp,#0xc]
                  |L1.124|
;;;729        }
;;;730    
;;;731        /* Fill this fragment */
;;;732        cop = last ? left : nfb * 8;
00007c  9805              LDR      r0,[sp,#0x14]
00007e  b108              CBZ      r0,|L1.132|
000080  9809              LDR      r0,[sp,#0x24]
000082  e001              B        |L1.136|
                  |L1.132|
000084  980a              LDR      r0,[sp,#0x28]
000086  00c0              LSLS     r0,r0,#3
                  |L1.136|
000088  fa1ffb80          UXTH     r11,r0
;;;733    
;;;734    #if IP_FRAG_USES_STATIC_BUF
;;;735        poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
;;;736    #else /* IP_FRAG_USES_STATIC_BUF */
;;;737    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;738        rambuf = pbuf_alloc(PBUF_IP, cop, PBUF_RAM);
;;;739        if (rambuf == NULL) {
;;;740          return ERR_MEM;
;;;741        }
;;;742        LWIP_ASSERT("this needs a pbuf in one piece!",
;;;743          (rambuf->len == rambuf->tot_len) && (rambuf->next == NULL));
;;;744        poff += pbuf_copy_partial(p, rambuf->payload, cop, poff);
;;;745        /* make room for the IP header */
;;;746        if(pbuf_header(rambuf, IP_HLEN)) {
;;;747          pbuf_free(rambuf);
;;;748          return ERR_MEM;
;;;749        }
;;;750        /* fill in the IP header */
;;;751        SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
;;;752        iphdr = rambuf->payload;
;;;753    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;754        /* When not using a static buffer, create a chain of pbufs.
;;;755         * The first will be a PBUF_RAM holding the link and IP header.
;;;756         * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
;;;757         * but limited to the size of an mtu.
;;;758         */
;;;759        rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
00008c  2200              MOVS     r2,#0
00008e  2114              MOVS     r1,#0x14
000090  2002              MOVS     r0,#2
000092  f7fffffe          BL       pbuf_alloc
000096  4605              MOV      r5,r0
;;;760        if (rambuf == NULL) {
000098  b925              CBNZ     r5,|L1.164|
;;;761          return ERR_MEM;
00009a  f04f30ff          MOV      r0,#0xffffffff
                  |L1.158|
;;;762        }
;;;763        LWIP_ASSERT("this needs a pbuf in one piece!",
;;;764                    (p->len >= (IP_HLEN)));
;;;765        SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
;;;766        iphdr = (struct ip_hdr *)rambuf->payload;
;;;767    
;;;768        /* Can just adjust p directly for needed offset. */
;;;769        p->payload = (u8_t *)p->payload + poff;
;;;770        p->len -= poff;
;;;771    
;;;772        left_to_copy = cop;
;;;773        while (left_to_copy) {
;;;774          struct pbuf_custom_ref *pcr;
;;;775          newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
;;;776          /* Is this pbuf already empty? */
;;;777          if (!newpbuflen) {
;;;778            p = p->next;
;;;779            continue;
;;;780          }
;;;781          pcr = ip_frag_alloc_pbuf_custom_ref();
;;;782          if (pcr == NULL) {
;;;783            pbuf_free(rambuf);
;;;784            return ERR_MEM;
;;;785          }
;;;786          /* Mirror this pbuf, although we might not need all of it. */
;;;787          newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
;;;788          if (newpbuf == NULL) {
;;;789            ip_frag_free_pbuf_custom_ref(pcr);
;;;790            pbuf_free(rambuf);
;;;791            return ERR_MEM;
;;;792          }
;;;793          pbuf_ref(p);
;;;794          pcr->original = p;
;;;795          pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
;;;796    
;;;797          /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
;;;798           * so that it is removed when pbuf_dechain is later called on rambuf.
;;;799           */
;;;800          pbuf_cat(rambuf, newpbuf);
;;;801          left_to_copy -= newpbuflen;
;;;802          if (left_to_copy) {
;;;803            p = p->next;
;;;804          }
;;;805        }
;;;806        poff = newpbuflen;
;;;807    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;808    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;809    
;;;810        /* Correct header */
;;;811        IPH_OFFSET_SET(iphdr, htons(tmp));
;;;812        IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
;;;813        IPH_CHKSUM_SET(iphdr, 0);
;;;814        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
;;;815    
;;;816    #if IP_FRAG_USES_STATIC_BUF
;;;817        if (last) {
;;;818          pbuf_realloc(rambuf, left + IP_HLEN);
;;;819        }
;;;820    
;;;821        /* This part is ugly: we alloc a RAM based pbuf for 
;;;822         * the link level header for each chunk and then 
;;;823         * free it.A PBUF_ROM style pbuf for which pbuf_header
;;;824         * worked would make things simpler.
;;;825         */
;;;826        header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
;;;827        if (header != NULL) {
;;;828          pbuf_chain(header, rambuf);
;;;829          netif->output(netif, header, dest);
;;;830          IPFRAG_STATS_INC(ip_frag.xmit);
;;;831          snmp_inc_ipfragcreates();
;;;832          pbuf_free(header);
;;;833        } else {
;;;834          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
;;;835          pbuf_free(rambuf);
;;;836          return ERR_MEM;
;;;837        }
;;;838    #else /* IP_FRAG_USES_STATIC_BUF */
;;;839        /* No need for separate header pbuf - we allowed room for it in rambuf
;;;840         * when allocated.
;;;841         */
;;;842        netif->output(netif, rambuf, dest);
;;;843        IPFRAG_STATS_INC(ip_frag.xmit);
;;;844    
;;;845        /* Unfortunately we can't reuse rambuf - the hardware may still be
;;;846         * using the buffer. Instead we free it (and the ensuing chain) and
;;;847         * recreate it next time round the loop. If we're lucky the hardware
;;;848         * will have already sent the packet, the free will really free, and
;;;849         * there will be zero memory penalty.
;;;850         */
;;;851        
;;;852        pbuf_free(rambuf);
;;;853    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;854        left -= cop;
;;;855        ofo += nfb;
;;;856      }
;;;857    #if IP_FRAG_USES_STATIC_BUF
;;;858      pbuf_free(rambuf);
;;;859    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;860      snmp_inc_ipfragoks();
;;;861      return ERR_OK;
;;;862    }
00009e  b00f              ADD      sp,sp,#0x3c
0000a0  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.164|
0000a4  bf00              NOP                            ;763
0000a6  8960              LDRH     r0,[r4,#0xa]          ;763
0000a8  2814              CMP      r0,#0x14              ;763
0000aa  da04              BGE      |L1.182|
0000ac  a045              ADR      r0,|L1.452|
0000ae  f7fffffe          BL       __2printf
0000b2  bf00              NOP                            ;763
                  |L1.180|
0000b4  e7fe              B        |L1.180|
                  |L1.182|
0000b6  bf00              NOP                            ;763
0000b8  2214              MOVS     r2,#0x14              ;765
0000ba  6868              LDR      r0,[r5,#4]            ;765
0000bc  990b              LDR      r1,[sp,#0x2c]         ;765
0000be  f7fffffe          BL       __aeabi_memcpy
0000c2  686e              LDR      r6,[r5,#4]            ;766
0000c4  6861              LDR      r1,[r4,#4]            ;769
0000c6  9804              LDR      r0,[sp,#0x10]         ;769
0000c8  4408              ADD      r0,r0,r1              ;769
0000ca  6060              STR      r0,[r4,#4]            ;769
0000cc  8961              LDRH     r1,[r4,#0xa]          ;770
0000ce  9804              LDR      r0,[sp,#0x10]         ;770
0000d0  1a08              SUBS     r0,r1,r0              ;770
0000d2  8160              STRH     r0,[r4,#0xa]          ;770
0000d4  f8cdb008          STR      r11,[sp,#8]           ;772
0000d8  e03f              B        |L1.346|
                  |L1.218|
0000da  8961              LDRH     r1,[r4,#0xa]          ;775
0000dc  9802              LDR      r0,[sp,#8]            ;775
0000de  4281              CMP      r1,r0                 ;775
0000e0  dd01              BLE      |L1.230|
0000e2  9802              LDR      r0,[sp,#8]            ;775
0000e4  e000              B        |L1.232|
                  |L1.230|
0000e6  8960              LDRH     r0,[r4,#0xa]          ;775
                  |L1.232|
0000e8  4680              MOV      r8,r0                 ;775
0000ea  f1b80f00          CMP      r8,#0                 ;777
0000ee  d101              BNE      |L1.244|
0000f0  6824              LDR      r4,[r4,#0]            ;778
0000f2  e032              B        |L1.346|
                  |L1.244|
0000f4  f7fffffe          BL       ip_frag_alloc_pbuf_custom_ref
0000f8  4607              MOV      r7,r0                 ;781
0000fa  b92f              CBNZ     r7,|L1.264|
0000fc  4628              MOV      r0,r5                 ;783
0000fe  f7fffffe          BL       pbuf_free
000102  f04f30ff          MOV      r0,#0xffffffff        ;784
000106  e7ca              B        |L1.158|
                  |L1.264|
000108  6860              LDR      r0,[r4,#4]            ;787
00010a  463b              MOV      r3,r7                 ;787
00010c  2202              MOVS     r2,#2                 ;787
00010e  4641              MOV      r1,r8                 ;787
000110  e9cd0800          STRD     r0,r8,[sp,#0]         ;787
000114  2003              MOVS     r0,#3                 ;787
000116  f7fffffe          BL       pbuf_alloced_custom
00011a  4682              MOV      r10,r0                ;787
00011c  f1ba0f00          CMP      r10,#0                ;788
000120  d108              BNE      |L1.308|
000122  4638              MOV      r0,r7                 ;789
000124  f7fffffe          BL       ip_frag_free_pbuf_custom_ref
000128  4628              MOV      r0,r5                 ;790
00012a  f7fffffe          BL       pbuf_free
00012e  f04f30ff          MOV      r0,#0xffffffff        ;791
000132  e7b4              B        |L1.158|
                  |L1.308|
000134  4620              MOV      r0,r4                 ;793
000136  f7fffffe          BL       pbuf_ref
00013a  617c              STR      r4,[r7,#0x14]         ;794
00013c  4829              LDR      r0,|L1.484|
00013e  6138              STR      r0,[r7,#0x10]         ;795
000140  4651              MOV      r1,r10                ;800
000142  4628              MOV      r0,r5                 ;800
000144  f7fffffe          BL       pbuf_cat
000148  9802              LDR      r0,[sp,#8]            ;801
00014a  eba00008          SUB      r0,r0,r8              ;801
00014e  b280              UXTH     r0,r0                 ;801
000150  9002              STR      r0,[sp,#8]            ;801
000152  9802              LDR      r0,[sp,#8]            ;802
000154  b100              CBZ      r0,|L1.344|
000156  6824              LDR      r4,[r4,#0]            ;803
                  |L1.344|
000158  bf00              NOP                            ;779
                  |L1.346|
00015a  9802              LDR      r0,[sp,#8]            ;773
00015c  2800              CMP      r0,#0                 ;773
00015e  d1bc              BNE      |L1.218|
000160  f8cd8010          STR      r8,[sp,#0x10]         ;806
000164  9803              LDR      r0,[sp,#0xc]          ;811
000166  f7fffffe          BL       lwip_htons
00016a  80f0              STRH     r0,[r6,#6]            ;811
00016c  f10b0114          ADD      r1,r11,#0x14          ;812
000170  b288              UXTH     r0,r1                 ;812
000172  f7fffffe          BL       lwip_htons
000176  8070              STRH     r0,[r6,#2]            ;812
000178  2000              MOVS     r0,#0                 ;813
00017a  8170              STRH     r0,[r6,#0xa]          ;813
00017c  2114              MOVS     r1,#0x14              ;814
00017e  4630              MOV      r0,r6                 ;814
000180  f7fffffe          BL       inet_chksum
000184  8170              STRH     r0,[r6,#0xa]          ;814
000186  f8d93014          LDR      r3,[r9,#0x14]         ;842
00018a  4629              MOV      r1,r5                 ;842
00018c  4648              MOV      r0,r9                 ;842
00018e  9a0e              LDR      r2,[sp,#0x38]         ;842
000190  4798              BLX      r3                    ;842
000192  4815              LDR      r0,|L1.488|
000194  8e00              LDRH     r0,[r0,#0x30]         ;843  ; lwip_stats
000196  1c40              ADDS     r0,r0,#1              ;843
000198  4913              LDR      r1,|L1.488|
00019a  8608              STRH     r0,[r1,#0x30]         ;843
00019c  4628              MOV      r0,r5                 ;852
00019e  f7fffffe          BL       pbuf_free
0001a2  9809              LDR      r0,[sp,#0x24]         ;854
0001a4  eba0000b          SUB      r0,r0,r11             ;854
0001a8  b280              UXTH     r0,r0                 ;854
0001aa  9009              STR      r0,[sp,#0x24]         ;854
0001ac  990a              LDR      r1,[sp,#0x28]         ;855
0001ae  9807              LDR      r0,[sp,#0x1c]         ;855
0001b0  4408              ADD      r0,r0,r1              ;855
0001b2  b280              UXTH     r0,r0                 ;855
0001b4  9007              STR      r0,[sp,#0x1c]         ;855
                  |L1.438|
0001b6  9809              LDR      r0,[sp,#0x24]         ;722
0001b8  2800              CMP      r0,#0                 ;722
0001ba  f47faf4a          BNE      |L1.82|
0001be  bf00              NOP                            ;861
0001c0  e76d              B        |L1.158|
;;;863    #endif /* IP_FRAG */
                          ENDP

0001c2  0000              DCW      0x0000
                  |L1.452|
0001c4  74686973          DCB      "this needs a pbuf in one piece!",0
0001c8  206e6565
0001cc  64732061
0001d0  20706275
0001d4  6620696e
0001d8  206f6e65
0001dc  20706965
0001e0  63652100
                  |L1.484|
                          DCD      ipfrag_free_pbuf_custom
                  |L1.488|
                          DCD      lwip_stats

                          AREA ||i.ip_frag_alloc_pbuf_custom_ref||, CODE, READONLY, ALIGN=1

                  ip_frag_alloc_pbuf_custom_ref PROC
;;;623    static struct pbuf_custom_ref*
;;;624    ip_frag_alloc_pbuf_custom_ref(void)
000000  b510              PUSH     {r4,lr}
;;;625    {
;;;626      return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
000002  2006              MOVS     r0,#6
000004  f7fffffe          BL       memp_malloc
;;;627    }
000008  bd10              POP      {r4,pc}
;;;628    
                          ENDP


                          AREA ||i.ip_frag_free_pbuf_custom_ref||, CODE, READONLY, ALIGN=2

                  ip_frag_free_pbuf_custom_ref PROC
;;;630    static void
;;;631    ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
000000  b510              PUSH     {r4,lr}
;;;632    {
000002  4604              MOV      r4,r0
;;;633      LWIP_ASSERT("p != NULL", p != NULL);
000004  bf00              NOP      
000006  b924              CBNZ     r4,|L3.18|
000008  a005              ADR      r0,|L3.32|
00000a  f7fffffe          BL       __2printf
00000e  bf00              NOP      
                  |L3.16|
000010  e7fe              B        |L3.16|
                  |L3.18|
000012  bf00              NOP      
;;;634      memp_free(MEMP_FRAG_PBUF, p);
000014  4621              MOV      r1,r4
000016  2006              MOVS     r0,#6
000018  f7fffffe          BL       memp_free
;;;635    }
00001c  bd10              POP      {r4,pc}
;;;636    
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
000020  7020213d          DCB      "p != NULL",0
000024  204e554c
000028  4c00    
00002a  00                DCB      0
00002b  00                DCB      0

                          AREA ||i.ip_reass||, CODE, READONLY, ALIGN=2

                  ip_reass PROC
;;;475    struct pbuf *
;;;476    ip_reass(struct pbuf *p)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;477    {
000004  4680              MOV      r8,r0
;;;478      struct pbuf *r;
;;;479      struct ip_hdr *fraghdr;
;;;480      struct ip_reassdata *ipr;
;;;481      struct ip_reass_helper *iprh;
;;;482      u16_t offset, len;
;;;483      u8_t clen;
;;;484      struct ip_reassdata *ipr_prev = NULL;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;485    
;;;486      IPFRAG_STATS_INC(ip_frag.recv);
00000a  4875              LDR      r0,|L4.480|
00000c  8e40              LDRH     r0,[r0,#0x32]
00000e  1c40              ADDS     r0,r0,#1
000010  b281              UXTH     r1,r0
000012  4873              LDR      r0,|L4.480|
000014  8641              STRH     r1,[r0,#0x32]
;;;487      snmp_inc_ipreasmreqds();
;;;488    
;;;489      fraghdr = (struct ip_hdr*)p->payload;
000016  f8d85004          LDR      r5,[r8,#4]
;;;490    
;;;491      if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
00001a  7828              LDRB     r0,[r5,#0]
00001c  f000000f          AND      r0,r0,#0xf
000020  2114              MOVS     r1,#0x14
000022  ebb10f80          CMP      r1,r0,LSL #2
000026  d00a              BEQ      |L4.62|
;;;492        LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
000028  bf00              NOP      
00002a  bf00              NOP      
;;;493        IPFRAG_STATS_INC(ip_frag.err);
00002c  486c              LDR      r0,|L4.480|
00002e  f8b00044          LDRH     r0,[r0,#0x44]
000032  1c40              ADDS     r0,r0,#1
000034  b281              UXTH     r1,r0
000036  486a              LDR      r0,|L4.480|
000038  f8a01044          STRH     r1,[r0,#0x44]
;;;494        goto nullreturn;
00003c  e0c2              B        |L4.452|
                  |L4.62|
;;;495      }
;;;496    
;;;497      offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
00003e  88e8              LDRH     r0,[r5,#6]
000040  f7fffffe          BL       lwip_ntohs
000044  f3c0000c          UBFX     r0,r0,#0,#13
000048  f64f71ff          MOV      r1,#0xffff
00004c  ea010ac0          AND      r10,r1,r0,LSL #3
;;;498      len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
000050  8868              LDRH     r0,[r5,#2]
000052  f7fffffe          BL       lwip_ntohs
000056  7829              LDRB     r1,[r5,#0]
000058  f001010f          AND      r1,r1,#0xf
00005c  eba00081          SUB      r0,r0,r1,LSL #2
000060  fa1ffb80          UXTH     r11,r0
;;;499    
;;;500      /* Check if we are allowed to enqueue more datagrams. */
;;;501      clen = pbuf_clen(p);
000064  4640              MOV      r0,r8
000066  f7fffffe          BL       pbuf_clen
00006a  4606              MOV      r6,r0
;;;502      if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
00006c  485d              LDR      r0,|L4.484|
00006e  8801              LDRH     r1,[r0,#0]  ; ip_reass_pbufcount
000070  1988              ADDS     r0,r1,r6
000072  280a              CMP      r0,#0xa
000074  dd12              BLE      |L4.156|
;;;503    #if IP_REASS_FREE_OLDEST
;;;504        if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
000076  4631              MOV      r1,r6
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       ip_reass_remove_oldest_datagram
00007e  b120              CBZ      r0,|L4.138|
;;;505            ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
000080  4858              LDR      r0,|L4.484|
000082  8800              LDRH     r0,[r0,#0]  ; ip_reass_pbufcount
000084  4430              ADD      r0,r0,r6
000086  280a              CMP      r0,#0xa
000088  dd08              BLE      |L4.156|
                  |L4.138|
;;;506    #endif /* IP_REASS_FREE_OLDEST */
;;;507        {
;;;508          /* No datagram could be freed and still too many pbufs enqueued */
;;;509          LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
00008a  bf00              NOP      
00008c  bf00              NOP      
;;;510            ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
;;;511          IPFRAG_STATS_INC(ip_frag.memerr);
00008e  4854              LDR      r0,|L4.480|
000090  8f80              LDRH     r0,[r0,#0x3c]
000092  1c40              ADDS     r0,r0,#1
000094  b281              UXTH     r1,r0
000096  4852              LDR      r0,|L4.480|
000098  8781              STRH     r1,[r0,#0x3c]
;;;512          /* @todo: send ICMP time exceeded here? */
;;;513          /* drop this pbuf */
;;;514          goto nullreturn;
00009a  e093              B        |L4.452|
                  |L4.156|
;;;515        }
;;;516      }
;;;517    
;;;518      /* Look for the datagram the fragment belongs to in the current datagram queue,
;;;519       * remembering the previous in the queue for later dequeueing. */
;;;520      for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
00009c  4852              LDR      r0,|L4.488|
00009e  6804              LDR      r4,[r0,#0]  ; reassdatagrams
0000a0  e01c              B        |L4.220|
                  |L4.162|
;;;521        /* Check if the incoming fragment matches the one currently present
;;;522           in the reassembly buffer. If so, we proceed with copying the
;;;523           fragment into the buffer. */
;;;524        if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
0000a2  6960              LDR      r0,[r4,#0x14]
0000a4  68e9              LDR      r1,[r5,#0xc]
0000a6  4288              CMP      r0,r1
0000a8  d109              BNE      |L4.190|
0000aa  69a0              LDR      r0,[r4,#0x18]
0000ac  6929              LDR      r1,[r5,#0x10]
0000ae  4288              CMP      r0,r1
0000b0  d105              BNE      |L4.190|
0000b2  89a0              LDRH     r0,[r4,#0xc]
0000b4  88a9              LDRH     r1,[r5,#4]
0000b6  4288              CMP      r0,r1
0000b8  d101              BNE      |L4.190|
0000ba  2001              MOVS     r0,#1
0000bc  e000              B        |L4.192|
                  |L4.190|
0000be  2000              MOVS     r0,#0
                  |L4.192|
0000c0  b150              CBZ      r0,|L4.216|
;;;525          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
0000c2  bf00              NOP      
0000c4  bf00              NOP      
;;;526            ntohs(IPH_ID(fraghdr))));
;;;527          IPFRAG_STATS_INC(ip_frag.cachehit);
0000c6  4846              LDR      r0,|L4.480|
0000c8  f8b00046          LDRH     r0,[r0,#0x46]
0000cc  1c40              ADDS     r0,r0,#1
0000ce  b281              UXTH     r1,r0
0000d0  4843              LDR      r0,|L4.480|
0000d2  f8a01046          STRH     r1,[r0,#0x46]
;;;528          break;
0000d6  e003              B        |L4.224|
                  |L4.216|
;;;529        }
;;;530        ipr_prev = ipr;
0000d8  9400              STR      r4,[sp,#0]
0000da  6824              LDR      r4,[r4,#0]            ;520
                  |L4.220|
0000dc  2c00              CMP      r4,#0                 ;520
0000de  d1e0              BNE      |L4.162|
                  |L4.224|
0000e0  bf00              NOP                            ;528
;;;531      }
;;;532    
;;;533      if (ipr == NULL) {
0000e2  b934              CBNZ     r4,|L4.242|
;;;534      /* Enqueue a new datagram into the datagram queue */
;;;535        ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
0000e4  4631              MOV      r1,r6
0000e6  4628              MOV      r0,r5
0000e8  f7fffffe          BL       ip_reass_enqueue_new_datagram
0000ec  4604              MOV      r4,r0
;;;536        /* Bail if unable to enqueue */
;;;537        if(ipr == NULL) {
0000ee  b994              CBNZ     r4,|L4.278|
;;;538          goto nullreturn;
0000f0  e068              B        |L4.452|
                  |L4.242|
;;;539        }
;;;540      } else {
;;;541        if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
0000f2  88e8              LDRH     r0,[r5,#6]
0000f4  f7fffffe          BL       lwip_ntohs
0000f8  f3c0000c          UBFX     r0,r0,#0,#13
0000fc  b958              CBNZ     r0,|L4.278|
;;;542          ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
0000fe  89e0              LDRH     r0,[r4,#0xe]
000100  f7fffffe          BL       lwip_ntohs
000104  f3c0000c          UBFX     r0,r0,#0,#13
000108  b128              CBZ      r0,|L4.278|
;;;543          /* ipr->iphdr is not the header from the first fragment, but fraghdr is
;;;544           * -> copy fraghdr into ipr->iphdr since we want to have the header
;;;545           * of the first fragment (for ICMP time exceeded and later, for copying
;;;546           * all options, if supported)*/
;;;547          SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
00010a  2214              MOVS     r2,#0x14
00010c  4629              MOV      r1,r5
00010e  f1040008          ADD      r0,r4,#8
000112  f7fffffe          BL       __aeabi_memcpy
                  |L4.278|
;;;548        }
;;;549      }
;;;550      /* Track the current number of pbufs current 'in-flight', in order to limit 
;;;551      the number of fragments that may be enqueued at any one time */
;;;552      ip_reass_pbufcount += clen;
000116  4833              LDR      r0,|L4.484|
000118  8800              LDRH     r0,[r0,#0]  ; ip_reass_pbufcount
00011a  4430              ADD      r0,r0,r6
00011c  4931              LDR      r1,|L4.484|
00011e  8008              STRH     r0,[r1,#0]
;;;553    
;;;554      /* At this point, we have either created a new entry or pointing 
;;;555       * to an existing one */
;;;556    
;;;557      /* check for 'no more fragments', and update queue entry*/
;;;558      if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
000120  79a8              LDRB     r0,[r5,#6]
000122  f0000020          AND      r0,r0,#0x20
000126  b940              CBNZ     r0,|L4.314|
;;;559        ipr->flags |= IP_REASS_FLAG_LASTFRAG;
000128  7fa0              LDRB     r0,[r4,#0x1e]
00012a  f0400001          ORR      r0,r0,#1
00012e  77a0              STRB     r0,[r4,#0x1e]
;;;560        ipr->datagram_len = offset + len;
000130  eb0a000b          ADD      r0,r10,r11
000134  83a0              STRH     r0,[r4,#0x1c]
;;;561        LWIP_DEBUGF(IP_REASS_DEBUG,
000136  bf00              NOP      
000138  bf00              NOP      
                  |L4.314|
;;;562         ("ip_reass: last fragment seen, total len %"S16_F"\n",
;;;563          ipr->datagram_len));
;;;564      }
;;;565      /* find the right place to insert this pbuf */
;;;566      /* @todo: trim pbufs if fragments are overlapping */
;;;567      if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
00013a  4641              MOV      r1,r8
00013c  4620              MOV      r0,r4
00013e  f7fffffe          BL       ip_reass_chain_frag_into_datagram_and_validate
000142  b3d0              CBZ      r0,|L4.442|
;;;568        /* the totally last fragment (flag more fragments = 0) was received at least
;;;569         * once AND all fragments are received */
;;;570        ipr->datagram_len += IP_HLEN;
000144  8ba0              LDRH     r0,[r4,#0x1c]
000146  3014              ADDS     r0,r0,#0x14
000148  83a0              STRH     r0,[r4,#0x1c]
;;;571    
;;;572        /* save the second pbuf before copying the header over the pointer */
;;;573        r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
00014a  6860              LDR      r0,[r4,#4]
00014c  6840              LDR      r0,[r0,#4]
00014e  6807              LDR      r7,[r0,#0]
;;;574    
;;;575        /* copy the original ip header back to the first pbuf */
;;;576        fraghdr = (struct ip_hdr*)(ipr->p->payload);
000150  6860              LDR      r0,[r4,#4]
000152  6845              LDR      r5,[r0,#4]
;;;577        SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
000154  2214              MOVS     r2,#0x14
000156  f1040108          ADD      r1,r4,#8
00015a  4628              MOV      r0,r5
00015c  f7fffffe          BL       __aeabi_memcpy
;;;578        IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
000160  8ba0              LDRH     r0,[r4,#0x1c]
000162  f7fffffe          BL       lwip_htons
000166  8068              STRH     r0,[r5,#2]
;;;579        IPH_OFFSET_SET(fraghdr, 0);
000168  2000              MOVS     r0,#0
00016a  80e8              STRH     r0,[r5,#6]
;;;580        IPH_CHKSUM_SET(fraghdr, 0);
00016c  8168              STRH     r0,[r5,#0xa]
;;;581        /* @todo: do we need to set calculate the correct checksum? */
;;;582        IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
00016e  2114              MOVS     r1,#0x14
000170  4628              MOV      r0,r5
000172  f7fffffe          BL       inet_chksum
000176  8168              STRH     r0,[r5,#0xa]
;;;583    
;;;584        p = ipr->p;
000178  f8d48004          LDR      r8,[r4,#4]
;;;585    
;;;586        /* chain together the pbufs contained within the reass_data list. */
;;;587        while(r != NULL) {
00017c  e00c              B        |L4.408|
                  |L4.382|
;;;588          iprh = (struct ip_reass_helper*)r->payload;
00017e  f8d79004          LDR      r9,[r7,#4]
;;;589    
;;;590          /* hide the ip header for every succeding fragment */
;;;591          pbuf_header(r, -IP_HLEN);
000182  f06f0113          MVN      r1,#0x13
000186  4638              MOV      r0,r7
000188  f7fffffe          BL       pbuf_header
;;;592          pbuf_cat(p, r);
00018c  4639              MOV      r1,r7
00018e  4640              MOV      r0,r8
000190  f7fffffe          BL       pbuf_cat
;;;593          r = iprh->next_pbuf;
000194  f8d97000          LDR      r7,[r9,#0]
                  |L4.408|
000198  2f00              CMP      r7,#0                 ;587
00019a  d1f0              BNE      |L4.382|
;;;594        }
;;;595        /* release the sources allocate for the fragment queue entry */
;;;596        ip_reass_dequeue_datagram(ipr, ipr_prev);
00019c  4620              MOV      r0,r4
00019e  9900              LDR      r1,[sp,#0]
0001a0  f7fffffe          BL       ip_reass_dequeue_datagram
;;;597    
;;;598        /* and adjust the number of pbufs currently queued for reassembly. */
;;;599        ip_reass_pbufcount -= pbuf_clen(p);
0001a4  4640              MOV      r0,r8
0001a6  f7fffffe          BL       pbuf_clen
0001aa  490e              LDR      r1,|L4.484|
0001ac  8809              LDRH     r1,[r1,#0]  ; ip_reass_pbufcount
0001ae  1a08              SUBS     r0,r1,r0
0001b0  490c              LDR      r1,|L4.484|
0001b2  8008              STRH     r0,[r1,#0]
;;;600    
;;;601        /* Return the pbuf chain */
;;;602        return p;
0001b4  4640              MOV      r0,r8
                  |L4.438|
;;;603      }
;;;604      /* the datagram is not (yet?) reassembled completely */
;;;605      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
;;;606      return NULL;
;;;607    
;;;608    nullreturn:
;;;609      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
;;;610      IPFRAG_STATS_INC(ip_frag.drop);
;;;611      pbuf_free(p);
;;;612      return NULL;
;;;613    }
0001b6  e8bd8ff8          POP      {r3-r11,pc}
                  |L4.442|
0001ba  e7ff              B        |L4.444|
                  |L4.444|
0001bc  bf00              NOP                            ;605
0001be  bf00              NOP                            ;605
0001c0  2000              MOVS     r0,#0                 ;606
0001c2  e7f8              B        |L4.438|
                  |L4.452|
0001c4  bf00              NOP                            ;609
0001c6  bf00              NOP                            ;609
0001c8  4805              LDR      r0,|L4.480|
0001ca  8ec0              LDRH     r0,[r0,#0x36]         ;610
0001cc  1c40              ADDS     r0,r0,#1              ;610
0001ce  b281              UXTH     r1,r0                 ;610
0001d0  4803              LDR      r0,|L4.480|
0001d2  86c1              STRH     r1,[r0,#0x36]         ;610
0001d4  4640              MOV      r0,r8                 ;611
0001d6  f7fffffe          BL       pbuf_free
0001da  2000              MOVS     r0,#0                 ;612
0001dc  e7eb              B        |L4.438|
;;;614    #endif /* IP_REASSEMBLY */
                          ENDP

0001de  0000              DCW      0x0000
                  |L4.480|
                          DCD      lwip_stats
                  |L4.484|
                          DCD      ip_reass_pbufcount
                  |L4.488|
                          DCD      reassdatagrams

                          AREA ||i.ip_reass_chain_frag_into_datagram_and_validate||, CODE, READONLY, ALIGN=2

                  ip_reass_chain_frag_into_datagram_and_validate PROC
;;;330    static int
;;;331    ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;332    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;333      struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
000008  2500              MOVS     r5,#0
;;;334      struct pbuf *q;
;;;335      u16_t offset,len;
;;;336      struct ip_hdr *fraghdr;
;;;337      int valid = 1;
00000a  f04f0b01          MOV      r11,#1
;;;338    
;;;339      /* Extract length and fragment offset from current fragment */
;;;340      fraghdr = (struct ip_hdr*)new_p->payload; 
00000e  f8d7a004          LDR      r10,[r7,#4]
;;;341      len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
000012  f8ba0002          LDRH     r0,[r10,#2]
000016  f7fffffe          BL       lwip_ntohs
00001a  f89a1000          LDRB     r1,[r10,#0]
00001e  f001010f          AND      r1,r1,#0xf
000022  eba00081          SUB      r0,r0,r1,LSL #2
000026  b280              UXTH     r0,r0
000028  9000              STR      r0,[sp,#0]
;;;342      offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
00002a  f8ba0006          LDRH     r0,[r10,#6]
00002e  f7fffffe          BL       lwip_ntohs
000032  f3c0000c          UBFX     r0,r0,#0,#13
000036  f64f71ff          MOV      r1,#0xffff
00003a  ea0100c0          AND      r0,r1,r0,LSL #3
00003e  9001              STR      r0,[sp,#4]
;;;343    
;;;344      /* overwrite the fragment's ip header from the pbuf with our helper struct,
;;;345       * and setup the embedded helper structure. */
;;;346      /* make sure the struct ip_reass_helper fits into the IP header */
;;;347      LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
000040  bf00              NOP      
000042  bf00              NOP      
;;;348                  sizeof(struct ip_reass_helper) <= IP_HLEN);
;;;349      iprh = (struct ip_reass_helper*)new_p->payload;
000044  687c              LDR      r4,[r7,#4]
;;;350      iprh->next_pbuf = NULL;
000046  2000              MOVS     r0,#0
000048  6020              STR      r0,[r4,#0]
;;;351      iprh->start = offset;
00004a  9801              LDR      r0,[sp,#4]
00004c  80a0              STRH     r0,[r4,#4]
;;;352      iprh->end = offset + len;
00004e  e9dd1000          LDRD     r1,r0,[sp,#0]
000052  4408              ADD      r0,r0,r1
000054  80e0              STRH     r0,[r4,#6]
;;;353    
;;;354      /* Iterate through until we either get to the end of the list (append),
;;;355       * or we find on with a larger offset (insert). */
;;;356      for (q = ipr->p; q != NULL;) {
000056  f8d69004          LDR      r9,[r6,#4]
00005a  e02e              B        |L5.186|
                  |L5.92|
;;;357        iprh_tmp = (struct ip_reass_helper*)q->payload;
00005c  f8d98004          LDR      r8,[r9,#4]
;;;358        if (iprh->start < iprh_tmp->start) {
000060  88a0              LDRH     r0,[r4,#4]
000062  f8b81004          LDRH     r1,[r8,#4]
000066  4288              CMP      r0,r1
000068  da10              BGE      |L5.140|
;;;359          /* the new pbuf should be inserted before this */
;;;360          iprh->next_pbuf = q;
00006a  f8c49000          STR      r9,[r4,#0]
;;;361          if (iprh_prev != NULL) {
00006e  b15d              CBZ      r5,|L5.136|
;;;362            /* not the fragment with the lowest offset */
;;;363    #if IP_REASS_CHECK_OVERLAP
;;;364            if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
000070  88a0              LDRH     r0,[r4,#4]
000072  88e9              LDRH     r1,[r5,#6]
000074  4288              CMP      r0,r1
000076  db04              BLT      |L5.130|
000078  88e0              LDRH     r0,[r4,#6]
00007a  f8b81004          LDRH     r1,[r8,#4]
00007e  4288              CMP      r0,r1
000080  dd00              BLE      |L5.132|
                  |L5.130|
;;;365              /* fragment overlaps with previous or following, throw away */
;;;366              goto freepbuf;
000082  e092              B        |L5.426|
                  |L5.132|
;;;367            }
;;;368    #endif /* IP_REASS_CHECK_OVERLAP */
;;;369            iprh_prev->next_pbuf = new_p;
000084  602f              STR      r7,[r5,#0]
000086  e000              B        |L5.138|
                  |L5.136|
;;;370          } else {
;;;371            /* fragment with the lowest offset */
;;;372            ipr->p = new_p;
000088  6077              STR      r7,[r6,#4]
                  |L5.138|
;;;373          }
;;;374          break;
00008a  e019              B        |L5.192|
                  |L5.140|
;;;375        } else if(iprh->start == iprh_tmp->start) {
00008c  88a0              LDRH     r0,[r4,#4]
00008e  f8b81004          LDRH     r1,[r8,#4]
000092  4288              CMP      r0,r1
000094  d100              BNE      |L5.152|
;;;376          /* received the same datagram twice: no need to keep the datagram */
;;;377          goto freepbuf;
000096  e088              B        |L5.426|
                  |L5.152|
;;;378    #if IP_REASS_CHECK_OVERLAP
;;;379        } else if(iprh->start < iprh_tmp->end) {
000098  88a0              LDRH     r0,[r4,#4]
00009a  f8b81006          LDRH     r1,[r8,#6]
00009e  4288              CMP      r0,r1
0000a0  da00              BGE      |L5.164|
;;;380          /* overlap: no need to keep the new datagram */
;;;381          goto freepbuf;
0000a2  e082              B        |L5.426|
                  |L5.164|
;;;382    #endif /* IP_REASS_CHECK_OVERLAP */
;;;383        } else {
;;;384          /* Check if the fragments received so far have no wholes. */
;;;385          if (iprh_prev != NULL) {
0000a4  b135              CBZ      r5,|L5.180|
;;;386            if (iprh_prev->end != iprh_tmp->start) {
0000a6  88e8              LDRH     r0,[r5,#6]
0000a8  f8b81004          LDRH     r1,[r8,#4]
0000ac  4288              CMP      r0,r1
0000ae  d001              BEQ      |L5.180|
;;;387              /* There is a fragment missing between the current
;;;388               * and the previous fragment */
;;;389              valid = 0;
0000b0  f04f0b00          MOV      r11,#0
                  |L5.180|
;;;390            }
;;;391          }
;;;392        }
;;;393        q = iprh_tmp->next_pbuf;
0000b4  f8d89000          LDR      r9,[r8,#0]
;;;394        iprh_prev = iprh_tmp;
0000b8  4645              MOV      r5,r8
                  |L5.186|
0000ba  f1b90f00          CMP      r9,#0                 ;356
0000be  d1cd              BNE      |L5.92|
                  |L5.192|
0000c0  bf00              NOP                            ;374
;;;395      }
;;;396    
;;;397      /* If q is NULL, then we made it to the end of the list. Determine what to do now */
;;;398      if (q == NULL) {
0000c2  f1b90f00          CMP      r9,#0
0000c6  d11d              BNE      |L5.260|
;;;399        if (iprh_prev != NULL) {
0000c8  b195              CBZ      r5,|L5.240|
;;;400          /* this is (for now), the fragment with the highest offset:
;;;401           * chain it to the last fragment */
;;;402    #if IP_REASS_CHECK_OVERLAP
;;;403          LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
0000ca  bf00              NOP      
0000cc  88e8              LDRH     r0,[r5,#6]
0000ce  88a1              LDRH     r1,[r4,#4]
0000d0  4288              CMP      r0,r1
0000d2  dd04              BLE      |L5.222|
0000d4  a03b              ADR      r0,|L5.452|
0000d6  f7fffffe          BL       __2printf
0000da  bf00              NOP      
                  |L5.220|
0000dc  e7fe              B        |L5.220|
                  |L5.222|
0000de  bf00              NOP      
;;;404    #endif /* IP_REASS_CHECK_OVERLAP */
;;;405          iprh_prev->next_pbuf = new_p;
0000e0  602f              STR      r7,[r5,#0]
;;;406          if (iprh_prev->end != iprh->start) {
0000e2  88e8              LDRH     r0,[r5,#6]
0000e4  88a1              LDRH     r1,[r4,#4]
0000e6  4288              CMP      r0,r1
0000e8  d00c              BEQ      |L5.260|
;;;407            valid = 0;
0000ea  f04f0b00          MOV      r11,#0
0000ee  e009              B        |L5.260|
                  |L5.240|
;;;408          }
;;;409        } else {
;;;410    #if IP_REASS_CHECK_OVERLAP
;;;411          LWIP_ASSERT("no previous fragment, this must be the first fragment!",
0000f0  bf00              NOP      
0000f2  6870              LDR      r0,[r6,#4]
0000f4  b120              CBZ      r0,|L5.256|
0000f6  a03b              ADR      r0,|L5.484|
0000f8  f7fffffe          BL       __2printf
0000fc  bf00              NOP      
                  |L5.254|
0000fe  e7fe              B        |L5.254|
                  |L5.256|
000100  bf00              NOP      
;;;412            ipr->p == NULL);
;;;413    #endif /* IP_REASS_CHECK_OVERLAP */
;;;414          /* this is the first fragment we ever received for this ip datagram */
;;;415          ipr->p = new_p;
000102  6077              STR      r7,[r6,#4]
                  |L5.260|
;;;416        }
;;;417      }
;;;418    
;;;419      /* At this point, the validation part begins: */
;;;420      /* If we already received the last fragment */
;;;421      if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
000104  7fb0              LDRB     r0,[r6,#0x1e]
000106  f0000001          AND      r0,r0,#1
00010a  2800              CMP      r0,#0
00010c  d04b              BEQ      |L5.422|
;;;422        /* and had no wholes so far */
;;;423        if (valid) {
00010e  f1bb0f00          CMP      r11,#0
000112  d045              BEQ      |L5.416|
;;;424          /* then check if the rest of the fragments is here */
;;;425          /* Check if the queue starts with the first datagram */
;;;426          if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
000114  6870              LDR      r0,[r6,#4]
000116  6840              LDR      r0,[r0,#4]
000118  8880              LDRH     r0,[r0,#4]
00011a  b110              CBZ      r0,|L5.290|
;;;427            valid = 0;
00011c  f04f0b00          MOV      r11,#0
000120  e03e              B        |L5.416|
                  |L5.290|
;;;428          } else {
;;;429            /* and check that there are no wholes after this datagram */
;;;430            iprh_prev = iprh;
000122  4625              MOV      r5,r4
;;;431            q = iprh->next_pbuf;
000124  f8d49000          LDR      r9,[r4,#0]
;;;432            while (q != NULL) {
000128  e00b              B        |L5.322|
                  |L5.298|
;;;433              iprh = (struct ip_reass_helper*)q->payload;
00012a  f8d94004          LDR      r4,[r9,#4]
;;;434              if (iprh_prev->end != iprh->start) {
00012e  88e8              LDRH     r0,[r5,#6]
000130  88a1              LDRH     r1,[r4,#4]
000132  4288              CMP      r0,r1
000134  d002              BEQ      |L5.316|
;;;435                valid = 0;
000136  f04f0b00          MOV      r11,#0
;;;436                break;
00013a  e005              B        |L5.328|
                  |L5.316|
;;;437              }
;;;438              iprh_prev = iprh;
00013c  4625              MOV      r5,r4
;;;439              q = iprh->next_pbuf;
00013e  f8d49000          LDR      r9,[r4,#0]
                  |L5.322|
000142  f1b90f00          CMP      r9,#0                 ;432
000146  d1f0              BNE      |L5.298|
                  |L5.328|
000148  bf00              NOP                            ;436
;;;440            }
;;;441            /* if still valid, all fragments are received
;;;442             * (because to the MF==0 already arrived */
;;;443            if (valid) {
00014a  f1bb0f00          CMP      r11,#0
00014e  d027              BEQ      |L5.416|
;;;444              LWIP_ASSERT("sanity check", ipr->p != NULL);
000150  bf00              NOP      
000152  6870              LDR      r0,[r6,#4]
000154  b920              CBNZ     r0,|L5.352|
000156  a031              ADR      r0,|L5.540|
000158  f7fffffe          BL       __2printf
00015c  bf00              NOP      
                  |L5.350|
00015e  e7fe              B        |L5.350|
                  |L5.352|
000160  bf00              NOP      
;;;445              LWIP_ASSERT("sanity check",
000162  bf00              NOP      
000164  6870              LDR      r0,[r6,#4]
000166  6840              LDR      r0,[r0,#4]
000168  42a0              CMP      r0,r4
00016a  d104              BNE      |L5.374|
00016c  a02b              ADR      r0,|L5.540|
00016e  f7fffffe          BL       __2printf
000172  bf00              NOP      
                  |L5.372|
000174  e7fe              B        |L5.372|
                  |L5.374|
000176  bf00              NOP      
;;;446                ((struct ip_reass_helper*)ipr->p->payload) != iprh);
;;;447              LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
000178  bf00              NOP      
00017a  6820              LDR      r0,[r4,#0]
00017c  b120              CBZ      r0,|L5.392|
00017e  a02b              ADR      r0,|L5.556|
000180  f7fffffe          BL       __2printf
000184  bf00              NOP      
                  |L5.390|
000186  e7fe              B        |L5.390|
                  |L5.392|
000188  bf00              NOP      
;;;448                iprh->next_pbuf == NULL);
;;;449              LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
00018a  bf00              NOP      
00018c  88e0              LDRH     r0,[r4,#6]
00018e  8bb1              LDRH     r1,[r6,#0x1c]
000190  4288              CMP      r0,r1
000192  d004              BEQ      |L5.414|
000194  a02e              ADR      r0,|L5.592|
000196  f7fffffe          BL       __2printf
00019a  bf00              NOP      
                  |L5.412|
00019c  e7fe              B        |L5.412|
                  |L5.414|
00019e  bf00              NOP      
                  |L5.416|
;;;450                iprh->end == ipr->datagram_len);
;;;451            }
;;;452          }
;;;453        }
;;;454        /* If valid is 0 here, there are some fragments missing in the middle
;;;455         * (since MF == 0 has already arrived). Such datagrams simply time out if
;;;456         * no more fragments are received... */
;;;457        return valid;
0001a0  4658              MOV      r0,r11
                  |L5.418|
;;;458      }
;;;459      /* If we come here, not all fragments were received, yet! */
;;;460      return 0; /* not yet valid! */
;;;461    #if IP_REASS_CHECK_OVERLAP
;;;462    freepbuf:
;;;463      ip_reass_pbufcount -= pbuf_clen(new_p);
;;;464      pbuf_free(new_p);
;;;465      return 0;
;;;466    #endif /* IP_REASS_CHECK_OVERLAP */
;;;467    }
0001a2  e8bd9ffc          POP      {r2-r12,pc}
                  |L5.422|
0001a6  2000              MOVS     r0,#0                 ;460
0001a8  e7fb              B        |L5.418|
                  |L5.426|
0001aa  4638              MOV      r0,r7                 ;463
0001ac  f7fffffe          BL       pbuf_clen
0001b0  4933              LDR      r1,|L5.640|
0001b2  8809              LDRH     r1,[r1,#0]            ;463  ; ip_reass_pbufcount
0001b4  1a08              SUBS     r0,r1,r0              ;463
0001b6  4932              LDR      r1,|L5.640|
0001b8  8008              STRH     r0,[r1,#0]            ;463
0001ba  4638              MOV      r0,r7                 ;464
0001bc  f7fffffe          BL       pbuf_free
0001c0  2000              MOVS     r0,#0                 ;465
0001c2  e7ee              B        |L5.418|
;;;468    
                          ENDP

                  |L5.452|
0001c4  63686563          DCB      "check fragments don't overlap",0
0001c8  6b206672
0001cc  61676d65
0001d0  6e747320
0001d4  646f6e27
0001d8  74206f76
0001dc  65726c61
0001e0  7000    
0001e2  00                DCB      0
0001e3  00                DCB      0
                  |L5.484|
0001e4  6e6f2070          DCB      "no previous fragment, this must be the first fragment!",0
0001e8  72657669
0001ec  6f757320
0001f0  66726167
0001f4  6d656e74
0001f8  2c207468
0001fc  6973206d
000200  75737420
000204  62652074
000208  68652066
00020c  69727374
000210  20667261
000214  676d656e
000218  742100  
00021b  00                DCB      0
                  |L5.540|
00021c  73616e69          DCB      "sanity check",0
000220  74792063
000224  6865636b
000228  00      
000229  00                DCB      0
00022a  00                DCB      0
00022b  00                DCB      0
                  |L5.556|
00022c  76616c69          DCB      "validate_datagram:next_pbuf!=NULL",0
000230  64617465
000234  5f646174
000238  61677261
00023c  6d3a6e65
000240  78745f70
000244  62756621
000248  3d4e554c
00024c  4c00    
00024e  00                DCB      0
00024f  00                DCB      0
                  |L5.592|
000250  76616c69          DCB      "validate_datagram:datagram end!=datagram len",0
000254  64617465
000258  5f646174
00025c  61677261
000260  6d3a6461
000264  74616772
000268  616d2065
00026c  6e64213d
000270  64617461
000274  6772616d
000278  206c656e
00027c  00      
00027d  00                DCB      0
00027e  00                DCB      0
00027f  00                DCB      0
                  |L5.640|
                          DCD      ip_reass_pbufcount

                          AREA ||i.ip_reass_dequeue_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_dequeue_datagram PROC
;;;303    static void
;;;304    ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000000  b570              PUSH     {r4-r6,lr}
;;;305    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;306      
;;;307      /* dequeue the reass struct  */
;;;308      if (reassdatagrams == ipr) {
000006  480b              LDR      r0,|L6.52|
000008  6800              LDR      r0,[r0,#0]  ; reassdatagrams
00000a  42a0              CMP      r0,r4
00000c  d103              BNE      |L6.22|
;;;309        /* it was the first in the list */
;;;310        reassdatagrams = ipr->next;
00000e  4909              LDR      r1,|L6.52|
000010  6820              LDR      r0,[r4,#0]
000012  6008              STR      r0,[r1,#0]  ; reassdatagrams
000014  e009              B        |L6.42|
                  |L6.22|
;;;311      } else {
;;;312        /* it wasn't the first, so it must have a valid 'prev' */
;;;313        LWIP_ASSERT("sanity check linked list", prev != NULL);
000016  bf00              NOP      
000018  b925              CBNZ     r5,|L6.36|
00001a  a007              ADR      r0,|L6.56|
00001c  f7fffffe          BL       __2printf
000020  bf00              NOP      
                  |L6.34|
000022  e7fe              B        |L6.34|
                  |L6.36|
000024  bf00              NOP      
;;;314        prev->next = ipr->next;
000026  6820              LDR      r0,[r4,#0]
000028  6028              STR      r0,[r5,#0]
                  |L6.42|
;;;315      }
;;;316    
;;;317      /* now we can free the ip_reass struct */
;;;318      memp_free(MEMP_REASSDATA, ipr);
00002a  4621              MOV      r1,r4
00002c  2005              MOVS     r0,#5
00002e  f7fffffe          BL       memp_free
;;;319    }
000032  bd70              POP      {r4-r6,pc}
;;;320    
                          ENDP

                  |L6.52|
                          DCD      reassdatagrams
                  |L6.56|
000038  73616e69          DCB      "sanity check linked list",0
00003c  74792063
000040  6865636b
000044  206c696e
000048  6b656420
00004c  6c697374
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.ip_reass_enqueue_new_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_enqueue_new_datagram PROC
;;;268    static struct ip_reassdata*
;;;269    ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
000000  b570              PUSH     {r4-r6,lr}
;;;270    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;271      struct ip_reassdata* ipr;
;;;272      /* No matching previous fragment found, allocate a new reassdata struct */
;;;273      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       memp_malloc
00000c  4604              MOV      r4,r0
;;;274      if (ipr == NULL) {
00000e  b9a4              CBNZ     r4,|L7.58|
;;;275    #if IP_REASS_FREE_OLDEST
;;;276        if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
000010  4631              MOV      r1,r6
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       ip_reass_remove_oldest_datagram
000018  42b0              CMP      r0,r6
00001a  db03              BLT      |L7.36|
;;;277          ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       memp_malloc
000022  4604              MOV      r4,r0
                  |L7.36|
;;;278        }
;;;279        if (ipr == NULL)
000024  b94c              CBNZ     r4,|L7.58|
;;;280    #endif /* IP_REASS_FREE_OLDEST */
;;;281        {
;;;282          IPFRAG_STATS_INC(ip_frag.memerr);
000026  480e              LDR      r0,|L7.96|
000028  8f80              LDRH     r0,[r0,#0x3c]
00002a  1c40              ADDS     r0,r0,#1
00002c  b281              UXTH     r1,r0
00002e  480c              LDR      r0,|L7.96|
000030  8781              STRH     r1,[r0,#0x3c]
;;;283          LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
000032  bf00              NOP      
000034  bf00              NOP      
;;;284          return NULL;
000036  2000              MOVS     r0,#0
                  |L7.56|
;;;285        }
;;;286      }
;;;287      memset(ipr, 0, sizeof(struct ip_reassdata));
;;;288      ipr->timer = IP_REASS_MAXAGE;
;;;289    
;;;290      /* enqueue the new structure to the front of the list */
;;;291      ipr->next = reassdatagrams;
;;;292      reassdatagrams = ipr;
;;;293      /* copy the ip header for later tests and input */
;;;294      /* @todo: no ip options supported? */
;;;295      SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
;;;296      return ipr;
;;;297    }
000038  bd70              POP      {r4-r6,pc}
                  |L7.58|
00003a  2120              MOVS     r1,#0x20              ;287
00003c  4620              MOV      r0,r4                 ;287
00003e  f7fffffe          BL       __aeabi_memclr4
000042  2003              MOVS     r0,#3                 ;288
000044  77e0              STRB     r0,[r4,#0x1f]         ;288
000046  4807              LDR      r0,|L7.100|
000048  6800              LDR      r0,[r0,#0]            ;291  ; reassdatagrams
00004a  6020              STR      r0,[r4,#0]            ;291
00004c  4805              LDR      r0,|L7.100|
00004e  6004              STR      r4,[r0,#0]            ;292  ; reassdatagrams
000050  2214              MOVS     r2,#0x14              ;295
000052  4629              MOV      r1,r5                 ;295
000054  f1040008          ADD      r0,r4,#8              ;295
000058  f7fffffe          BL       __aeabi_memcpy
00005c  4620              MOV      r0,r4                 ;296
00005e  e7eb              B        |L7.56|
;;;298    
                          ENDP

                  |L7.96|
                          DCD      lwip_stats
                  |L7.100|
                          DCD      reassdatagrams

                          AREA ||i.ip_reass_free_complete_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_free_complete_datagram PROC
;;;157    static int
;;;158    ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;159    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;160      u16_t pbufs_freed = 0;
000008  2500              MOVS     r5,#0
;;;161      u8_t clen;
;;;162      struct pbuf *p;
;;;163      struct ip_reass_helper *iprh;
;;;164    
;;;165      LWIP_ASSERT("prev != ipr", prev != ipr);
00000a  bf00              NOP      
00000c  45a0              CMP      r8,r4
00000e  d104              BNE      |L8.26|
000010  a038              ADR      r0,|L8.244|
000012  f7fffffe          BL       __2printf
000016  bf00              NOP      
                  |L8.24|
000018  e7fe              B        |L8.24|
                  |L8.26|
00001a  bf00              NOP      
;;;166      if (prev != NULL) {
00001c  f1b80f00          CMP      r8,#0
000020  d00a              BEQ      |L8.56|
;;;167        LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
000022  bf00              NOP      
000024  f8d80000          LDR      r0,[r8,#0]
000028  42a0              CMP      r0,r4
00002a  d004              BEQ      |L8.54|
00002c  a034              ADR      r0,|L8.256|
00002e  f7fffffe          BL       __2printf
000032  bf00              NOP      
                  |L8.52|
000034  e7fe              B        |L8.52|
                  |L8.54|
000036  bf00              NOP      
                  |L8.56|
;;;168      }
;;;169    
;;;170      snmp_inc_ipreasmfails();
;;;171    #if LWIP_ICMP
;;;172      iprh = (struct ip_reass_helper *)ipr->p->payload;
000038  6860              LDR      r0,[r4,#4]
00003a  f8d09004          LDR      r9,[r0,#4]
;;;173      if (iprh->start == 0) {
00003e  f8b90004          LDRH     r0,[r9,#4]
000042  bb08              CBNZ     r0,|L8.136|
;;;174        /* The first fragment was received, send ICMP time exceeded. */
;;;175        /* First, de-queue the first pbuf from r->p. */
;;;176        p = ipr->p;
000044  6867              LDR      r7,[r4,#4]
;;;177        ipr->p = iprh->next_pbuf;
000046  f8d90000          LDR      r0,[r9,#0]
00004a  6060              STR      r0,[r4,#4]
;;;178        /* Then, copy the original header into it. */
;;;179        SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
00004c  2214              MOVS     r2,#0x14
00004e  f1040108          ADD      r1,r4,#8
000052  6878              LDR      r0,[r7,#4]
000054  f7fffffe          BL       __aeabi_memcpy
;;;180        icmp_time_exceeded(p, ICMP_TE_FRAG);
000058  2101              MOVS     r1,#1
00005a  4638              MOV      r0,r7
00005c  f7fffffe          BL       icmp_time_exceeded
;;;181        clen = pbuf_clen(p);
000060  4638              MOV      r0,r7
000062  f7fffffe          BL       pbuf_clen
000066  4606              MOV      r6,r0
;;;182        LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
000068  bf00              NOP      
00006a  19a8              ADDS     r0,r5,r6
00006c  f5b03f80          CMP      r0,#0x10000
000070  db04              BLT      |L8.124|
000072  a028              ADR      r0,|L8.276|
000074  f7fffffe          BL       __2printf
000078  bf00              NOP      
                  |L8.122|
00007a  e7fe              B        |L8.122|
                  |L8.124|
00007c  bf00              NOP      
;;;183        pbufs_freed += clen;
00007e  19a8              ADDS     r0,r5,r6
000080  b285              UXTH     r5,r0
;;;184        pbuf_free(p);
000082  4638              MOV      r0,r7
000084  f7fffffe          BL       pbuf_free
                  |L8.136|
;;;185      }
;;;186    #endif /* LWIP_ICMP */
;;;187    
;;;188      /* First, free all received pbufs.  The individual pbufs need to be released 
;;;189         separately as they have not yet been chained */
;;;190      p = ipr->p;
000088  6867              LDR      r7,[r4,#4]
;;;191      while (p != NULL) {
00008a  e019              B        |L8.192|
                  |L8.140|
;;;192        struct pbuf *pcur;
;;;193        iprh = (struct ip_reass_helper *)p->payload;
00008c  f8d79004          LDR      r9,[r7,#4]
;;;194        pcur = p;
000090  46ba              MOV      r10,r7
;;;195        /* get the next pointer before freeing */
;;;196        p = iprh->next_pbuf;
000092  f8d97000          LDR      r7,[r9,#0]
;;;197        clen = pbuf_clen(pcur);
000096  4650              MOV      r0,r10
000098  f7fffffe          BL       pbuf_clen
00009c  4606              MOV      r6,r0
;;;198        LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
00009e  bf00              NOP      
0000a0  19a8              ADDS     r0,r5,r6
0000a2  f5b03f80          CMP      r0,#0x10000
0000a6  db04              BLT      |L8.178|
0000a8  a01a              ADR      r0,|L8.276|
0000aa  f7fffffe          BL       __2printf
0000ae  bf00              NOP      
                  |L8.176|
0000b0  e7fe              B        |L8.176|
                  |L8.178|
0000b2  bf00              NOP      
;;;199        pbufs_freed += clen;
0000b4  19a8              ADDS     r0,r5,r6
0000b6  b285              UXTH     r5,r0
;;;200        pbuf_free(pcur);
0000b8  4650              MOV      r0,r10
0000ba  f7fffffe          BL       pbuf_free
;;;201      }
0000be  bf00              NOP      
                  |L8.192|
0000c0  2f00              CMP      r7,#0                 ;191
0000c2  d1e3              BNE      |L8.140|
;;;202      /* Then, unchain the struct ip_reassdata from the list and free it. */
;;;203      ip_reass_dequeue_datagram(ipr, prev);
0000c4  4641              MOV      r1,r8
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       ip_reass_dequeue_datagram
;;;204      LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
0000cc  bf00              NOP      
0000ce  4819              LDR      r0,|L8.308|
0000d0  8800              LDRH     r0,[r0,#0]  ; ip_reass_pbufcount
0000d2  42a8              CMP      r0,r5
0000d4  da04              BGE      |L8.224|
0000d6  a018              ADR      r0,|L8.312|
0000d8  f7fffffe          BL       __2printf
0000dc  bf00              NOP      
                  |L8.222|
0000de  e7fe              B        |L8.222|
                  |L8.224|
0000e0  bf00              NOP      
;;;205      ip_reass_pbufcount -= pbufs_freed;
0000e2  4814              LDR      r0,|L8.308|
0000e4  8800              LDRH     r0,[r0,#0]  ; ip_reass_pbufcount
0000e6  1b40              SUBS     r0,r0,r5
0000e8  4912              LDR      r1,|L8.308|
0000ea  8008              STRH     r0,[r1,#0]
;;;206    
;;;207      return pbufs_freed;
0000ec  4628              MOV      r0,r5
;;;208    }
0000ee  e8bd87f0          POP      {r4-r10,pc}
;;;209    
                          ENDP

0000f2  0000              DCW      0x0000
                  |L8.244|
0000f4  70726576          DCB      "prev != ipr",0
0000f8  20213d20
0000fc  69707200
                  |L8.256|
000100  70726576          DCB      "prev->next == ipr",0
000104  2d3e6e65
000108  7874203d
00010c  3d206970
000110  7200    
000112  00                DCB      0
000113  00                DCB      0
                  |L8.276|
000114  70627566          DCB      "pbufs_freed + clen <= 0xffff",0
000118  735f6672
00011c  65656420
000120  2b20636c
000124  656e203c
000128  3d203078
00012c  66666666
000130  00      
000131  00                DCB      0
000132  00                DCB      0
000133  00                DCB      0
                  |L8.308|
                          DCD      ip_reass_pbufcount
                  |L8.312|
000138  69705f72          DCB      "ip_reass_pbufcount >= clen",0
00013c  65617373
000140  5f706275
000144  66636f75
000148  6e74203e
00014c  3d20636c
000150  656e00  
000153  00                DCB      0

                          AREA ||i.ip_reass_remove_oldest_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_remove_oldest_datagram PROC
;;;220    static int
;;;221    ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;222    {
000004  4605              MOV      r5,r0
000006  4689              MOV      r9,r1
;;;223      /* @todo Can't we simply remove the last datagram in the
;;;224       *       linked list behind reassdatagrams?
;;;225       */
;;;226      struct ip_reassdata *r, *oldest, *prev;
;;;227      int pbufs_freed = 0, pbufs_freed_current;
000008  2700              MOVS     r7,#0
;;;228      int other_datagrams;
;;;229    
;;;230      /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
;;;231       * but don't free the datagram that 'fraghdr' belongs to! */
;;;232      do {
00000a  bf00              NOP      
                  |L9.12|
;;;233        oldest = NULL;
00000c  2600              MOVS     r6,#0
;;;234        prev = NULL;
00000e  46b3              MOV      r11,r6
;;;235        other_datagrams = 0;
000010  46b2              MOV      r10,r6
;;;236        r = reassdatagrams;
000012  4819              LDR      r0,|L9.120|
000014  6804              LDR      r4,[r0,#0]  ; reassdatagrams
;;;237        while (r != NULL) {
000016  e01d              B        |L9.84|
                  |L9.24|
;;;238          if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
000018  6960              LDR      r0,[r4,#0x14]
00001a  68e9              LDR      r1,[r5,#0xc]
00001c  4288              CMP      r0,r1
00001e  d107              BNE      |L9.48|
000020  69a0              LDR      r0,[r4,#0x18]
000022  6929              LDR      r1,[r5,#0x10]
000024  4288              CMP      r0,r1
000026  d103              BNE      |L9.48|
000028  89a0              LDRH     r0,[r4,#0xc]
00002a  88a9              LDRH     r1,[r5,#4]
00002c  4288              CMP      r0,r1
00002e  d001              BEQ      |L9.52|
                  |L9.48|
000030  2001              MOVS     r0,#1
000032  e000              B        |L9.54|
                  |L9.52|
000034  2000              MOVS     r0,#0
                  |L9.54|
000036  b148              CBZ      r0,|L9.76|
;;;239            /* Not the same datagram as fraghdr */
;;;240            other_datagrams++;
000038  f10a0a01          ADD      r10,r10,#1
;;;241            if (oldest == NULL) {
00003c  b90e              CBNZ     r6,|L9.66|
;;;242              oldest = r;
00003e  4626              MOV      r6,r4
000040  e004              B        |L9.76|
                  |L9.66|
;;;243            } else if (r->timer <= oldest->timer) {
000042  7fe0              LDRB     r0,[r4,#0x1f]
000044  7ff1              LDRB     r1,[r6,#0x1f]
000046  4288              CMP      r0,r1
000048  dc00              BGT      |L9.76|
;;;244              /* older than the previous oldest */
;;;245              oldest = r;
00004a  4626              MOV      r6,r4
                  |L9.76|
;;;246            }
;;;247          }
;;;248          if (r->next != NULL) {
00004c  6820              LDR      r0,[r4,#0]
00004e  b100              CBZ      r0,|L9.82|
;;;249            prev = r;
000050  46a3              MOV      r11,r4
                  |L9.82|
;;;250          }
;;;251          r = r->next;
000052  6824              LDR      r4,[r4,#0]
                  |L9.84|
000054  2c00              CMP      r4,#0                 ;237
000056  d1df              BNE      |L9.24|
;;;252        }
;;;253        if (oldest != NULL) {
000058  b12e              CBZ      r6,|L9.102|
;;;254          pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
00005a  4659              MOV      r1,r11
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       ip_reass_free_complete_datagram
000062  4680              MOV      r8,r0
;;;255          pbufs_freed += pbufs_freed_current;
000064  4447              ADD      r7,r7,r8
                  |L9.102|
;;;256        }
;;;257      } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
000066  454f              CMP      r7,r9
000068  da02              BGE      |L9.112|
00006a  f1ba0f01          CMP      r10,#1
00006e  dccd              BGT      |L9.12|
                  |L9.112|
;;;258      return pbufs_freed;
000070  4638              MOV      r0,r7
;;;259    }
000072  e8bd9ff0          POP      {r4-r12,pc}
;;;260    #endif /* IP_REASS_FREE_OLDEST */
                          ENDP

000076  0000              DCW      0x0000
                  |L9.120|
                          DCD      reassdatagrams

                          AREA ||i.ip_reass_tmr||, CODE, READONLY, ALIGN=2

                  ip_reass_tmr PROC
;;;121    void
;;;122    ip_reass_tmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;123    {
;;;124      struct ip_reassdata *r, *prev = NULL;
000002  2600              MOVS     r6,#0
;;;125    
;;;126      r = reassdatagrams;
000004  480c              LDR      r0,|L10.56|
000006  6804              LDR      r4,[r0,#0]  ; reassdatagrams
;;;127      while (r != NULL) {
000008  e013              B        |L10.50|
                  |L10.10|
;;;128        /* Decrement the timer. Once it reaches 0,
;;;129         * clean up the incomplete fragment assembly */
;;;130        if (r->timer > 0) {
00000a  7fe0              LDRB     r0,[r4,#0x1f]
00000c  2800              CMP      r0,#0
00000e  dd07              BLE      |L10.32|
;;;131          r->timer--;
000010  7fe0              LDRB     r0,[r4,#0x1f]
000012  1e40              SUBS     r0,r0,#1
000014  77e0              STRB     r0,[r4,#0x1f]
;;;132          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
000016  bf00              NOP      
000018  bf00              NOP      
;;;133          prev = r;
00001a  4626              MOV      r6,r4
;;;134          r = r->next;
00001c  6824              LDR      r4,[r4,#0]
00001e  e008              B        |L10.50|
                  |L10.32|
;;;135        } else {
;;;136          /* reassembly timed out */
;;;137          struct ip_reassdata *tmp;
;;;138          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
000020  bf00              NOP      
000022  bf00              NOP      
;;;139          tmp = r;
000024  4625              MOV      r5,r4
;;;140          /* get the next pointer before freeing */
;;;141          r = r->next;
000026  6824              LDR      r4,[r4,#0]
;;;142          /* free the helper struct and all enqueued pbufs */
;;;143          ip_reass_free_complete_datagram(tmp, prev);
000028  4631              MOV      r1,r6
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       ip_reass_free_complete_datagram
;;;144         }
000030  bf00              NOP      
                  |L10.50|
000032  2c00              CMP      r4,#0                 ;127
000034  d1e9              BNE      |L10.10|
;;;145       }
;;;146    }
000036  bd70              POP      {r4-r6,pc}
;;;147    
                          ENDP

                  |L10.56|
                          DCD      reassdatagrams

                          AREA ||i.ipfrag_free_pbuf_custom||, CODE, READONLY, ALIGN=2

                  ipfrag_free_pbuf_custom PROC
;;;639    static void
;;;640    ipfrag_free_pbuf_custom(struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;641    {
000002  4605              MOV      r5,r0
;;;642      struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
000004  462c              MOV      r4,r5
;;;643      LWIP_ASSERT("pcr != NULL", pcr != NULL);
000006  bf00              NOP      
000008  b924              CBNZ     r4,|L11.20|
00000a  a00c              ADR      r0,|L11.60|
00000c  f7fffffe          BL       __2printf
000010  bf00              NOP      
                  |L11.18|
000012  e7fe              B        |L11.18|
                  |L11.20|
000014  bf00              NOP      
;;;644      LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
000016  bf00              NOP      
000018  42ac              CMP      r4,r5
00001a  d004              BEQ      |L11.38|
00001c  a00a              ADR      r0,|L11.72|
00001e  f7fffffe          BL       __2printf
000022  bf00              NOP      
                  |L11.36|
000024  e7fe              B        |L11.36|
                  |L11.38|
000026  bf00              NOP      
;;;645      if (pcr->original != NULL) {
000028  6960              LDR      r0,[r4,#0x14]
00002a  b110              CBZ      r0,|L11.50|
;;;646        pbuf_free(pcr->original);
00002c  6960              LDR      r0,[r4,#0x14]
00002e  f7fffffe          BL       pbuf_free
                  |L11.50|
;;;647      }
;;;648      ip_frag_free_pbuf_custom_ref(pcr);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       ip_frag_free_pbuf_custom_ref
;;;649    }
000038  bd70              POP      {r4-r6,pc}
;;;650    #endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
                          ENDP

00003a  0000              DCW      0x0000
                  |L11.60|
00003c  70637220          DCB      "pcr != NULL",0
000040  213d204e
000044  554c4c00
                  |L11.72|
000048  70637220          DCB      "pcr == p",0
00004c  3d3d2070
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  reassdatagrams
                          DCD      0x00000000
                  ip_reass_pbufcount
000004  0000              DCB      0x00,0x00
