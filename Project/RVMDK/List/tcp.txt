; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\tcp.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\tcp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IC:\Users\Administrator\Desktop\lwip.practise\example6-1\Project\RVMDK\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\tcp.crf ..\..\lwip\src\core\tcp.c]
                          THUMB

                          AREA ||i.tcp_abandon||, CODE, READONLY, ALIGN=2

                  tcp_abandon PROC
;;;356    void
;;;357    tcp_abandon(struct tcp_pcb *pcb, int reset)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;358    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;359      u32_t seqno, ackno;
;;;360    #if LWIP_CALLBACK_API  
;;;361      tcp_err_fn errf;
;;;362    #endif /* LWIP_CALLBACK_API */
;;;363      void *errf_arg;
;;;364    
;;;365      /* pcb->state LISTEN not allowed here */
;;;366      LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
000008  bf00              NOP      
00000a  7e20              LDRB     r0,[r4,#0x18]
00000c  2801              CMP      r0,#1
00000e  d104              BNE      |L1.26|
000010  a025              ADR      r0,|L1.168|
000012  f7fffffe          BL       __2printf
000016  bf00              NOP      
                  |L1.24|
000018  e7fe              B        |L1.24|
                  |L1.26|
00001a  bf00              NOP      
;;;367        pcb->state != LISTEN);
;;;368      /* Figure out on which TCP PCB list we are, and remove us. If we
;;;369         are in an active state, call the receive function associated with
;;;370         the PCB with a NULL argument, and send an RST to the remote end. */
;;;371      if (pcb->state == TIME_WAIT) {
00001c  7e20              LDRB     r0,[r4,#0x18]
00001e  280a              CMP      r0,#0xa
000020  d108              BNE      |L1.52|
;;;372        tcp_pcb_remove(&tcp_tw_pcbs, pcb);
000022  4621              MOV      r1,r4
000024  482d              LDR      r0,|L1.220|
000026  f7fffffe          BL       tcp_pcb_remove
;;;373        memp_free(MEMP_TCP_PCB, pcb);
00002a  4621              MOV      r1,r4
00002c  2002              MOVS     r0,#2
00002e  f7fffffe          BL       memp_free
000032  e036              B        |L1.162|
                  |L1.52|
;;;374      } else {
;;;375        seqno = pcb->snd_nxt;
000034  6d27              LDR      r7,[r4,#0x50]
;;;376        ackno = pcb->rcv_nxt;
000036  f8d48028          LDR      r8,[r4,#0x28]
;;;377    #if LWIP_CALLBACK_API
;;;378        errf = pcb->errf;
00003a  f8d4508c          LDR      r5,[r4,#0x8c]
;;;379    #endif /* LWIP_CALLBACK_API */
;;;380        errf_arg = pcb->callback_arg;
00003e  f8d49010          LDR      r9,[r4,#0x10]
;;;381        TCP_PCB_REMOVE_ACTIVE(pcb);
000042  bf00              NOP      
000044  4621              MOV      r1,r4
000046  4826              LDR      r0,|L1.224|
000048  f7fffffe          BL       tcp_pcb_remove
00004c  2001              MOVS     r0,#1
00004e  4925              LDR      r1,|L1.228|
000050  7008              STRB     r0,[r1,#0]
000052  bf00              NOP      
;;;382        if (pcb->unacked != NULL) {
000054  6f20              LDR      r0,[r4,#0x70]
000056  b110              CBZ      r0,|L1.94|
;;;383          tcp_segs_free(pcb->unacked);
000058  6f20              LDR      r0,[r4,#0x70]
00005a  f7fffffe          BL       tcp_segs_free
                  |L1.94|
;;;384        }
;;;385        if (pcb->unsent != NULL) {
00005e  6ee0              LDR      r0,[r4,#0x6c]
000060  b110              CBZ      r0,|L1.104|
;;;386          tcp_segs_free(pcb->unsent);
000062  6ee0              LDR      r0,[r4,#0x6c]
000064  f7fffffe          BL       tcp_segs_free
                  |L1.104|
;;;387        }
;;;388    #if TCP_QUEUE_OOSEQ    
;;;389        if (pcb->ooseq != NULL) {
000068  6f60              LDR      r0,[r4,#0x74]
00006a  b110              CBZ      r0,|L1.114|
;;;390          tcp_segs_free(pcb->ooseq);
00006c  6f60              LDR      r0,[r4,#0x74]
00006e  f7fffffe          BL       tcp_segs_free
                  |L1.114|
;;;391        }
;;;392    #endif /* TCP_QUEUE_OOSEQ */
;;;393        if (reset) {
000072  b15e              CBZ      r6,|L1.140|
;;;394          LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
000074  bf00              NOP      
000076  bf00              NOP      
;;;395          tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
000078  8ba0              LDRH     r0,[r4,#0x1c]
00007a  8b61              LDRH     r1,[r4,#0x1a]
00007c  1d23              ADDS     r3,r4,#4
00007e  4622              MOV      r2,r4
000080  e9cd1000          STRD     r1,r0,[sp,#0]
000084  4641              MOV      r1,r8
000086  4638              MOV      r0,r7
000088  f7fffffe          BL       tcp_rst
                  |L1.140|
;;;396        }
;;;397        memp_free(MEMP_TCP_PCB, pcb);
00008c  4621              MOV      r1,r4
00008e  2002              MOVS     r0,#2
000090  f7fffffe          BL       memp_free
;;;398        TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
000094  bf00              NOP      
000096  b11d              CBZ      r5,|L1.160|
000098  f06f0109          MVN      r1,#9
00009c  4648              MOV      r0,r9
00009e  47a8              BLX      r5
                  |L1.160|
0000a0  bf00              NOP      
                  |L1.162|
;;;399      }
;;;400    }
0000a2  e8bd87fc          POP      {r2-r10,pc}
;;;401    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L1.168|
0000a8  646f6e27          DCB      "don't call tcp_abort/tcp_abandon for listen-pcbs",0
0000ac  74206361
0000b0  6c6c2074
0000b4  63705f61
0000b8  626f7274
0000bc  2f746370
0000c0  5f616261
0000c4  6e646f6e
0000c8  20666f72
0000cc  206c6973
0000d0  74656e2d
0000d4  70636273
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L1.220|
                          DCD      tcp_tw_pcbs
                  |L1.224|
                          DCD      tcp_active_pcbs
                  |L1.228|
                          DCD      tcp_active_pcbs_changed

                          AREA ||i.tcp_abort||, CODE, READONLY, ALIGN=1

                  tcp_abort PROC
;;;412    void
;;;413    tcp_abort(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;414    {
000002  4604              MOV      r4,r0
;;;415      tcp_abandon(pcb, 1);
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       tcp_abandon
;;;416    }
00000c  bd10              POP      {r4,pc}
;;;417    
                          ENDP


                          AREA ||i.tcp_accept||, CODE, READONLY, ALIGN=1

                  tcp_accept PROC
;;;1435   void
;;;1436   tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
000000  6141              STR      r1,[r0,#0x14]
;;;1437   {
;;;1438     /* This function is allowed to be called for both listen pcbs and
;;;1439        connection pcbs. */
;;;1440     pcb->accept = accept;
;;;1441   }
000002  4770              BX       lr
;;;1442   #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_accept_null||, CODE, READONLY, ALIGN=1

                  tcp_accept_null PROC
;;;493    static err_t
;;;494    tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
000000  4603              MOV      r3,r0
;;;495    {
;;;496      LWIP_UNUSED_ARG(arg);
;;;497      LWIP_UNUSED_ARG(pcb);
;;;498      LWIP_UNUSED_ARG(err);
;;;499    
;;;500      return ERR_ABRT;
000002  f06f0009          MVN      r0,#9
;;;501    }
000006  4770              BX       lr
;;;502    #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_alloc||, CODE, READONLY, ALIGN=2

                  tcp_alloc PROC
;;;1277   struct tcp_pcb *
;;;1278   tcp_alloc(u8_t prio)
000000  b570              PUSH     {r4-r6,lr}
;;;1279   {
000002  4606              MOV      r6,r0
;;;1280     struct tcp_pcb *pcb;
;;;1281     u32_t iss;
;;;1282     
;;;1283     pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       memp_malloc
00000a  4604              MOV      r4,r0
;;;1284     if (pcb == NULL) {
00000c  bb1c              CBNZ     r4,|L5.86|
;;;1285       /* Try killing oldest connection in TIME-WAIT. */
;;;1286       LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
00000e  bf00              NOP      
000010  bf00              NOP      
;;;1287       tcp_kill_timewait();
000012  f7fffffe          BL       tcp_kill_timewait
;;;1288       /* Try to allocate a tcp_pcb again. */
;;;1289       pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000016  2002              MOVS     r0,#2
000018  f7fffffe          BL       memp_malloc
00001c  4604              MOV      r4,r0
;;;1290       if (pcb == NULL) {
00001e  b98c              CBNZ     r4,|L5.68|
;;;1291         /* Try killing active connections with lower priority than the new one. */
;;;1292         LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
000020  bf00              NOP      
000022  bf00              NOP      
;;;1293         tcp_kill_prio(prio);
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       tcp_kill_prio
;;;1294         /* Try to allocate a tcp_pcb again. */
;;;1295         pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
00002a  2002              MOVS     r0,#2
00002c  f7fffffe          BL       memp_malloc
000030  4604              MOV      r4,r0
;;;1296         if (pcb != NULL) {
000032  b13c              CBZ      r4,|L5.68|
;;;1297           /* adjust err stats: memp_malloc failed twice before */
;;;1298           MEMP_STATS_DEC(err, MEMP_TCP_PCB);
000034  4827              LDR      r0,|L5.212|
000036  f8b000e2          LDRH     r0,[r0,#0xe2]
00003a  1e40              SUBS     r0,r0,#1
00003c  b281              UXTH     r1,r0
00003e  4825              LDR      r0,|L5.212|
000040  f8a010e2          STRH     r1,[r0,#0xe2]
                  |L5.68|
;;;1299         }
;;;1300       }
;;;1301       if (pcb != NULL) {
000044  b13c              CBZ      r4,|L5.86|
;;;1302         /* adjust err stats: timewait PCB was freed above */
;;;1303         MEMP_STATS_DEC(err, MEMP_TCP_PCB);
000046  4823              LDR      r0,|L5.212|
000048  f8b000e2          LDRH     r0,[r0,#0xe2]
00004c  1e40              SUBS     r0,r0,#1
00004e  b281              UXTH     r1,r0
000050  4820              LDR      r0,|L5.212|
000052  f8a010e2          STRH     r1,[r0,#0xe2]
                  |L5.86|
;;;1304       }
;;;1305     }
;;;1306     if (pcb != NULL) {
000056  2c00              CMP      r4,#0
000058  d03a              BEQ      |L5.208|
;;;1307       memset(pcb, 0, sizeof(struct tcp_pcb));
00005a  2198              MOVS     r1,#0x98
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       __aeabi_memclr4
;;;1308       pcb->prio = prio;
000062  3414              ADDS     r4,r4,#0x14
000064  7166              STRB     r6,[r4,#5]
;;;1309       pcb->snd_buf = TCP_SND_BUF;
000066  f44f607a          MOV      r0,#0xfa0
00006a  f8a40052          STRH     r0,[r4,#0x52]
;;;1310       pcb->snd_queuelen = 0;
00006e  2000              MOVS     r0,#0
000070  f8a40054          STRH     r0,[r4,#0x54]
;;;1311       pcb->rcv_wnd = TCP_WND;
000074  f44f607a          MOV      r0,#0xfa0
000078  8320              STRH     r0,[r4,#0x18]
;;;1312       pcb->rcv_ann_wnd = TCP_WND;
00007a  8360              STRH     r0,[r4,#0x1a]
;;;1313       pcb->tos = 0;
00007c  2000              MOVS     r0,#0
00007e  f8040c0b          STRB     r0,[r4,#-0xb]
;;;1314       pcb->ttl = TCP_TTL;
000082  20ff              MOVS     r0,#0xff
000084  f8040c0a          STRB     r0,[r4,#-0xa]
;;;1315       /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;1316          The send MSS is updated when an MSS option is received. */
;;;1317       pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
000088  f44f7006          MOV      r0,#0x218
00008c  8460              STRH     r0,[r4,#0x22]
;;;1318       pcb->rto = 3000 / TCP_SLOW_INTERVAL;
00008e  2006              MOVS     r0,#6
000090  8620              STRH     r0,[r4,#0x30]
;;;1319       pcb->sa = 0;
000092  2000              MOVS     r0,#0
000094  85a0              STRH     r0,[r4,#0x2c]
;;;1320       pcb->sv = 3000 / TCP_SLOW_INTERVAL;
000096  2006              MOVS     r0,#6
000098  85e0              STRH     r0,[r4,#0x2e]
;;;1321       pcb->rtime = -1;
00009a  1fc0              SUBS     r0,r0,#7
00009c  8420              STRH     r0,[r4,#0x20]
;;;1322       pcb->cwnd = 1;
00009e  2001              MOVS     r0,#1
0000a0  8720              STRH     r0,[r4,#0x38]
;;;1323       iss = tcp_next_iss();
0000a2  f7fffffe          BL       tcp_next_iss
0000a6  4605              MOV      r5,r0
;;;1324       pcb->snd_wl2 = iss;
0000a8  6465              STR      r5,[r4,#0x44]
;;;1325       pcb->snd_nxt = iss;
0000aa  63e5              STR      r5,[r4,#0x3c]
;;;1326       pcb->lastack = iss;
0000ac  6365              STR      r5,[r4,#0x34]
;;;1327       pcb->snd_lbb = iss;   
0000ae  64a5              STR      r5,[r4,#0x48]
;;;1328       pcb->tmr = tcp_ticks;
0000b0  4809              LDR      r0,|L5.216|
0000b2  6800              LDR      r0,[r0,#0]  ; tcp_ticks
0000b4  6120              STR      r0,[r4,#0x10]
;;;1329       pcb->last_timer = tcp_timer_ctr;
0000b6  4809              LDR      r0,|L5.220|
0000b8  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
0000ba  7360              STRB     r0,[r4,#0xd]
;;;1330   
;;;1331       pcb->polltmr = 0;
0000bc  2000              MOVS     r0,#0
0000be  72e0              STRB     r0,[r4,#0xb]
;;;1332   
;;;1333   #if LWIP_CALLBACK_API
;;;1334       pcb->recv = tcp_recv_null;
0000c0  4807              LDR      r0,|L5.224|
0000c2  66e0              STR      r0,[r4,#0x6c]
;;;1335   #endif /* LWIP_CALLBACK_API */  
;;;1336       
;;;1337       /* Init KEEPALIVE timer */
;;;1338       pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
0000c4  4807              LDR      r0,|L5.228|
0000c6  67e0              STR      r0,[r4,#0x7c]
;;;1339       
;;;1340   #if LWIP_TCP_KEEPALIVE
;;;1341       pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
;;;1342       pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
;;;1343   #endif /* LWIP_TCP_KEEPALIVE */
;;;1344   
;;;1345       pcb->keep_cnt_sent = 0;
0000c8  2000              MOVS     r0,#0
0000ca  f8840082          STRB     r0,[r4,#0x82]
0000ce  3c14              SUBS     r4,r4,#0x14
                  |L5.208|
;;;1346     }
;;;1347     return pcb;
0000d0  4620              MOV      r0,r4
;;;1348   }
0000d2  bd70              POP      {r4-r6,pc}
;;;1349   
                          ENDP

                  |L5.212|
                          DCD      lwip_stats
                  |L5.216|
                          DCD      tcp_ticks
                  |L5.220|
                          DCD      tcp_timer_ctr
                  |L5.224|
                          DCD      tcp_recv_null
                  |L5.228|
                          DCD      0x006ddd00

                          AREA ||i.tcp_arg||, CODE, READONLY, ALIGN=1

                  tcp_arg PROC
;;;1375   void
;;;1376   tcp_arg(struct tcp_pcb *pcb, void *arg)
000000  6101              STR      r1,[r0,#0x10]
;;;1377   {
;;;1378     /* This function is allowed to be called for both listen pcbs and
;;;1379        connection pcbs. */
;;;1380     pcb->callback_arg = arg;
;;;1381   }
000002  4770              BX       lr
;;;1382   #if LWIP_CALLBACK_API
                          ENDP


                          AREA ||i.tcp_bind||, CODE, READONLY, ALIGN=2

                  tcp_bind PROC
;;;432    err_t
;;;433    tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;434    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;435      int i;
;;;436      int max_pcb_list = NUM_TCP_PCB_LISTS;
00000a  f04f0904          MOV      r9,#4
;;;437      struct tcp_pcb *cpcb;
;;;438    
;;;439      LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
00000e  bf00              NOP      
000010  7e28              LDRB     r0,[r5,#0x18]
000012  b130              CBZ      r0,|L7.34|
000014  a020              ADR      r0,|L7.152|
000016  f7fffffe          BL       __2printf
00001a  f06f0005          MVN      r0,#5
                  |L7.30|
;;;440    
;;;441    #if SO_REUSE
;;;442      /* Unless the REUSEADDR flag is set,
;;;443         we have to check the pcbs in TIME-WAIT state, also.
;;;444         We do not dump TIME_WAIT pcb's; they can still be matched by incoming
;;;445         packets using both local and remote IP addresses and ports to distinguish.
;;;446       */
;;;447      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;448        max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
;;;449      }
;;;450    #endif /* SO_REUSE */
;;;451    
;;;452      if (port == 0) {
;;;453        port = tcp_new_port();
;;;454        if (port == 0) {
;;;455          return ERR_BUF;
;;;456        }
;;;457      }
;;;458    
;;;459      /* Check if the address already is in use (on all lists) */
;;;460      for (i = 0; i < max_pcb_list; i++) {
;;;461        for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;462          if (cpcb->local_port == port) {
;;;463    #if SO_REUSE
;;;464            /* Omit checking for the same port if both pcbs have REUSEADDR set.
;;;465               For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
;;;466               tcp_connect. */
;;;467            if (!ip_get_option(pcb, SOF_REUSEADDR) ||
;;;468                !ip_get_option(cpcb, SOF_REUSEADDR))
;;;469    #endif /* SO_REUSE */
;;;470            {
;;;471              if (ip_addr_isany(&(cpcb->local_ip)) ||
;;;472                  ip_addr_isany(ipaddr) ||
;;;473                  ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
;;;474                return ERR_USE;
;;;475              }
;;;476            }
;;;477          }
;;;478        }
;;;479      }
;;;480    
;;;481      if (!ip_addr_isany(ipaddr)) {
;;;482        pcb->local_ip = *ipaddr;
;;;483      }
;;;484      pcb->local_port = port;
;;;485      TCP_REG(&tcp_bound_pcbs, pcb);
;;;486      LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
;;;487      return ERR_OK;
;;;488    }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L7.34|
000022  bf00              NOP                            ;439
000024  b937              CBNZ     r7,|L7.52|
000026  f7fffffe          BL       tcp_new_port
00002a  4607              MOV      r7,r0                 ;453
00002c  b917              CBNZ     r7,|L7.52|
00002e  f06f0001          MVN      r0,#1                 ;455
000032  e7f4              B        |L7.30|
                  |L7.52|
000034  f04f0800          MOV      r8,#0                 ;460
000038  e019              B        |L7.110|
                  |L7.58|
00003a  4821              LDR      r0,|L7.192|
00003c  f8500028          LDR      r0,[r0,r8,LSL #2]     ;461
000040  6806              LDR      r6,[r0,#0]            ;461
000042  e010              B        |L7.102|
                  |L7.68|
000044  8b70              LDRH     r0,[r6,#0x1a]         ;462
000046  42b8              CMP      r0,r7                 ;462
000048  d10c              BNE      |L7.100|
00004a  b146              CBZ      r6,|L7.94|
00004c  6830              LDR      r0,[r6,#0]            ;471
00004e  b130              CBZ      r0,|L7.94|
000050  b12c              CBZ      r4,|L7.94|
000052  6820              LDR      r0,[r4,#0]            ;472
000054  b118              CBZ      r0,|L7.94|
000056  6830              LDR      r0,[r6,#0]            ;473
000058  6821              LDR      r1,[r4,#0]            ;473
00005a  4288              CMP      r0,r1                 ;473
00005c  d102              BNE      |L7.100|
                  |L7.94|
00005e  f06f0007          MVN      r0,#7                 ;474
000062  e7dc              B        |L7.30|
                  |L7.100|
000064  68f6              LDR      r6,[r6,#0xc]          ;461
                  |L7.102|
000066  2e00              CMP      r6,#0                 ;461
000068  d1ec              BNE      |L7.68|
00006a  f1080801          ADD      r8,r8,#1              ;460
                  |L7.110|
00006e  45c8              CMP      r8,r9                 ;460
000070  dbe3              BLT      |L7.58|
000072  b11c              CBZ      r4,|L7.124|
000074  6820              LDR      r0,[r4,#0]            ;481
000076  b108              CBZ      r0,|L7.124|
000078  6820              LDR      r0,[r4,#0]            ;482
00007a  6028              STR      r0,[r5,#0]            ;482
                  |L7.124|
00007c  836f              STRH     r7,[r5,#0x1a]         ;484
00007e  bf00              NOP                            ;485
000080  4810              LDR      r0,|L7.196|
000082  6800              LDR      r0,[r0,#0]            ;485  ; tcp_bound_pcbs
000084  60e8              STR      r0,[r5,#0xc]          ;485
000086  480f              LDR      r0,|L7.196|
000088  6005              STR      r5,[r0,#0]            ;485  ; tcp_bound_pcbs
00008a  f7fffffe          BL       tcp_timer_needed
00008e  bf00              NOP                            ;485
000090  bf00              NOP                            ;486
000092  bf00              NOP                            ;486
000094  2000              MOVS     r0,#0                 ;487
000096  e7c2              B        |L7.30|
;;;489    #if LWIP_CALLBACK_API
                          ENDP

                  |L7.152|
000098  7463705f          DCB      "tcp_bind: can only bind in state CLOSED",0
00009c  62696e64
0000a0  3a206361
0000a4  6e206f6e
0000a8  6c792062
0000ac  696e6420
0000b0  696e2073
0000b4  74617465
0000b8  20434c4f
0000bc  53454400
                  |L7.192|
                          DCD      tcp_pcb_lists
                  |L7.196|
                          DCD      tcp_bound_pcbs

                          AREA ||i.tcp_close||, CODE, READONLY, ALIGN=1

                  tcp_close PROC
;;;284    err_t
;;;285    tcp_close(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;286    {
000002  4604              MOV      r4,r0
;;;287    #if TCP_DEBUG
;;;288      LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
;;;289      tcp_debug_print_state(pcb->state);
;;;290    #endif /* TCP_DEBUG */
;;;291    
;;;292      if (pcb->state != LISTEN) {
000004  7e20              LDRB     r0,[r4,#0x18]
000006  2801              CMP      r0,#1
000008  d003              BEQ      |L8.18|
;;;293        /* Set a flag not to receive any more data... */
;;;294        pcb->flags |= TF_RXCLOSED;
00000a  7fa0              LDRB     r0,[r4,#0x1e]
00000c  f0400010          ORR      r0,r0,#0x10
000010  77a0              STRB     r0,[r4,#0x1e]
                  |L8.18|
;;;295      }
;;;296      /* ... and close */
;;;297      return tcp_close_shutdown(pcb, 1);
000012  2101              MOVS     r1,#1
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       tcp_close_shutdown
;;;298    }
00001a  bd10              POP      {r4,pc}
;;;299    
                          ENDP


                          AREA ||i.tcp_close_shutdown||, CODE, READONLY, ALIGN=2

                  tcp_close_shutdown PROC
;;;169    static err_t
;;;170    tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
000000  b57c              PUSH     {r2-r6,lr}
;;;171    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;172      err_t err;
;;;173    
;;;174      if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
000006  2e00              CMP      r6,#0
000008  d063              BEQ      |L9.210|
00000a  7e20              LDRB     r0,[r4,#0x18]
00000c  2804              CMP      r0,#4
00000e  d002              BEQ      |L9.22|
000010  7e20              LDRB     r0,[r4,#0x18]
000012  2807              CMP      r0,#7
000014  d15d              BNE      |L9.210|
                  |L9.22|
;;;175        if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
000016  6fa0              LDR      r0,[r4,#0x78]
000018  b918              CBNZ     r0,|L9.34|
00001a  8da0              LDRH     r0,[r4,#0x2c]
00001c  f5b06f7a          CMP      r0,#0xfa0
000020  d057              BEQ      |L9.210|
                  |L9.34|
;;;176          /* Not all data received by application, send RST to tell the remote
;;;177             side about this. */
;;;178          LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
000022  bf00              NOP      
000024  7fa0              LDRB     r0,[r4,#0x1e]
000026  f0000010          AND      r0,r0,#0x10
00002a  b920              CBNZ     r0,|L9.54|
00002c  a064              ADR      r0,|L9.448|
00002e  f7fffffe          BL       __2printf
000032  bf00              NOP      
                  |L9.52|
000034  e7fe              B        |L9.52|
                  |L9.54|
000036  bf00              NOP      
;;;179    
;;;180          /* don't call tcp_abort here: we must not deallocate the pcb since
;;;181             that might not be expected when calling tcp_close */
;;;182          tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
000038  8ba0              LDRH     r0,[r4,#0x1c]
00003a  8b61              LDRH     r1,[r4,#0x1a]
00003c  e9cd1000          STRD     r1,r0,[sp,#0]
000040  1d23              ADDS     r3,r4,#4
000042  4622              MOV      r2,r4
000044  6aa1              LDR      r1,[r4,#0x28]
000046  6d20              LDR      r0,[r4,#0x50]
000048  f7fffffe          BL       tcp_rst
;;;183            pcb->local_port, pcb->remote_port);
;;;184    
;;;185          tcp_pcb_purge(pcb);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       tcp_pcb_purge
;;;186          TCP_RMV_ACTIVE(pcb);
000052  bf00              NOP      
000054  bf00              NOP      
000056  4861              LDR      r0,|L9.476|
000058  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
00005a  42a0              CMP      r0,r4
00005c  d105              BNE      |L9.106|
00005e  485f              LDR      r0,|L9.476|
000060  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
000062  68c0              LDR      r0,[r0,#0xc]
000064  495d              LDR      r1,|L9.476|
000066  6008              STR      r0,[r1,#0]  ; tcp_active_pcbs
000068  e018              B        |L9.156|
                  |L9.106|
00006a  485c              LDR      r0,|L9.476|
00006c  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
00006e  495c              LDR      r1,|L9.480|
000070  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
000072  e00e              B        |L9.146|
                  |L9.116|
000074  485a              LDR      r0,|L9.480|
000076  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000078  68c0              LDR      r0,[r0,#0xc]
00007a  42a0              CMP      r0,r4
00007c  d104              BNE      |L9.136|
00007e  4958              LDR      r1,|L9.480|
000080  68e0              LDR      r0,[r4,#0xc]
000082  6809              LDR      r1,[r1,#0]  ; tcp_tmp_pcb
000084  60c8              STR      r0,[r1,#0xc]
000086  e008              B        |L9.154|
                  |L9.136|
000088  4855              LDR      r0,|L9.480|
00008a  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
00008c  68c0              LDR      r0,[r0,#0xc]
00008e  4954              LDR      r1,|L9.480|
000090  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
                  |L9.146|
000092  4853              LDR      r0,|L9.480|
000094  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000096  2800              CMP      r0,#0
000098  d1ec              BNE      |L9.116|
                  |L9.154|
00009a  bf00              NOP      
                  |L9.156|
00009c  2000              MOVS     r0,#0
00009e  60e0              STR      r0,[r4,#0xc]
0000a0  bf00              NOP      
0000a2  2001              MOVS     r0,#1
0000a4  494f              LDR      r1,|L9.484|
0000a6  7008              STRB     r0,[r1,#0]
0000a8  bf00              NOP      
;;;187          if (pcb->state == ESTABLISHED) {
0000aa  7e20              LDRB     r0,[r4,#0x18]
0000ac  2804              CMP      r0,#4
0000ae  d10a              BNE      |L9.198|
;;;188            /* move to TIME_WAIT since we close actively */
;;;189            pcb->state = TIME_WAIT;
0000b0  200a              MOVS     r0,#0xa
0000b2  7620              STRB     r0,[r4,#0x18]
;;;190            TCP_REG(&tcp_tw_pcbs, pcb);
0000b4  bf00              NOP      
0000b6  484c              LDR      r0,|L9.488|
0000b8  6800              LDR      r0,[r0,#0]  ; tcp_tw_pcbs
0000ba  60e0              STR      r0,[r4,#0xc]
0000bc  484a              LDR      r0,|L9.488|
0000be  6004              STR      r4,[r0,#0]  ; tcp_tw_pcbs
0000c0  f7fffffe          BL       tcp_timer_needed
0000c4  e003              B        |L9.206|
                  |L9.198|
;;;191          } else {
;;;192            /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
;;;193            memp_free(MEMP_TCP_PCB, pcb);
0000c6  4621              MOV      r1,r4
0000c8  2002              MOVS     r0,#2
0000ca  f7fffffe          BL       memp_free
                  |L9.206|
;;;194          }
;;;195          return ERR_OK;
0000ce  2000              MOVS     r0,#0
                  |L9.208|
;;;196        }
;;;197      }
;;;198    
;;;199      switch (pcb->state) {
;;;200      case CLOSED:
;;;201        /* Closing a pcb in the CLOSED state might seem erroneous,
;;;202         * however, it is in this state once allocated and as yet unused
;;;203         * and the user needs some way to free it should the need arise.
;;;204         * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
;;;205         * or for a pcb that has been used and then entered the CLOSED state 
;;;206         * is erroneous, but this should never happen as the pcb has in those cases
;;;207         * been freed, and so any remaining handles are bogus. */
;;;208        err = ERR_OK;
;;;209        if (pcb->local_port != 0) {
;;;210          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;211        }
;;;212        memp_free(MEMP_TCP_PCB, pcb);
;;;213        pcb = NULL;
;;;214        break;
;;;215      case LISTEN:
;;;216        err = ERR_OK;
;;;217        tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
;;;218        memp_free(MEMP_TCP_PCB_LISTEN, pcb);
;;;219        pcb = NULL;
;;;220        break;
;;;221      case SYN_SENT:
;;;222        err = ERR_OK;
;;;223        TCP_PCB_REMOVE_ACTIVE(pcb);
;;;224        memp_free(MEMP_TCP_PCB, pcb);
;;;225        pcb = NULL;
;;;226        snmp_inc_tcpattemptfails();
;;;227        break;
;;;228      case SYN_RCVD:
;;;229        err = tcp_send_fin(pcb);
;;;230        if (err == ERR_OK) {
;;;231          snmp_inc_tcpattemptfails();
;;;232          pcb->state = FIN_WAIT_1;
;;;233        }
;;;234        break;
;;;235      case ESTABLISHED:
;;;236        err = tcp_send_fin(pcb);
;;;237        if (err == ERR_OK) {
;;;238          snmp_inc_tcpestabresets();
;;;239          pcb->state = FIN_WAIT_1;
;;;240        }
;;;241        break;
;;;242      case CLOSE_WAIT:
;;;243        err = tcp_send_fin(pcb);
;;;244        if (err == ERR_OK) {
;;;245          snmp_inc_tcpestabresets();
;;;246          pcb->state = LAST_ACK;
;;;247        }
;;;248        break;
;;;249      default:
;;;250        /* Has already been closed, do nothing. */
;;;251        err = ERR_OK;
;;;252        pcb = NULL;
;;;253        break;
;;;254      }
;;;255    
;;;256      if (pcb != NULL && err == ERR_OK) {
;;;257        /* To ensure all data has been sent when tcp_close returns, we have
;;;258           to make sure tcp_output doesn't fail.
;;;259           Since we don't really have to ensure all data has been sent when tcp_close
;;;260           returns (unsent data is sent from tcp timer functions, also), we don't care
;;;261           for the return value of tcp_output for now. */
;;;262        /* @todo: When implementing SO_LINGER, this must be changed somehow:
;;;263           If SOF_LINGER is set, the data should be sent and acked before close returns.
;;;264           This can only be valid for sequential APIs, not for the raw API. */
;;;265        tcp_output(pcb);
;;;266      }
;;;267      return err;
;;;268    }
0000d0  bd7c              POP      {r2-r6,pc}
                  |L9.210|
0000d2  7e20              LDRB     r0,[r4,#0x18]         ;199
0000d4  2808              CMP      r0,#8                 ;199
0000d6  d268              BCS      |L9.426|
0000d8  e8dff000          TBB      [pc,r0]               ;199
0000dc  04343f4f          DCB      0x04,0x34,0x3f,0x4f
0000e0  5767675f          DCB      0x57,0x67,0x67,0x5f
0000e4  2500              MOVS     r5,#0                 ;208
0000e6  8b60              LDRH     r0,[r4,#0x1a]         ;209
0000e8  b330              CBZ      r0,|L9.312|
0000ea  bf00              NOP                            ;210
0000ec  483f              LDR      r0,|L9.492|
0000ee  6800              LDR      r0,[r0,#0]            ;210  ; tcp_bound_pcbs
0000f0  42a0              CMP      r0,r4                 ;210
0000f2  d105              BNE      |L9.256|
0000f4  483d              LDR      r0,|L9.492|
0000f6  6800              LDR      r0,[r0,#0]            ;210  ; tcp_bound_pcbs
0000f8  68c0              LDR      r0,[r0,#0xc]          ;210
0000fa  493c              LDR      r1,|L9.492|
0000fc  6008              STR      r0,[r1,#0]            ;210  ; tcp_bound_pcbs
0000fe  e018              B        |L9.306|
                  |L9.256|
000100  483a              LDR      r0,|L9.492|
000102  6800              LDR      r0,[r0,#0]            ;210  ; tcp_bound_pcbs
000104  4936              LDR      r1,|L9.480|
000106  6008              STR      r0,[r1,#0]            ;210  ; tcp_tmp_pcb
000108  e00e              B        |L9.296|
                  |L9.266|
00010a  4835              LDR      r0,|L9.480|
00010c  6800              LDR      r0,[r0,#0]            ;210  ; tcp_tmp_pcb
00010e  68c0              LDR      r0,[r0,#0xc]          ;210
000110  42a0              CMP      r0,r4                 ;210
000112  d104              BNE      |L9.286|
000114  4932              LDR      r1,|L9.480|
000116  68e0              LDR      r0,[r4,#0xc]          ;210
000118  6809              LDR      r1,[r1,#0]            ;210  ; tcp_tmp_pcb
00011a  60c8              STR      r0,[r1,#0xc]          ;210
00011c  e008              B        |L9.304|
                  |L9.286|
00011e  4830              LDR      r0,|L9.480|
000120  6800              LDR      r0,[r0,#0]            ;210  ; tcp_tmp_pcb
000122  68c0              LDR      r0,[r0,#0xc]          ;210
000124  492e              LDR      r1,|L9.480|
000126  6008              STR      r0,[r1,#0]            ;210  ; tcp_tmp_pcb
                  |L9.296|
000128  482d              LDR      r0,|L9.480|
00012a  6800              LDR      r0,[r0,#0]            ;210  ; tcp_tmp_pcb
00012c  2800              CMP      r0,#0                 ;210
00012e  d1ec              BNE      |L9.266|
                  |L9.304|
000130  bf00              NOP                            ;210
                  |L9.306|
000132  2000              MOVS     r0,#0                 ;210
000134  60e0              STR      r0,[r4,#0xc]          ;210
000136  bf00              NOP                            ;210
                  |L9.312|
000138  4621              MOV      r1,r4                 ;212
00013a  2002              MOVS     r0,#2                 ;212
00013c  f7fffffe          BL       memp_free
000140  2400              MOVS     r4,#0                 ;213
000142  e035              B        |L9.432|
000144  2500              MOVS     r5,#0                 ;216
000146  4621              MOV      r1,r4                 ;217
000148  4829              LDR      r0,|L9.496|
00014a  f7fffffe          BL       tcp_pcb_remove
00014e  4621              MOV      r1,r4                 ;218
000150  2003              MOVS     r0,#3                 ;218
000152  f7fffffe          BL       memp_free
000156  2400              MOVS     r4,#0                 ;219
000158  e02a              B        |L9.432|
00015a  2500              MOVS     r5,#0                 ;222
00015c  bf00              NOP                            ;223
00015e  4621              MOV      r1,r4                 ;223
000160  481e              LDR      r0,|L9.476|
000162  f7fffffe          BL       tcp_pcb_remove
000166  2001              MOVS     r0,#1                 ;223
000168  491e              LDR      r1,|L9.484|
00016a  7008              STRB     r0,[r1,#0]            ;223
00016c  bf00              NOP                            ;223
00016e  4621              MOV      r1,r4                 ;224
000170  2002              MOVS     r0,#2                 ;224
000172  f7fffffe          BL       memp_free
000176  2400              MOVS     r4,#0                 ;225
000178  e01a              B        |L9.432|
00017a  4620              MOV      r0,r4                 ;229
00017c  f7fffffe          BL       tcp_send_fin
000180  4605              MOV      r5,r0                 ;229
000182  b90d              CBNZ     r5,|L9.392|
000184  2005              MOVS     r0,#5                 ;232
000186  7620              STRB     r0,[r4,#0x18]         ;232
                  |L9.392|
000188  e012              B        |L9.432|
00018a  4620              MOV      r0,r4                 ;236
00018c  f7fffffe          BL       tcp_send_fin
000190  4605              MOV      r5,r0                 ;236
000192  b90d              CBNZ     r5,|L9.408|
000194  2005              MOVS     r0,#5                 ;239
000196  7620              STRB     r0,[r4,#0x18]         ;239
                  |L9.408|
000198  e00a              B        |L9.432|
00019a  4620              MOV      r0,r4                 ;243
00019c  f7fffffe          BL       tcp_send_fin
0001a0  4605              MOV      r5,r0                 ;243
0001a2  b90d              CBNZ     r5,|L9.424|
0001a4  2009              MOVS     r0,#9                 ;246
0001a6  7620              STRB     r0,[r4,#0x18]         ;246
                  |L9.424|
0001a8  e002              B        |L9.432|
                  |L9.426|
0001aa  2500              MOVS     r5,#0                 ;251
0001ac  2400              MOVS     r4,#0                 ;252
0001ae  bf00              NOP                            ;253
                  |L9.432|
0001b0  bf00              NOP                            ;214
0001b2  b11c              CBZ      r4,|L9.444|
0001b4  b915              CBNZ     r5,|L9.444|
0001b6  4620              MOV      r0,r4                 ;265
0001b8  f7fffffe          BL       tcp_output
                  |L9.444|
0001bc  4628              MOV      r0,r5                 ;267
0001be  e787              B        |L9.208|
;;;269    
                          ENDP

                  |L9.448|
0001c0  7063622d          DCB      "pcb->flags & TF_RXCLOSED",0
0001c4  3e666c61
0001c8  67732026
0001cc  2054465f
0001d0  5258434c
0001d4  4f534544
0001d8  00      
0001d9  00                DCB      0
0001da  00                DCB      0
0001db  00                DCB      0
                  |L9.476|
                          DCD      tcp_active_pcbs
                  |L9.480|
                          DCD      tcp_tmp_pcb
                  |L9.484|
                          DCD      tcp_active_pcbs_changed
                  |L9.488|
                          DCD      tcp_tw_pcbs
                  |L9.492|
                          DCD      tcp_bound_pcbs
                  |L9.496|
                          DCD      tcp_listen_pcbs

                          AREA ||i.tcp_connect||, CODE, READONLY, ALIGN=2

                  tcp_connect PROC
;;;683    err_t
;;;684    tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;685          tcp_connected_fn connected)
;;;686    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;687      err_t ret;
;;;688      u32_t iss;
;;;689      u16_t old_local_port;
;;;690    
;;;691      LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
00000c  bf00              NOP      
00000e  7e20              LDRB     r0,[r4,#0x18]
000010  b130              CBZ      r0,|L10.32|
000012  a04f              ADR      r0,|L10.336|
000014  f7fffffe          BL       __2printf
000018  f06f0008          MVN      r0,#8
                  |L10.28|
;;;692    
;;;693      LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
;;;694      if (ipaddr != NULL) {
;;;695        pcb->remote_ip = *ipaddr;
;;;696      } else {
;;;697        return ERR_VAL;
;;;698      }
;;;699      pcb->remote_port = port;
;;;700    
;;;701      /* check if we have a route to the remote host */
;;;702      if (ip_addr_isany(&(pcb->local_ip))) {
;;;703        /* no local IP address set, yet. */
;;;704        struct netif *netif = ip_route(&(pcb->remote_ip));
;;;705        if (netif == NULL) {
;;;706          /* Don't even try to send a SYN packet if we have no route
;;;707             since that will fail. */
;;;708          return ERR_RTE;
;;;709        }
;;;710        /* Use the netif's IP address as local address. */
;;;711        ip_addr_copy(pcb->local_ip, netif->ip_addr);
;;;712      }
;;;713    
;;;714      old_local_port = pcb->local_port;
;;;715      if (pcb->local_port == 0) {
;;;716        pcb->local_port = tcp_new_port();
;;;717        if (pcb->local_port == 0) {
;;;718          return ERR_BUF;
;;;719        }
;;;720      }
;;;721    #if SO_REUSE
;;;722      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;723        /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
;;;724           now that the 5-tuple is unique. */
;;;725        struct tcp_pcb *cpcb;
;;;726        int i;
;;;727        /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
;;;728        for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
;;;729          for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;730            if ((cpcb->local_port == pcb->local_port) &&
;;;731                (cpcb->remote_port == port) &&
;;;732                ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
;;;733                ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
;;;734              /* linux returns EISCONN here, but ERR_USE should be OK for us */
;;;735              return ERR_USE;
;;;736            }
;;;737          }
;;;738        }
;;;739      }
;;;740    #endif /* SO_REUSE */
;;;741      iss = tcp_next_iss();
;;;742      pcb->rcv_nxt = 0;
;;;743      pcb->snd_nxt = iss;
;;;744      pcb->lastack = iss - 1;
;;;745      pcb->snd_lbb = iss - 1;
;;;746      pcb->rcv_wnd = TCP_WND;
;;;747      pcb->rcv_ann_wnd = TCP_WND;
;;;748      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;749      pcb->snd_wnd = TCP_WND;
;;;750      /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;751         The send MSS is updated when an MSS option is received. */
;;;752      pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
;;;753    #if TCP_CALCULATE_EFF_SEND_MSS
;;;754      pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
;;;755    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;756      pcb->cwnd = 1;
;;;757      pcb->ssthresh = pcb->mss * 10;
;;;758    #if LWIP_CALLBACK_API
;;;759      pcb->connected = connected;
;;;760    #else /* LWIP_CALLBACK_API */  
;;;761      LWIP_UNUSED_ARG(connected);
;;;762    #endif /* LWIP_CALLBACK_API */
;;;763    
;;;764      /* Send a SYN together with the MSS option. */
;;;765      ret = tcp_enqueue_flags(pcb, TCP_SYN);
;;;766      if (ret == ERR_OK) {
;;;767        /* SYN segment was enqueued, changed the pcbs state now */
;;;768        pcb->state = SYN_SENT;
;;;769        if (old_local_port != 0) {
;;;770          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;771        }
;;;772        TCP_REG_ACTIVE(pcb);
;;;773        snmp_inc_tcpactiveopens();
;;;774    
;;;775        tcp_output(pcb);
;;;776      }
;;;777      return ret;
;;;778    }
00001c  e8bd9ff0          POP      {r4-r12,pc}
                  |L10.32|
000020  bf00              NOP                            ;691
000022  bf00              NOP                            ;693
000024  bf00              NOP                            ;693
000026  b116              CBZ      r6,|L10.46|
000028  6830              LDR      r0,[r6,#0]            ;695
00002a  6060              STR      r0,[r4,#4]            ;695
00002c  e002              B        |L10.52|
                  |L10.46|
00002e  f06f0005          MVN      r0,#5                 ;697
000032  e7f3              B        |L10.28|
                  |L10.52|
000034  f8a4801c          STRH     r8,[r4,#0x1c]         ;699
000038  b10c              CBZ      r4,|L10.62|
00003a  6820              LDR      r0,[r4,#0]            ;702
00003c  b968              CBNZ     r0,|L10.90|
                  |L10.62|
00003e  1d20              ADDS     r0,r4,#4              ;704
000040  f7fffffe          BL       ip_route
000044  4683              MOV      r11,r0                ;704
000046  f1bb0f00          CMP      r11,#0                ;705
00004a  d102              BNE      |L10.82|
00004c  f06f0003          MVN      r0,#3                 ;708
000050  e7e4              B        |L10.28|
                  |L10.82|
000052  f8db0004          LDR      r0,[r11,#4]           ;711
000056  6020              STR      r0,[r4,#0]            ;711
000058  bf00              NOP                            ;712
                  |L10.90|
00005a  f8b4a01a          LDRH     r10,[r4,#0x1a]        ;714
00005e  8b60              LDRH     r0,[r4,#0x1a]         ;715
000060  b938              CBNZ     r0,|L10.114|
000062  f7fffffe          BL       tcp_new_port
000066  8360              STRH     r0,[r4,#0x1a]         ;716
000068  8b60              LDRH     r0,[r4,#0x1a]         ;717
00006a  b910              CBNZ     r0,|L10.114|
00006c  f06f0001          MVN      r0,#1                 ;718
000070  e7d4              B        |L10.28|
                  |L10.114|
000072  f7fffffe          BL       tcp_next_iss
000076  4605              MOV      r5,r0                 ;741
000078  2000              MOVS     r0,#0                 ;742
00007a  f8440f28          STR      r0,[r4,#0x28]!        ;742
00007e  62a5              STR      r5,[r4,#0x28]         ;743
000080  1e68              SUBS     r0,r5,#1              ;744
000082  6220              STR      r0,[r4,#0x20]         ;744
000084  6360              STR      r0,[r4,#0x34]         ;745
000086  f44f607a          MOV      r0,#0xfa0             ;746
00008a  80a0              STRH     r0,[r4,#4]            ;746
00008c  80e0              STRH     r0,[r4,#6]            ;747
00008e  6820              LDR      r0,[r4,#0]            ;748
000090  60a0              STR      r0,[r4,#8]            ;748
000092  f44f607a          MOV      r0,#0xfa0             ;749
000096  8720              STRH     r0,[r4,#0x38]         ;749
000098  f44f7006          MOV      r0,#0x218             ;752
00009c  81e0              STRH     r0,[r4,#0xe]          ;752
00009e  89e0              LDRH     r0,[r4,#0xe]          ;754
0000a0  4631              MOV      r1,r6                 ;754
0000a2  f7fffffe          BL       tcp_eff_send_mss
0000a6  81e0              STRH     r0,[r4,#0xe]          ;754
0000a8  2001              MOVS     r0,#1                 ;756
0000aa  84a0              STRH     r0,[r4,#0x24]         ;756
0000ac  89e0              LDRH     r0,[r4,#0xe]          ;757
0000ae  eb000080          ADD      r0,r0,r0,LSL #2       ;757
0000b2  f64f71ff          MOV      r1,#0xffff            ;757
0000b6  ea010040          AND      r0,r1,r0,LSL #1       ;757
0000ba  84e0              STRH     r0,[r4,#0x26]         ;757
0000bc  f8c4905c          STR      r9,[r4,#0x5c]         ;759
0000c0  3c28              SUBS     r4,r4,#0x28           ;759
0000c2  2102              MOVS     r1,#2                 ;765
0000c4  4620              MOV      r0,r4                 ;765
0000c6  f7fffffe          BL       tcp_enqueue_flags
0000ca  4607              MOV      r7,r0                 ;765
0000cc  2f00              CMP      r7,#0                 ;766
0000ce  d13c              BNE      |L10.330|
0000d0  2002              MOVS     r0,#2                 ;768
0000d2  7620              STRB     r0,[r4,#0x18]         ;768
0000d4  f1ba0f00          CMP      r10,#0                ;769
0000d8  d026              BEQ      |L10.296|
0000da  bf00              NOP                            ;770
0000dc  4828              LDR      r0,|L10.384|
0000de  6800              LDR      r0,[r0,#0]            ;770  ; tcp_bound_pcbs
0000e0  42a0              CMP      r0,r4                 ;770
0000e2  d105              BNE      |L10.240|
0000e4  4826              LDR      r0,|L10.384|
0000e6  6800              LDR      r0,[r0,#0]            ;770  ; tcp_bound_pcbs
0000e8  68c0              LDR      r0,[r0,#0xc]          ;770
0000ea  4925              LDR      r1,|L10.384|
0000ec  6008              STR      r0,[r1,#0]            ;770  ; tcp_bound_pcbs
0000ee  e018              B        |L10.290|
                  |L10.240|
0000f0  4823              LDR      r0,|L10.384|
0000f2  6800              LDR      r0,[r0,#0]            ;770  ; tcp_bound_pcbs
0000f4  4923              LDR      r1,|L10.388|
0000f6  6008              STR      r0,[r1,#0]            ;770  ; tcp_tmp_pcb
0000f8  e00e              B        |L10.280|
                  |L10.250|
0000fa  4822              LDR      r0,|L10.388|
0000fc  6800              LDR      r0,[r0,#0]            ;770  ; tcp_tmp_pcb
0000fe  68c0              LDR      r0,[r0,#0xc]          ;770
000100  42a0              CMP      r0,r4                 ;770
000102  d104              BNE      |L10.270|
000104  491f              LDR      r1,|L10.388|
000106  68e0              LDR      r0,[r4,#0xc]          ;770
000108  6809              LDR      r1,[r1,#0]            ;770  ; tcp_tmp_pcb
00010a  60c8              STR      r0,[r1,#0xc]          ;770
00010c  e008              B        |L10.288|
                  |L10.270|
00010e  481d              LDR      r0,|L10.388|
000110  6800              LDR      r0,[r0,#0]            ;770  ; tcp_tmp_pcb
000112  68c0              LDR      r0,[r0,#0xc]          ;770
000114  491b              LDR      r1,|L10.388|
000116  6008              STR      r0,[r1,#0]            ;770  ; tcp_tmp_pcb
                  |L10.280|
000118  481a              LDR      r0,|L10.388|
00011a  6800              LDR      r0,[r0,#0]            ;770  ; tcp_tmp_pcb
00011c  2800              CMP      r0,#0                 ;770
00011e  d1ec              BNE      |L10.250|
                  |L10.288|
000120  bf00              NOP                            ;770
                  |L10.290|
000122  2000              MOVS     r0,#0                 ;770
000124  60e0              STR      r0,[r4,#0xc]          ;770
000126  bf00              NOP                            ;770
                  |L10.296|
000128  bf00              NOP                            ;772
00012a  bf00              NOP                            ;772
00012c  4816              LDR      r0,|L10.392|
00012e  6800              LDR      r0,[r0,#0]            ;772  ; tcp_active_pcbs
000130  60e0              STR      r0,[r4,#0xc]          ;772
000132  4815              LDR      r0,|L10.392|
000134  6004              STR      r4,[r0,#0]            ;772  ; tcp_active_pcbs
000136  f7fffffe          BL       tcp_timer_needed
00013a  bf00              NOP                            ;772
00013c  2001              MOVS     r0,#1                 ;772
00013e  4913              LDR      r1,|L10.396|
000140  7008              STRB     r0,[r1,#0]            ;772
000142  bf00              NOP                            ;772
000144  4620              MOV      r0,r4                 ;775
000146  f7fffffe          BL       tcp_output
                  |L10.330|
00014a  4638              MOV      r0,r7                 ;777
00014c  e766              B        |L10.28|
;;;779    
                          ENDP

00014e  0000              DCW      0x0000
                  |L10.336|
000150  7463705f          DCB      "tcp_connect: can only connect from state CLOSED",0
000154  636f6e6e
000158  6563743a
00015c  2063616e
000160  206f6e6c
000164  7920636f
000168  6e6e6563
00016c  74206672
000170  6f6d2073
000174  74617465
000178  20434c4f
00017c  53454400
                  |L10.384|
                          DCD      tcp_bound_pcbs
                  |L10.388|
                          DCD      tcp_tmp_pcb
                  |L10.392|
                          DCD      tcp_active_pcbs
                  |L10.396|
                          DCD      tcp_active_pcbs_changed

                          AREA ||i.tcp_debug_state_str||, CODE, READONLY, ALIGN=2

                  tcp_debug_state_str PROC
;;;1604   const char*
;;;1605   tcp_debug_state_str(enum tcp_state s)
000000  4601              MOV      r1,r0
;;;1606   {
;;;1607     return tcp_state_str[s];
000002  4802              LDR      r0,|L11.12|
000004  f8500021          LDR      r0,[r0,r1,LSL #2]
;;;1608   }
000008  4770              BX       lr
;;;1609   
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      tcp_state_str

                          AREA ||i.tcp_eff_send_mss||, CODE, READONLY, ALIGN=1

                  tcp_eff_send_mss PROC
;;;1585   u16_t
;;;1586   tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1587   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;1588     u16_t mss_s;
;;;1589     struct netif *outif;
;;;1590   
;;;1591     outif = ip_route(addr);
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       ip_route
00000e  4604              MOV      r4,r0
;;;1592     if ((outif != NULL) && (outif->mtu != 0)) {
000010  b154              CBZ      r4,|L12.40|
000012  8c20              LDRH     r0,[r4,#0x20]
000014  b140              CBZ      r0,|L12.40|
;;;1593       mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
000016  8c20              LDRH     r0,[r4,#0x20]
000018  3828              SUBS     r0,r0,#0x28
00001a  b287              UXTH     r7,r0
;;;1594       /* RFC 1122, chap 4.2.2.6:
;;;1595        * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
;;;1596        * We correct for TCP options in tcp_write(), and don't support IP options.
;;;1597        */
;;;1598       sendmss = LWIP_MIN(sendmss, mss_s);
00001c  42bd              CMP      r5,r7
00001e  da01              BGE      |L12.36|
000020  4628              MOV      r0,r5
000022  e000              B        |L12.38|
                  |L12.36|
000024  4638              MOV      r0,r7
                  |L12.38|
000026  4605              MOV      r5,r0
                  |L12.40|
;;;1599     }
;;;1600     return sendmss;
000028  4628              MOV      r0,r5
;;;1601   }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;1602   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
                          ENDP


                          AREA ||i.tcp_err||, CODE, READONLY, ALIGN=2

                  tcp_err PROC
;;;1420   void
;;;1421   tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
000000  b570              PUSH     {r4-r6,lr}
;;;1422   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1423     LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
000006  bf00              NOP      
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  2801              CMP      r0,#1
00000c  d104              BNE      |L13.24|
00000e  a004              ADR      r0,|L13.32|
000010  f7fffffe          BL       __2printf
000014  bf00              NOP      
                  |L13.22|
000016  e7fe              B        |L13.22|
                  |L13.24|
000018  bf00              NOP      
;;;1424     pcb->errf = err;
00001a  f8c4508c          STR      r5,[r4,#0x8c]
;;;1425   }
00001e  bd70              POP      {r4-r6,pc}
;;;1426   
                          ENDP

                  |L13.32|
000020  696e7661          DCB      "invalid socket state for err callback",0
000024  6c696420
000028  736f636b
00002c  65742073
000030  74617465
000034  20666f72
000038  20657272
00003c  2063616c
000040  6c626163
000044  6b00    
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.tcp_fasttmr||, CODE, READONLY, ALIGN=2

                  tcp_fasttmr PROC
;;;1045   void
;;;1046   tcp_fasttmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1047   {
;;;1048     struct tcp_pcb *pcb;
;;;1049   
;;;1050     ++tcp_timer_ctr;
000002  481c              LDR      r0,|L14.116|
000004  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
000006  1c40              ADDS     r0,r0,#1
000008  491a              LDR      r1,|L14.116|
00000a  7008              STRB     r0,[r1,#0]
;;;1051   
;;;1052   tcp_fasttmr_start:
00000c  bf00              NOP      
                  |L14.14|
;;;1053     pcb = tcp_active_pcbs;
00000e  481a              LDR      r0,|L14.120|
000010  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
;;;1054   
;;;1055     while(pcb != NULL) {
000012  e02b              B        |L14.108|
                  |L14.20|
;;;1056       if (pcb->last_timer != tcp_timer_ctr) {
000014  f8940021          LDRB     r0,[r4,#0x21]
000018  4916              LDR      r1,|L14.116|
00001a  7809              LDRB     r1,[r1,#0]  ; tcp_timer_ctr
00001c  4288              CMP      r0,r1
00001e  d025              BEQ      |L14.108|
;;;1057         struct tcp_pcb *next;
;;;1058         pcb->last_timer = tcp_timer_ctr;
000020  4814              LDR      r0,|L14.116|
000022  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
000024  f8840021          STRB     r0,[r4,#0x21]
;;;1059         /* send delayed ACKs */
;;;1060         if (pcb->flags & TF_ACK_DELAY) {
000028  7fa0              LDRB     r0,[r4,#0x1e]
00002a  f0000001          AND      r0,r0,#1
00002e  b170              CBZ      r0,|L14.78|
;;;1061           LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
000030  bf00              NOP      
000032  bf00              NOP      
;;;1062           tcp_ack_now(pcb);
000034  bf00              NOP      
000036  7fa0              LDRB     r0,[r4,#0x1e]
000038  f0400002          ORR      r0,r0,#2
00003c  77a0              STRB     r0,[r4,#0x1e]
00003e  bf00              NOP      
;;;1063           tcp_output(pcb);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       tcp_output
;;;1064           pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
000046  7fa0              LDRB     r0,[r4,#0x1e]
000048  f0200003          BIC      r0,r0,#3
00004c  77a0              STRB     r0,[r4,#0x1e]
                  |L14.78|
;;;1065         }
;;;1066   
;;;1067         next = pcb->next;
00004e  68e5              LDR      r5,[r4,#0xc]
;;;1068   
;;;1069         /* If there is data which was previously "refused" by upper layer */
;;;1070         if (pcb->refused_data != NULL) {
000050  6fa0              LDR      r0,[r4,#0x78]
000052  b148              CBZ      r0,|L14.104|
;;;1071           tcp_active_pcbs_changed = 0;
000054  2000              MOVS     r0,#0
000056  4909              LDR      r1,|L14.124|
000058  7008              STRB     r0,[r1,#0]
;;;1072           tcp_process_refused_data(pcb);
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       tcp_process_refused_data
;;;1073           if (tcp_active_pcbs_changed) {
000060  4806              LDR      r0,|L14.124|
000062  7800              LDRB     r0,[r0,#0]  ; tcp_active_pcbs_changed
000064  b100              CBZ      r0,|L14.104|
;;;1074             /* application callback has changed the pcb list: restart the loop */
;;;1075             goto tcp_fasttmr_start;
000066  e7d2              B        |L14.14|
                  |L14.104|
;;;1076           }
;;;1077         }
;;;1078         pcb = next;
000068  462c              MOV      r4,r5
;;;1079       }
00006a  bf00              NOP      
                  |L14.108|
00006c  2c00              CMP      r4,#0                 ;1055
00006e  d1d1              BNE      |L14.20|
;;;1080     }
;;;1081   }
000070  bd70              POP      {r4-r6,pc}
;;;1082   
                          ENDP

000072  0000              DCW      0x0000
                  |L14.116|
                          DCD      tcp_timer_ctr
                  |L14.120|
                          DCD      tcp_active_pcbs
                  |L14.124|
                          DCD      tcp_active_pcbs_changed

                          AREA ||i.tcp_init||, CODE, READONLY, ALIGN=1

                  tcp_init PROC
;;;129    void
;;;130    tcp_init(void)
000000  4770              BX       lr
;;;131    {
;;;132    #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
;;;133      tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
;;;134    #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
;;;135    }
;;;136    
                          ENDP


                          AREA ||i.tcp_kill_prio||, CODE, READONLY, ALIGN=2

                  tcp_kill_prio PROC
;;;1216   static void
;;;1217   tcp_kill_prio(u8_t prio)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1218   {
000004  4606              MOV      r6,r0
;;;1219     struct tcp_pcb *pcb, *inactive;
;;;1220     u32_t inactivity;
;;;1221     u8_t mprio;
;;;1222   
;;;1223   
;;;1224     mprio = TCP_PRIO_MAX;
000006  f04f087f          MOV      r8,#0x7f
;;;1225     
;;;1226     /* We kill the oldest active connection that has lower priority than prio. */
;;;1227     inactivity = 0;
00000a  2700              MOVS     r7,#0
;;;1228     inactive = NULL;
00000c  2500              MOVS     r5,#0
;;;1229     for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
00000e  4810              LDR      r0,|L16.80|
000010  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
000012  e013              B        |L16.60|
                  |L16.20|
;;;1230       if (pcb->prio <= prio &&
000014  7e60              LDRB     r0,[r4,#0x19]
000016  42b0              CMP      r0,r6
000018  dc0f              BGT      |L16.58|
;;;1231          pcb->prio <= mprio &&
00001a  7e60              LDRB     r0,[r4,#0x19]
00001c  4540              CMP      r0,r8
00001e  dc0c              BGT      |L16.58|
;;;1232          (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
000020  490c              LDR      r1,|L16.84|
000022  6a60              LDR      r0,[r4,#0x24]
000024  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000026  1a08              SUBS     r0,r1,r0
000028  42b8              CMP      r0,r7
00002a  d306              BCC      |L16.58|
;;;1233         inactivity = tcp_ticks - pcb->tmr;
00002c  4909              LDR      r1,|L16.84|
00002e  6a60              LDR      r0,[r4,#0x24]
000030  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000032  1a0f              SUBS     r7,r1,r0
;;;1234         inactive = pcb;
000034  4625              MOV      r5,r4
;;;1235         mprio = pcb->prio;
000036  f8948019          LDRB     r8,[r4,#0x19]
                  |L16.58|
00003a  68e4              LDR      r4,[r4,#0xc]          ;1229
                  |L16.60|
00003c  2c00              CMP      r4,#0                 ;1229
00003e  d1e9              BNE      |L16.20|
;;;1236       }
;;;1237     }
;;;1238     if (inactive != NULL) {
000040  b125              CBZ      r5,|L16.76|
;;;1239       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
000042  bf00              NOP      
000044  bf00              NOP      
;;;1240              (void *)inactive, inactivity));
;;;1241       tcp_abort(inactive);
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       tcp_abort
                  |L16.76|
;;;1242     }
;;;1243   }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;1244   
                          ENDP

                  |L16.80|
                          DCD      tcp_active_pcbs
                  |L16.84|
                          DCD      tcp_ticks

                          AREA ||i.tcp_kill_timewait||, CODE, READONLY, ALIGN=2

                  tcp_kill_timewait PROC
;;;1249   static void
;;;1250   tcp_kill_timewait(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1251   {
;;;1252     struct tcp_pcb *pcb, *inactive;
;;;1253     u32_t inactivity;
;;;1254   
;;;1255     inactivity = 0;
000002  2600              MOVS     r6,#0
;;;1256     inactive = NULL;
000004  2500              MOVS     r5,#0
;;;1257     /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
;;;1258     for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
000006  480c              LDR      r0,|L17.56|
000008  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
00000a  e00b              B        |L17.36|
                  |L17.12|
;;;1259       if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
00000c  490b              LDR      r1,|L17.60|
00000e  6a60              LDR      r0,[r4,#0x24]
000010  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000012  1a08              SUBS     r0,r1,r0
000014  42b0              CMP      r0,r6
000016  d304              BCC      |L17.34|
;;;1260         inactivity = tcp_ticks - pcb->tmr;
000018  4908              LDR      r1,|L17.60|
00001a  6a60              LDR      r0,[r4,#0x24]
00001c  6809              LDR      r1,[r1,#0]  ; tcp_ticks
00001e  1a0e              SUBS     r6,r1,r0
;;;1261         inactive = pcb;
000020  4625              MOV      r5,r4
                  |L17.34|
000022  68e4              LDR      r4,[r4,#0xc]          ;1258
                  |L17.36|
000024  2c00              CMP      r4,#0                 ;1258
000026  d1f1              BNE      |L17.12|
;;;1262       }
;;;1263     }
;;;1264     if (inactive != NULL) {
000028  b125              CBZ      r5,|L17.52|
;;;1265       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
00002a  bf00              NOP      
00002c  bf00              NOP      
;;;1266              (void *)inactive, inactivity));
;;;1267       tcp_abort(inactive);
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       tcp_abort
                  |L17.52|
;;;1268     }
;;;1269   }
000034  bd70              POP      {r4-r6,pc}
;;;1270   
                          ENDP

000036  0000              DCW      0x0000
                  |L17.56|
                          DCD      tcp_tw_pcbs
                  |L17.60|
                          DCD      tcp_ticks

                          AREA ||i.tcp_listen_with_backlog||, CODE, READONLY, ALIGN=2

                  tcp_listen_with_backlog PROC
;;;518    struct tcp_pcb *
;;;519    tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
000000  b570              PUSH     {r4-r6,lr}
;;;520    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;521      struct tcp_pcb_listen *lpcb;
;;;522    
;;;523      LWIP_UNUSED_ARG(backlog);
;;;524      LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
000006  bf00              NOP      
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  b120              CBZ      r0,|L18.22|
00000c  a02f              ADR      r0,|L18.204|
00000e  f7fffffe          BL       __2printf
000012  2000              MOVS     r0,#0
                  |L18.20|
;;;525    
;;;526      /* already listening? */
;;;527      if (pcb->state == LISTEN) {
;;;528        return pcb;
;;;529      }
;;;530    #if SO_REUSE
;;;531      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;532        /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
;;;533           is declared (listen-/connection-pcb), we have to make sure now that
;;;534           this port is only used once for every local IP. */
;;;535        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;536          if (lpcb->local_port == pcb->local_port) {
;;;537            if (ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
;;;538              /* this address/port is already used */
;;;539              return NULL;
;;;540            }
;;;541          }
;;;542        }
;;;543      }
;;;544    #endif /* SO_REUSE */
;;;545      lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
;;;546      if (lpcb == NULL) {
;;;547        return NULL;
;;;548      }
;;;549      lpcb->callback_arg = pcb->callback_arg;
;;;550      lpcb->local_port = pcb->local_port;
;;;551      lpcb->state = LISTEN;
;;;552      lpcb->prio = pcb->prio;
;;;553      lpcb->so_options = pcb->so_options;
;;;554      ip_set_option(lpcb, SOF_ACCEPTCONN);
;;;555      lpcb->ttl = pcb->ttl;
;;;556      lpcb->tos = pcb->tos;
;;;557      ip_addr_copy(lpcb->local_ip, pcb->local_ip);
;;;558      if (pcb->local_port != 0) {
;;;559        TCP_RMV(&tcp_bound_pcbs, pcb);
;;;560      }
;;;561      memp_free(MEMP_TCP_PCB, pcb);
;;;562    #if LWIP_CALLBACK_API
;;;563      lpcb->accept = tcp_accept_null;
;;;564    #endif /* LWIP_CALLBACK_API */
;;;565    #if TCP_LISTEN_BACKLOG
;;;566      lpcb->accepts_pending = 0;
;;;567      lpcb->backlog = (backlog ? backlog : 1);
;;;568    #endif /* TCP_LISTEN_BACKLOG */
;;;569      TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
;;;570      return (struct tcp_pcb *)lpcb;
;;;571    }
000014  bd70              POP      {r4-r6,pc}
                  |L18.22|
000016  bf00              NOP                            ;524
000018  7e20              LDRB     r0,[r4,#0x18]         ;527
00001a  2801              CMP      r0,#1                 ;527
00001c  d101              BNE      |L18.34|
00001e  4620              MOV      r0,r4                 ;528
000020  e7f8              B        |L18.20|
                  |L18.34|
000022  2003              MOVS     r0,#3                 ;545
000024  f7fffffe          BL       memp_malloc
000028  4605              MOV      r5,r0                 ;545
00002a  b90d              CBNZ     r5,|L18.48|
00002c  2000              MOVS     r0,#0                 ;547
00002e  e7f1              B        |L18.20|
                  |L18.48|
000030  6920              LDR      r0,[r4,#0x10]         ;549
000032  6128              STR      r0,[r5,#0x10]         ;549
000034  8b60              LDRH     r0,[r4,#0x1a]         ;550
000036  8368              STRH     r0,[r5,#0x1a]         ;550
000038  2001              MOVS     r0,#1                 ;551
00003a  7628              STRB     r0,[r5,#0x18]         ;551
00003c  7e60              LDRB     r0,[r4,#0x19]         ;552
00003e  7668              STRB     r0,[r5,#0x19]         ;552
000040  7a20              LDRB     r0,[r4,#8]            ;553
000042  7228              STRB     r0,[r5,#8]            ;553
000044  7a28              LDRB     r0,[r5,#8]            ;554
000046  f0400002          ORR      r0,r0,#2              ;554
00004a  7228              STRB     r0,[r5,#8]            ;554
00004c  7aa0              LDRB     r0,[r4,#0xa]          ;555
00004e  72a8              STRB     r0,[r5,#0xa]          ;555
000050  7a60              LDRB     r0,[r4,#9]            ;556
000052  7268              STRB     r0,[r5,#9]            ;556
000054  6820              LDR      r0,[r4,#0]            ;557
000056  6028              STR      r0,[r5,#0]            ;557
000058  8b60              LDRH     r0,[r4,#0x1a]         ;558
00005a  b330              CBZ      r0,|L18.170|
00005c  bf00              NOP                            ;559
00005e  4824              LDR      r0,|L18.240|
000060  6800              LDR      r0,[r0,#0]            ;559  ; tcp_bound_pcbs
000062  42a0              CMP      r0,r4                 ;559
000064  d105              BNE      |L18.114|
000066  4822              LDR      r0,|L18.240|
000068  6800              LDR      r0,[r0,#0]            ;559  ; tcp_bound_pcbs
00006a  68c0              LDR      r0,[r0,#0xc]          ;559
00006c  4920              LDR      r1,|L18.240|
00006e  6008              STR      r0,[r1,#0]            ;559  ; tcp_bound_pcbs
000070  e018              B        |L18.164|
                  |L18.114|
000072  481f              LDR      r0,|L18.240|
000074  6800              LDR      r0,[r0,#0]            ;559  ; tcp_bound_pcbs
000076  491f              LDR      r1,|L18.244|
000078  6008              STR      r0,[r1,#0]            ;559  ; tcp_tmp_pcb
00007a  e00e              B        |L18.154|
                  |L18.124|
00007c  481d              LDR      r0,|L18.244|
00007e  6800              LDR      r0,[r0,#0]            ;559  ; tcp_tmp_pcb
000080  68c0              LDR      r0,[r0,#0xc]          ;559
000082  42a0              CMP      r0,r4                 ;559
000084  d104              BNE      |L18.144|
000086  491b              LDR      r1,|L18.244|
000088  68e0              LDR      r0,[r4,#0xc]          ;559
00008a  6809              LDR      r1,[r1,#0]            ;559  ; tcp_tmp_pcb
00008c  60c8              STR      r0,[r1,#0xc]          ;559
00008e  e008              B        |L18.162|
                  |L18.144|
000090  4818              LDR      r0,|L18.244|
000092  6800              LDR      r0,[r0,#0]            ;559  ; tcp_tmp_pcb
000094  68c0              LDR      r0,[r0,#0xc]          ;559
000096  4917              LDR      r1,|L18.244|
000098  6008              STR      r0,[r1,#0]            ;559  ; tcp_tmp_pcb
                  |L18.154|
00009a  4816              LDR      r0,|L18.244|
00009c  6800              LDR      r0,[r0,#0]            ;559  ; tcp_tmp_pcb
00009e  2800              CMP      r0,#0                 ;559
0000a0  d1ec              BNE      |L18.124|
                  |L18.162|
0000a2  bf00              NOP                            ;559
                  |L18.164|
0000a4  2000              MOVS     r0,#0                 ;559
0000a6  60e0              STR      r0,[r4,#0xc]          ;559
0000a8  bf00              NOP                            ;559
                  |L18.170|
0000aa  4621              MOV      r1,r4                 ;561
0000ac  2002              MOVS     r0,#2                 ;561
0000ae  f7fffffe          BL       memp_free
0000b2  4811              LDR      r0,|L18.248|
0000b4  6168              STR      r0,[r5,#0x14]         ;563
0000b6  bf00              NOP                            ;569
0000b8  4810              LDR      r0,|L18.252|
0000ba  6800              LDR      r0,[r0,#0]            ;569  ; tcp_listen_pcbs
0000bc  60e8              STR      r0,[r5,#0xc]          ;569
0000be  480f              LDR      r0,|L18.252|
0000c0  6005              STR      r5,[r0,#0]            ;569  ; tcp_listen_pcbs
0000c2  f7fffffe          BL       tcp_timer_needed
0000c6  bf00              NOP                            ;569
0000c8  4628              MOV      r0,r5                 ;570
0000ca  e7a3              B        |L18.20|
;;;572    
                          ENDP

                  |L18.204|
0000cc  7463705f          DCB      "tcp_listen: pcb already connected",0
0000d0  6c697374
0000d4  656e3a20
0000d8  70636220
0000dc  616c7265
0000e0  61647920
0000e4  636f6e6e
0000e8  65637465
0000ec  6400    
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L18.240|
                          DCD      tcp_bound_pcbs
                  |L18.244|
                          DCD      tcp_tmp_pcb
                  |L18.248|
                          DCD      tcp_accept_null
                  |L18.252|
                          DCD      tcp_listen_pcbs

                          AREA ||i.tcp_new||, CODE, READONLY, ALIGN=1

                  tcp_new PROC
;;;1362   struct tcp_pcb *
;;;1363   tcp_new(void)
000000  b510              PUSH     {r4,lr}
;;;1364   {
;;;1365     return tcp_alloc(TCP_PRIO_NORMAL);
000002  2040              MOVS     r0,#0x40
000004  f7fffffe          BL       tcp_alloc
;;;1366   }
000008  bd10              POP      {r4,pc}
;;;1367   
                          ENDP


                          AREA ||i.tcp_new_port||, CODE, READONLY, ALIGN=2

                  tcp_new_port PROC
;;;646    static u16_t
;;;647    tcp_new_port(void)
000000  b530              PUSH     {r4,r5,lr}
;;;648    {
;;;649      u8_t i;
;;;650      u16_t n = 0;
000002  2300              MOVS     r3,#0
;;;651      struct tcp_pcb *pcb;
;;;652      
;;;653    again:
000004  bf00              NOP      
                  |L20.6|
;;;654      if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
000006  4816              LDR      r0,|L20.96|
000008  8804              LDRH     r4,[r0,#0]  ; tcp_port
00000a  8800              LDRH     r0,[r0,#0]  ; tcp_port
00000c  1c40              ADDS     r0,r0,#1
00000e  4d14              LDR      r5,|L20.96|
000010  8028              STRH     r0,[r5,#0]
000012  f64f70ff          MOV      r0,#0xffff
000016  4284              CMP      r4,r0
000018  d103              BNE      |L20.34|
;;;655        tcp_port = TCP_LOCAL_PORT_RANGE_START;
00001a  f44f4040          MOV      r0,#0xc000
00001e  462c              MOV      r4,r5
000020  8020              STRH     r0,[r4,#0]
                  |L20.34|
;;;656      }
;;;657      /* Check all PCB lists. */
;;;658      for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
000022  2100              MOVS     r1,#0
000024  e017              B        |L20.86|
                  |L20.38|
;;;659        for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
000026  480f              LDR      r0,|L20.100|
000028  f8500021          LDR      r0,[r0,r1,LSL #2]
00002c  6802              LDR      r2,[r0,#0]
00002e  e00e              B        |L20.78|
                  |L20.48|
;;;660          if (pcb->local_port == tcp_port) {
000030  8b50              LDRH     r0,[r2,#0x1a]
000032  4c0b              LDR      r4,|L20.96|
000034  8824              LDRH     r4,[r4,#0]  ; tcp_port
000036  42a0              CMP      r0,r4
000038  d108              BNE      |L20.76|
;;;661            if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
00003a  1c58              ADDS     r0,r3,#1
00003c  b280              UXTH     r0,r0
00003e  4603              MOV      r3,r0
000040  f5b04f80          CMP      r0,#0x4000
000044  db01              BLT      |L20.74|
;;;662              return 0;
000046  2000              MOVS     r0,#0
                  |L20.72|
;;;663            }
;;;664            goto again;
;;;665          }
;;;666        }
;;;667      }
;;;668      return tcp_port;
;;;669    }
000048  bd30              POP      {r4,r5,pc}
                  |L20.74|
00004a  e7dc              B        |L20.6|
                  |L20.76|
00004c  68d2              LDR      r2,[r2,#0xc]          ;659
                  |L20.78|
00004e  2a00              CMP      r2,#0                 ;659
000050  d1ee              BNE      |L20.48|
000052  1c48              ADDS     r0,r1,#1              ;658
000054  b2c1              UXTB     r1,r0                 ;658
                  |L20.86|
000056  2904              CMP      r1,#4                 ;658
000058  dbe5              BLT      |L20.38|
00005a  4801              LDR      r0,|L20.96|
00005c  8800              LDRH     r0,[r0,#0]            ;668  ; tcp_port
00005e  e7f3              B        |L20.72|
;;;670    
                          ENDP

                  |L20.96|
                          DCD      tcp_port
                  |L20.100|
                          DCD      tcp_pcb_lists

                          AREA ||i.tcp_next_iss||, CODE, READONLY, ALIGN=2

                  tcp_next_iss PROC
;;;1570   u32_t
;;;1571   tcp_next_iss(void)
000000  4804              LDR      r0,|L21.20|
;;;1572   {
;;;1573     static u32_t iss = 6510;
;;;1574     
;;;1575     iss += tcp_ticks;       /* XXX */
000002  6800              LDR      r0,[r0,#0]  ; iss
000004  4904              LDR      r1,|L21.24|
000006  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000008  4408              ADD      r0,r0,r1
00000a  4902              LDR      r1,|L21.20|
00000c  6008              STR      r0,[r1,#0]  ; iss
;;;1576     return iss;
00000e  4608              MOV      r0,r1
000010  6800              LDR      r0,[r0,#0]  ; iss
;;;1577   }
000012  4770              BX       lr
;;;1578   
                          ENDP

                  |L21.20|
                          DCD      iss
                  |L21.24|
                          DCD      tcp_ticks

                          AREA ||i.tcp_pcb_purge||, CODE, READONLY, ALIGN=1

                  tcp_pcb_purge PROC
;;;1469   void
;;;1470   tcp_pcb_purge(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;1471   {
000002  4604              MOV      r4,r0
;;;1472     if (pcb->state != CLOSED &&
000004  7e20              LDRB     r0,[r4,#0x18]
000006  2800              CMP      r0,#0
000008  d02e              BEQ      |L22.104|
;;;1473        pcb->state != TIME_WAIT &&
00000a  7e20              LDRB     r0,[r4,#0x18]
00000c  280a              CMP      r0,#0xa
00000e  d02b              BEQ      |L22.104|
;;;1474        pcb->state != LISTEN) {
000010  7e20              LDRB     r0,[r4,#0x18]
000012  2801              CMP      r0,#1
000014  d028              BEQ      |L22.104|
;;;1475   
;;;1476       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
000016  bf00              NOP      
000018  bf00              NOP      
;;;1477   
;;;1478   #if TCP_LISTEN_BACKLOG
;;;1479       if (pcb->state == SYN_RCVD) {
;;;1480         /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
;;;1481         struct tcp_pcb_listen *lpcb;
;;;1482         LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
;;;1483           tcp_listen_pcbs.listen_pcbs != NULL);
;;;1484         for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;1485           if ((lpcb->local_port == pcb->local_port) &&
;;;1486               (ip_addr_isany(&lpcb->local_ip) ||
;;;1487                ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
;;;1488               /* port and address of the listen pcb match the timed-out pcb */
;;;1489               LWIP_ASSERT("tcp_pcb_purge: listen pcb does not have accepts pending",
;;;1490                 lpcb->accepts_pending > 0);
;;;1491               lpcb->accepts_pending--;
;;;1492               break;
;;;1493             }
;;;1494         }
;;;1495       }
;;;1496   #endif /* TCP_LISTEN_BACKLOG */
;;;1497   
;;;1498   
;;;1499       if (pcb->refused_data != NULL) {
00001a  6fa0              LDR      r0,[r4,#0x78]
00001c  b130              CBZ      r0,|L22.44|
;;;1500         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
00001e  bf00              NOP      
000020  bf00              NOP      
;;;1501         pbuf_free(pcb->refused_data);
000022  6fa0              LDR      r0,[r4,#0x78]
000024  f7fffffe          BL       pbuf_free
;;;1502         pcb->refused_data = NULL;
000028  2000              MOVS     r0,#0
00002a  67a0              STR      r0,[r4,#0x78]
                  |L22.44|
;;;1503       }
;;;1504       if (pcb->unsent != NULL) {
00002c  6ee0              LDR      r0,[r4,#0x6c]
00002e  b108              CBZ      r0,|L22.52|
;;;1505         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
000030  bf00              NOP      
000032  bf00              NOP      
                  |L22.52|
;;;1506       }
;;;1507       if (pcb->unacked != NULL) {
000034  6f20              LDR      r0,[r4,#0x70]
000036  b108              CBZ      r0,|L22.60|
;;;1508         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
000038  bf00              NOP      
00003a  bf00              NOP      
                  |L22.60|
;;;1509       }
;;;1510   #if TCP_QUEUE_OOSEQ
;;;1511       if (pcb->ooseq != NULL) {
00003c  6f60              LDR      r0,[r4,#0x74]
00003e  b108              CBZ      r0,|L22.68|
;;;1512         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
000040  bf00              NOP      
000042  bf00              NOP      
                  |L22.68|
;;;1513       }
;;;1514       tcp_segs_free(pcb->ooseq);
000044  6f60              LDR      r0,[r4,#0x74]
000046  f7fffffe          BL       tcp_segs_free
;;;1515       pcb->ooseq = NULL;
00004a  2000              MOVS     r0,#0
00004c  6760              STR      r0,[r4,#0x74]
;;;1516   #endif /* TCP_QUEUE_OOSEQ */
;;;1517   
;;;1518       /* Stop the retransmission timer as it will expect data on unacked
;;;1519          queue if it fires */
;;;1520       pcb->rtime = -1;
00004e  1e40              SUBS     r0,r0,#1
000050  86a0              STRH     r0,[r4,#0x34]
;;;1521   
;;;1522       tcp_segs_free(pcb->unsent);
000052  6ee0              LDR      r0,[r4,#0x6c]
000054  f7fffffe          BL       tcp_segs_free
;;;1523       tcp_segs_free(pcb->unacked);
000058  6f20              LDR      r0,[r4,#0x70]
00005a  f7fffffe          BL       tcp_segs_free
;;;1524       pcb->unacked = pcb->unsent = NULL;
00005e  2000              MOVS     r0,#0
000060  66e0              STR      r0,[r4,#0x6c]
000062  6720              STR      r0,[r4,#0x70]
;;;1525   #if TCP_OVERSIZE
;;;1526       pcb->unsent_oversize = 0;
000064  f8a4006a          STRH     r0,[r4,#0x6a]
                  |L22.104|
;;;1527   #endif /* TCP_OVERSIZE */
;;;1528     }
;;;1529   }
000068  bd10              POP      {r4,pc}
;;;1530   
                          ENDP


                          AREA ||i.tcp_pcb_remove||, CODE, READONLY, ALIGN=2

                  tcp_pcb_remove PROC
;;;1537   void
;;;1538   tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1539   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1540     TCP_RMV(pcblist, pcb);
000006  bf00              NOP      
000008  6828              LDR      r0,[r5,#0]
00000a  42a0              CMP      r0,r4
00000c  d103              BNE      |L23.22|
00000e  6828              LDR      r0,[r5,#0]
000010  68c0              LDR      r0,[r0,#0xc]
000012  6028              STR      r0,[r5,#0]
000014  e017              B        |L23.70|
                  |L23.22|
000016  4929              LDR      r1,|L23.188|
000018  6828              LDR      r0,[r5,#0]
00001a  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
00001c  e00e              B        |L23.60|
                  |L23.30|
00001e  4827              LDR      r0,|L23.188|
000020  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000022  68c0              LDR      r0,[r0,#0xc]
000024  42a0              CMP      r0,r4
000026  d104              BNE      |L23.50|
000028  4924              LDR      r1,|L23.188|
00002a  68e0              LDR      r0,[r4,#0xc]
00002c  6809              LDR      r1,[r1,#0]  ; tcp_tmp_pcb
00002e  60c8              STR      r0,[r1,#0xc]
000030  e008              B        |L23.68|
                  |L23.50|
000032  4822              LDR      r0,|L23.188|
000034  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000036  68c0              LDR      r0,[r0,#0xc]
000038  4920              LDR      r1,|L23.188|
00003a  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
                  |L23.60|
00003c  481f              LDR      r0,|L23.188|
00003e  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000040  2800              CMP      r0,#0
000042  d1ec              BNE      |L23.30|
                  |L23.68|
000044  bf00              NOP      
                  |L23.70|
000046  2000              MOVS     r0,#0
000048  60e0              STR      r0,[r4,#0xc]
00004a  bf00              NOP      
;;;1541   
;;;1542     tcp_pcb_purge(pcb);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       tcp_pcb_purge
;;;1543     
;;;1544     /* if there is an outstanding delayed ACKs, send it */
;;;1545     if (pcb->state != TIME_WAIT &&
000052  7e20              LDRB     r0,[r4,#0x18]
000054  280a              CMP      r0,#0xa
000056  d00d              BEQ      |L23.116|
;;;1546        pcb->state != LISTEN &&
000058  7e20              LDRB     r0,[r4,#0x18]
00005a  2801              CMP      r0,#1
00005c  d00a              BEQ      |L23.116|
;;;1547        pcb->flags & TF_ACK_DELAY) {
00005e  7fa0              LDRB     r0,[r4,#0x1e]
000060  f0000001          AND      r0,r0,#1
000064  b130              CBZ      r0,|L23.116|
;;;1548       pcb->flags |= TF_ACK_NOW;
000066  7fa0              LDRB     r0,[r4,#0x1e]
000068  f0400002          ORR      r0,r0,#2
00006c  77a0              STRB     r0,[r4,#0x1e]
;;;1549       tcp_output(pcb);
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       tcp_output
                  |L23.116|
;;;1550     }
;;;1551   
;;;1552     if (pcb->state != LISTEN) {
000074  7e20              LDRB     r0,[r4,#0x18]
000076  2801              CMP      r0,#1
000078  d01a              BEQ      |L23.176|
;;;1553       LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
00007a  bf00              NOP      
00007c  6ee0              LDR      r0,[r4,#0x6c]
00007e  b120              CBZ      r0,|L23.138|
000080  a00f              ADR      r0,|L23.192|
000082  f7fffffe          BL       __2printf
000086  bf00              NOP      
                  |L23.136|
000088  e7fe              B        |L23.136|
                  |L23.138|
00008a  bf00              NOP      
;;;1554       LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
00008c  bf00              NOP      
00008e  6f20              LDR      r0,[r4,#0x70]
000090  b120              CBZ      r0,|L23.156|
000092  a011              ADR      r0,|L23.216|
000094  f7fffffe          BL       __2printf
000098  bf00              NOP      
                  |L23.154|
00009a  e7fe              B        |L23.154|
                  |L23.156|
00009c  bf00              NOP      
;;;1555   #if TCP_QUEUE_OOSEQ
;;;1556       LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
00009e  bf00              NOP      
0000a0  6f60              LDR      r0,[r4,#0x74]
0000a2  b120              CBZ      r0,|L23.174|
0000a4  a013              ADR      r0,|L23.244|
0000a6  f7fffffe          BL       __2printf
0000aa  bf00              NOP      
                  |L23.172|
0000ac  e7fe              B        |L23.172|
                  |L23.174|
0000ae  bf00              NOP      
                  |L23.176|
;;;1557   #endif /* TCP_QUEUE_OOSEQ */
;;;1558     }
;;;1559   
;;;1560     pcb->state = CLOSED;
0000b0  2000              MOVS     r0,#0
0000b2  7620              STRB     r0,[r4,#0x18]
;;;1561   
;;;1562     LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
0000b4  bf00              NOP      
0000b6  bf00              NOP      
;;;1563   }
0000b8  bd70              POP      {r4-r6,pc}
;;;1564   
                          ENDP

0000ba  0000              DCW      0x0000
                  |L23.188|
                          DCD      tcp_tmp_pcb
                  |L23.192|
0000c0  756e7365          DCB      "unsent segments leaking",0
0000c4  6e742073
0000c8  65676d65
0000cc  6e747320
0000d0  6c65616b
0000d4  696e6700
                  |L23.216|
0000d8  756e6163          DCB      "unacked segments leaking",0
0000dc  6b656420
0000e0  7365676d
0000e4  656e7473
0000e8  206c6561
0000ec  6b696e67
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L23.244|
0000f4  6f6f7365          DCB      "ooseq segments leaking",0
0000f8  71207365
0000fc  676d656e
000100  7473206c
000104  65616b69
000108  6e6700  
00010b  00                DCB      0

                          AREA ||i.tcp_poll||, CODE, READONLY, ALIGN=2

                  tcp_poll PROC
;;;1451   void
;;;1452   tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
000000  b570              PUSH     {r4-r6,lr}
;;;1453   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1454     LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
000008  bf00              NOP      
00000a  7e20              LDRB     r0,[r4,#0x18]
00000c  2801              CMP      r0,#1
00000e  d104              BNE      |L24.26|
000010  a005              ADR      r0,|L24.40|
000012  f7fffffe          BL       __2printf
000016  bf00              NOP      
                  |L24.24|
000018  e7fe              B        |L24.24|
                  |L24.26|
00001a  bf00              NOP      
;;;1455   #if LWIP_CALLBACK_API
;;;1456     pcb->poll = poll;
00001c  f8c46088          STR      r6,[r4,#0x88]
;;;1457   #else /* LWIP_CALLBACK_API */  
;;;1458     LWIP_UNUSED_ARG(poll);
;;;1459   #endif /* LWIP_CALLBACK_API */  
;;;1460     pcb->pollinterval = interval;
000020  f8845020          STRB     r5,[r4,#0x20]
;;;1461   }
000024  bd70              POP      {r4-r6,pc}
;;;1462   
                          ENDP

000026  0000              DCW      0x0000
                  |L24.40|
000028  696e7661          DCB      "invalid socket state for poll",0
00002c  6c696420
000030  736f636b
000034  65742073
000038  74617465
00003c  20666f72
000040  20706f6c
000044  6c00    
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.tcp_process_refused_data||, CODE, READONLY, ALIGN=1

                  tcp_process_refused_data PROC
;;;1084   err_t
;;;1085   tcp_process_refused_data(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1086   {
000004  4604              MOV      r4,r0
;;;1087     err_t err;
;;;1088     u8_t refused_flags = pcb->refused_data->flags;
000006  6fa0              LDR      r0,[r4,#0x78]
000008  7b47              LDRB     r7,[r0,#0xd]
;;;1089     /* set pcb->refused_data to NULL in case the callback frees it and then
;;;1090        closes the pcb */
;;;1091     struct pbuf *refused_data = pcb->refused_data;
00000a  6fa6              LDR      r6,[r4,#0x78]
;;;1092     pcb->refused_data = NULL;
00000c  2000              MOVS     r0,#0
00000e  67a0              STR      r0,[r4,#0x78]
;;;1093     /* Notify again application with data previously received. */
;;;1094     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
000010  bf00              NOP      
000012  bf00              NOP      
;;;1095     TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
000014  bf00              NOP      
000016  f8d40080          LDR      r0,[r4,#0x80]
00001a  b140              CBZ      r0,|L25.46|
00001c  2300              MOVS     r3,#0
00001e  4632              MOV      r2,r6
000020  4621              MOV      r1,r4
000022  f8d4c080          LDR      r12,[r4,#0x80]
000026  6920              LDR      r0,[r4,#0x10]
000028  47e0              BLX      r12
00002a  4605              MOV      r5,r0
00002c  e006              B        |L25.60|
                  |L25.46|
00002e  2300              MOVS     r3,#0
000030  4632              MOV      r2,r6
000032  4621              MOV      r1,r4
000034  4618              MOV      r0,r3
000036  f7fffffe          BL       tcp_recv_null
00003a  4605              MOV      r5,r0
                  |L25.60|
00003c  bf00              NOP      
;;;1096     if (err == ERR_OK) {
00003e  b9fd              CBNZ     r5,|L25.128|
;;;1097       /* did refused_data include a FIN? */
;;;1098       if (refused_flags & PBUF_FLAG_TCP_FIN) {
000040  f0070020          AND      r0,r7,#0x20
000044  b328              CBZ      r0,|L25.146|
;;;1099         /* correct rcv_wnd as the application won't call tcp_recved()
;;;1100            for the FIN's seqno */
;;;1101         if (pcb->rcv_wnd != TCP_WND) {
000046  8da0              LDRH     r0,[r4,#0x2c]
000048  f5b06f7a          CMP      r0,#0xfa0
00004c  d002              BEQ      |L25.84|
;;;1102           pcb->rcv_wnd++;
00004e  8da0              LDRH     r0,[r4,#0x2c]
000050  1c40              ADDS     r0,r0,#1
000052  85a0              STRH     r0,[r4,#0x2c]
                  |L25.84|
;;;1103         }
;;;1104         TCP_EVENT_CLOSED(pcb, err);
000054  bf00              NOP      
000056  f8d40080          LDR      r0,[r4,#0x80]
00005a  b140              CBZ      r0,|L25.110|
00005c  2300              MOVS     r3,#0
00005e  461a              MOV      r2,r3
000060  4621              MOV      r1,r4
000062  f8d4c080          LDR      r12,[r4,#0x80]
000066  6920              LDR      r0,[r4,#0x10]
000068  47e0              BLX      r12
00006a  4605              MOV      r5,r0
00006c  e000              B        |L25.112|
                  |L25.110|
00006e  2500              MOVS     r5,#0
                  |L25.112|
000070  bf00              NOP      
;;;1105         if (err == ERR_ABRT) {
000072  f105000a          ADD      r0,r5,#0xa
000076  b960              CBNZ     r0,|L25.146|
;;;1106           return ERR_ABRT;
000078  f06f0009          MVN      r0,#9
                  |L25.124|
;;;1107         }
;;;1108       }
;;;1109     } else if (err == ERR_ABRT) {
;;;1110       /* if err == ERR_ABRT, 'pcb' is already deallocated */
;;;1111       /* Drop incoming packets because pcb is "full" (only if the incoming
;;;1112          segment contains data). */
;;;1113       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
;;;1114       return ERR_ABRT;
;;;1115     } else {
;;;1116       /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
;;;1117       pcb->refused_data = refused_data;
;;;1118     }
;;;1119     return ERR_OK;
;;;1120   }
00007c  e8bd81f0          POP      {r4-r8,pc}
                  |L25.128|
000080  f105000a          ADD      r0,r5,#0xa            ;1109
000084  b920              CBNZ     r0,|L25.144|
000086  bf00              NOP                            ;1113
000088  bf00              NOP                            ;1113
00008a  f06f0009          MVN      r0,#9                 ;1114
00008e  e7f5              B        |L25.124|
                  |L25.144|
000090  67a6              STR      r6,[r4,#0x78]         ;1117
                  |L25.146|
000092  2000              MOVS     r0,#0                 ;1119
000094  e7f2              B        |L25.124|
;;;1121   
                          ENDP


                          AREA ||i.tcp_recv||, CODE, READONLY, ALIGN=2

                  tcp_recv PROC
;;;1391   void
;;;1392   tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
000000  b570              PUSH     {r4-r6,lr}
;;;1393   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1394     LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
000006  bf00              NOP      
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  2801              CMP      r0,#1
00000c  d104              BNE      |L26.24|
00000e  a004              ADR      r0,|L26.32|
000010  f7fffffe          BL       __2printf
000014  bf00              NOP      
                  |L26.22|
000016  e7fe              B        |L26.22|
                  |L26.24|
000018  bf00              NOP      
;;;1395     pcb->recv = recv;
00001a  f8c45080          STR      r5,[r4,#0x80]
;;;1396   }
00001e  bd70              POP      {r4-r6,pc}
;;;1397   
                          ENDP

                  |L26.32|
000020  696e7661          DCB      "invalid socket state for recv callback",0
000024  6c696420
000028  736f636b
00002c  65742073
000030  74617465
000034  20666f72
000038  20726563
00003c  76206361
000040  6c6c6261
000044  636b00  
000047  00                DCB      0

                          AREA ||i.tcp_recv_null||, CODE, READONLY, ALIGN=1

                  tcp_recv_null PROC
;;;1196   err_t
;;;1197   tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1198   {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
;;;1199     LWIP_UNUSED_ARG(arg);
;;;1200     if (p != NULL) {
00000c  b13c              CBZ      r4,|L27.30|
;;;1201       tcp_recved(pcb, p->tot_len);
00000e  8921              LDRH     r1,[r4,#8]
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       tcp_recved
;;;1202       pbuf_free(p);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       pbuf_free
00001c  e005              B        |L27.42|
                  |L27.30|
;;;1203     } else if (err == ERR_OK) {
00001e  b926              CBNZ     r6,|L27.42|
;;;1204       return tcp_close(pcb);
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       tcp_close
                  |L27.38|
;;;1205     }
;;;1206     return ERR_OK;
;;;1207   }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L27.42|
00002a  2000              MOVS     r0,#0                 ;1206
00002c  e7fb              B        |L27.38|
;;;1208   #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_recved||, CODE, READONLY, ALIGN=2

                  tcp_recved PROC
;;;610    void
;;;611    tcp_recved(struct tcp_pcb *pcb, u16_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;612    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;613      int wnd_inflation;
;;;614    
;;;615      /* pcb->state LISTEN not allowed here */
;;;616      LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
000006  bf00              NOP      
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  2801              CMP      r0,#1
00000c  d104              BNE      |L28.24|
00000e  a018              ADR      r0,|L28.112|
000010  f7fffffe          BL       __2printf
000014  bf00              NOP      
                  |L28.22|
000016  e7fe              B        |L28.22|
                  |L28.24|
000018  bf00              NOP      
;;;617        pcb->state != LISTEN);
;;;618      LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
00001a  bf00              NOP      
00001c  8da0              LDRH     r0,[r4,#0x2c]
00001e  f64f71ff          MOV      r1,#0xffff
000022  1a08              SUBS     r0,r1,r0
000024  42a8              CMP      r0,r5
000026  da04              BGE      |L28.50|
000028  a01b              ADR      r0,|L28.152|
00002a  f7fffffe          BL       __2printf
00002e  bf00              NOP      
                  |L28.48|
000030  e7fe              B        |L28.48|
                  |L28.50|
000032  bf00              NOP      
;;;619                  len <= 0xffff - pcb->rcv_wnd );
;;;620    
;;;621      pcb->rcv_wnd += len;
000034  8da0              LDRH     r0,[r4,#0x2c]
000036  4428              ADD      r0,r0,r5
000038  85a0              STRH     r0,[r4,#0x2c]
;;;622      if (pcb->rcv_wnd > TCP_WND) {
00003a  8da0              LDRH     r0,[r4,#0x2c]
00003c  f5b06f7a          CMP      r0,#0xfa0
000040  dd02              BLE      |L28.72|
;;;623        pcb->rcv_wnd = TCP_WND;
000042  f44f607a          MOV      r0,#0xfa0
000046  85a0              STRH     r0,[r4,#0x2c]
                  |L28.72|
;;;624      }
;;;625    
;;;626      wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       tcp_update_rcv_ann_wnd
00004e  4606              MOV      r6,r0
;;;627    
;;;628      /* If the change in the right edge of window is significant (default
;;;629       * watermark is TCP_WND/4), then send an explicit update now.
;;;630       * Otherwise wait for a packet to be sent in the normal course of
;;;631       * events (or more window to be available later) */
;;;632      if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
000050  f5b67f7a          CMP      r6,#0x3e8
000054  db08              BLT      |L28.104|
;;;633        tcp_ack_now(pcb);
000056  bf00              NOP      
000058  7fa0              LDRB     r0,[r4,#0x1e]
00005a  f0400002          ORR      r0,r0,#2
00005e  77a0              STRB     r0,[r4,#0x1e]
000060  bf00              NOP      
;;;634        tcp_output(pcb);
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       tcp_output
                  |L28.104|
;;;635      }
;;;636    
;;;637      LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
000068  bf00              NOP      
00006a  bf00              NOP      
;;;638             len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
;;;639    }
00006c  bd70              POP      {r4-r6,pc}
;;;640    
                          ENDP

00006e  0000              DCW      0x0000
                  |L28.112|
000070  646f6e27          DCB      "don't call tcp_recved for listen-pcbs",0
000074  74206361
000078  6c6c2074
00007c  63705f72
000080  65637665
000084  6420666f
000088  72206c69
00008c  7374656e
000090  2d706362
000094  7300    
000096  00                DCB      0
000097  00                DCB      0
                  |L28.152|
000098  7463705f          DCB      "tcp_recved: len would wrap rcv_wnd\n",0
00009c  72656376
0000a0  65643a20
0000a4  6c656e20
0000a8  776f756c
0000ac  64207772
0000b0  61702072
0000b4  63765f77
0000b8  6e640a00

                          AREA ||i.tcp_seg_copy||, CODE, READONLY, ALIGN=1

                  tcp_seg_copy PROC
;;;1176   struct tcp_seg *
;;;1177   tcp_seg_copy(struct tcp_seg *seg)
000000  b570              PUSH     {r4-r6,lr}
;;;1178   {
000002  4605              MOV      r5,r0
;;;1179     struct tcp_seg *cseg;
;;;1180   
;;;1181     cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       memp_malloc
00000a  4604              MOV      r4,r0
;;;1182     if (cseg == NULL) {
00000c  b90c              CBNZ     r4,|L29.18|
;;;1183       return NULL;
00000e  2000              MOVS     r0,#0
                  |L29.16|
;;;1184     }
;;;1185     SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
;;;1186     pbuf_ref(cseg->p);
;;;1187     return cseg;
;;;1188   }
000010  bd70              POP      {r4-r6,pc}
                  |L29.18|
000012  2214              MOVS     r2,#0x14              ;1185
000014  4629              MOV      r1,r5                 ;1185
000016  4620              MOV      r0,r4                 ;1185
000018  f7fffffe          BL       __aeabi_memcpy4
00001c  6860              LDR      r0,[r4,#4]            ;1186
00001e  f7fffffe          BL       pbuf_ref
000022  4620              MOV      r0,r4                 ;1187
000024  e7f4              B        |L29.16|
;;;1189   #endif /* TCP_QUEUE_OOSEQ */
                          ENDP


                          AREA ||i.tcp_seg_free||, CODE, READONLY, ALIGN=1

                  tcp_seg_free PROC
;;;1142   void
;;;1143   tcp_seg_free(struct tcp_seg *seg)
000000  b510              PUSH     {r4,lr}
;;;1144   {
000002  4604              MOV      r4,r0
;;;1145     if (seg != NULL) {
000004  b144              CBZ      r4,|L30.24|
;;;1146       if (seg->p != NULL) {
000006  6860              LDR      r0,[r4,#4]
000008  b110              CBZ      r0,|L30.16|
;;;1147         pbuf_free(seg->p);
00000a  6860              LDR      r0,[r4,#4]
00000c  f7fffffe          BL       pbuf_free
                  |L30.16|
;;;1148   #if TCP_DEBUG
;;;1149         seg->p = NULL;
;;;1150   #endif /* TCP_DEBUG */
;;;1151       }
;;;1152       memp_free(MEMP_TCP_SEG, seg);
000010  4621              MOV      r1,r4
000012  2004              MOVS     r0,#4
000014  f7fffffe          BL       memp_free
                  |L30.24|
;;;1153     }
;;;1154   }
000018  bd10              POP      {r4,pc}
;;;1155   
                          ENDP


                          AREA ||i.tcp_segs_free||, CODE, READONLY, ALIGN=1

                  tcp_segs_free PROC
;;;1127   void
;;;1128   tcp_segs_free(struct tcp_seg *seg)
000000  b570              PUSH     {r4-r6,lr}
;;;1129   {
000002  4604              MOV      r4,r0
;;;1130     while (seg != NULL) {
000004  e005              B        |L31.18|
                  |L31.6|
;;;1131       struct tcp_seg *next = seg->next;
000006  6825              LDR      r5,[r4,#0]
;;;1132       tcp_seg_free(seg);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       tcp_seg_free
;;;1133       seg = next;
00000e  462c              MOV      r4,r5
;;;1134     }
000010  bf00              NOP      
                  |L31.18|
000012  2c00              CMP      r4,#0                 ;1130
000014  d1f7              BNE      |L31.6|
;;;1135   }
000016  bd70              POP      {r4-r6,pc}
;;;1136   
                          ENDP


                          AREA ||i.tcp_sent||, CODE, READONLY, ALIGN=2

                  tcp_sent PROC
;;;1405   void
;;;1406   tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
000000  b570              PUSH     {r4-r6,lr}
;;;1407   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1408     LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
000006  bf00              NOP      
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  2801              CMP      r0,#1
00000c  d104              BNE      |L32.24|
00000e  a004              ADR      r0,|L32.32|
000010  f7fffffe          BL       __2printf
000014  bf00              NOP      
                  |L32.22|
000016  e7fe              B        |L32.22|
                  |L32.24|
000018  bf00              NOP      
;;;1409     pcb->sent = sent;
00001a  67e5              STR      r5,[r4,#0x7c]
;;;1410   }
00001c  bd70              POP      {r4-r6,pc}
;;;1411   
                          ENDP

00001e  0000              DCW      0x0000
                  |L32.32|
000020  696e7661          DCB      "invalid socket state for sent callback",0
000024  6c696420
000028  736f636b
00002c  65742073
000030  74617465
000034  20666f72
000038  2073656e
00003c  74206361
000040  6c6c6261
000044  636b00  
000047  00                DCB      0

                          AREA ||i.tcp_setprio||, CODE, READONLY, ALIGN=1

                  tcp_setprio PROC
;;;1162   void
;;;1163   tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
000000  7641              STRB     r1,[r0,#0x19]
;;;1164   {
;;;1165     pcb->prio = prio;
;;;1166   }
000002  4770              BX       lr
;;;1167   
                          ENDP


                          AREA ||i.tcp_shutdown||, CODE, READONLY, ALIGN=1

                  tcp_shutdown PROC
;;;312    err_t
;;;313    tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
000000  b570              PUSH     {r4-r6,lr}
;;;314    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;315      if (pcb->state == LISTEN) {
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  2801              CMP      r0,#1
00000c  d102              BNE      |L34.20|
;;;316        return ERR_CONN;
00000e  f06f000c          MVN      r0,#0xc
                  |L34.18|
;;;317      }
;;;318      if (shut_rx) {
;;;319        /* shut down the receive side: set a flag not to receive any more data... */
;;;320        pcb->flags |= TF_RXCLOSED;
;;;321        if (shut_tx) {
;;;322          /* shutting down the tx AND rx side is the same as closing for the raw API */
;;;323          return tcp_close_shutdown(pcb, 1);
;;;324        }
;;;325        /* ... and free buffered data */
;;;326        if (pcb->refused_data != NULL) {
;;;327          pbuf_free(pcb->refused_data);
;;;328          pcb->refused_data = NULL;
;;;329        }
;;;330      }
;;;331      if (shut_tx) {
;;;332        /* This can't happen twice since if it succeeds, the pcb's state is changed.
;;;333           Only close in these states as the others directly deallocate the PCB */
;;;334        switch (pcb->state) {
;;;335        case SYN_RCVD:
;;;336        case ESTABLISHED:
;;;337        case CLOSE_WAIT:
;;;338          return tcp_close_shutdown(pcb, shut_rx);
;;;339        default:
;;;340          /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
;;;341            into CLOSED state, where the PCB is deallocated. */
;;;342          return ERR_CONN;
;;;343        }
;;;344      }
;;;345      return ERR_OK;
;;;346    }
000012  bd70              POP      {r4-r6,pc}
                  |L34.20|
000014  b185              CBZ      r5,|L34.56|
000016  7fa0              LDRB     r0,[r4,#0x1e]         ;320
000018  f0400010          ORR      r0,r0,#0x10           ;320
00001c  77a0              STRB     r0,[r4,#0x1e]         ;320
00001e  b126              CBZ      r6,|L34.42|
000020  2101              MOVS     r1,#1                 ;323
000022  4620              MOV      r0,r4                 ;323
000024  f7fffffe          BL       tcp_close_shutdown
000028  e7f3              B        |L34.18|
                  |L34.42|
00002a  6fa0              LDR      r0,[r4,#0x78]         ;326
00002c  b120              CBZ      r0,|L34.56|
00002e  6fa0              LDR      r0,[r4,#0x78]         ;327
000030  f7fffffe          BL       pbuf_free
000034  2000              MOVS     r0,#0                 ;328
000036  67a0              STR      r0,[r4,#0x78]         ;328
                  |L34.56|
000038  b18e              CBZ      r6,|L34.94|
00003a  7e20              LDRB     r0,[r4,#0x18]         ;334
00003c  2803              CMP      r0,#3                 ;334
00003e  d004              BEQ      |L34.74|
000040  2804              CMP      r0,#4                 ;334
000042  d003              BEQ      |L34.76|
000044  2807              CMP      r0,#7                 ;334
000046  d107              BNE      |L34.88|
000048  e001              B        |L34.78|
                  |L34.74|
00004a  bf00              NOP                            ;336
                  |L34.76|
00004c  bf00              NOP                            ;337
                  |L34.78|
00004e  b2e9              UXTB     r1,r5                 ;338
000050  4620              MOV      r0,r4                 ;338
000052  f7fffffe          BL       tcp_close_shutdown
000056  e7dc              B        |L34.18|
                  |L34.88|
000058  f06f000c          MVN      r0,#0xc               ;342
00005c  e7d9              B        |L34.18|
                  |L34.94|
00005e  2000              MOVS     r0,#0                 ;345
000060  e7d7              B        |L34.18|
;;;347    
                          ENDP


                          AREA ||i.tcp_slowtmr||, CODE, READONLY, ALIGN=2

                  tcp_slowtmr PROC
;;;787    void
;;;788    tcp_slowtmr(void)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;789    {
;;;790      struct tcp_pcb *pcb, *prev;
;;;791      u16_t eff_wnd;
;;;792      u8_t pcb_remove;      /* flag if a PCB should be removed */
;;;793      u8_t pcb_reset;       /* flag if a RST should be sent when removing */
;;;794      err_t err;
;;;795    
;;;796      err = ERR_OK;
000004  2000              MOVS     r0,#0
000006  9002              STR      r0,[sp,#8]
;;;797    
;;;798      ++tcp_ticks;
000008  48f6              LDR      r0,|L35.996|
00000a  6800              LDR      r0,[r0,#0]  ; tcp_ticks
00000c  1c40              ADDS     r0,r0,#1
00000e  49f5              LDR      r1,|L35.996|
000010  6008              STR      r0,[r1,#0]  ; tcp_ticks
;;;799      ++tcp_timer_ctr;
000012  48f5              LDR      r0,|L35.1000|
000014  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
000016  1c40              ADDS     r0,r0,#1
000018  49f3              LDR      r1,|L35.1000|
00001a  7008              STRB     r0,[r1,#0]
;;;800    
;;;801    tcp_slowtmr_start:
00001c  bf00              NOP      
                  |L35.30|
;;;802      /* Steps through all of the active PCBs. */
;;;803      prev = NULL;
00001e  2500              MOVS     r5,#0
;;;804      pcb = tcp_active_pcbs;
000020  48f2              LDR      r0,|L35.1004|
000022  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
;;;805      if (pcb == NULL) {
000024  b90c              CBNZ     r4,|L35.42|
;;;806        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
000026  bf00              NOP      
000028  bf00              NOP      
                  |L35.42|
;;;807      }
;;;808      while (pcb != NULL) {
00002a  e197              B        |L35.860|
                  |L35.44|
;;;809        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;810        LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
000030  bf00              NOP      
000032  7e20              LDRB     r0,[r4,#0x18]
000034  b920              CBNZ     r0,|L35.64|
000036  a0ee              ADR      r0,|L35.1008|
000038  f7fffffe          BL       __2printf
00003c  bf00              NOP      
                  |L35.62|
00003e  e7fe              B        |L35.62|
                  |L35.64|
000040  bf00              NOP      
;;;811        LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
000042  bf00              NOP      
000044  7e20              LDRB     r0,[r4,#0x18]
000046  2801              CMP      r0,#1
000048  d104              BNE      |L35.84|
00004a  a0f4              ADR      r0,|L35.1052|
00004c  f7fffffe          BL       __2printf
000050  bf00              NOP      
                  |L35.82|
000052  e7fe              B        |L35.82|
                  |L35.84|
000054  bf00              NOP      
;;;812        LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
000056  bf00              NOP      
000058  7e20              LDRB     r0,[r4,#0x18]
00005a  280a              CMP      r0,#0xa
00005c  d104              BNE      |L35.104|
00005e  a0fa              ADR      r0,|L35.1096|
000060  f7fffffe          BL       __2printf
000064  bf00              NOP      
                  |L35.102|
000066  e7fe              B        |L35.102|
                  |L35.104|
000068  bf00              NOP      
;;;813        if (pcb->last_timer == tcp_timer_ctr) {
00006a  f8940021          LDRB     r0,[r4,#0x21]
00006e  49de              LDR      r1,|L35.1000|
000070  7809              LDRB     r1,[r1,#0]  ; tcp_timer_ctr
000072  4288              CMP      r0,r1
000074  d101              BNE      |L35.122|
;;;814          /* skip this pcb, we have already processed it */
;;;815          pcb = pcb->next;
000076  68e4              LDR      r4,[r4,#0xc]
;;;816          continue;
000078  e170              B        |L35.860|
                  |L35.122|
;;;817        }
;;;818        pcb->last_timer = tcp_timer_ctr;
00007a  48db              LDR      r0,|L35.1000|
00007c  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
00007e  f8840021          STRB     r0,[r4,#0x21]
;;;819    
;;;820        pcb_remove = 0;
000082  2600              MOVS     r6,#0
;;;821        pcb_reset = 0;
000084  46b1              MOV      r9,r6
;;;822    
;;;823        if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
000086  7e20              LDRB     r0,[r4,#0x18]
000088  2802              CMP      r0,#2
00008a  d107              BNE      |L35.156|
00008c  f8940046          LDRB     r0,[r4,#0x46]
000090  2806              CMP      r0,#6
000092  d103              BNE      |L35.156|
;;;824          ++pcb_remove;
000094  1c70              ADDS     r0,r6,#1
000096  b2c6              UXTB     r6,r0
;;;825          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
000098  bf00              NOP      
00009a  e072              B        |L35.386|
                  |L35.156|
;;;826        }
;;;827        else if (pcb->nrtx == TCP_MAXRTX) {
00009c  f8940046          LDRB     r0,[r4,#0x46]
0000a0  280c              CMP      r0,#0xc
0000a2  d103              BNE      |L35.172|
;;;828          ++pcb_remove;
0000a4  1c70              ADDS     r0,r6,#1
0000a6  b2c6              UXTB     r6,r0
;;;829          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
0000a8  bf00              NOP      
0000aa  e06a              B        |L35.386|
                  |L35.172|
;;;830        } else {
;;;831          if (pcb->persist_backoff > 0) {
0000ac  f8940095          LDRB     r0,[r4,#0x95]
0000b0  2800              CMP      r0,#0
0000b2  dd1b              BLE      |L35.236|
;;;832            /* If snd_wnd is zero, use persist timer to send 1 byte probes
;;;833             * instead of using the standard retransmission mechanism. */
;;;834            pcb->persist_cnt++;
0000b4  f8140f94          LDRB     r0,[r4,#0x94]!
0000b8  1c40              ADDS     r0,r0,#1
0000ba  7020              STRB     r0,[r4,#0]
;;;835            if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
0000bc  7821              LDRB     r1,[r4,#0]
0000be  7860              LDRB     r0,[r4,#1]
0000c0  3c94              SUBS     r4,r4,#0x94
0000c2  1e40              SUBS     r0,r0,#1
0000c4  4aec              LDR      r2,|L35.1144|
0000c6  5c10              LDRB     r0,[r2,r0]
0000c8  4281              CMP      r1,r0
0000ca  db5a              BLT      |L35.386|
;;;836              pcb->persist_cnt = 0;
0000cc  2000              MOVS     r0,#0
0000ce  f8840094          STRB     r0,[r4,#0x94]
;;;837              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
0000d2  f8940095          LDRB     r0,[r4,#0x95]
0000d6  2807              CMP      r0,#7
0000d8  d204              BCS      |L35.228|
;;;838                pcb->persist_backoff++;
0000da  f8940095          LDRB     r0,[r4,#0x95]
0000de  1c40              ADDS     r0,r0,#1
0000e0  f8840095          STRB     r0,[r4,#0x95]
                  |L35.228|
;;;839              }
;;;840              tcp_zero_window_probe(pcb);
0000e4  4620              MOV      r0,r4
0000e6  f7fffffe          BL       tcp_zero_window_probe
0000ea  e04a              B        |L35.386|
                  |L35.236|
;;;841            }
;;;842          } else {
;;;843            /* Increase the retransmission timer if it is running */
;;;844            if(pcb->rtime >= 0) {
0000ec  f9b40034          LDRSH    r0,[r4,#0x34]
0000f0  2800              CMP      r0,#0
0000f2  db03              BLT      |L35.252|
;;;845              ++pcb->rtime;
0000f4  8ea0              LDRH     r0,[r4,#0x34]
0000f6  1c40              ADDS     r0,r0,#1
0000f8  b200              SXTH     r0,r0
0000fa  86a0              STRH     r0,[r4,#0x34]
                  |L35.252|
;;;846            }
;;;847    
;;;848            if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
0000fc  6f20              LDR      r0,[r4,#0x70]
0000fe  b3e8              CBZ      r0,|L35.380|
000100  f9b40034          LDRSH    r0,[r4,#0x34]
000104  f9b41044          LDRSH    r1,[r4,#0x44]
000108  4288              CMP      r0,r1
00010a  db3a              BLT      |L35.386|
;;;849              /* Time for a retransmission. */
;;;850              LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %"S16_F
00010c  bf00              NOP      
00010e  bf00              NOP      
;;;851                                          " pcb->rto %"S16_F"\n",
;;;852                                          pcb->rtime, pcb->rto));
;;;853    
;;;854              /* Double retransmission time-out unless we are trying to
;;;855               * connect to somebody (i.e., we are in SYN_SENT). */
;;;856              if (pcb->state != SYN_SENT) {
000110  7e20              LDRB     r0,[r4,#0x18]
000112  2802              CMP      r0,#2
000114  d00c              BEQ      |L35.304|
;;;857                pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
000116  3440              ADDS     r4,r4,#0x40
000118  8860              LDRH     r0,[r4,#2]
00011a  f9b41000          LDRSH    r1,[r4,#0]
00011e  eb0000e1          ADD      r0,r0,r1,ASR #3
000122  79a1              LDRB     r1,[r4,#6]
000124  4ad5              LDR      r2,|L35.1148|
000126  5c51              LDRB     r1,[r2,r1]
000128  4088              LSLS     r0,r0,r1
00012a  b200              SXTH     r0,r0
00012c  80a0              STRH     r0,[r4,#4]
00012e  3c40              SUBS     r4,r4,#0x40
                  |L35.304|
;;;858              }
;;;859    
;;;860              /* Reset the retransmission timer. */
;;;861              pcb->rtime = 0;
000130  2000              MOVS     r0,#0
000132  86a0              STRH     r0,[r4,#0x34]
;;;862    
;;;863              /* Reduce congestion window and ssthresh. */
;;;864              eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
000134  f8b4004c          LDRH     r0,[r4,#0x4c]
000138  f8b41060          LDRH     r1,[r4,#0x60]
00013c  4288              CMP      r0,r1
00013e  da02              BGE      |L35.326|
000140  f8b4004c          LDRH     r0,[r4,#0x4c]
000144  e001              B        |L35.330|
                  |L35.326|
000146  f8b40060          LDRH     r0,[r4,#0x60]
                  |L35.330|
00014a  4682              MOV      r10,r0
;;;865              pcb->ssthresh = eff_wnd >> 1;
00014c  ea4f006a          ASR      r0,r10,#1
000150  f8a4004e          STRH     r0,[r4,#0x4e]
;;;866              if (pcb->ssthresh < (pcb->mss << 1)) {
000154  f8b4004e          LDRH     r0,[r4,#0x4e]
000158  8ee1              LDRH     r1,[r4,#0x36]
00015a  ebb00f41          CMP      r0,r1,LSL #1
00015e  da06              BGE      |L35.366|
;;;867                pcb->ssthresh = (pcb->mss << 1);
000160  8ee0              LDRH     r0,[r4,#0x36]
000162  f64f71ff          MOV      r1,#0xffff
000166  ea010040          AND      r0,r1,r0,LSL #1
00016a  f8a4004e          STRH     r0,[r4,#0x4e]
                  |L35.366|
;;;868              }
;;;869              pcb->cwnd = pcb->mss;
00016e  8ee0              LDRH     r0,[r4,#0x36]
000170  f8a4004c          STRH     r0,[r4,#0x4c]
;;;870              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"U16_F
000174  bf00              NOP      
000176  bf00              NOP      
;;;871                                           " ssthresh %"U16_F"\n",
;;;872                                           pcb->cwnd, pcb->ssthresh));
;;;873     
;;;874              /* The following needs to be called AFTER cwnd is set to one
;;;875                 mss - STJ */
;;;876              tcp_rexmit_rto(pcb);
000178  4620              MOV      r0,r4
00017a  e000              B        |L35.382|
                  |L35.380|
00017c  e001              B        |L35.386|
                  |L35.382|
00017e  f7fffffe          BL       tcp_rexmit_rto
                  |L35.386|
;;;877            }
;;;878          }
;;;879        }
;;;880        /* Check if this PCB has stayed too long in FIN-WAIT-2 */
;;;881        if (pcb->state == FIN_WAIT_2) {
000182  7e20              LDRB     r0,[r4,#0x18]
000184  2806              CMP      r0,#6
000186  d10d              BNE      |L35.420|
;;;882          /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
;;;883          if (pcb->flags & TF_RXCLOSED) {
000188  7fa0              LDRB     r0,[r4,#0x1e]
00018a  f0000010          AND      r0,r0,#0x10
00018e  b148              CBZ      r0,|L35.420|
;;;884            /* PCB was fully closed (either through close() or SHUT_RDWR):
;;;885               normal FIN-WAIT timeout handling. */
;;;886            if ((u32_t)(tcp_ticks - pcb->tmr) >
000190  4994              LDR      r1,|L35.996|
000192  6a60              LDR      r0,[r4,#0x24]
000194  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000196  1a08              SUBS     r0,r1,r0
000198  2828              CMP      r0,#0x28
00019a  d903              BLS      |L35.420|
;;;887                TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;888              ++pcb_remove;
00019c  1c70              ADDS     r0,r6,#1
00019e  b2c6              UXTB     r6,r0
;;;889              LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
0001a0  bf00              NOP      
0001a2  bf00              NOP      
                  |L35.420|
;;;890            }
;;;891          }
;;;892        }
;;;893    
;;;894        /* Check if KEEPALIVE should be sent */
;;;895        if(ip_get_option(pcb, SOF_KEEPALIVE) &&
0001a4  7a20              LDRB     r0,[r4,#8]
0001a6  f0000008          AND      r0,r0,#8
0001aa  b3b8              CBZ      r0,|L35.540|
;;;896           ((pcb->state == ESTABLISHED) ||
0001ac  7e20              LDRB     r0,[r4,#0x18]
0001ae  2804              CMP      r0,#4
0001b0  d002              BEQ      |L35.440|
;;;897            (pcb->state == CLOSE_WAIT))) {
0001b2  7e20              LDRB     r0,[r4,#0x18]
0001b4  2807              CMP      r0,#7
0001b6  d131              BNE      |L35.540|
                  |L35.440|
;;;898          if((u32_t)(tcp_ticks - pcb->tmr) >
0001b8  49b1              LDR      r1,|L35.1152|
0001ba  f8d40090          LDR      r0,[r4,#0x90]
0001be  4408              ADD      r0,r0,r1
0001c0  f44f71fa          MOV      r1,#0x1f4
0001c4  fbb0f0f1          UDIV     r0,r0,r1
0001c8  4a86              LDR      r2,|L35.996|
0001ca  6a61              LDR      r1,[r4,#0x24]
0001cc  6812              LDR      r2,[r2,#0]  ; tcp_ticks
0001ce  1a51              SUBS     r1,r2,r1
0001d0  4288              CMP      r0,r1
0001d2  d208              BCS      |L35.486|
;;;899             (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
;;;900          {
;;;901            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
0001d4  bf00              NOP      
0001d6  bf00              NOP      
;;;902                                    ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;903                                    ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;904            
;;;905            ++pcb_remove;
0001d8  1c70              ADDS     r0,r6,#1
0001da  b2c6              UXTB     r6,r0
;;;906            ++pcb_reset;
0001dc  f1090001          ADD      r0,r9,#1
0001e0  f00009ff          AND      r9,r0,#0xff
0001e4  e01a              B        |L35.540|
                  |L35.486|
;;;907          }
;;;908          else if((u32_t)(tcp_ticks - pcb->tmr) > 
0001e6  f8940096          LDRB     r0,[r4,#0x96]
0001ea  f242429f          MOV      r2,#0x249f
0001ee  4350              MULS     r0,r2,r0
0001f0  f8d41090          LDR      r1,[r4,#0x90]
0001f4  eb0100c0          ADD      r0,r1,r0,LSL #3
0001f8  f44f71fa          MOV      r1,#0x1f4
0001fc  fbb0f0f1          UDIV     r0,r0,r1
000200  4a78              LDR      r2,|L35.996|
000202  6a61              LDR      r1,[r4,#0x24]
000204  6812              LDR      r2,[r2,#0]  ; tcp_ticks
000206  1a51              SUBS     r1,r2,r1
000208  4288              CMP      r0,r1
00020a  d207              BCS      |L35.540|
;;;909                  (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
;;;910                  / TCP_SLOW_INTERVAL)
;;;911          {
;;;912            tcp_keepalive(pcb);
00020c  4620              MOV      r0,r4
00020e  f7fffffe          BL       tcp_keepalive
;;;913            pcb->keep_cnt_sent++;
000212  f8940096          LDRB     r0,[r4,#0x96]
000216  1c40              ADDS     r0,r0,#1
000218  f8840096          STRB     r0,[r4,#0x96]
                  |L35.540|
;;;914          }
;;;915        }
;;;916    
;;;917        /* If this PCB has queued out of sequence data, but has been
;;;918           inactive for too long, will drop the data (it will eventually
;;;919           be retransmitted). */
;;;920    #if TCP_QUEUE_OOSEQ
;;;921        if (pcb->ooseq != NULL &&
00021c  6f60              LDR      r0,[r4,#0x74]
00021e  b188              CBZ      r0,|L35.580|
;;;922            (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
000220  4970              LDR      r1,|L35.996|
000222  6a60              LDR      r0,[r4,#0x24]
000224  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000226  1a08              SUBS     r0,r1,r0
000228  f9b41044          LDRSH    r1,[r4,#0x44]
00022c  eb010141          ADD      r1,r1,r1,LSL #1
000230  ebb00f41          CMP      r0,r1,LSL #1
000234  d306              BCC      |L35.580|
;;;923          tcp_segs_free(pcb->ooseq);
000236  6f60              LDR      r0,[r4,#0x74]
000238  f7fffffe          BL       tcp_segs_free
;;;924          pcb->ooseq = NULL;
00023c  2000              MOVS     r0,#0
00023e  6760              STR      r0,[r4,#0x74]
;;;925          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
000240  bf00              NOP      
000242  bf00              NOP      
                  |L35.580|
;;;926        }
;;;927    #endif /* TCP_QUEUE_OOSEQ */
;;;928    
;;;929        /* Check if this PCB has stayed too long in SYN-RCVD */
;;;930        if (pcb->state == SYN_RCVD) {
000244  7e20              LDRB     r0,[r4,#0x18]
000246  2803              CMP      r0,#3
000248  d109              BNE      |L35.606|
;;;931          if ((u32_t)(tcp_ticks - pcb->tmr) >
00024a  4966              LDR      r1,|L35.996|
00024c  6a60              LDR      r0,[r4,#0x24]
00024e  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000250  1a08              SUBS     r0,r1,r0
000252  2828              CMP      r0,#0x28
000254  d903              BLS      |L35.606|
;;;932              TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;933            ++pcb_remove;
000256  1c70              ADDS     r0,r6,#1
000258  b2c6              UXTB     r6,r0
;;;934            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
00025a  bf00              NOP      
00025c  bf00              NOP      
                  |L35.606|
;;;935          }
;;;936        }
;;;937    
;;;938        /* Check if this PCB has stayed too long in LAST-ACK */
;;;939        if (pcb->state == LAST_ACK) {
00025e  7e20              LDRB     r0,[r4,#0x18]
000260  2809              CMP      r0,#9
000262  d109              BNE      |L35.632|
;;;940          if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
000264  495f              LDR      r1,|L35.996|
000266  6a60              LDR      r0,[r4,#0x24]
000268  6809              LDR      r1,[r1,#0]  ; tcp_ticks
00026a  1a08              SUBS     r0,r1,r0
00026c  28f0              CMP      r0,#0xf0
00026e  d903              BLS      |L35.632|
;;;941            ++pcb_remove;
000270  1c70              ADDS     r0,r6,#1
000272  b2c6              UXTB     r6,r0
;;;942            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
000274  bf00              NOP      
000276  bf00              NOP      
                  |L35.632|
;;;943          }
;;;944        }
;;;945    
;;;946        /* If the PCB should be removed, do it. */
;;;947        if (pcb_remove) {
000278  2e00              CMP      r6,#0
00027a  d047              BEQ      |L35.780|
;;;948          struct tcp_pcb *pcb2;
;;;949          tcp_err_fn err_fn;
;;;950          void *err_arg;
;;;951          tcp_pcb_purge(pcb);
00027c  4620              MOV      r0,r4
00027e  f7fffffe          BL       tcp_pcb_purge
;;;952          /* Remove PCB from tcp_active_pcbs list. */
;;;953          if (prev != NULL) {
000282  b16d              CBZ      r5,|L35.672|
;;;954            LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
000284  bf00              NOP      
000286  4859              LDR      r0,|L35.1004|
000288  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
00028a  4284              CMP      r4,r0
00028c  d104              BNE      |L35.664|
00028e  a07d              ADR      r0,|L35.1156|
000290  f7fffffe          BL       __2printf
000294  bf00              NOP      
                  |L35.662|
000296  e7fe              B        |L35.662|
                  |L35.664|
000298  bf00              NOP      
;;;955            prev->next = pcb->next;
00029a  68e0              LDR      r0,[r4,#0xc]
00029c  60e8              STR      r0,[r5,#0xc]
00029e  e00d              B        |L35.700|
                  |L35.672|
;;;956          } else {
;;;957            /* This PCB was the first. */
;;;958            LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
0002a0  bf00              NOP      
0002a2  4852              LDR      r0,|L35.1004|
0002a4  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
0002a6  42a0              CMP      r0,r4
0002a8  d004              BEQ      |L35.692|
0002aa  a081              ADR      r0,|L35.1200|
0002ac  f7fffffe          BL       __2printf
0002b0  bf00              NOP      
                  |L35.690|
0002b2  e7fe              B        |L35.690|
                  |L35.692|
0002b4  bf00              NOP      
;;;959            tcp_active_pcbs = pcb->next;
0002b6  494d              LDR      r1,|L35.1004|
0002b8  68e0              LDR      r0,[r4,#0xc]
0002ba  6008              STR      r0,[r1,#0]  ; tcp_active_pcbs
                  |L35.700|
;;;960          }
;;;961    
;;;962          if (pcb_reset) {
0002bc  f1b90f00          CMP      r9,#0
0002c0  d009              BEQ      |L35.726|
;;;963            tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
0002c2  8ba0              LDRH     r0,[r4,#0x1c]
0002c4  8b61              LDRH     r1,[r4,#0x1a]
0002c6  e9cd1000          STRD     r1,r0,[sp,#0]
0002ca  1d23              ADDS     r3,r4,#4
0002cc  4622              MOV      r2,r4
0002ce  6aa1              LDR      r1,[r4,#0x28]
0002d0  6d20              LDR      r0,[r4,#0x50]
0002d2  f7fffffe          BL       tcp_rst
                  |L35.726|
;;;964              pcb->local_port, pcb->remote_port);
;;;965          }
;;;966    
;;;967          err_fn = pcb->errf;
0002d6  f8d4808c          LDR      r8,[r4,#0x8c]
;;;968          err_arg = pcb->callback_arg;
0002da  f8d4b010          LDR      r11,[r4,#0x10]
;;;969          pcb2 = pcb;
0002de  4627              MOV      r7,r4
;;;970          pcb = pcb->next;
0002e0  68e4              LDR      r4,[r4,#0xc]
;;;971          memp_free(MEMP_TCP_PCB, pcb2);
0002e2  4639              MOV      r1,r7
0002e4  2002              MOVS     r0,#2
0002e6  f7fffffe          BL       memp_free
;;;972    
;;;973          tcp_active_pcbs_changed = 0;
0002ea  2000              MOVS     r0,#0
0002ec  497b              LDR      r1,|L35.1244|
0002ee  7008              STRB     r0,[r1,#0]
;;;974          TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
0002f0  bf00              NOP      
0002f2  f1b80f00          CMP      r8,#0
0002f6  d003              BEQ      |L35.768|
0002f8  f06f0109          MVN      r1,#9
0002fc  4658              MOV      r0,r11
0002fe  47c0              BLX      r8
                  |L35.768|
000300  bf00              NOP      
;;;975          if (tcp_active_pcbs_changed) {
000302  4876              LDR      r0,|L35.1244|
000304  7800              LDRB     r0,[r0,#0]  ; tcp_active_pcbs_changed
000306  b100              CBZ      r0,|L35.778|
;;;976            goto tcp_slowtmr_start;
000308  e689              B        |L35.30|
                  |L35.778|
;;;977          }
;;;978        } else {
00030a  e026              B        |L35.858|
                  |L35.780|
;;;979          /* get the 'next' element now and work with 'prev' below (in case of abort) */
;;;980          prev = pcb;
00030c  4625              MOV      r5,r4
;;;981          pcb = pcb->next;
00030e  68e4              LDR      r4,[r4,#0xc]
;;;982    
;;;983          /* We check if we should poll the connection. */
;;;984          ++prev->polltmr;
000310  7fe8              LDRB     r0,[r5,#0x1f]
000312  1c40              ADDS     r0,r0,#1
000314  77e8              STRB     r0,[r5,#0x1f]
;;;985          if (prev->polltmr >= prev->pollinterval) {
000316  7fe8              LDRB     r0,[r5,#0x1f]
000318  f8951020          LDRB     r1,[r5,#0x20]
00031c  4288              CMP      r0,r1
00031e  db1c              BLT      |L35.858|
;;;986            prev->polltmr = 0;
000320  2000              MOVS     r0,#0
000322  77e8              STRB     r0,[r5,#0x1f]
;;;987            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
000324  bf00              NOP      
000326  bf00              NOP      
;;;988            tcp_active_pcbs_changed = 0;
000328  496c              LDR      r1,|L35.1244|
00032a  7008              STRB     r0,[r1,#0]
;;;989            TCP_EVENT_POLL(prev, err);
00032c  bf00              NOP      
00032e  f8d50088          LDR      r0,[r5,#0x88]
000332  b130              CBZ      r0,|L35.834|
000334  4629              MOV      r1,r5
000336  f8d52088          LDR      r2,[r5,#0x88]
00033a  6928              LDR      r0,[r5,#0x10]
00033c  4790              BLX      r2
00033e  9002              STR      r0,[sp,#8]
000340  e001              B        |L35.838|
                  |L35.834|
000342  2000              MOVS     r0,#0
000344  9002              STR      r0,[sp,#8]
                  |L35.838|
000346  bf00              NOP      
;;;990            if (tcp_active_pcbs_changed) {
000348  4864              LDR      r0,|L35.1244|
00034a  7800              LDRB     r0,[r0,#0]  ; tcp_active_pcbs_changed
00034c  b100              CBZ      r0,|L35.848|
;;;991              goto tcp_slowtmr_start;
00034e  e666              B        |L35.30|
                  |L35.848|
;;;992            }
;;;993            /* if err == ERR_ABRT, 'prev' is already deallocated */
;;;994            if (err == ERR_OK) {
000350  9802              LDR      r0,[sp,#8]
000352  b910              CBNZ     r0,|L35.858|
;;;995              tcp_output(prev);
000354  4628              MOV      r0,r5
000356  f7fffffe          BL       tcp_output
                  |L35.858|
00035a  bf00              NOP                            ;816
                  |L35.860|
00035c  2c00              CMP      r4,#0                 ;808
00035e  f47fae65          BNE      |L35.44|
;;;996            }
;;;997          }
;;;998        }
;;;999      }
;;;1000   
;;;1001     
;;;1002     /* Steps through all of the TIME-WAIT PCBs. */
;;;1003     prev = NULL;
000362  2500              MOVS     r5,#0
;;;1004     pcb = tcp_tw_pcbs;
000364  485e              LDR      r0,|L35.1248|
000366  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
;;;1005     while (pcb != NULL) {
000368  e0fe              B        |L35.1384|
                  |L35.874|
;;;1006       LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
00036a  bf00              NOP      
00036c  7e20              LDRB     r0,[r4,#0x18]
00036e  280a              CMP      r0,#0xa
000370  d004              BEQ      |L35.892|
000372  a05c              ADR      r0,|L35.1252|
000374  f7fffffe          BL       __2printf
000378  bf00              NOP      
                  |L35.890|
00037a  e7fe              B        |L35.890|
                  |L35.892|
00037c  bf00              NOP      
;;;1007       pcb_remove = 0;
00037e  2600              MOVS     r6,#0
;;;1008   
;;;1009       /* Check if this PCB has stayed long enough in TIME-WAIT */
;;;1010       if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
000380  4918              LDR      r1,|L35.996|
000382  6a60              LDR      r0,[r4,#0x24]
000384  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000386  1a08              SUBS     r0,r1,r0
000388  28f0              CMP      r0,#0xf0
00038a  d901              BLS      |L35.912|
;;;1011         ++pcb_remove;
00038c  1c70              ADDS     r0,r6,#1
00038e  b2c6              UXTB     r6,r0
                  |L35.912|
;;;1012       }
;;;1013       
;;;1014   
;;;1015   
;;;1016       /* If the PCB should be removed, do it. */
;;;1017       if (pcb_remove) {
000390  b336              CBZ      r6,|L35.992|
;;;1018         struct tcp_pcb *pcb2;
;;;1019         tcp_pcb_purge(pcb);
000392  4620              MOV      r0,r4
000394  f7fffffe          BL       tcp_pcb_purge
;;;1020         /* Remove PCB from tcp_tw_pcbs list. */
;;;1021         if (prev != NULL) {
000398  b16d              CBZ      r5,|L35.950|
;;;1022           LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
00039a  bf00              NOP      
00039c  4850              LDR      r0,|L35.1248|
00039e  6800              LDR      r0,[r0,#0]  ; tcp_tw_pcbs
0003a0  4284              CMP      r4,r0
0003a2  d104              BNE      |L35.942|
0003a4  a05b              ADR      r0,|L35.1300|
0003a6  f7fffffe          BL       __2printf
0003aa  bf00              NOP      
                  |L35.940|
0003ac  e7fe              B        |L35.940|
                  |L35.942|
0003ae  bf00              NOP      
;;;1023           prev->next = pcb->next;
0003b0  68e0              LDR      r0,[r4,#0xc]
0003b2  60e8              STR      r0,[r5,#0xc]
0003b4  e00d              B        |L35.978|
                  |L35.950|
;;;1024         } else {
;;;1025           /* This PCB was the first. */
;;;1026           LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
0003b6  bf00              NOP      
0003b8  4849              LDR      r0,|L35.1248|
0003ba  6800              LDR      r0,[r0,#0]  ; tcp_tw_pcbs
0003bc  42a0              CMP      r0,r4
0003be  d004              BEQ      |L35.970|
0003c0  a05e              ADR      r0,|L35.1340|
0003c2  f7fffffe          BL       __2printf
0003c6  bf00              NOP      
                  |L35.968|
0003c8  e7fe              B        |L35.968|
                  |L35.970|
0003ca  bf00              NOP      
;;;1027           tcp_tw_pcbs = pcb->next;
0003cc  4944              LDR      r1,|L35.1248|
0003ce  68e0              LDR      r0,[r4,#0xc]
0003d0  6008              STR      r0,[r1,#0]  ; tcp_tw_pcbs
                  |L35.978|
;;;1028         }
;;;1029         pcb2 = pcb;
0003d2  4627              MOV      r7,r4
;;;1030         pcb = pcb->next;
0003d4  68e4              LDR      r4,[r4,#0xc]
;;;1031         memp_free(MEMP_TCP_PCB, pcb2);
0003d6  4639              MOV      r1,r7
0003d8  2002              MOVS     r0,#2
0003da  f7fffffe          BL       memp_free
;;;1032       } else {
0003de  e0c3              B        |L35.1384|
                  |L35.992|
0003e0  e0c0              B        |L35.1380|
0003e2  0000              DCW      0x0000
                  |L35.996|
                          DCD      tcp_ticks
                  |L35.1000|
                          DCD      tcp_timer_ctr
                  |L35.1004|
                          DCD      tcp_active_pcbs
                  |L35.1008|
0003f0  7463705f          DCB      "tcp_slowtmr: active pcb->state != CLOSED\n",0
0003f4  736c6f77
0003f8  746d723a
0003fc  20616374
000400  69766520
000404  7063622d
000408  3e737461
00040c  74652021
000410  3d20434c
000414  4f534544
000418  0a00    
00041a  00                DCB      0
00041b  00                DCB      0
                  |L35.1052|
00041c  7463705f          DCB      "tcp_slowtmr: active pcb->state != LISTEN\n",0
000420  736c6f77
000424  746d723a
000428  20616374
00042c  69766520
000430  7063622d
000434  3e737461
000438  74652021
00043c  3d204c49
000440  5354454e
000444  0a00    
000446  00                DCB      0
000447  00                DCB      0
                  |L35.1096|
000448  7463705f          DCB      "tcp_slowtmr: active pcb->state != TIME-WAIT\n",0
00044c  736c6f77
000450  746d723a
000454  20616374
000458  69766520
00045c  7063622d
000460  3e737461
000464  74652021
000468  3d205449
00046c  4d452d57
000470  4149540a
000474  00      
000475  00                DCB      0
000476  00                DCB      0
000477  00                DCB      0
                  |L35.1144|
                          DCD      tcp_persist_backoff
                  |L35.1148|
                          DCD      tcp_backoff
                  |L35.1152|
                          DCD      0x000a4cb8
                  |L35.1156|
000484  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_active_pcbs",0
000488  736c6f77
00048c  746d723a
000490  206d6964
000494  646c6520
000498  74637020
00049c  213d2074
0004a0  63705f61
0004a4  63746976
0004a8  655f7063
0004ac  627300  
0004af  00                DCB      0
                  |L35.1200|
0004b0  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_active_pcbs",0
0004b4  736c6f77
0004b8  746d723a
0004bc  20666972
0004c0  73742070
0004c4  6362203d
0004c8  3d207463
0004cc  705f6163
0004d0  74697665
0004d4  5f706362
0004d8  7300    
0004da  00                DCB      0
0004db  00                DCB      0
                  |L35.1244|
                          DCD      tcp_active_pcbs_changed
                  |L35.1248|
                          DCD      tcp_tw_pcbs
                  |L35.1252|
0004e4  7463705f          DCB      "tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT",0
0004e8  736c6f77
0004ec  746d723a
0004f0  2054494d
0004f4  452d5741
0004f8  49542070
0004fc  63622d3e
000500  73746174
000504  65203d3d
000508  2054494d
00050c  452d5741
000510  495400  
000513  00                DCB      0
                  |L35.1300|
000514  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_tw_pcbs",0
000518  736c6f77
00051c  746d723a
000520  206d6964
000524  646c6520
000528  74637020
00052c  213d2074
000530  63705f74
000534  775f7063
000538  627300  
00053b  00                DCB      0
                  |L35.1340|
00053c  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_tw_pcbs",0
000540  736c6f77
000544  746d723a
000548  20666972
00054c  73742070
000550  6362203d
000554  3d207463
000558  705f7477
00055c  5f706362
000560  7300    
000562  00                DCB      0
000563  00                DCB      0
                  |L35.1380|
;;;1033         prev = pcb;
000564  4625              MOV      r5,r4
;;;1034         pcb = pcb->next;
000566  68e4              LDR      r4,[r4,#0xc]
                  |L35.1384|
000568  2c00              CMP      r4,#0                 ;1005
00056a  f47faefe          BNE      |L35.874|
;;;1035       }
;;;1036     }
;;;1037   }
00056e  e8bd8ffe          POP      {r1-r11,pc}
;;;1038   
                          ENDP


                          AREA ||i.tcp_tmr||, CODE, READONLY, ALIGN=2

                  tcp_tmr PROC
;;;140    void
;;;141    tcp_tmr(void)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143      /* Call tcp_fasttmr() every 250 ms */
;;;144      tcp_fasttmr();
000002  f7fffffe          BL       tcp_fasttmr
;;;145    
;;;146      if (++tcp_timer & 1) {
000006  4806              LDR      r0,|L36.32|
000008  7800              LDRB     r0,[r0,#0]  ; tcp_timer
00000a  1c40              ADDS     r0,r0,#1
00000c  b2c0              UXTB     r0,r0
00000e  4904              LDR      r1,|L36.32|
000010  7008              STRB     r0,[r1,#0]
000012  f0000001          AND      r0,r0,#1
000016  b108              CBZ      r0,|L36.28|
;;;147        /* Call tcp_tmr() every 500 ms, i.e., every other timer
;;;148           tcp_tmr() is called. */
;;;149        tcp_slowtmr();
000018  f7fffffe          BL       tcp_slowtmr
                  |L36.28|
;;;150      }
;;;151    }
00001c  bd10              POP      {r4,pc}
;;;152    
                          ENDP

00001e  0000              DCW      0x0000
                  |L36.32|
                          DCD      tcp_timer

                          AREA ||i.tcp_update_rcv_ann_wnd||, CODE, READONLY, ALIGN=2

                  tcp_update_rcv_ann_wnd PROC
;;;578     */
;;;579    u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;580    {
000002  4604              MOV      r4,r0
;;;581      u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
000004  8da1              LDRH     r1,[r4,#0x2c]
000006  6aa0              LDR      r0,[r4,#0x28]
000008  1845              ADDS     r5,r0,r1
;;;582    
;;;583      if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
00000a  8ee0              LDRH     r0,[r4,#0x36]
00000c  6b21              LDR      r1,[r4,#0x30]
00000e  f5b06ffa          CMP      r0,#0x7d0
000012  dd02              BLE      |L37.26|
000014  f44f60fa          MOV      r0,#0x7d0
000018  e000              B        |L37.28|
                  |L37.26|
00001a  8ee0              LDRH     r0,[r4,#0x36]
                  |L37.28|
00001c  4408              ADD      r0,r0,r1
00001e  1a28              SUBS     r0,r5,r0
000020  d404              BMI      |L37.44|
;;;584        /* we can advertise more window */
;;;585        pcb->rcv_ann_wnd = pcb->rcv_wnd;
000022  8da0              LDRH     r0,[r4,#0x2c]
000024  85e0              STRH     r0,[r4,#0x2e]
;;;586        return new_right_edge - pcb->rcv_ann_right_edge;
000026  6b20              LDR      r0,[r4,#0x30]
000028  1a28              SUBS     r0,r5,r0
                  |L37.42|
;;;587      } else {
;;;588        if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
;;;589          /* Can happen due to other end sending out of advertised window,
;;;590           * but within actual available (but not yet advertised) window */
;;;591          pcb->rcv_ann_wnd = 0;
;;;592        } else {
;;;593          /* keep the right edge of window constant */
;;;594          u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
;;;595          LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
;;;596          pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
;;;597        }
;;;598        return 0;
;;;599      }
;;;600    }
00002a  bd70              POP      {r4-r6,pc}
                  |L37.44|
00002c  6b21              LDR      r1,[r4,#0x30]         ;588
00002e  6aa0              LDR      r0,[r4,#0x28]         ;588
000030  1a40              SUBS     r0,r0,r1              ;588
000032  2800              CMP      r0,#0                 ;588
000034  dd02              BLE      |L37.60|
000036  2000              MOVS     r0,#0                 ;591
000038  85e0              STRH     r0,[r4,#0x2e]         ;591
00003a  e00e              B        |L37.90|
                  |L37.60|
00003c  6aa1              LDR      r1,[r4,#0x28]         ;594
00003e  6b20              LDR      r0,[r4,#0x30]         ;594
000040  1a46              SUBS     r6,r0,r1              ;594
000042  bf00              NOP                            ;595
000044  f5b63f80          CMP      r6,#0x10000           ;595
000048  d304              BCC      |L37.84|
00004a  a005              ADR      r0,|L37.96|
00004c  f7fffffe          BL       __2printf
000050  bf00              NOP                            ;595
                  |L37.82|
000052  e7fe              B        |L37.82|
                  |L37.84|
000054  bf00              NOP                            ;595
000056  85e6              STRH     r6,[r4,#0x2e]         ;596
000058  bf00              NOP                            ;597
                  |L37.90|
00005a  2000              MOVS     r0,#0                 ;598
00005c  e7e5              B        |L37.42|
;;;601    
                          ENDP

00005e  0000              DCW      0x0000
                  |L37.96|
000060  6e65775f          DCB      "new_rcv_ann_wnd <= 0xffff",0
000064  7263765f
000068  616e6e5f
00006c  776e6420
000070  3c3d2030
000074  78666666
000078  6600    
00007a  00                DCB      0
00007b  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  tcp_state_str
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      ||.conststring||+0x10
                          DCD      ||.conststring||+0x1c
                          DCD      ||.conststring||+0x28
                          DCD      ||.conststring||+0x34
                          DCD      ||.conststring||+0x40
                          DCD      ||.conststring||+0x4c
                          DCD      ||.conststring||+0x58
                          DCD      ||.conststring||+0x60
                          DCD      ||.conststring||+0x6c
                  tcp_backoff
00002c  01020304          DCB      0x01,0x02,0x03,0x04
000030  05060707          DCB      0x05,0x06,0x07,0x07
000034  07070707          DCB      0x07,0x07,0x07,0x07
000038  07                DCB      0x07
                  tcp_persist_backoff
000039  03060c            DCB      0x03,0x06,0x0c
00003c  18306078          DCB      0x18,0x30,0x60,0x78
                  tcp_pcb_lists
                          DCD      tcp_listen_pcbs
                          DCD      tcp_bound_pcbs
                          DCD      tcp_active_pcbs
                          DCD      tcp_tw_pcbs

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  434c4f53          DCB      "CLOSED",0
000004  454400  
000007  00                DCB      0
000008  4c495354          DCB      "LISTEN",0
00000c  454e00  
00000f  00                DCB      0
000010  53594e5f          DCB      "SYN_SENT",0
000014  53454e54
000018  00      
000019  00                DCB      0
00001a  00                DCB      0
00001b  00                DCB      0
00001c  53594e5f          DCB      "SYN_RCVD",0
000020  52435644
000024  00      
000025  00                DCB      0
000026  00                DCB      0
000027  00                DCB      0
000028  45535441          DCB      "ESTABLISHED",0
00002c  424c4953
000030  48454400
000034  46494e5f          DCB      "FIN_WAIT_1",0
000038  57414954
00003c  5f3100  
00003f  00                DCB      0
000040  46494e5f          DCB      "FIN_WAIT_2",0
000044  57414954
000048  5f3200  
00004b  00                DCB      0
00004c  434c4f53          DCB      "CLOSE_WAIT",0
000050  455f5741
000054  495400  
000057  00                DCB      0
000058  434c4f53          DCB      "CLOSING",0
00005c  494e4700
000060  4c415354          DCB      "LAST_ACK",0
000064  5f41434b
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
00006c  54494d45          DCB      "TIME_WAIT",0
000070  5f574149
000074  5400    

                          AREA ||.data||, DATA, ALIGN=2

                  tcp_port
000000  c000              DCW      0xc000
000002  0000              DCB      0x00,0x00
                  tcp_ticks
                          DCD      0x00000000
                  tcp_bound_pcbs
                          DCD      0x00000000
                  tcp_listen_pcbs
                          DCD      0x00000000
                  tcp_active_pcbs
                          DCD      0x00000000
                  tcp_tw_pcbs
                          DCD      0x00000000
                  tcp_tmp_pcb
                          DCD      0x00000000
                  tcp_active_pcbs_changed
00001c  00                DCB      0x00
                  tcp_timer
00001d  00                DCB      0x00
                  tcp_timer_ctr
00001e  0000              DCB      0x00,0x00
                  iss
                          DCD      0x0000196e
