; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\ethernetif.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\ethernetif.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IE:\git_projects\enc28j60-for-uip\Project\RVMDK\RTE -I"D:\Program Files\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\ethernetif.crf ..\..\lwip\src\netif\ethernetif.c]
                          THUMB

                          AREA ||i.PacketReceive||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_int_dec
                  PacketReceive PROC
;;;137    static unsigned char  MyRecvbuf[1500]; 
;;;138    struct pbuf *PacketReceive(struct netif *netif)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;139    {
000004  4680              MOV      r8,r0
;;;140    	struct pbuf *p = NULL;	
000006  2600              MOVS     r6,#0
;;;141    	unsigned int recvlen = 0;
000008  2500              MOVS     r5,#0
;;;142    	unsigned int i = 0;
00000a  2700              MOVS     r7,#0
;;;143    	struct pbuf *q = NULL;
00000c  2400              MOVS     r4,#0
;;;144        
;;;145    	recvlen = enc28j60PacketReceive(1500, MyRecvbuf);
00000e  4915              LDR      r1,|L1.100|
000010  f24050dc          MOV      r0,#0x5dc
000014  f7fffffe          BL       enc28j60PacketReceive
000018  4605              MOV      r5,r0
;;;146    
;;;147    	if(!recvlen)	       //接收数据长度为0，直接返回空
00001a  b915              CBNZ     r5,|L1.34|
;;;148    	{
;;;149    	    return NULL;
00001c  2000              MOVS     r0,#0
                  |L1.30|
;;;150    	}
;;;151    	
;;;152    	//申请内核pbuf空间，为RAM类型
;;;153    	p = pbuf_alloc(PBUF_RAW, recvlen, PBUF_RAM);
;;;154    	
;;;155    	if(!p)			       //申请失败，则返回空
;;;156    	{
;;;157    	    LWIP_PLATFORM_DIAG(("PacketReceive: pbuf_alloc fail ,len=%"U32_F"\n\t", recvlen));
;;;158    		return NULL;
;;;159    	 }
;;;160        //申请成功，拷贝数据到pbuf中
;;;161    	q = p;
;;;162    		
;;;163    	while(q != NULL)
;;;164    	{   
;;;165    		memcpy(q->payload,&MyRecvbuf[i],q->len);
;;;166    		i += q->len;
;;;167    		q = q->next;
;;;168    		if(i >= recvlen)  break;
;;;169    	}
;;;170    		
;;;171    	return p;
;;;172    }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.34|
000022  b2a9              UXTH     r1,r5                 ;153
000024  2200              MOVS     r2,#0                 ;153
000026  2003              MOVS     r0,#3                 ;153
000028  f7fffffe          BL       pbuf_alloc
00002c  4606              MOV      r6,r0                 ;153
00002e  b92e              CBNZ     r6,|L1.60|
000030  4629              MOV      r1,r5                 ;157
000032  a00d              ADR      r0,|L1.104|
000034  f7fffffe          BL       __2printf
000038  2000              MOVS     r0,#0                 ;158
00003a  e7f0              B        |L1.30|
                  |L1.60|
00003c  4634              MOV      r4,r6                 ;161
00003e  e00b              B        |L1.88|
                  |L1.64|
000040  8962              LDRH     r2,[r4,#0xa]          ;165
000042  4b08              LDR      r3,|L1.100|
000044  19d9              ADDS     r1,r3,r7              ;165
000046  6860              LDR      r0,[r4,#4]            ;165
000048  f7fffffe          BL       __aeabi_memcpy
00004c  8960              LDRH     r0,[r4,#0xa]          ;166
00004e  4407              ADD      r7,r7,r0              ;166
000050  6824              LDR      r4,[r4,#0]            ;167
000052  42af              CMP      r7,r5                 ;168
000054  d300              BCC      |L1.88|
000056  e001              B        |L1.92|
                  |L1.88|
000058  2c00              CMP      r4,#0                 ;163
00005a  d1f1              BNE      |L1.64|
                  |L1.92|
00005c  bf00              NOP                            ;168
00005e  4630              MOV      r0,r6                 ;171
000060  e7dd              B        |L1.30|
;;;173    
                          ENDP

000062  0000              DCW      0x0000
                  |L1.100|
                          DCD      MyRecvbuf
                  |L1.104|
000068  5061636b          DCB      "PacketReceive: pbuf_alloc fail ,len=%u\n\t",0
00006c  65745265
000070  63656976
000074  653a2070
000078  6275665f
00007c  616c6c6f
000080  63206661
000084  696c202c
000088  6c656e3d
00008c  25750a09
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i.PacketSend||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_int_dec
                  PacketSend PROC
;;;100    static unsigned char  MySendbuf[1500]; 
;;;101    static err_t PacketSend (struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;102    {
000002  4605              MOV      r5,r0
;;;103    	struct pbuf *q = NULL;
000004  2600              MOVS     r6,#0
;;;104    	unsigned int templen = 0;
000006  2400              MOVS     r4,#0
;;;105    
;;;106    	for(q = p;q!=NULL;q = q->next)
000008  462e              MOV      r6,r5
00000a  e017              B        |L2.60|
                  |L2.12|
;;;107    	{
;;;108    		memcpy(&MySendbuf[templen],q->payload,q->len);	 //将pbuf中的数据拷贝到全局数组MyDatabuf中
00000c  8972              LDRH     r2,[r6,#0xa]
00000e  4b15              LDR      r3,|L2.100|
000010  1918              ADDS     r0,r3,r4
000012  6871              LDR      r1,[r6,#4]
000014  f7fffffe          BL       __aeabi_memcpy
;;;109    		templen += 	q->len ;
000018  8970              LDRH     r0,[r6,#0xa]
00001a  4404              ADD      r4,r4,r0
;;;110    
;;;111    		if(templen > 1500 || templen > p->tot_len)	 	//有效性校验，防止数据溢出
00001c  f24050dc          MOV      r0,#0x5dc
000020  4284              CMP      r4,r0
000022  d802              BHI      |L2.42|
000024  8928              LDRH     r0,[r5,#8]
000026  42a0              CMP      r0,r4
000028  d207              BCS      |L2.58|
                  |L2.42|
;;;112    		{
;;;113    			LWIP_PLATFORM_DIAG(("PacketSend: error,tmplen=%"U32_F",tot_len=%"U32_F"\n\t", templen, p->tot_len));
00002a  892a              LDRH     r2,[r5,#8]
00002c  4621              MOV      r1,r4
00002e  a00e              ADR      r0,|L2.104|
000030  f7fffffe          BL       __2printf
;;;114    			return ERR_BUF;
000034  f06f0001          MVN      r0,#1
                  |L2.56|
;;;115    		}
;;;116    	}
;;;117    	
;;;118    	//拷贝完毕，下面进行数据的发送工作
;;;119    	if(templen == p->tot_len)
;;;120    	{
;;;121    		enc28j60PacketSend(templen, MySendbuf);		   //调用网卡发送函数
;;;122    		return ERR_OK; 
;;;123    	}
;;;124    	
;;;125    	LWIP_PLATFORM_DIAG(("PacketSend: length mismatch ,tmplen=%"U32_F",tot_len=%"U32_F"\n\t", templen, p->tot_len));
;;;126    	return ERR_BUF;
;;;127    }
000038  bd70              POP      {r4-r6,pc}
                  |L2.58|
00003a  6836              LDR      r6,[r6,#0]            ;106
                  |L2.60|
00003c  2e00              CMP      r6,#0                 ;106
00003e  d1e5              BNE      |L2.12|
000040  8928              LDRH     r0,[r5,#8]            ;119
000042  42a0              CMP      r0,r4                 ;119
000044  d105              BNE      |L2.82|
000046  4907              LDR      r1,|L2.100|
000048  4620              MOV      r0,r4                 ;121
00004a  f7fffffe          BL       enc28j60PacketSend
00004e  2000              MOVS     r0,#0                 ;122
000050  e7f2              B        |L2.56|
                  |L2.82|
000052  892a              LDRH     r2,[r5,#8]            ;125
000054  4621              MOV      r1,r4                 ;125
000056  a00f              ADR      r0,|L2.148|
000058  f7fffffe          BL       __2printf
00005c  f06f0001          MVN      r0,#1                 ;126
000060  e7ea              B        |L2.56|
;;;128    /****************************************************************************
                          ENDP

000062  0000              DCW      0x0000
                  |L2.100|
                          DCD      MySendbuf
                  |L2.104|
000068  5061636b          DCB      "PacketSend: error,tmplen=%u,tot_len=%u\n\t",0
00006c  65745365
000070  6e643a20
000074  6572726f
000078  722c746d
00007c  706c656e
000080  3d25752c
000084  746f745f
000088  6c656e3d
00008c  25750a09
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0
                  |L2.148|
000094  5061636b          DCB      "PacketSend: length mismatch ,tmplen=%u,tot_len=%u\n\t",0
000098  65745365
00009c  6e643a20
0000a0  6c656e67
0000a4  7468206d
0000a8  69736d61
0000ac  74636820
0000b0  2c746d70
0000b4  6c656e3d
0000b8  25752c74
0000bc  6f745f6c
0000c0  656e3d25
0000c4  750a0900

                          AREA ||i.ethernetif_init||, CODE, READONLY, ALIGN=2

                  ethernetif_init PROC
;;;318    err_t
;;;319    ethernetif_init(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;320    {
000002  4604              MOV      r4,r0
;;;321      struct ethernetif *ethernetif;
;;;322    
;;;323      LWIP_ASSERT("netif != NULL", (netif != NULL));
000004  bf00              NOP      
000006  b924              CBNZ     r4,|L3.18|
000008  a012              ADR      r0,|L3.84|
00000a  f7fffffe          BL       __2printf
00000e  bf00              NOP      
                  |L3.16|
000010  e7fe              B        |L3.16|
                  |L3.18|
000012  bf00              NOP      
;;;324        
;;;325      ethernetif = mem_malloc(sizeof(struct ethernetif));
000014  2004              MOVS     r0,#4
000016  f7fffffe          BL       mem_malloc
00001a  4605              MOV      r5,r0
;;;326      if (ethernetif == NULL) {
00001c  b925              CBNZ     r5,|L3.40|
;;;327        LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
00001e  bf00              NOP      
000020  bf00              NOP      
;;;328        return ERR_MEM;
000022  f04f30ff          MOV      r0,#0xffffffff
                  |L3.38|
;;;329      }
;;;330    
;;;331    #if LWIP_NETIF_HOSTNAME
;;;332      /* Initialize interface hostname */
;;;333      netif->hostname = "lwip";
;;;334    #endif /* LWIP_NETIF_HOSTNAME */
;;;335    
;;;336      /*
;;;337       * Initialize the snmp variables and counters inside the struct netif.
;;;338       * The last argument should be replaced with your link speed, in units
;;;339       * of bits per second.
;;;340       */
;;;341      NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
;;;342    
;;;343      netif->state = ethernetif;
;;;344      netif->name[0] = IFNAME0;
;;;345      netif->name[1] = IFNAME1;
;;;346      /* We directly use etharp_output() here to save a function call.
;;;347       * You can instead declare your own function an call etharp_output()
;;;348       * from it if you have to do some checks before sending (e.g. if link
;;;349       * is available...) */
;;;350      netif->output = etharp_output;
;;;351      netif->linkoutput = low_level_output;
;;;352      
;;;353      ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
;;;354      
;;;355      /* initialize the hardware */
;;;356      low_level_init(netif);
;;;357    
;;;358      /*driver init ok,we set link up*/
;;;359      netif_set_link_up(netif );
;;;360      
;;;361      return ERR_OK;
;;;362    }
000026  bd70              POP      {r4-r6,pc}
                  |L3.40|
000028  61e5              STR      r5,[r4,#0x1c]         ;343
00002a  2065              MOVS     r0,#0x65              ;344
00002c  f884002a          STRB     r0,[r4,#0x2a]         ;344
000030  216e              MOVS     r1,#0x6e              ;345
000032  202b              MOVS     r0,#0x2b              ;345
000034  5501              STRB     r1,[r0,r4]            ;345
000036  480b              LDR      r0,|L3.100|
000038  6160              STR      r0,[r4,#0x14]         ;350
00003a  480b              LDR      r0,|L3.104|
00003c  61a0              STR      r0,[r4,#0x18]         ;351
00003e  f1040023          ADD      r0,r4,#0x23           ;353
000042  6028              STR      r0,[r5,#0]            ;353
000044  4620              MOV      r0,r4                 ;356
000046  f7fffffe          BL       low_level_init
00004a  4620              MOV      r0,r4                 ;359
00004c  f7fffffe          BL       netif_set_link_up
000050  2000              MOVS     r0,#0                 ;361
000052  e7e8              B        |L3.38|
;;;363    #endif /* 0 */
                          ENDP

                  |L3.84|
000054  6e657469          DCB      "netif != NULL",0
000058  6620213d
00005c  204e554c
000060  4c00    
000062  00                DCB      0
000063  00                DCB      0
                  |L3.100|
                          DCD      etharp_output
                  |L3.104|
                          DCD      low_level_output

                          AREA ||i.ethernetif_input||, CODE, READONLY, ALIGN=1

                  ethernetif_input PROC
;;;252    
;;;253    s32_t ethernetif_input(struct netif *netif)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;254    {
000004  4604              MOV      r4,r0
;;;255      struct ethernetif *ethernetif;
;;;256      struct eth_hdr *ethhdr;
;;;257      struct pbuf *p;
;;;258    
;;;259      ethernetif = netif->state;
000006  69e7              LDR      r7,[r4,#0x1c]
;;;260    
;;;261      /* move received packet into a new pbuf */
;;;262      p = low_level_input(netif);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       low_level_input
00000e  4605              MOV      r5,r0
;;;263      /* no packet could be read, silently ignore this */
;;;264      if (p == NULL) 
000010  b915              CBNZ     r5,|L4.24|
;;;265      {
;;;266      	return 0;
000012  2000              MOVS     r0,#0
                  |L4.20|
;;;267      }
;;;268      /* points to packet payload, which starts with an Ethernet header */
;;;269      ethhdr = p->payload;
;;;270    
;;;271      switch (htons(ethhdr->type)) {
;;;272      /* IP or ARP packet? */
;;;273      case ETHTYPE_IP:
;;;274      case ETHTYPE_ARP:
;;;275    #if PPPOE_SUPPORT
;;;276      /* PPPoE packet? */
;;;277      case ETHTYPE_PPPOEDISC:
;;;278      case ETHTYPE_PPPOE:
;;;279    #endif /* PPPOE_SUPPORT */
;;;280        /* full packet send to tcpip_thread to process */
;;;281        if (netif->input(p, netif)!=ERR_OK)
;;;282         { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
;;;283           pbuf_free(p);
;;;284           p = NULL;
;;;285         }
;;;286        break;
;;;287    
;;;288      default:
;;;289        pbuf_free(p);
;;;290        p = NULL;
;;;291        break;
;;;292      }
;;;293    
;;;294      return 1;
;;;295    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L4.24|
000018  686e              LDR      r6,[r5,#4]            ;269
00001a  89b0              LDRH     r0,[r6,#0xc]          ;271
00001c  f7fffffe          BL       lwip_htons
000020  f5b06f00          CMP      r0,#0x800             ;271
000024  d003              BEQ      |L4.46|
000026  f6a00006          SUB      r0,r0,#0x806          ;271
00002a  b968              CBNZ     r0,|L4.72|
00002c  e000              B        |L4.48|
                  |L4.46|
00002e  bf00              NOP                            ;274
                  |L4.48|
000030  4621              MOV      r1,r4                 ;281
000032  4628              MOV      r0,r5                 ;281
000034  6922              LDR      r2,[r4,#0x10]         ;281
000036  4790              BLX      r2                    ;281
000038  b128              CBZ      r0,|L4.70|
00003a  bf00              NOP                            ;282
00003c  bf00              NOP                            ;282
00003e  4628              MOV      r0,r5                 ;283
000040  f7fffffe          BL       pbuf_free
000044  2500              MOVS     r5,#0                 ;284
                  |L4.70|
000046  e004              B        |L4.82|
                  |L4.72|
000048  4628              MOV      r0,r5                 ;289
00004a  f7fffffe          BL       pbuf_free
00004e  2500              MOVS     r5,#0                 ;290
000050  bf00              NOP                            ;291
                  |L4.82|
000052  bf00              NOP                            ;286
000054  2001              MOVS     r0,#1                 ;294
000056  e7dd              B        |L4.20|
;;;296    
                          ENDP


                          AREA ||i.low_level_init||, CODE, READONLY, ALIGN=2

                  low_level_init PROC
;;;174    static void
;;;175    low_level_init(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;176    {
000002  4604              MOV      r4,r0
;;;177      struct ethernetif *ethernetif = netif->state;
000004  69e5              LDR      r5,[r4,#0x1c]
;;;178      
;;;179      /* set MAC hardware address length */
;;;180      netif->hwaddr_len = ETHARP_HWADDR_LEN;
000006  2006              MOVS     r0,#6
000008  f8840022          STRB     r0,[r4,#0x22]
;;;181    
;;;182      /* set MAC hardware address */
;;;183      netif->hwaddr[0] = MyMacID[0];
00000c  4810              LDR      r0,|L5.80|
00000e  7800              LDRB     r0,[r0,#0]  ; MyMacID
000010  f8840023          STRB     r0,[r4,#0x23]
;;;184      netif->hwaddr[1] = MyMacID[1];
000014  480e              LDR      r0,|L5.80|
000016  7841              LDRB     r1,[r0,#1]  ; MyMacID
000018  2024              MOVS     r0,#0x24
00001a  5501              STRB     r1,[r0,r4]
;;;185      netif->hwaddr[2] = MyMacID[2];
00001c  480c              LDR      r0,|L5.80|
00001e  7881              LDRB     r1,[r0,#2]  ; MyMacID
000020  2025              MOVS     r0,#0x25
000022  5501              STRB     r1,[r0,r4]
;;;186      netif->hwaddr[3] = MyMacID[3];
000024  480a              LDR      r0,|L5.80|
000026  78c1              LDRB     r1,[r0,#3]  ; MyMacID
000028  2026              MOVS     r0,#0x26
00002a  5501              STRB     r1,[r0,r4]
;;;187      netif->hwaddr[4] = MyMacID[4];                
00002c  4808              LDR      r0,|L5.80|
00002e  7901              LDRB     r1,[r0,#4]  ; MyMacID
000030  2027              MOVS     r0,#0x27
000032  5501              STRB     r1,[r0,r4]
;;;188      netif->hwaddr[5] = MyMacID[5];
000034  4806              LDR      r0,|L5.80|
000036  7941              LDRB     r1,[r0,#5]  ; MyMacID
000038  2028              MOVS     r0,#0x28
00003a  5501              STRB     r1,[r0,r4]
;;;189    
;;;190      /* maximum transfer unit */
;;;191      netif->mtu = 1500;
00003c  f24050dc          MOV      r0,#0x5dc
000040  8420              STRH     r0,[r4,#0x20]
;;;192      
;;;193      /* device capabilities */
;;;194      /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
;;;195      netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
000042  2032              MOVS     r0,#0x32
000044  f8840029          STRB     r0,[r4,#0x29]
;;;196    
;;;197      /* Do whatever else is needed to initialize interface. */
;;;198      //enc28j60Init(MyMacID); 
;;;199      mymacinit(MyMacID);
000048  4801              LDR      r0,|L5.80|
00004a  f7fffffe          BL       mymacinit
;;;200    }
00004e  bd70              POP      {r4-r6,pc}
;;;201    
                          ENDP

                  |L5.80|
                          DCD      MyMacID

                          AREA ||i.low_level_input||, CODE, READONLY, ALIGN=1

                  low_level_input PROC
;;;235    static struct pbuf *
;;;236    low_level_input(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;237    {
000002  4604              MOV      r4,r0
;;;238     
;;;239      //return NULL;
;;;240      return PacketReceive(netif);  
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       PacketReceive
;;;241    }
00000a  bd10              POP      {r4,pc}
;;;242    
                          ENDP


                          AREA ||i.low_level_output||, CODE, READONLY, ALIGN=1

                  low_level_output PROC
;;;218    static err_t
;;;219    low_level_output(struct netif *netif, struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;220    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;221    	//struct ethernetif *ethernetif = netif->state;
;;;222      /* Interrupts are disabled through this whole thing to support multi-threading
;;;223    	   transmit calls. Also this function might be called from an ISR. */
;;;224    	return PacketSend(p);	                // 调用网卡发送函数发送一帧数据
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       PacketSend
;;;225    }
00000c  bd70              POP      {r4-r6,pc}
;;;226    
                          ENDP


                          AREA ||i.process_mac||, CODE, READONLY, ALIGN=2

                  process_mac PROC
;;;296    
;;;297    void process_mac(void)
000000  b510              PUSH     {r4,lr}
;;;298    {
;;;299       s32_t ret = 0;
000002  2400              MOVS     r4,#0
;;;300       do
000004  bf00              NOP      
                  |L8.6|
;;;301       {
;;;302           ret = ethernetif_input(&enc28j60_netif);
000006  4803              LDR      r0,|L8.20|
000008  f7fffffe          BL       ethernetif_input
00000c  4604              MOV      r4,r0
;;;303    
;;;304       }while(ret);
00000e  2c00              CMP      r4,#0
000010  d1f9              BNE      |L8.6|
;;;305    }
000012  bd10              POP      {r4,pc}
;;;306    /**
                          ENDP

                  |L8.20|
                          DCD      enc28j60_netif

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  MySendbuf
                          %        1500
                  MyRecvbuf
                          %        1500

                          AREA ||.data||, DATA, ALIGN=0

                  MyMacID
000000  04023500          DCB      0x04,0x02,0x35,0x00
000004  0001              DCB      0x00,0x01
