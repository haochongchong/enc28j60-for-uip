; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mem.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\mem.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -ID:\ENC28J60\Project\RVMDK\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\mem.crf ..\..\lwip\src\core\mem.c]
                          THUMB

                          AREA ||i.mem_calloc||, CODE, READONLY, ALIGN=1

                  mem_calloc PROC
;;;645     */
;;;646    void *mem_calloc(mem_size_t count, mem_size_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;647    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;648      void *p;
;;;649    
;;;650      /* allocate 'count' objects of size 'size' */
;;;651      p = mem_malloc(count * size);
000006  fb04f105          MUL      r1,r4,r5
00000a  b288              UXTH     r0,r1
00000c  f7fffffe          BL       mem_malloc
000010  4606              MOV      r6,r0
;;;652      if (p) {
000012  b126              CBZ      r6,|L1.30|
;;;653        /* zero the memory */
;;;654        memset(p, 0, count * size);
000014  fb04f105          MUL      r1,r4,r5
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       __aeabi_memclr
                  |L1.30|
;;;655      }
;;;656      return p;
00001e  4630              MOV      r0,r6
;;;657    }
000020  bd70              POP      {r4-r6,pc}
;;;658    
                          ENDP


                          AREA ||i.mem_free||, CODE, READONLY, ALIGN=2

                  mem_free PROC
;;;310    void
;;;311    mem_free(void *rmem)
000000  b570              PUSH     {r4-r6,lr}
;;;312    {
000002  4605              MOV      r5,r0
;;;313      struct mem *mem;
;;;314      LWIP_MEM_FREE_DECL_PROTECT();
;;;315    
;;;316      if (rmem == NULL) {
000004  b915              CBNZ     r5,|L2.12|
;;;317        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
000006  bf00              NOP      
000008  bf00              NOP      
                  |L2.10|
;;;318        return;
;;;319      }
;;;320      LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
;;;321    
;;;322      LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
;;;323        (u8_t *)rmem < (u8_t *)ram_end);
;;;324    
;;;325      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;326        SYS_ARCH_DECL_PROTECT(lev);
;;;327        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
;;;328        /* protect mem stats from concurrent access */
;;;329        SYS_ARCH_PROTECT(lev);
;;;330        MEM_STATS_INC(illegal);
;;;331        SYS_ARCH_UNPROTECT(lev);
;;;332        return;
;;;333      }
;;;334      /* protect the heap from concurrent access */
;;;335      LWIP_MEM_FREE_PROTECT();
;;;336      /* Get the corresponding struct mem ... */
;;;337      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;338      /* ... which has to be in a used state ... */
;;;339      LWIP_ASSERT("mem_free: mem->used", mem->used);
;;;340      /* ... and is now unused. */
;;;341      mem->used = 0;
;;;342    
;;;343      if (mem < lfree) {
;;;344        /* the newly freed struct is now the lowest */
;;;345        lfree = mem;
;;;346      }
;;;347    
;;;348      MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
;;;349    
;;;350      /* finally, see if prev or next are free also */
;;;351      plug_holes(mem);
;;;352    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;353      mem_free_count = 1;
;;;354    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;355      LWIP_MEM_FREE_UNPROTECT();
;;;356    }
00000a  bd70              POP      {r4-r6,pc}
                  |L2.12|
00000c  bf00              NOP                            ;320
00000e  f0050003          AND      r0,r5,#3              ;320
000012  b120              CBZ      r0,|L2.30|
000014  a026              ADR      r0,|L2.176|
000016  f7fffffe          BL       __2printf
00001a  bf00              NOP                            ;320
                  |L2.28|
00001c  e7fe              B        |L2.28|
                  |L2.30|
00001e  bf00              NOP                            ;320
000020  bf00              NOP                            ;322
000022  482c              LDR      r0,|L2.212|
000024  6800              LDR      r0,[r0,#0]            ;322  ; ram
000026  4285              CMP      r5,r0                 ;322
000028  d303              BCC      |L2.50|
00002a  482b              LDR      r0,|L2.216|
00002c  6800              LDR      r0,[r0,#0]            ;322  ; ram_end
00002e  4285              CMP      r5,r0                 ;322
000030  d304              BCC      |L2.60|
                  |L2.50|
000032  a02a              ADR      r0,|L2.220|
000034  f7fffffe          BL       __2printf
000038  bf00              NOP                            ;322
                  |L2.58|
00003a  e7fe              B        |L2.58|
                  |L2.60|
00003c  bf00              NOP                            ;322
00003e  4825              LDR      r0,|L2.212|
000040  6800              LDR      r0,[r0,#0]            ;325  ; ram
000042  4285              CMP      r5,r0                 ;325
000044  d303              BCC      |L2.78|
000046  4824              LDR      r0,|L2.216|
000048  6800              LDR      r0,[r0,#0]            ;325  ; ram_end
00004a  4285              CMP      r5,r0                 ;325
00004c  d30a              BCC      |L2.100|
                  |L2.78|
00004e  bf00              NOP                            ;327
000050  bf00              NOP                            ;327
000052  4828              LDR      r0,|L2.244|
000054  f8b000b4          LDRH     r0,[r0,#0xb4]         ;330
000058  1c40              ADDS     r0,r0,#1              ;330
00005a  b281              UXTH     r1,r0                 ;330
00005c  4825              LDR      r0,|L2.244|
00005e  f8a010b4          STRH     r1,[r0,#0xb4]         ;330
000062  e7d2              B        |L2.10|
                  |L2.100|
000064  f1a50408          SUB      r4,r5,#8              ;337
000068  bf00              NOP                            ;339
00006a  7920              LDRB     r0,[r4,#4]            ;339
00006c  b920              CBNZ     r0,|L2.120|
00006e  a022              ADR      r0,|L2.248|
000070  f7fffffe          BL       __2printf
000074  bf00              NOP                            ;339
                  |L2.118|
000076  e7fe              B        |L2.118|
                  |L2.120|
000078  bf00              NOP                            ;339
00007a  2000              MOVS     r0,#0                 ;341
00007c  7120              STRB     r0,[r4,#4]            ;341
00007e  4823              LDR      r0,|L2.268|
000080  6800              LDR      r0,[r0,#0]            ;343  ; lfree
000082  4284              CMP      r4,r0                 ;343
000084  d201              BCS      |L2.138|
000086  4821              LDR      r0,|L2.268|
000088  6004              STR      r4,[r0,#0]            ;345  ; lfree
                  |L2.138|
00008a  8820              LDRH     r0,[r4,#0]            ;348
00008c  4911              LDR      r1,|L2.212|
00008e  8809              LDRH     r1,[r1,#0]            ;348  ; ram
000090  1a61              SUBS     r1,r4,r1              ;348
000092  1a41              SUBS     r1,r0,r1              ;348
000094  4817              LDR      r0,|L2.244|
000096  f8b000ae          LDRH     r0,[r0,#0xae]         ;348
00009a  1a40              SUBS     r0,r0,r1              ;348
00009c  b281              UXTH     r1,r0                 ;348
00009e  4815              LDR      r0,|L2.244|
0000a0  f8a010ae          STRH     r1,[r0,#0xae]         ;348
0000a4  4620              MOV      r0,r4                 ;351
0000a6  f7fffffe          BL       plug_holes
0000aa  bf00              NOP      
0000ac  e7ad              B        |L2.10|
;;;357    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L2.176|
0000b0  6d656d5f          DCB      "mem_free: sanity check alignment",0
0000b4  66726565
0000b8  3a207361
0000bc  6e697479
0000c0  20636865
0000c4  636b2061
0000c8  6c69676e
0000cc  6d656e74
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L2.212|
                          DCD      ||ram||
                  |L2.216|
                          DCD      ram_end
                  |L2.220|
0000dc  6d656d5f          DCB      "mem_free: legal memory",0
0000e0  66726565
0000e4  3a206c65
0000e8  67616c20
0000ec  6d656d6f
0000f0  727900  
0000f3  00                DCB      0
                  |L2.244|
                          DCD      lwip_stats
                  |L2.248|
0000f8  6d656d5f          DCB      "mem_free: mem->used",0
0000fc  66726565
000100  3a206d65
000104  6d2d3e75
000108  73656400
                  |L2.268|
                          DCD      lfree

                          AREA ||i.mem_init||, CODE, READONLY, ALIGN=2

                  mem_init PROC
;;;273    void
;;;274    mem_init(void)
000000  bf00              NOP      
;;;275    {
;;;276      struct mem *mem;
;;;277    
;;;278      LWIP_ASSERT("Sanity check alignment",
000002  bf00              NOP      
;;;279        (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);
;;;280    
;;;281      /* align the heap */
;;;282      ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
000004  4913              LDR      r1,|L3.84|
000006  f0210103          BIC      r1,r1,#3
00000a  4a13              LDR      r2,|L3.88|
00000c  6011              STR      r1,[r2,#0]  ; ram
;;;283      /* initialize the start of the heap */
;;;284      mem = (struct mem *)(void *)ram;
00000e  4611              MOV      r1,r2
000010  6808              LDR      r0,[r1,#0]  ; ram
;;;285      mem->next = MEM_SIZE_ALIGNED;
000012  f44f4120          MOV      r1,#0xa000
000016  8001              STRH     r1,[r0,#0]
;;;286      mem->prev = 0;
000018  2100              MOVS     r1,#0
00001a  8041              STRH     r1,[r0,#2]
;;;287      mem->used = 0;
00001c  7101              STRB     r1,[r0,#4]
;;;288      /* initialize the end of the heap */
;;;289      ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
00001e  4611              MOV      r1,r2
000020  6809              LDR      r1,[r1,#0]  ; ram
000022  f5014120          ADD      r1,r1,#0xa000
000026  4a0d              LDR      r2,|L3.92|
000028  6011              STR      r1,[r2,#0]  ; ram_end
;;;290      ram_end->used = 1;
00002a  2101              MOVS     r1,#1
00002c  6812              LDR      r2,[r2,#0]  ; ram_end
00002e  7111              STRB     r1,[r2,#4]
;;;291      ram_end->next = MEM_SIZE_ALIGNED;
000030  f44f4120          MOV      r1,#0xa000
000034  4a09              LDR      r2,|L3.92|
000036  6812              LDR      r2,[r2,#0]  ; ram_end
000038  8011              STRH     r1,[r2,#0]
;;;292      ram_end->prev = MEM_SIZE_ALIGNED;
00003a  4a08              LDR      r2,|L3.92|
00003c  6812              LDR      r2,[r2,#0]  ; ram_end
00003e  8051              STRH     r1,[r2,#2]
;;;293    
;;;294      /* initialize the lowest-free pointer to the start of the heap */
;;;295      lfree = (struct mem *)(void *)ram;
000040  4905              LDR      r1,|L3.88|
000042  6809              LDR      r1,[r1,#0]  ; ram
000044  4a06              LDR      r2,|L3.96|
000046  6011              STR      r1,[r2,#0]  ; lfree
;;;296    
;;;297      MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
000048  f44f4220          MOV      r2,#0xa000
00004c  4905              LDR      r1,|L3.100|
00004e  f8a120ac          STRH     r2,[r1,#0xac]
;;;298    
;;;299      if(sys_mutex_new(&mem_mutex) != ERR_OK) {
;;;300        LWIP_ASSERT("failed to create mem_mutex", 0);
;;;301      }
;;;302    }
000052  4770              BX       lr
;;;303    
                          ENDP

                  |L3.84|
                          DCD      ram_heap+0x3
                  |L3.88|
                          DCD      ||ram||
                  |L3.92|
                          DCD      ram_end
                  |L3.96|
                          DCD      lfree
                  |L3.100|
                          DCD      lwip_stats

                          AREA ||i.mem_malloc||, CODE, READONLY, ALIGN=2

                  mem_malloc PROC
;;;493    void *
;;;494    mem_malloc(mem_size_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;495    {
000004  4605              MOV      r5,r0
;;;496      mem_size_t ptr, ptr2;
;;;497      struct mem *mem, *mem2;
;;;498    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;499      u8_t local_mem_free_count = 0;
;;;500    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;501      LWIP_MEM_ALLOC_DECL_PROTECT();
;;;502    
;;;503      if (size == 0) {
000006  b915              CBNZ     r5,|L4.14|
;;;504        return NULL;
000008  2000              MOVS     r0,#0
                  |L4.10|
;;;505      }
;;;506    
;;;507      /* Expand the size of the allocated memory region so that we can
;;;508         adjust for alignment. */
;;;509      size = LWIP_MEM_ALIGN_SIZE(size);
;;;510    
;;;511      if(size < MIN_SIZE_ALIGNED) {
;;;512        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;513        size = MIN_SIZE_ALIGNED;
;;;514      }
;;;515    
;;;516      if (size > MEM_SIZE_ALIGNED) {
;;;517        return NULL;
;;;518      }
;;;519    
;;;520      /* protect the heap from concurrent access */
;;;521      sys_mutex_lock(&mem_mutex);
;;;522      LWIP_MEM_ALLOC_PROTECT();
;;;523    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;524      /* run as long as a mem_free disturbed mem_malloc or mem_trim */
;;;525      do {
;;;526        local_mem_free_count = 0;
;;;527    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;528    
;;;529        /* Scan through the heap searching for a free block that is big enough,
;;;530         * beginning with the lowest free block.
;;;531         */
;;;532        for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
;;;533             ptr = ((struct mem *)(void *)&ram[ptr])->next) {
;;;534          mem = (struct mem *)(void *)&ram[ptr];
;;;535    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;536          mem_free_count = 0;
;;;537          LWIP_MEM_ALLOC_UNPROTECT();
;;;538          /* allow mem_free or mem_trim to run */
;;;539          LWIP_MEM_ALLOC_PROTECT();
;;;540          if (mem_free_count != 0) {
;;;541            /* If mem_free or mem_trim have run, we have to restart since they
;;;542               could have altered our current struct mem. */
;;;543            local_mem_free_count = 1;
;;;544            break;
;;;545          }
;;;546    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;547    
;;;548          if ((!mem->used) &&
;;;549              (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
;;;550            /* mem is not used and at least perfect fit is possible:
;;;551             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
;;;552    
;;;553            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
;;;554              /* (in addition to the above, we test if another struct mem (SIZEOF_STRUCT_MEM) containing
;;;555               * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
;;;556               * -> split large block, create empty remainder,
;;;557               * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
;;;558               * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
;;;559               * struct mem would fit in but no data between mem2 and mem2->next
;;;560               * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;561               *       region that couldn't hold data, but when mem->next gets freed,
;;;562               *       the 2 regions would be combined, resulting in more free memory
;;;563               */
;;;564              ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
;;;565              /* create mem2 struct */
;;;566              mem2 = (struct mem *)(void *)&ram[ptr2];
;;;567              mem2->used = 0;
;;;568              mem2->next = mem->next;
;;;569              mem2->prev = ptr;
;;;570              /* and insert it between mem and mem->next */
;;;571              mem->next = ptr2;
;;;572              mem->used = 1;
;;;573    
;;;574              if (mem2->next != MEM_SIZE_ALIGNED) {
;;;575                ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;576              }
;;;577              MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
;;;578            } else {
;;;579              /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
;;;580               * be used at this point: if not we have 2 unused structs in a row, plug_holes should have
;;;581               * take care of this).
;;;582               * -> near fit or excact fit: do not split, no mem2 creation
;;;583               * also can't move mem->next directly behind mem, since mem->next
;;;584               * will always be used at this point!
;;;585               */
;;;586              mem->used = 1;
;;;587              MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
;;;588            }
;;;589    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;590    mem_malloc_adjust_lfree:
;;;591    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;592            if (mem == lfree) {
;;;593              struct mem *cur = lfree;
;;;594              /* Find next free block after mem and update lowest free pointer */
;;;595              while (cur->used && cur != ram_end) {
;;;596    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;597                mem_free_count = 0;
;;;598                LWIP_MEM_ALLOC_UNPROTECT();
;;;599                /* prevent high interrupt latency... */
;;;600                LWIP_MEM_ALLOC_PROTECT();
;;;601                if (mem_free_count != 0) {
;;;602                  /* If mem_free or mem_trim have run, we have to restart since they
;;;603                     could have altered our current struct mem or lfree. */
;;;604                  goto mem_malloc_adjust_lfree;
;;;605                }
;;;606    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;607                cur = (struct mem *)(void *)&ram[cur->next];
;;;608              }
;;;609              lfree = cur;
;;;610              LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
;;;611            }
;;;612            LWIP_MEM_ALLOC_UNPROTECT();
;;;613            sys_mutex_unlock(&mem_mutex);
;;;614            LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
;;;615             (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
;;;616            LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
;;;617             ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
;;;618            LWIP_ASSERT("mem_malloc: sanity check alignment",
;;;619              (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);
;;;620    
;;;621            return (u8_t *)mem + SIZEOF_STRUCT_MEM;
;;;622          }
;;;623        }
;;;624    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;625        /* if we got interrupted by a mem_free, try again */
;;;626      } while(local_mem_free_count != 0);
;;;627    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;628      LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
;;;629      MEM_STATS_INC(err);
;;;630      LWIP_MEM_ALLOC_UNPROTECT();
;;;631      sys_mutex_unlock(&mem_mutex);
;;;632      return NULL;
;;;633    }
00000a  e8bd87f0          POP      {r4-r10,pc}
                  |L4.14|
00000e  1ce8              ADDS     r0,r5,#3              ;509
000010  f0200003          BIC      r0,r0,#3              ;509
000014  b285              UXTH     r5,r0                 ;509
000016  2d0c              CMP      r5,#0xc               ;511
000018  da00              BGE      |L4.28|
00001a  250c              MOVS     r5,#0xc               ;513
                  |L4.28|
00001c  f5b54f20          CMP      r5,#0xa000            ;516
000020  dd01              BLE      |L4.38|
000022  2000              MOVS     r0,#0                 ;517
000024  e7f1              B        |L4.10|
                  |L4.38|
000026  4867              LDR      r0,|L4.452|
000028  8800              LDRH     r0,[r0,#0]            ;532  ; lfree
00002a  4967              LDR      r1,|L4.456|
00002c  8809              LDRH     r1,[r1,#0]            ;532  ; ram
00002e  1a40              SUBS     r0,r0,r1              ;532
000030  b286              UXTH     r6,r0                 ;532
000032  e0b5              B        |L4.416|
                  |L4.52|
000034  4864              LDR      r0,|L4.456|
000036  6800              LDR      r0,[r0,#0]            ;534  ; ram
000038  1984              ADDS     r4,r0,r6              ;534
00003a  7920              LDRB     r0,[r4,#4]            ;548
00003c  2800              CMP      r0,#0                 ;548
00003e  d17d              BNE      |L4.316|
000040  8821              LDRH     r1,[r4,#0]            ;549
000042  f1060008          ADD      r0,r6,#8              ;549
000046  1a08              SUBS     r0,r1,r0              ;549
000048  42a8              CMP      r0,r5                 ;549
00004a  d377              BCC      |L4.316|
00004c  8821              LDRH     r1,[r4,#0]            ;553
00004e  f1060008          ADD      r0,r6,#8              ;553
000052  1a09              SUBS     r1,r1,r0              ;553
000054  f1050014          ADD      r0,r5,#0x14           ;553
000058  4281              CMP      r1,r0                 ;553
00005a  d332              BCC      |L4.194|
00005c  f1060008          ADD      r0,r6,#8              ;564
000060  4428              ADD      r0,r0,r5              ;564
000062  fa1ff880          UXTH     r8,r0                 ;564
000066  4858              LDR      r0,|L4.456|
000068  6800              LDR      r0,[r0,#0]            ;566  ; ram
00006a  eb000708          ADD      r7,r0,r8              ;566
00006e  2000              MOVS     r0,#0                 ;567
000070  7138              STRB     r0,[r7,#4]            ;567
000072  8820              LDRH     r0,[r4,#0]            ;568
000074  8038              STRH     r0,[r7,#0]            ;568
000076  807e              STRH     r6,[r7,#2]            ;569
000078  f8a48000          STRH     r8,[r4,#0]            ;571
00007c  2001              MOVS     r0,#1                 ;572
00007e  7120              STRB     r0,[r4,#4]            ;572
000080  8838              LDRH     r0,[r7,#0]            ;574
000082  f5b04f20          CMP      r0,#0xa000            ;574
000086  d005              BEQ      |L4.148|
000088  8838              LDRH     r0,[r7,#0]            ;575
00008a  494f              LDR      r1,|L4.456|
00008c  6809              LDR      r1,[r1,#0]            ;575  ; ram
00008e  4408              ADD      r0,r0,r1              ;575
000090  f8a08002          STRH     r8,[r0,#2]            ;575
                  |L4.148|
000094  bf00              NOP                            ;577
000096  484d              LDR      r0,|L4.460|
000098  f8b010ae          LDRH     r1,[r0,#0xae]         ;577
00009c  f1050008          ADD      r0,r5,#8              ;577
0000a0  4408              ADD      r0,r0,r1              ;577
0000a2  b281              UXTH     r1,r0                 ;577
0000a4  4849              LDR      r0,|L4.460|
0000a6  f8a010ae          STRH     r1,[r0,#0xae]         ;577
0000aa  f8b010b0          LDRH     r1,[r0,#0xb0]         ;577
0000ae  f8b000ae          LDRH     r0,[r0,#0xae]         ;577
0000b2  4281              CMP      r1,r0                 ;577
0000b4  da04              BGE      |L4.192|
0000b6  4845              LDR      r0,|L4.460|
0000b8  f8b010ae          LDRH     r1,[r0,#0xae]         ;577
0000bc  f8a010b0          STRH     r1,[r0,#0xb0]         ;577
                  |L4.192|
0000c0  e01b              B        |L4.250|
                  |L4.194|
0000c2  2001              MOVS     r0,#1                 ;586
0000c4  7120              STRB     r0,[r4,#4]            ;586
0000c6  bf00              NOP                            ;587
0000c8  8820              LDRH     r0,[r4,#0]            ;587
0000ca  493f              LDR      r1,|L4.456|
0000cc  8809              LDRH     r1,[r1,#0]            ;587  ; ram
0000ce  1a61              SUBS     r1,r4,r1              ;587
0000d0  1a41              SUBS     r1,r0,r1              ;587
0000d2  483e              LDR      r0,|L4.460|
0000d4  f8b000ae          LDRH     r0,[r0,#0xae]         ;587
0000d8  4408              ADD      r0,r0,r1              ;587
0000da  b281              UXTH     r1,r0                 ;587
0000dc  483b              LDR      r0,|L4.460|
0000de  f8a010ae          STRH     r1,[r0,#0xae]         ;587
0000e2  f8b010b0          LDRH     r1,[r0,#0xb0]         ;587
0000e6  f8b000ae          LDRH     r0,[r0,#0xae]         ;587
0000ea  4281              CMP      r1,r0                 ;587
0000ec  da04              BGE      |L4.248|
0000ee  4837              LDR      r0,|L4.460|
0000f0  f8b010ae          LDRH     r1,[r0,#0xae]         ;587
0000f4  f8a010b0          STRH     r1,[r0,#0xb0]         ;587
                  |L4.248|
0000f8  bf00              NOP                            ;587
                  |L4.250|
0000fa  4832              LDR      r0,|L4.452|
0000fc  6800              LDR      r0,[r0,#0]            ;592  ; lfree
0000fe  4284              CMP      r4,r0                 ;592
000100  d126              BNE      |L4.336|
000102  4830              LDR      r0,|L4.452|
000104  f8d09000          LDR      r9,[r0,#0]            ;593  ; lfree
000108  e005              B        |L4.278|
                  |L4.266|
00010a  f8b90000          LDRH     r0,[r9,#0]            ;607
00010e  492e              LDR      r1,|L4.456|
000110  6809              LDR      r1,[r1,#0]            ;607  ; ram
000112  eb000901          ADD      r9,r0,r1              ;607
                  |L4.278|
000116  f8990004          LDRB     r0,[r9,#4]            ;595
00011a  b118              CBZ      r0,|L4.292|
00011c  482c              LDR      r0,|L4.464|
00011e  6800              LDR      r0,[r0,#0]            ;595  ; ram_end
000120  4581              CMP      r9,r0                 ;595
000122  d1f2              BNE      |L4.266|
                  |L4.292|
000124  4827              LDR      r0,|L4.452|
000126  f8c09000          STR      r9,[r0,#0]            ;609  ; lfree
00012a  bf00              NOP                            ;610
00012c  6800              LDR      r0,[r0,#0]            ;610  ; lfree
00012e  4928              LDR      r1,|L4.464|
000130  6809              LDR      r1,[r1,#0]            ;610  ; ram_end
000132  4288              CMP      r0,r1                 ;610
000134  d00a              BEQ      |L4.332|
000136  4823              LDR      r0,|L4.452|
000138  6800              LDR      r0,[r0,#0]            ;610  ; lfree
00013a  e000              B        |L4.318|
                  |L4.316|
00013c  e02d              B        |L4.410|
                  |L4.318|
00013e  7900              LDRB     r0,[r0,#4]            ;610
000140  b120              CBZ      r0,|L4.332|
000142  a024              ADR      r0,|L4.468|
000144  f7fffffe          BL       __2printf
000148  bf00              NOP                            ;610
                  |L4.330|
00014a  e7fe              B        |L4.330|
                  |L4.332|
00014c  bf00              NOP                            ;610
00014e  bf00              NOP                            ;611
                  |L4.336|
000150  bf00              NOP                            ;614
000152  f1040008          ADD      r0,r4,#8              ;614
000156  4428              ADD      r0,r0,r5              ;614
000158  491d              LDR      r1,|L4.464|
00015a  6809              LDR      r1,[r1,#0]            ;614  ; ram_end
00015c  4288              CMP      r0,r1                 ;614
00015e  d904              BLS      |L4.362|
000160  a023              ADR      r0,|L4.496|
000162  f7fffffe          BL       __2printf
000166  bf00              NOP                            ;614
                  |L4.360|
000168  e7fe              B        |L4.360|
                  |L4.362|
00016a  bf00              NOP                            ;614
00016c  bf00              NOP                            ;616
00016e  f0040003          AND      r0,r4,#3              ;616
000172  b120              CBZ      r0,|L4.382|
000174  a02a              ADR      r0,|L4.544|
000176  f7fffffe          BL       __2printf
00017a  bf00              NOP                            ;616
                  |L4.380|
00017c  e7fe              B        |L4.380|
                  |L4.382|
00017e  bf00              NOP                            ;616
000180  bf00              NOP                            ;618
000182  f0040003          AND      r0,r4,#3              ;618
000186  b120              CBZ      r0,|L4.402|
000188  a031              ADR      r0,|L4.592|
00018a  f7fffffe          BL       __2printf
00018e  bf00              NOP                            ;618
                  |L4.400|
000190  e7fe              B        |L4.400|
                  |L4.402|
000192  bf00              NOP                            ;618
000194  f1040008          ADD      r0,r4,#8              ;621
000198  e737              B        |L4.10|
                  |L4.410|
00019a  480b              LDR      r0,|L4.456|
00019c  6800              LDR      r0,[r0,#0]            ;533  ; ram
00019e  5b86              LDRH     r6,[r0,r6]            ;533
                  |L4.416|
0001a0  f5c54020          RSB      r0,r5,#0xa000         ;532
0001a4  42b0              CMP      r0,r6                 ;532
0001a6  f73faf45          BGT      |L4.52|
0001aa  bf00              NOP                            ;628
0001ac  bf00              NOP                            ;628
0001ae  4807              LDR      r0,|L4.460|
0001b0  f8b000b2          LDRH     r0,[r0,#0xb2]         ;629
0001b4  1c40              ADDS     r0,r0,#1              ;629
0001b6  b281              UXTH     r1,r0                 ;629
0001b8  4804              LDR      r0,|L4.460|
0001ba  f8a010b2          STRH     r1,[r0,#0xb2]         ;629
0001be  2000              MOVS     r0,#0                 ;632
0001c0  e723              B        |L4.10|
;;;634    
                          ENDP

0001c2  0000              DCW      0x0000
                  |L4.452|
                          DCD      lfree
                  |L4.456|
                          DCD      ||ram||
                  |L4.460|
                          DCD      lwip_stats
                  |L4.464|
                          DCD      ram_end
                  |L4.468|
0001d4  6d656d5f          DCB      "mem_malloc: !lfree->used",0
0001d8  6d616c6c
0001dc  6f633a20
0001e0  216c6672
0001e4  65652d3e
0001e8  75736564
0001ec  00      
0001ed  00                DCB      0
0001ee  00                DCB      0
0001ef  00                DCB      0
                  |L4.496|
0001f0  6d656d5f          DCB      "mem_malloc: allocated memory not above ram_end.",0
0001f4  6d616c6c
0001f8  6f633a20
0001fc  616c6c6f
000200  63617465
000204  64206d65
000208  6d6f7279
00020c  206e6f74
000210  2061626f
000214  76652072
000218  616d5f65
00021c  6e642e00
                  |L4.544|
000220  6d656d5f          DCB      "mem_malloc: allocated memory properly aligned.",0
000224  6d616c6c
000228  6f633a20
00022c  616c6c6f
000230  63617465
000234  64206d65
000238  6d6f7279
00023c  2070726f
000240  7065726c
000244  7920616c
000248  69676e65
00024c  642e00  
00024f  00                DCB      0
                  |L4.592|
000250  6d656d5f          DCB      "mem_malloc: sanity check alignment",0
000254  6d616c6c
000258  6f633a20
00025c  73616e69
000260  74792063
000264  6865636b
000268  20616c69
00026c  676e6d65
000270  6e7400  
000273  00                DCB      0

                          AREA ||i.mem_trim||, CODE, READONLY, ALIGN=2

                  mem_trim PROC
;;;368    void *
;;;369    mem_trim(void *rmem, mem_size_t newsize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;370    {
000004  4681              MOV      r9,r0
000006  460d              MOV      r5,r1
;;;371      mem_size_t size;
;;;372      mem_size_t ptr, ptr2;
;;;373      struct mem *mem, *mem2;
;;;374      /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
;;;375      LWIP_MEM_FREE_DECL_PROTECT();
;;;376    
;;;377      /* Expand the size of the allocated memory region so that we can
;;;378         adjust for alignment. */
;;;379      newsize = LWIP_MEM_ALIGN_SIZE(newsize);
000008  1ce8              ADDS     r0,r5,#3
00000a  f0200003          BIC      r0,r0,#3
00000e  b285              UXTH     r5,r0
;;;380    
;;;381      if(newsize < MIN_SIZE_ALIGNED) {
000010  2d0c              CMP      r5,#0xc
000012  da00              BGE      |L5.22|
;;;382        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;383        newsize = MIN_SIZE_ALIGNED;
000014  250c              MOVS     r5,#0xc
                  |L5.22|
;;;384      }
;;;385    
;;;386      if (newsize > MEM_SIZE_ALIGNED) {
000016  f5b54f20          CMP      r5,#0xa000
00001a  dd02              BLE      |L5.34|
;;;387        return NULL;
00001c  2000              MOVS     r0,#0
                  |L5.30|
;;;388      }
;;;389    
;;;390      LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
;;;391       (u8_t *)rmem < (u8_t *)ram_end);
;;;392    
;;;393      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;394        SYS_ARCH_DECL_PROTECT(lev);
;;;395        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
;;;396        /* protect mem stats from concurrent access */
;;;397        SYS_ARCH_PROTECT(lev);
;;;398        MEM_STATS_INC(illegal);
;;;399        SYS_ARCH_UNPROTECT(lev);
;;;400        return rmem;
;;;401      }
;;;402      /* Get the corresponding struct mem ... */
;;;403      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;404      /* ... and its offset pointer */
;;;405      ptr = (mem_size_t)((u8_t *)mem - ram);
;;;406    
;;;407      size = mem->next - ptr - SIZEOF_STRUCT_MEM;
;;;408      LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
;;;409      if (newsize > size) {
;;;410        /* not supported */
;;;411        return NULL;
;;;412      }
;;;413      if (newsize == size) {
;;;414        /* No change in size, simply return */
;;;415        return rmem;
;;;416      }
;;;417    
;;;418      /* protect the heap from concurrent access */
;;;419      LWIP_MEM_FREE_PROTECT();
;;;420    
;;;421      mem2 = (struct mem *)(void *)&ram[mem->next];
;;;422      if(mem2->used == 0) {
;;;423        /* The next struct is unused, we can simply move it at little */
;;;424        mem_size_t next;
;;;425        /* remember the old next pointer */
;;;426        next = mem2->next;
;;;427        /* create new struct mem which is moved directly after the shrinked mem */
;;;428        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;429        if (lfree == mem2) {
;;;430          lfree = (struct mem *)(void *)&ram[ptr2];
;;;431        }
;;;432        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;433        mem2->used = 0;
;;;434        /* restore the next pointer */
;;;435        mem2->next = next;
;;;436        /* link it back to mem */
;;;437        mem2->prev = ptr;
;;;438        /* link mem to it */
;;;439        mem->next = ptr2;
;;;440        /* last thing to restore linked list: as we have moved mem2,
;;;441         * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
;;;442         * the end of the heap */
;;;443        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;444          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;445        }
;;;446        MEM_STATS_DEC_USED(used, (size - newsize));
;;;447        /* no need to plug holes, we've already done that */
;;;448      } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
;;;449        /* Next struct is used but there's room for another struct mem with
;;;450         * at least MIN_SIZE_ALIGNED of data.
;;;451         * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
;;;452         * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
;;;453         * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;454         *       region that couldn't hold data, but when mem->next gets freed,
;;;455         *       the 2 regions would be combined, resulting in more free memory */
;;;456        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;457        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;458        if (mem2 < lfree) {
;;;459          lfree = mem2;
;;;460        }
;;;461        mem2->used = 0;
;;;462        mem2->next = mem->next;
;;;463        mem2->prev = ptr;
;;;464        mem->next = ptr2;
;;;465        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;466          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;467        }
;;;468        MEM_STATS_DEC_USED(used, (size - newsize));
;;;469        /* the original mem->next is used, so no need to plug holes! */
;;;470      }
;;;471      /* else {
;;;472        next struct mem is used but size between mem and mem2 is not big enough
;;;473        to create another struct mem
;;;474        -> don't do anyhting. 
;;;475        -> the remaining space stays unused since it is too small
;;;476      } */
;;;477    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;478      mem_free_count = 1;
;;;479    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;480      LWIP_MEM_FREE_UNPROTECT();
;;;481      return rmem;
;;;482    }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L5.34|
000022  bf00              NOP                            ;390
000024  4850              LDR      r0,|L5.360|
000026  6800              LDR      r0,[r0,#0]            ;390  ; ram
000028  4581              CMP      r9,r0                 ;390
00002a  d303              BCC      |L5.52|
00002c  484f              LDR      r0,|L5.364|
00002e  6800              LDR      r0,[r0,#0]            ;390  ; ram_end
000030  4581              CMP      r9,r0                 ;390
000032  d304              BCC      |L5.62|
                  |L5.52|
000034  a04e              ADR      r0,|L5.368|
000036  f7fffffe          BL       __2printf
00003a  bf00              NOP                            ;390
                  |L5.60|
00003c  e7fe              B        |L5.60|
                  |L5.62|
00003e  bf00              NOP                            ;390
000040  4849              LDR      r0,|L5.360|
000042  6800              LDR      r0,[r0,#0]            ;393  ; ram
000044  4581              CMP      r9,r0                 ;393
000046  d303              BCC      |L5.80|
000048  4848              LDR      r0,|L5.364|
00004a  6800              LDR      r0,[r0,#0]            ;393  ; ram_end
00004c  4581              CMP      r9,r0                 ;393
00004e  d30b              BCC      |L5.104|
                  |L5.80|
000050  bf00              NOP                            ;395
000052  bf00              NOP                            ;395
000054  484c              LDR      r0,|L5.392|
000056  f8b000b4          LDRH     r0,[r0,#0xb4]         ;398
00005a  1c40              ADDS     r0,r0,#1              ;398
00005c  b281              UXTH     r1,r0                 ;398
00005e  484a              LDR      r0,|L5.392|
000060  f8a010b4          STRH     r1,[r0,#0xb4]         ;398
000064  4648              MOV      r0,r9                 ;400
000066  e7da              B        |L5.30|
                  |L5.104|
000068  f1a90808          SUB      r8,r9,#8              ;403
00006c  483e              LDR      r0,|L5.360|
00006e  8800              LDRH     r0,[r0,#0]            ;405  ; ram
000070  eba80000          SUB      r0,r8,r0              ;405
000074  fa1ffa80          UXTH     r10,r0                ;405
000078  f8b80000          LDRH     r0,[r8,#0]            ;407
00007c  eba0000a          SUB      r0,r0,r10             ;407
000080  3808              SUBS     r0,r0,#8              ;407
000082  b287              UXTH     r7,r0                 ;407
000084  bf00              NOP                            ;408
000086  42bd              CMP      r5,r7                 ;408
000088  dd04              BLE      |L5.148|
00008a  a040              ADR      r0,|L5.396|
00008c  f7fffffe          BL       __2printf
000090  bf00              NOP                            ;408
                  |L5.146|
000092  e7fe              B        |L5.146|
                  |L5.148|
000094  bf00              NOP                            ;408
000096  42bd              CMP      r5,r7                 ;409
000098  dd01              BLE      |L5.158|
00009a  2000              MOVS     r0,#0                 ;411
00009c  e7bf              B        |L5.30|
                  |L5.158|
00009e  42bd              CMP      r5,r7                 ;413
0000a0  d101              BNE      |L5.166|
0000a2  4648              MOV      r0,r9                 ;415
0000a4  e7bb              B        |L5.30|
                  |L5.166|
0000a6  f8b80000          LDRH     r0,[r8,#0]            ;421
0000aa  492f              LDR      r1,|L5.360|
0000ac  6809              LDR      r1,[r1,#0]            ;421  ; ram
0000ae  1844              ADDS     r4,r0,r1              ;421
0000b0  7920              LDRB     r0,[r4,#4]            ;422
0000b2  bb50              CBNZ     r0,|L5.266|
0000b4  8820              LDRH     r0,[r4,#0]            ;426
0000b6  f10a0108          ADD      r1,r10,#8             ;428
0000ba  4429              ADD      r1,r1,r5              ;428
0000bc  b28e              UXTH     r6,r1                 ;428
0000be  493b              LDR      r1,|L5.428|
0000c0  6809              LDR      r1,[r1,#0]            ;429  ; lfree
0000c2  42a1              CMP      r1,r4                 ;429
0000c4  d104              BNE      |L5.208|
0000c6  4928              LDR      r1,|L5.360|
0000c8  6809              LDR      r1,[r1,#0]            ;430  ; ram
0000ca  4431              ADD      r1,r1,r6              ;430
0000cc  4a37              LDR      r2,|L5.428|
0000ce  6011              STR      r1,[r2,#0]            ;430  ; lfree
                  |L5.208|
0000d0  4925              LDR      r1,|L5.360|
0000d2  6809              LDR      r1,[r1,#0]            ;432  ; ram
0000d4  198c              ADDS     r4,r1,r6              ;432
0000d6  2100              MOVS     r1,#0                 ;433
0000d8  7121              STRB     r1,[r4,#4]            ;433
0000da  8020              STRH     r0,[r4,#0]            ;435
0000dc  f8a4a002          STRH     r10,[r4,#2]           ;437
0000e0  f8a86000          STRH     r6,[r8,#0]            ;439
0000e4  8821              LDRH     r1,[r4,#0]            ;443
0000e6  f5b14f20          CMP      r1,#0xa000            ;443
0000ea  d004              BEQ      |L5.246|
0000ec  8821              LDRH     r1,[r4,#0]            ;444
0000ee  4a1e              LDR      r2,|L5.360|
0000f0  6812              LDR      r2,[r2,#0]            ;444  ; ram
0000f2  4411              ADD      r1,r1,r2              ;444
0000f4  804e              STRH     r6,[r1,#2]            ;444
                  |L5.246|
0000f6  4924              LDR      r1,|L5.392|
0000f8  f8b110ae          LDRH     r1,[r1,#0xae]         ;446
0000fc  1b7a              SUBS     r2,r7,r5              ;446
0000fe  1a89              SUBS     r1,r1,r2              ;446
000100  b28a              UXTH     r2,r1                 ;446
000102  4921              LDR      r1,|L5.392|
000104  f8a120ae          STRH     r2,[r1,#0xae]         ;446
000108  e02b              B        |L5.354|
                  |L5.266|
00010a  f1050014          ADD      r0,r5,#0x14           ;448
00010e  42b8              CMP      r0,r7                 ;448
000110  d827              BHI      |L5.354|
000112  f10a0008          ADD      r0,r10,#8             ;456
000116  4428              ADD      r0,r0,r5              ;456
000118  b286              UXTH     r6,r0                 ;456
00011a  4813              LDR      r0,|L5.360|
00011c  6800              LDR      r0,[r0,#0]            ;457  ; ram
00011e  1984              ADDS     r4,r0,r6              ;457
000120  4822              LDR      r0,|L5.428|
000122  6800              LDR      r0,[r0,#0]            ;458  ; lfree
000124  4284              CMP      r4,r0                 ;458
000126  d201              BCS      |L5.300|
000128  4820              LDR      r0,|L5.428|
00012a  6004              STR      r4,[r0,#0]            ;459  ; lfree
                  |L5.300|
00012c  2000              MOVS     r0,#0                 ;461
00012e  7120              STRB     r0,[r4,#4]            ;461
000130  f8b80000          LDRH     r0,[r8,#0]            ;462
000134  8020              STRH     r0,[r4,#0]            ;462
000136  f8a4a002          STRH     r10,[r4,#2]           ;463
00013a  f8a86000          STRH     r6,[r8,#0]            ;464
00013e  8820              LDRH     r0,[r4,#0]            ;465
000140  f5b04f20          CMP      r0,#0xa000            ;465
000144  d004              BEQ      |L5.336|
000146  8820              LDRH     r0,[r4,#0]            ;466
000148  4907              LDR      r1,|L5.360|
00014a  6809              LDR      r1,[r1,#0]            ;466  ; ram
00014c  4408              ADD      r0,r0,r1              ;466
00014e  8046              STRH     r6,[r0,#2]            ;466
                  |L5.336|
000150  480d              LDR      r0,|L5.392|
000152  f8b000ae          LDRH     r0,[r0,#0xae]         ;468
000156  1b79              SUBS     r1,r7,r5              ;468
000158  1a40              SUBS     r0,r0,r1              ;468
00015a  b281              UXTH     r1,r0                 ;468
00015c  480a              LDR      r0,|L5.392|
00015e  f8a010ae          STRH     r1,[r0,#0xae]         ;468
                  |L5.354|
000162  4648              MOV      r0,r9                 ;481
000164  e75b              B        |L5.30|
;;;483    
                          ENDP

000166  0000              DCW      0x0000
                  |L5.360|
                          DCD      ||ram||
                  |L5.364|
                          DCD      ram_end
                  |L5.368|
000170  6d656d5f          DCB      "mem_trim: legal memory",0
000174  7472696d
000178  3a206c65
00017c  67616c20
000180  6d656d6f
000184  727900  
000187  00                DCB      0
                  |L5.392|
                          DCD      lwip_stats
                  |L5.396|
00018c  6d656d5f          DCB      "mem_trim can only shrink memory",0
000190  7472696d
000194  2063616e
000198  206f6e6c
00019c  79207368
0001a0  72696e6b
0001a4  206d656d
0001a8  6f727900
                  |L5.428|
                          DCD      lfree

                          AREA ||i.plug_holes||, CODE, READONLY, ALIGN=2

                  plug_holes PROC
;;;235    static void
;;;236    plug_holes(struct mem *mem)
000000  b570              PUSH     {r4-r6,lr}
;;;237    {
000002  4604              MOV      r4,r0
;;;238      struct mem *nmem;
;;;239      struct mem *pmem;
;;;240    
;;;241      LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
000004  bf00              NOP      
000006  482f              LDR      r0,|L6.196|
000008  6800              LDR      r0,[r0,#0]  ; ram
00000a  4284              CMP      r4,r0
00000c  d204              BCS      |L6.24|
00000e  a02e              ADR      r0,|L6.200|
000010  f7fffffe          BL       __2printf
000014  bf00              NOP      
                  |L6.22|
000016  e7fe              B        |L6.22|
                  |L6.24|
000018  bf00              NOP      
;;;242      LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
00001a  bf00              NOP      
00001c  4830              LDR      r0,|L6.224|
00001e  6800              LDR      r0,[r0,#0]  ; ram_end
000020  4284              CMP      r4,r0
000022  d304              BCC      |L6.46|
000024  a02f              ADR      r0,|L6.228|
000026  f7fffffe          BL       __2printf
00002a  bf00              NOP      
                  |L6.44|
00002c  e7fe              B        |L6.44|
                  |L6.46|
00002e  bf00              NOP      
;;;243      LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
000030  bf00              NOP      
000032  7920              LDRB     r0,[r4,#4]
000034  b120              CBZ      r0,|L6.64|
000036  a032              ADR      r0,|L6.256|
000038  f7fffffe          BL       __2printf
00003c  bf00              NOP      
                  |L6.62|
00003e  e7fe              B        |L6.62|
                  |L6.64|
000040  bf00              NOP      
;;;244    
;;;245      /* plug hole forward */
;;;246      LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
000042  bf00              NOP      
000044  8820              LDRH     r0,[r4,#0]
000046  f5b04f20          CMP      r0,#0xa000
00004a  dd04              BLE      |L6.86|
00004c  a033              ADR      r0,|L6.284|
00004e  f7fffffe          BL       __2printf
000052  bf00              NOP      
                  |L6.84|
000054  e7fe              B        |L6.84|
                  |L6.86|
000056  bf00              NOP      
;;;247    
;;;248      nmem = (struct mem *)(void *)&ram[mem->next];
000058  8820              LDRH     r0,[r4,#0]
00005a  491a              LDR      r1,|L6.196|
00005c  6809              LDR      r1,[r1,#0]  ; ram
00005e  1845              ADDS     r5,r0,r1
;;;249      if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
000060  42ac              CMP      r4,r5
000062  d015              BEQ      |L6.144|
000064  7928              LDRB     r0,[r5,#4]
000066  b998              CBNZ     r0,|L6.144|
000068  481d              LDR      r0,|L6.224|
00006a  6800              LDR      r0,[r0,#0]  ; ram_end
00006c  4285              CMP      r5,r0
00006e  d00f              BEQ      |L6.144|
;;;250        /* if mem->next is unused and not end of ram, combine mem and mem->next */
;;;251        if (lfree == nmem) {
000070  4835              LDR      r0,|L6.328|
000072  6800              LDR      r0,[r0,#0]  ; lfree
000074  42a8              CMP      r0,r5
000076  d101              BNE      |L6.124|
;;;252          lfree = mem;
000078  4833              LDR      r0,|L6.328|
00007a  6004              STR      r4,[r0,#0]  ; lfree
                  |L6.124|
;;;253        }
;;;254        mem->next = nmem->next;
00007c  8828              LDRH     r0,[r5,#0]
00007e  8020              STRH     r0,[r4,#0]
;;;255        ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
000080  4810              LDR      r0,|L6.196|
000082  8800              LDRH     r0,[r0,#0]  ; ram
000084  1a20              SUBS     r0,r4,r0
000086  8829              LDRH     r1,[r5,#0]
000088  4a0e              LDR      r2,|L6.196|
00008a  6812              LDR      r2,[r2,#0]  ; ram
00008c  4411              ADD      r1,r1,r2
00008e  8048              STRH     r0,[r1,#2]
                  |L6.144|
;;;256      }
;;;257    
;;;258      /* plug hole backward */
;;;259      pmem = (struct mem *)(void *)&ram[mem->prev];
000090  8860              LDRH     r0,[r4,#2]
000092  490c              LDR      r1,|L6.196|
000094  6809              LDR      r1,[r1,#0]  ; ram
000096  1846              ADDS     r6,r0,r1
;;;260      if (pmem != mem && pmem->used == 0) {
000098  42a6              CMP      r6,r4
00009a  d011              BEQ      |L6.192|
00009c  7930              LDRB     r0,[r6,#4]
00009e  b978              CBNZ     r0,|L6.192|
;;;261        /* if mem->prev is unused, combine mem and mem->prev */
;;;262        if (lfree == mem) {
0000a0  4829              LDR      r0,|L6.328|
0000a2  6800              LDR      r0,[r0,#0]  ; lfree
0000a4  42a0              CMP      r0,r4
0000a6  d101              BNE      |L6.172|
;;;263          lfree = pmem;
0000a8  4827              LDR      r0,|L6.328|
0000aa  6006              STR      r6,[r0,#0]  ; lfree
                  |L6.172|
;;;264        }
;;;265        pmem->next = mem->next;
0000ac  8820              LDRH     r0,[r4,#0]
0000ae  8030              STRH     r0,[r6,#0]
;;;266        ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
0000b0  4804              LDR      r0,|L6.196|
0000b2  8800              LDRH     r0,[r0,#0]  ; ram
0000b4  1a30              SUBS     r0,r6,r0
0000b6  8821              LDRH     r1,[r4,#0]
0000b8  4a02              LDR      r2,|L6.196|
0000ba  6812              LDR      r2,[r2,#0]  ; ram
0000bc  4411              ADD      r1,r1,r2
0000be  8048              STRH     r0,[r1,#2]
                  |L6.192|
;;;267      }
;;;268    }
0000c0  bd70              POP      {r4-r6,pc}
;;;269    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L6.196|
                          DCD      ||ram||
                  |L6.200|
0000c8  706c7567          DCB      "plug_holes: mem >= ram",0
0000cc  5f686f6c
0000d0  65733a20
0000d4  6d656d20
0000d8  3e3d2072
0000dc  616d00  
0000df  00                DCB      0
                  |L6.224|
                          DCD      ram_end
                  |L6.228|
0000e4  706c7567          DCB      "plug_holes: mem < ram_end",0
0000e8  5f686f6c
0000ec  65733a20
0000f0  6d656d20
0000f4  3c207261
0000f8  6d5f656e
0000fc  6400    
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L6.256|
000100  706c7567          DCB      "plug_holes: mem->used == 0",0
000104  5f686f6c
000108  65733a20
00010c  6d656d2d
000110  3e757365
000114  64203d3d
000118  203000  
00011b  00                DCB      0
                  |L6.284|
00011c  706c7567          DCB      "plug_holes: mem->next <= MEM_SIZE_ALIGNED",0
000120  5f686f6c
000124  65733a20
000128  6d656d2d
00012c  3e6e6578
000130  74203c3d
000134  204d454d
000138  5f53495a
00013c  455f414c
000140  49474e45
000144  4400    
000146  00                DCB      0
000147  00                DCB      0
                  |L6.328|
                          DCD      lfree

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ram_heap
                          %        40980

                          AREA ||.data||, DATA, ALIGN=2

                  ||ram||
                          DCD      0x00000000
                  ram_end
                          DCD      0x00000000
                  lfree
                          DCD      0x00000000
