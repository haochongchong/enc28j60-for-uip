; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\icmp.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\icmp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IE:\git_projects\enc28j60-for-uip\Project\RVMDK\RTE -I"D:\Program Files\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\icmp.crf ..\..\lwip\src\core\ipv4\icmp.c]
                          THUMB

                          AREA ||i.icmp_dest_unreach||, CODE, READONLY, ALIGN=1

                  icmp_dest_unreach PROC
;;;260    void
;;;261    icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
000000  b570              PUSH     {r4-r6,lr}
;;;262    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;263      icmp_send_response(p, ICMP_DUR, t);
000006  4622              MOV      r2,r4
000008  2103              MOVS     r1,#3
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       icmp_send_response
;;;264    }
000010  bd70              POP      {r4-r6,pc}
;;;265    
                          ENDP


                          AREA ||i.icmp_input||, CODE, READONLY, ALIGN=2

                  icmp_input PROC
;;;76     void
;;;77     icmp_input(struct pbuf *p, struct netif *inp)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;78     {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
;;;79       u8_t type;
;;;80     #ifdef LWIP_DEBUG
;;;81       u8_t code;
;;;82     #endif /* LWIP_DEBUG */
;;;83       struct icmp_echo_hdr *iecho;
;;;84       struct ip_hdr *iphdr;
;;;85       s16_t hlen;
;;;86     
;;;87       ICMP_STATS_INC(icmp.recv);
000008  4891              LDR      r0,|L2.592|
00000a  f8b00062          LDRH     r0,[r0,#0x62]
00000e  1c40              ADDS     r0,r0,#1
000010  b281              UXTH     r1,r0
000012  488f              LDR      r0,|L2.592|
000014  f8a01062          STRH     r1,[r0,#0x62]
;;;88       snmp_inc_icmpinmsgs();
;;;89     
;;;90     
;;;91       iphdr = (struct ip_hdr *)p->payload;
000018  6866              LDR      r6,[r4,#4]
;;;92       hlen = IPH_HL(iphdr) * 4;
00001a  7830              LDRB     r0,[r6,#0]
00001c  0700              LSLS     r0,r0,#28
00001e  ea4f6890          LSR      r8,r0,#26
;;;93       if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
000022  f1c80100          RSB      r1,r8,#0
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       pbuf_header
00002c  b910              CBNZ     r0,|L2.52|
00002e  8920              LDRH     r0,[r4,#8]
000030  2804              CMP      r0,#4
000032  d202              BCS      |L2.58|
                  |L2.52|
;;;94         LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
000034  bf00              NOP      
000036  bf00              NOP      
;;;95         goto lenerr;
000038  e0f0              B        |L2.540|
                  |L2.58|
;;;96       }
;;;97     
;;;98       type = *((u8_t *)p->payload);
00003a  6860              LDR      r0,[r4,#4]
00003c  f890a000          LDRB     r10,[r0,#0]
;;;99     #ifdef LWIP_DEBUG
;;;100      code = *(((u8_t *)p->payload)+1);
000040  6860              LDR      r0,[r4,#4]
000042  f890b001          LDRB     r11,[r0,#1]
;;;101    #endif /* LWIP_DEBUG */
;;;102      switch (type) {
000046  f1ba0f00          CMP      r10,#0
00004a  d003              BEQ      |L2.84|
00004c  f1ba0f08          CMP      r10,#8
000050  d17a              BNE      |L2.328|
000052  e000              B        |L2.86|
                  |L2.84|
;;;103      case ICMP_ER:
;;;104        /* This is OK, echo reply might have been parsed by a raw PCB
;;;105           (as obviously, an echo request has been sent, too). */
;;;106        break; 
000054  e0dd              B        |L2.530|
                  |L2.86|
;;;107      case ICMP_ECHO:
;;;108    #if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
;;;109        {
;;;110          int accepted = 1;
000056  2701              MOVS     r7,#1
;;;111    #if !LWIP_MULTICAST_PING
;;;112          /* multicast destination address? */
;;;113          if (ip_addr_ismulticast(&current_iphdr_dest)) {
000058  487e              LDR      r0,|L2.596|
00005a  7800              LDRB     r0,[r0,#0]  ; current_iphdr_dest
00005c  f00000f0          AND      r0,r0,#0xf0
000060  28e0              CMP      r0,#0xe0
000062  d100              BNE      |L2.102|
;;;114            accepted = 0;
000064  2700              MOVS     r7,#0
                  |L2.102|
;;;115          }
;;;116    #endif /* LWIP_MULTICAST_PING */
;;;117    #if !LWIP_BROADCAST_PING
;;;118          /* broadcast destination address? */
;;;119          if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
000066  497b              LDR      r1,|L2.596|
000068  6808              LDR      r0,[r1,#0]  ; current_iphdr_dest
00006a  4649              MOV      r1,r9
00006c  f7fffffe          BL       ip4_addr_isbroadcast
000070  b100              CBZ      r0,|L2.116|
;;;120            accepted = 0;
000072  2700              MOVS     r7,#0
                  |L2.116|
;;;121          }
;;;122    #endif /* LWIP_BROADCAST_PING */
;;;123          /* broadcast or multicast destination address not acceptd? */
;;;124          if (!accepted) {
000074  b977              CBNZ     r7,|L2.148|
;;;125            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
000076  bf00              NOP      
000078  bf00              NOP      
;;;126            ICMP_STATS_INC(icmp.err);
00007a  4875              LDR      r0,|L2.592|
00007c  f8b00074          LDRH     r0,[r0,#0x74]
000080  1c40              ADDS     r0,r0,#1
000082  b281              UXTH     r1,r0
000084  4872              LDR      r0,|L2.592|
000086  f8a01074          STRH     r1,[r0,#0x74]
;;;127            pbuf_free(p);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       pbuf_free
                  |L2.144|
;;;128            return;
;;;129          }
;;;130        }
;;;131    #endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
;;;132        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
;;;133        if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
;;;134          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
;;;135          goto lenerr;
;;;136        }
;;;137        if (inet_chksum_pbuf(p) != 0) {
;;;138          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
;;;139          pbuf_free(p);
;;;140          ICMP_STATS_INC(icmp.chkerr);
;;;141          snmp_inc_icmpinerrors();
;;;142          return;
;;;143        }
;;;144    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;145        if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
;;;146          /* p is not big enough to contain link headers
;;;147           * allocate a new one and copy p into it
;;;148           */
;;;149          struct pbuf *r;
;;;150          /* switch p->payload to ip header */
;;;151          if (pbuf_header(p, hlen)) {
;;;152            LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
;;;153            goto memerr;
;;;154          }
;;;155          /* allocate new packet buffer with space for link headers */
;;;156          r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
;;;157          if (r == NULL) {
;;;158            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
;;;159            goto memerr;
;;;160          }
;;;161          LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
;;;162                      (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
;;;163          /* copy the whole packet including ip header */
;;;164          if (pbuf_copy(r, p) != ERR_OK) {
;;;165            LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
;;;166            goto memerr;
;;;167          }
;;;168          iphdr = (struct ip_hdr *)r->payload;
;;;169          /* switch r->payload back to icmp header */
;;;170          if (pbuf_header(r, -hlen)) {
;;;171            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;172            goto memerr;
;;;173          }
;;;174          /* free the original p */
;;;175          pbuf_free(p);
;;;176          /* we now have an identical copy of p that has room for link headers */
;;;177          p = r;
;;;178        } else {
;;;179          /* restore p->payload to point to icmp header */
;;;180          if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
;;;181            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;182            goto memerr;
;;;183          }
;;;184        }
;;;185    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;186        /* At this point, all checks are OK. */
;;;187        /* We generate an answer by switching the dest and src ip addresses,
;;;188         * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
;;;189        iecho = (struct icmp_echo_hdr *)p->payload;
;;;190        ip_addr_copy(iphdr->src, *ip_current_dest_addr());
;;;191        ip_addr_copy(iphdr->dest, *ip_current_src_addr());
;;;192        ICMPH_TYPE_SET(iecho, ICMP_ER);
;;;193    #if CHECKSUM_GEN_ICMP
;;;194        /* adjust the checksum */
;;;195        if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
;;;196          iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
;;;197        } else {
;;;198          iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
;;;199        }
;;;200    #else /* CHECKSUM_GEN_ICMP */
;;;201        iecho->chksum = 0;
;;;202    #endif /* CHECKSUM_GEN_ICMP */
;;;203    
;;;204        /* Set the correct TTL and recalculate the header checksum. */
;;;205        IPH_TTL_SET(iphdr, ICMP_TTL);
;;;206        IPH_CHKSUM_SET(iphdr, 0);
;;;207    #if CHECKSUM_GEN_IP
;;;208        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
;;;209    #endif /* CHECKSUM_GEN_IP */
;;;210    
;;;211        ICMP_STATS_INC(icmp.xmit);
;;;212        /* increase number of messages attempted to send */
;;;213        snmp_inc_icmpoutmsgs();
;;;214        /* increase number of echo replies attempted to send */
;;;215        snmp_inc_icmpoutechoreps();
;;;216    
;;;217        if(pbuf_header(p, hlen)) {
;;;218          LWIP_ASSERT("Can't move over header in packet", 0);
;;;219        } else {
;;;220          err_t ret;
;;;221          /* send an ICMP packet, src addr is the dest addr of the curren packet */
;;;222          ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
;;;223                       ICMP_TTL, 0, IP_PROTO_ICMP, inp);
;;;224          if (ret != ERR_OK) {
;;;225            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
;;;226          }
;;;227        }
;;;228        break;
;;;229      default:
;;;230        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
;;;231                    (s16_t)type, (s16_t)code));
;;;232        ICMP_STATS_INC(icmp.proterr);
;;;233        ICMP_STATS_INC(icmp.drop);
;;;234      }
;;;235      pbuf_free(p);
;;;236      return;
;;;237    lenerr:
;;;238      pbuf_free(p);
;;;239      ICMP_STATS_INC(icmp.lenerr);
;;;240      snmp_inc_icmpinerrors();
;;;241      return;
;;;242    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;243    memerr:
;;;244      pbuf_free(p);
;;;245      ICMP_STATS_INC(icmp.err);
;;;246      snmp_inc_icmpinerrors();
;;;247      return;
;;;248    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;249    }
000090  e8bd8ffe          POP      {r1-r11,pc}
                  |L2.148|
000094  bf00              NOP                            ;132
000096  bf00              NOP                            ;132
000098  8920              LDRH     r0,[r4,#8]            ;133
00009a  2808              CMP      r0,#8                 ;133
00009c  d202              BCS      |L2.164|
00009e  bf00              NOP                            ;134
0000a0  bf00              NOP                            ;134
0000a2  e0bb              B        |L2.540|
                  |L2.164|
0000a4  4620              MOV      r0,r4                 ;137
0000a6  f7fffffe          BL       inet_chksum_pbuf
0000aa  b168              CBZ      r0,|L2.200|
0000ac  bf00              NOP                            ;138
0000ae  bf00              NOP                            ;138
0000b0  4620              MOV      r0,r4                 ;139
0000b2  f7fffffe          BL       pbuf_free
0000b6  4866              LDR      r0,|L2.592|
0000b8  f8b00068          LDRH     r0,[r0,#0x68]         ;140
0000bc  1c40              ADDS     r0,r0,#1              ;140
0000be  b281              UXTH     r1,r0                 ;140
0000c0  4863              LDR      r0,|L2.592|
0000c2  f8a01068          STRH     r1,[r0,#0x68]         ;140
0000c6  e7e3              B        |L2.144|
                  |L2.200|
0000c8  2122              MOVS     r1,#0x22              ;145
0000ca  4620              MOV      r0,r4                 ;145
0000cc  f7fffffe          BL       pbuf_header
0000d0  2800              CMP      r0,#0                 ;145
0000d2  d03f              BEQ      |L2.340|
0000d4  4641              MOV      r1,r8                 ;151
0000d6  4620              MOV      r0,r4                 ;151
0000d8  f7fffffe          BL       pbuf_header
0000dc  b128              CBZ      r0,|L2.234|
0000de  bf00              NOP                            ;152
0000e0  a05d              ADR      r0,|L2.600|
0000e2  f7fffffe          BL       __2printf
0000e6  bf00              NOP                            ;152
                  |L2.232|
0000e8  e7fe              B        |L2.232|
                  |L2.234|
0000ea  8921              LDRH     r1,[r4,#8]            ;156
0000ec  2200              MOVS     r2,#0                 ;156
0000ee  2002              MOVS     r0,#2                 ;156
0000f0  f7fffffe          BL       pbuf_alloc
0000f4  4607              MOV      r7,r0                 ;156
0000f6  b917              CBNZ     r7,|L2.254|
0000f8  bf00              NOP                            ;158
0000fa  bf00              NOP                            ;158
0000fc  e09a              B        |L2.564|
                  |L2.254|
0000fe  bf00              NOP                            ;161
000100  8979              LDRH     r1,[r7,#0xa]          ;161
000102  f1080008          ADD      r0,r8,#8              ;161
000106  4281              CMP      r1,r0                 ;161
000108  d204              BCS      |L2.276|
00010a  a060              ADR      r0,|L2.652|
00010c  f7fffffe          BL       __2printf
000110  bf00              NOP                            ;161
                  |L2.274|
000112  e7fe              B        |L2.274|
                  |L2.276|
000114  bf00              NOP                            ;161
000116  4621              MOV      r1,r4                 ;164
000118  4638              MOV      r0,r7                 ;164
00011a  f7fffffe          BL       pbuf_copy
00011e  b128              CBZ      r0,|L2.300|
000120  bf00              NOP                            ;165
000122  a068              ADR      r0,|L2.708|
000124  f7fffffe          BL       __2printf
000128  bf00              NOP                            ;165
                  |L2.298|
00012a  e7fe              B        |L2.298|
                  |L2.300|
00012c  687e              LDR      r6,[r7,#4]            ;168
00012e  f1c80000          RSB      r0,r8,#0              ;170
000132  b201              SXTH     r1,r0                 ;170
000134  4638              MOV      r0,r7                 ;170
000136  f7fffffe          BL       pbuf_header
00013a  b130              CBZ      r0,|L2.330|
00013c  bf00              NOP                            ;171
00013e  a06b              ADR      r0,|L2.748|
000140  f7fffffe          BL       __2printf
000144  bf00              NOP                            ;171
                  |L2.326|
000146  e7fe              B        |L2.326|
                  |L2.328|
000148  e051              B        |L2.494|
                  |L2.330|
00014a  4620              MOV      r0,r4                 ;175
00014c  f7fffffe          BL       pbuf_free
000150  463c              MOV      r4,r7                 ;177
000152  e00b              B        |L2.364|
                  |L2.340|
000154  f06f0121          MVN      r1,#0x21              ;180
000158  4620              MOV      r0,r4                 ;180
00015a  f7fffffe          BL       pbuf_header
00015e  b128              CBZ      r0,|L2.364|
000160  bf00              NOP                            ;181
000162  a062              ADR      r0,|L2.748|
000164  f7fffffe          BL       __2printf
000168  bf00              NOP                            ;181
                  |L2.362|
00016a  e7fe              B        |L2.362|
                  |L2.364|
00016c  6865              LDR      r5,[r4,#4]            ;189
00016e  4839              LDR      r0,|L2.596|
000170  6800              LDR      r0,[r0,#0]            ;190  ; current_iphdr_dest
000172  60f0              STR      r0,[r6,#0xc]          ;190
000174  486a              LDR      r0,|L2.800|
000176  6800              LDR      r0,[r0,#0]            ;191  ; current_iphdr_src
000178  6130              STR      r0,[r6,#0x10]         ;191
00017a  2000              MOVS     r0,#0                 ;192
00017c  7028              STRB     r0,[r5,#0]            ;192
00017e  8868              LDRH     r0,[r5,#2]            ;195
000180  f64f71f7          MOV      r1,#0xfff7            ;195
000184  4288              CMP      r0,r1                 ;195
000186  d303              BCC      |L2.400|
000188  8868              LDRH     r0,[r5,#2]            ;196
00018a  3009              ADDS     r0,r0,#9              ;196
00018c  8068              STRH     r0,[r5,#2]            ;196
00018e  e002              B        |L2.406|
                  |L2.400|
000190  8868              LDRH     r0,[r5,#2]            ;198
000192  3008              ADDS     r0,r0,#8              ;198
000194  8068              STRH     r0,[r5,#2]            ;198
                  |L2.406|
000196  20ff              MOVS     r0,#0xff              ;205
000198  7230              STRB     r0,[r6,#8]            ;205
00019a  2000              MOVS     r0,#0                 ;206
00019c  8170              STRH     r0,[r6,#0xa]          ;206
00019e  2114              MOVS     r1,#0x14              ;208
0001a0  4630              MOV      r0,r6                 ;208
0001a2  f7fffffe          BL       inet_chksum
0001a6  8170              STRH     r0,[r6,#0xa]          ;208
0001a8  4829              LDR      r0,|L2.592|
0001aa  f8b00060          LDRH     r0,[r0,#0x60]         ;211  ; lwip_stats
0001ae  1c40              ADDS     r0,r0,#1              ;211
0001b0  4927              LDR      r1,|L2.592|
0001b2  f8a10060          STRH     r0,[r1,#0x60]         ;211
0001b6  4641              MOV      r1,r8                 ;217
0001b8  4620              MOV      r0,r4                 ;217
0001ba  f7fffffe          BL       pbuf_header
0001be  b128              CBZ      r0,|L2.460|
0001c0  bf00              NOP                            ;218
0001c2  a058              ADR      r0,|L2.804|
0001c4  f7fffffe          BL       __2printf
0001c8  bf00              NOP                            ;218
                  |L2.458|
0001ca  e7fe              B        |L2.458|
                  |L2.460|
0001cc  2001              MOVS     r0,#1                 ;222
0001ce  2100              MOVS     r1,#0                 ;222
0001d0  23ff              MOVS     r3,#0xff              ;222
0001d2  460a              MOV      r2,r1                 ;222
0001d4  e9cd0901          STRD     r0,r9,[sp,#4]         ;222
0001d8  9100              STR      r1,[sp,#0]            ;222
0001da  491e              LDR      r1,|L2.596|
0001dc  4620              MOV      r0,r4                 ;222
0001de  f7fffffe          BL       ip_output_if
0001e2  4607              MOV      r7,r0                 ;222
0001e4  b10f              CBZ      r7,|L2.490|
0001e6  bf00              NOP                            ;225
0001e8  bf00              NOP                            ;225
                  |L2.490|
0001ea  bf00              NOP                            ;227
0001ec  e011              B        |L2.530|
                  |L2.494|
0001ee  bf00              NOP                            ;230
0001f0  bf00              NOP                            ;230
0001f2  4817              LDR      r0,|L2.592|
0001f4  f8b00070          LDRH     r0,[r0,#0x70]         ;232
0001f8  1c40              ADDS     r0,r0,#1              ;232
0001fa  b281              UXTH     r1,r0                 ;232
0001fc  4814              LDR      r0,|L2.592|
0001fe  f8a01070          STRH     r1,[r0,#0x70]         ;232
000202  f8b00066          LDRH     r0,[r0,#0x66]         ;233
000206  1c40              ADDS     r0,r0,#1              ;233
000208  b281              UXTH     r1,r0                 ;233
00020a  4811              LDR      r0,|L2.592|
00020c  f8a01066          STRH     r1,[r0,#0x66]         ;233
000210  bf00              NOP                            ;102
                  |L2.530|
000212  bf00              NOP                            ;106
000214  4620              MOV      r0,r4                 ;235
000216  f7fffffe          BL       pbuf_free
00021a  e739              B        |L2.144|
                  |L2.540|
00021c  4620              MOV      r0,r4                 ;238
00021e  f7fffffe          BL       pbuf_free
000222  480b              LDR      r0,|L2.592|
000224  f8b0006a          LDRH     r0,[r0,#0x6a]         ;239
000228  1c40              ADDS     r0,r0,#1              ;239
00022a  b281              UXTH     r1,r0                 ;239
00022c  4808              LDR      r0,|L2.592|
00022e  f8a0106a          STRH     r1,[r0,#0x6a]         ;239
000232  e72d              B        |L2.144|
                  |L2.564|
000234  4620              MOV      r0,r4                 ;244
000236  f7fffffe          BL       pbuf_free
00023a  4805              LDR      r0,|L2.592|
00023c  f8b00074          LDRH     r0,[r0,#0x74]         ;245
000240  1c40              ADDS     r0,r0,#1              ;245
000242  b281              UXTH     r1,r0                 ;245
000244  4802              LDR      r0,|L2.592|
000246  f8a01074          STRH     r1,[r0,#0x74]         ;245
00024a  bf00              NOP                            ;247
00024c  e720              B        |L2.144|
;;;250    
                          ENDP

00024e  0000              DCW      0x0000
                  |L2.592|
                          DCD      lwip_stats
                  |L2.596|
                          DCD      current_iphdr_dest
                  |L2.600|
000258  69636d70          DCB      "icmp_input: moving p->payload to ip header failed\n",0
00025c  5f696e70
000260  75743a20
000264  6d6f7669
000268  6e672070
00026c  2d3e7061
000270  796c6f61
000274  6420746f
000278  20697020
00027c  68656164
000280  65722066
000284  61696c65
000288  640a00  
00028b  00                DCB      0
                  |L2.652|
00028c  63686563          DCB      "check that first pbuf can hold struct the ICMP header",0
000290  6b207468
000294  61742066
000298  69727374
00029c  20706275
0002a0  66206361
0002a4  6e20686f
0002a8  6c642073
0002ac  74727563
0002b0  74207468
0002b4  65204943
0002b8  4d502068
0002bc  65616465
0002c0  7200    
0002c2  00                DCB      0
0002c3  00                DCB      0
                  |L2.708|
0002c4  69636d70          DCB      "icmp_input: copying to new pbuf failed\n",0
0002c8  5f696e70
0002cc  75743a20
0002d0  636f7079
0002d4  696e6720
0002d8  746f206e
0002dc  65772070
0002e0  62756620
0002e4  6661696c
0002e8  65640a00
                  |L2.748|
0002ec  69636d70          DCB      "icmp_input: restoring original p->payload failed\n",0
0002f0  5f696e70
0002f4  75743a20
0002f8  72657374
0002fc  6f72696e
000300  67206f72
000304  6967696e
000308  616c2070
00030c  2d3e7061
000310  796c6f61
000314  64206661
000318  696c6564
00031c  0a00    
00031e  00                DCB      0
00031f  00                DCB      0
                  |L2.800|
                          DCD      current_iphdr_src
                  |L2.804|
000324  43616e27          DCB      "Can't move over header in packet",0
000328  74206d6f
00032c  7665206f
000330  76657220
000334  68656164
000338  65722069
00033c  6e207061
000340  636b6574
000344  00      
000345  00                DCB      0
000346  00                DCB      0
000347  00                DCB      0

                          AREA ||i.icmp_send_response||, CODE, READONLY, ALIGN=2

                  icmp_send_response PROC
;;;290    static void
;;;291    icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;292    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;293      struct pbuf *q;
;;;294      struct ip_hdr *iphdr;
;;;295      /* we can use the echo header here */
;;;296      struct icmp_echo_hdr *icmphdr;
;;;297      ip_addr_t iphdr_src;
;;;298    
;;;299      /* ICMP header + IP header + 8 bytes of data */
;;;300      q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
00000a  2200              MOVS     r2,#0
00000c  2124              MOVS     r1,#0x24
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       pbuf_alloc
000014  4605              MOV      r5,r0
;;;301                     PBUF_RAM);
;;;302      if (q == NULL) {
000016  b91d              CBNZ     r5,|L3.32|
;;;303        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L3.28|
;;;304        return;
;;;305      }
;;;306      LWIP_ASSERT("check that first pbuf can hold icmp message",
;;;307                 (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));
;;;308    
;;;309      iphdr = (struct ip_hdr *)p->payload;
;;;310      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded from "));
;;;311      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
;;;312      LWIP_DEBUGF(ICMP_DEBUG, (" to "));
;;;313      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
;;;314      LWIP_DEBUGF(ICMP_DEBUG, ("\n"));
;;;315    
;;;316      icmphdr = (struct icmp_echo_hdr *)q->payload;
;;;317      icmphdr->type = type;
;;;318      icmphdr->code = code;
;;;319      icmphdr->id = 0;
;;;320      icmphdr->seqno = 0;
;;;321    
;;;322      /* copy fields from original packet */
;;;323      SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
;;;324              IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
;;;325    
;;;326      /* calculate checksum */
;;;327      icmphdr->chksum = 0;
;;;328      icmphdr->chksum = inet_chksum(icmphdr, q->len);
;;;329      ICMP_STATS_INC(icmp.xmit);
;;;330      /* increase number of messages attempted to send */
;;;331      snmp_inc_icmpoutmsgs();
;;;332      /* increase number of destination unreachable messages attempted to send */
;;;333      snmp_inc_icmpouttimeexcds();
;;;334      ip_addr_copy(iphdr_src, iphdr->src);
;;;335      ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
;;;336      pbuf_free(q);
;;;337    }
00001c  e8bd83fe          POP      {r1-r9,pc}
                  |L3.32|
000020  bf00              NOP                            ;306
000022  8968              LDRH     r0,[r5,#0xa]          ;306
000024  2824              CMP      r0,#0x24              ;306
000026  d204              BCS      |L3.50|
000028  a01f              ADR      r0,|L3.168|
00002a  f7fffffe          BL       __2printf
00002e  bf00              NOP                            ;306
                  |L3.48|
000030  e7fe              B        |L3.48|
                  |L3.50|
000032  bf00              NOP                            ;306
000034  f8d69004          LDR      r9,[r6,#4]            ;309
000038  bf00              NOP                            ;310
00003a  bf00              NOP                            ;310
00003c  bf00              NOP                            ;311
00003e  bf00              NOP                            ;311
000040  bf00              NOP                            ;312
000042  bf00              NOP                            ;312
000044  bf00              NOP                            ;313
000046  bf00              NOP                            ;313
000048  bf00              NOP                            ;314
00004a  bf00              NOP                            ;314
00004c  686c              LDR      r4,[r5,#4]            ;316
00004e  7027              STRB     r7,[r4,#0]            ;317
000050  f8848001          STRB     r8,[r4,#1]            ;318
000054  2000              MOVS     r0,#0                 ;319
000056  80a0              STRH     r0,[r4,#4]            ;319
000058  80e0              STRH     r0,[r4,#6]            ;320
00005a  6871              LDR      r1,[r6,#4]            ;323
00005c  686a              LDR      r2,[r5,#4]            ;323
00005e  f1020008          ADD      r0,r2,#8              ;323
000062  221c              MOVS     r2,#0x1c              ;323
000064  f7fffffe          BL       __aeabi_memcpy
000068  2000              MOVS     r0,#0                 ;327
00006a  8060              STRH     r0,[r4,#2]            ;327
00006c  8969              LDRH     r1,[r5,#0xa]          ;328
00006e  4620              MOV      r0,r4                 ;328
000070  f7fffffe          BL       inet_chksum
000074  8060              STRH     r0,[r4,#2]            ;328
000076  4817              LDR      r0,|L3.212|
000078  f8b00060          LDRH     r0,[r0,#0x60]         ;329  ; lwip_stats
00007c  1c40              ADDS     r0,r0,#1              ;329
00007e  4915              LDR      r1,|L3.212|
000080  f8a10060          STRH     r0,[r1,#0x60]         ;329
000084  f8d9000c          LDR      r0,[r9,#0xc]          ;334
000088  9002              STR      r0,[sp,#8]            ;334
00008a  2001              MOVS     r0,#1                 ;335
00008c  2100              MOVS     r1,#0                 ;335
00008e  23ff              MOVS     r3,#0xff              ;335
000090  aa02              ADD      r2,sp,#8              ;335
000092  e9cd1000          STRD     r1,r0,[sp,#0]         ;335
000096  4628              MOV      r0,r5                 ;335
000098  f7fffffe          BL       ip_output
00009c  4628              MOV      r0,r5                 ;336
00009e  f7fffffe          BL       pbuf_free
0000a2  bf00              NOP      
0000a4  e7ba              B        |L3.28|
;;;338    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L3.168|
0000a8  63686563          DCB      "check that first pbuf can hold icmp message",0
0000ac  6b207468
0000b0  61742066
0000b4  69727374
0000b8  20706275
0000bc  66206361
0000c0  6e20686f
0000c4  6c642069
0000c8  636d7020
0000cc  6d657373
0000d0  61676500
                  |L3.212|
                          DCD      lwip_stats

                          AREA ||i.icmp_time_exceeded||, CODE, READONLY, ALIGN=1

                  icmp_time_exceeded PROC
;;;274    void
;;;275    icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
000000  b570              PUSH     {r4-r6,lr}
;;;276    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;277      icmp_send_response(p, ICMP_TE, t);
000006  4622              MOV      r2,r4
000008  210b              MOVS     r1,#0xb
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       icmp_send_response
;;;278    }
000010  bd70              POP      {r4-r6,pc}
;;;279    
                          ENDP

