; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\pbuf.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\pbuf.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IE:\git_projects\enc28j60-for-uip\Project\RVMDK\RTE -I"D:\Program Files\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\pbuf.crf ..\..\lwip\src\core\pbuf.c]
                          THUMB

                          AREA ||i.pbuf_alloc||, CODE, READONLY, ALIGN=2

                  pbuf_alloc PROC
;;;206    struct pbuf *
;;;207    pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;208    {
000004  4683              MOV      r11,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
;;;209      struct pbuf *p, *q, *r;
;;;210      u16_t offset;
;;;211      s32_t rem_len; /* remaining length */
;;;212      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;213    
;;;214      /* determine header offset */
;;;215      switch (layer) {
00000e  f1bb0f00          CMP      r11,#0
000012  d009              BEQ      |L1.40|
000014  f1bb0f01          CMP      r11,#1
000018  d008              BEQ      |L1.44|
00001a  f1bb0f02          CMP      r11,#2
00001e  d007              BEQ      |L1.48|
000020  f1bb0f03          CMP      r11,#3
000024  d108              BNE      |L1.56|
000026  e005              B        |L1.52|
                  |L1.40|
;;;216      case PBUF_TRANSPORT:
;;;217        /* add room for transport (often TCP) layer header */
;;;218        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
000028  2636              MOVS     r6,#0x36
;;;219        break;
00002a  e00b              B        |L1.68|
                  |L1.44|
;;;220      case PBUF_IP:
;;;221        /* add room for IP layer header */
;;;222        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
00002c  2622              MOVS     r6,#0x22
;;;223        break;
00002e  e009              B        |L1.68|
                  |L1.48|
;;;224      case PBUF_LINK:
;;;225        /* add room for link layer header */
;;;226        offset = PBUF_LINK_HLEN;
000030  260e              MOVS     r6,#0xe
;;;227        break;
000032  e007              B        |L1.68|
                  |L1.52|
;;;228      case PBUF_RAW:
;;;229        offset = 0;
000034  2600              MOVS     r6,#0
;;;230        break;
000036  e005              B        |L1.68|
                  |L1.56|
;;;231      default:
;;;232        LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
000038  bf00              NOP      
00003a  a083              ADR      r0,|L1.584|
00003c  f7fffffe          BL       __2printf
000040  bf00              NOP      
                  |L1.66|
000042  e7fe              B        |L1.66|
                  |L1.68|
000044  bf00              NOP                            ;219
;;;233        return NULL;
;;;234      }
;;;235    
;;;236      switch (type) {
000046  f1b90f00          CMP      r9,#0
00004a  d076              BEQ      |L1.314|
00004c  f1b90f01          CMP      r9,#1
000050  d074              BEQ      |L1.316|
000052  f1b90f02          CMP      r9,#2
000056  d072              BEQ      |L1.318|
000058  f1b90f03          CMP      r9,#3
00005c  d170              BNE      |L1.320|
;;;237      case PBUF_POOL:
;;;238        /* allocate head of pbuf chain into p */
;;;239        p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
00005e  2009              MOVS     r0,#9
000060  f7fffffe          BL       memp_malloc
000064  4604              MOV      r4,r0
;;;240        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
000066  bf00              NOP      
000068  bf00              NOP      
;;;241        if (p == NULL) {
00006a  b924              CBNZ     r4,|L1.118|
;;;242          PBUF_POOL_IS_EMPTY();
00006c  f7fffffe          BL       pbuf_pool_is_empty
;;;243          return NULL;
000070  2000              MOVS     r0,#0
                  |L1.114|
;;;244        }
;;;245        p->type = type;
;;;246        p->next = NULL;
;;;247    
;;;248        /* make the payload pointer point 'offset' bytes into pbuf data memory */
;;;249        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
;;;250        LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
;;;251                ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;252        /* the total length of the pbuf chain is the requested size */
;;;253        p->tot_len = length;
;;;254        /* set the length of the first pbuf in the chain */
;;;255        p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
;;;256        LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;257                    ((u8_t*)p->payload + p->len <=
;;;258                     (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;259        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
;;;260          (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
;;;261        /* set reference count (needed here in case we fail) */
;;;262        p->ref = 1;
;;;263    
;;;264        /* now allocate the tail of the pbuf chain */
;;;265    
;;;266        /* remember first pbuf for linkage in next iteration */
;;;267        r = p;
;;;268        /* remaining length to be allocated */
;;;269        rem_len = length - p->len;
;;;270        /* any remaining pbufs to be allocated? */
;;;271        while (rem_len > 0) {
;;;272          q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;273          if (q == NULL) {
;;;274            PBUF_POOL_IS_EMPTY();
;;;275            /* free chain so far allocated */
;;;276            pbuf_free(p);
;;;277            /* bail out unsuccesfully */
;;;278            return NULL;
;;;279          }
;;;280          q->type = type;
;;;281          q->flags = 0;
;;;282          q->next = NULL;
;;;283          /* make previous pbuf point to this pbuf */
;;;284          r->next = q;
;;;285          /* set total length of this pbuf and next in chain */
;;;286          LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
;;;287          q->tot_len = (u16_t)rem_len;
;;;288          /* this pbuf length is pool size, unless smaller sized tail */
;;;289          q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
;;;290          q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
;;;291          LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
;;;292                  ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
;;;293          LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;294                      ((u8_t*)p->payload + p->len <=
;;;295                       (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;296          q->ref = 1;
;;;297          /* calculate remaining length to be allocated */
;;;298          rem_len -= q->len;
;;;299          /* remember this pbuf for linkage in next iteration */
;;;300          r = q;
;;;301        }
;;;302        /* end of chain */
;;;303        /*r->next = NULL;*/
;;;304    
;;;305        break;
;;;306      case PBUF_RAM:
;;;307        /* If pbuf is to be allocated in RAM, allocate memory for it. */
;;;308        p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
;;;309        if (p == NULL) {
;;;310          return NULL;
;;;311        }
;;;312        /* Set up internal structure of the pbuf. */
;;;313        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
;;;314        p->len = p->tot_len = length;
;;;315        p->next = NULL;
;;;316        p->type = type;
;;;317    
;;;318        LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
;;;319               ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;320        break;
;;;321      /* pbuf references existing (non-volatile static constant) ROM payload? */
;;;322      case PBUF_ROM:
;;;323      /* pbuf references existing (externally allocated) RAM payload? */
;;;324      case PBUF_REF:
;;;325        /* only allocate memory for the pbuf structure */
;;;326        p = (struct pbuf *)memp_malloc(MEMP_PBUF);
;;;327        if (p == NULL) {
;;;328          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;329                      ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
;;;330                      (type == PBUF_ROM) ? "ROM" : "REF"));
;;;331          return NULL;
;;;332        }
;;;333        /* caller must set this field properly, afterwards */
;;;334        p->payload = NULL;
;;;335        p->len = p->tot_len = length;
;;;336        p->next = NULL;
;;;337        p->type = type;
;;;338        break;
;;;339      default:
;;;340        LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
;;;341        return NULL;
;;;342      }
;;;343      /* set reference count */
;;;344      p->ref = 1;
;;;345      /* set flags */
;;;346      p->flags = 0;
;;;347      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
;;;348      return p;
;;;349    }
000072  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.118|
000076  f884900c          STRB     r9,[r4,#0xc]          ;245
00007a  2000              MOVS     r0,#0                 ;246
00007c  6020              STR      r0,[r4,#0]            ;246
00007e  f1060010          ADD      r0,r6,#0x10           ;249
000082  4420              ADD      r0,r0,r4              ;249
000084  1cc0              ADDS     r0,r0,#3              ;249
000086  f0200003          BIC      r0,r0,#3              ;249
00008a  6060              STR      r0,[r4,#4]            ;249
00008c  bf00              NOP                            ;250
00008e  7920              LDRB     r0,[r4,#4]            ;250
000090  f0000003          AND      r0,r0,#3              ;250
000094  b120              CBZ      r0,|L1.160|
000096  a073              ADR      r0,|L1.612|
000098  f7fffffe          BL       __2printf
00009c  bf00              NOP                            ;250
                  |L1.158|
00009e  e7fe              B        |L1.158|
                  |L1.160|
0000a0  bf00              NOP                            ;250
0000a2  8127              STRH     r7,[r4,#8]            ;253
0000a4  1cf0              ADDS     r0,r6,#3              ;255
0000a6  f0200003          BIC      r0,r0,#3              ;255
0000aa  f5c06084          RSB      r0,r0,#0x420          ;255
0000ae  42b8              CMP      r0,r7                 ;255
0000b0  dd01              BLE      |L1.182|
0000b2  4638              MOV      r0,r7                 ;255
0000b4  e004              B        |L1.192|
                  |L1.182|
0000b6  1cf0              ADDS     r0,r6,#3              ;255
0000b8  f0200003          BIC      r0,r0,#3              ;255
0000bc  f5c06084          RSB      r0,r0,#0x420          ;255
                  |L1.192|
0000c0  8160              STRH     r0,[r4,#0xa]          ;255
0000c2  bf00              NOP                            ;256
0000c4  8961              LDRH     r1,[r4,#0xa]          ;256
0000c6  6860              LDR      r0,[r4,#4]            ;256
0000c8  4401              ADD      r1,r1,r0              ;256
0000ca  f5046086          ADD      r0,r4,#0x430          ;256
0000ce  4281              CMP      r1,r0                 ;256
0000d0  d904              BLS      |L1.220|
0000d2  a070              ADR      r0,|L1.660|
0000d4  f7fffffe          BL       __2printf
0000d8  bf00              NOP                            ;256
                  |L1.218|
0000da  e7fe              B        |L1.218|
                  |L1.220|
0000dc  bf00              NOP                            ;256
0000de  bf00              NOP                            ;259
0000e0  1cf0              ADDS     r0,r6,#3              ;259
0000e2  f0200003          BIC      r0,r0,#3              ;259
0000e6  f5c06084          RSB      r0,r0,#0x420          ;259
0000ea  2800              CMP      r0,#0                 ;259
0000ec  dc04              BGT      |L1.248|
0000ee  a076              ADR      r0,|L1.712|
0000f0  f7fffffe          BL       __2printf
0000f4  bf00              NOP                            ;259
                  |L1.246|
0000f6  e7fe              B        |L1.246|
                  |L1.248|
0000f8  bf00              NOP                            ;259
0000fa  2001              MOVS     r0,#1                 ;262
0000fc  81e0              STRH     r0,[r4,#0xe]          ;262
0000fe  46a2              MOV      r10,r4                ;267
000100  8960              LDRH     r0,[r4,#0xa]          ;269
000102  eba70800          SUB      r8,r7,r0              ;269
000106  e051              B        |L1.428|
                  |L1.264|
000108  2009              MOVS     r0,#9                 ;272
00010a  f7fffffe          BL       memp_malloc
00010e  4605              MOV      r5,r0                 ;272
000110  b935              CBNZ     r5,|L1.288|
000112  f7fffffe          BL       pbuf_pool_is_empty
000116  4620              MOV      r0,r4                 ;276
000118  f7fffffe          BL       pbuf_free
00011c  2000              MOVS     r0,#0                 ;278
00011e  e7a8              B        |L1.114|
                  |L1.288|
000120  f885900c          STRB     r9,[r5,#0xc]          ;280
000124  2000              MOVS     r0,#0                 ;281
000126  7368              STRB     r0,[r5,#0xd]          ;281
000128  6028              STR      r0,[r5,#0]            ;282
00012a  f8ca5000          STR      r5,[r10,#0]           ;284
00012e  bf00              NOP                            ;286
000130  f64f70ff          MOV      r0,#0xffff            ;286
000134  4580              CMP      r8,r0                 ;286
000136  db09              BLT      |L1.332|
000138  e003              B        |L1.322|
                  |L1.314|
00013a  e03b              B        |L1.436|
                  |L1.316|
00013c  e062              B        |L1.516|
                  |L1.318|
00013e  e062              B        |L1.518|
                  |L1.320|
000140  e072              B        |L1.552|
                  |L1.322|
000142  a06e              ADR      r0,|L1.764|
000144  f7fffffe          BL       __2printf
000148  bf00              NOP                            ;286
                  |L1.330|
00014a  e7fe              B        |L1.330|
                  |L1.332|
00014c  bf00              NOP                            ;286
00014e  f8a58008          STRH     r8,[r5,#8]            ;287
000152  fa1ff088          UXTH     r0,r8                 ;289
000156  f5b06f84          CMP      r0,#0x420             ;289
00015a  da02              BGE      |L1.354|
00015c  fa1ff088          UXTH     r0,r8                 ;289
000160  e001              B        |L1.358|
                  |L1.354|
000162  f44f6084          MOV      r0,#0x420             ;289
                  |L1.358|
000166  8168              STRH     r0,[r5,#0xa]          ;289
000168  f1050010          ADD      r0,r5,#0x10           ;290
00016c  6068              STR      r0,[r5,#4]            ;290
00016e  bf00              NOP                            ;291
000170  7928              LDRB     r0,[r5,#4]            ;291
000172  f0000003          AND      r0,r0,#3              ;291
000176  b120              CBZ      r0,|L1.386|
000178  a065              ADR      r0,|L1.784|
00017a  f7fffffe          BL       __2printf
00017e  bf00              NOP                            ;291
                  |L1.384|
000180  e7fe              B        |L1.384|
                  |L1.386|
000182  bf00              NOP                            ;291
000184  bf00              NOP                            ;293
000186  8961              LDRH     r1,[r4,#0xa]          ;293
000188  6860              LDR      r0,[r4,#4]            ;293
00018a  4401              ADD      r1,r1,r0              ;293
00018c  f5046086          ADD      r0,r4,#0x430          ;293
000190  4281              CMP      r1,r0                 ;293
000192  d904              BLS      |L1.414|
000194  a03f              ADR      r0,|L1.660|
000196  f7fffffe          BL       __2printf
00019a  bf00              NOP                            ;293
                  |L1.412|
00019c  e7fe              B        |L1.412|
                  |L1.414|
00019e  bf00              NOP                            ;293
0001a0  2001              MOVS     r0,#1                 ;296
0001a2  81e8              STRH     r0,[r5,#0xe]          ;296
0001a4  8968              LDRH     r0,[r5,#0xa]          ;298
0001a6  eba80800          SUB      r8,r8,r0              ;298
0001aa  46aa              MOV      r10,r5                ;300
                  |L1.428|
0001ac  f1b80f00          CMP      r8,#0                 ;271
0001b0  dcaa              BGT      |L1.264|
0001b2  e03f              B        |L1.564|
                  |L1.436|
0001b4  f1060113          ADD      r1,r6,#0x13           ;308
0001b8  f0210203          BIC      r2,r1,#3              ;308
0001bc  1cf9              ADDS     r1,r7,#3              ;308
0001be  f0210103          BIC      r1,r1,#3              ;308
0001c2  4411              ADD      r1,r1,r2              ;308
0001c4  b288              UXTH     r0,r1                 ;308
0001c6  f7fffffe          BL       mem_malloc
0001ca  4604              MOV      r4,r0                 ;308
0001cc  b90c              CBNZ     r4,|L1.466|
0001ce  2000              MOVS     r0,#0                 ;310
0001d0  e74f              B        |L1.114|
                  |L1.466|
0001d2  f1040010          ADD      r0,r4,#0x10           ;313
0001d6  4430              ADD      r0,r0,r6              ;313
0001d8  1cc0              ADDS     r0,r0,#3              ;313
0001da  f0200003          BIC      r0,r0,#3              ;313
0001de  6060              STR      r0,[r4,#4]            ;313
0001e0  8127              STRH     r7,[r4,#8]            ;314
0001e2  8167              STRH     r7,[r4,#0xa]          ;314
0001e4  2000              MOVS     r0,#0                 ;315
0001e6  6020              STR      r0,[r4,#0]            ;315
0001e8  f884900c          STRB     r9,[r4,#0xc]          ;316
0001ec  bf00              NOP                            ;318
0001ee  7920              LDRB     r0,[r4,#4]            ;318
0001f0  f0000003          AND      r0,r0,#3              ;318
0001f4  b120              CBZ      r0,|L1.512|
0001f6  a052              ADR      r0,|L1.832|
0001f8  f7fffffe          BL       __2printf
0001fc  bf00              NOP                            ;318
                  |L1.510|
0001fe  e7fe              B        |L1.510|
                  |L1.512|
000200  bf00              NOP                            ;318
000202  e017              B        |L1.564|
                  |L1.516|
000204  bf00              NOP                            ;324
                  |L1.518|
000206  2008              MOVS     r0,#8                 ;326
000208  f7fffffe          BL       memp_malloc
00020c  4604              MOV      r4,r0                 ;326
00020e  b91c              CBNZ     r4,|L1.536|
000210  bf00              NOP                            ;328
000212  bf00              NOP                            ;328
000214  2000              MOVS     r0,#0                 ;331
000216  e72c              B        |L1.114|
                  |L1.536|
000218  2000              MOVS     r0,#0                 ;334
00021a  6060              STR      r0,[r4,#4]            ;334
00021c  8127              STRH     r7,[r4,#8]            ;335
00021e  8167              STRH     r7,[r4,#0xa]          ;335
000220  6020              STR      r0,[r4,#0]            ;336
000222  f884900c          STRB     r9,[r4,#0xc]          ;337
000226  e005              B        |L1.564|
                  |L1.552|
000228  bf00              NOP                            ;340
00022a  a050              ADR      r0,|L1.876|
00022c  f7fffffe          BL       __2printf
000230  bf00              NOP                            ;340
                  |L1.562|
000232  e7fe              B        |L1.562|
                  |L1.564|
000234  bf00              NOP                            ;305
000236  2001              MOVS     r0,#1                 ;344
000238  81e0              STRH     r0,[r4,#0xe]          ;344
00023a  2000              MOVS     r0,#0                 ;346
00023c  7360              STRB     r0,[r4,#0xd]          ;346
00023e  bf00              NOP                            ;347
000240  bf00              NOP                            ;347
000242  4620              MOV      r0,r4                 ;348
000244  e715              B        |L1.114|
;;;350    
                          ENDP

000246  0000              DCW      0x0000
                  |L1.584|
000248  70627566          DCB      "pbuf_alloc: bad pbuf layer",0
00024c  5f616c6c
000250  6f633a20
000254  62616420
000258  70627566
00025c  206c6179
000260  657200  
000263  00                DCB      0
                  |L1.612|
000264  70627566          DCB      "pbuf_alloc: pbuf p->payload properly aligned",0
000268  5f616c6c
00026c  6f633a20
000270  70627566
000274  20702d3e
000278  7061796c
00027c  6f616420
000280  70726f70
000284  65726c79
000288  20616c69
00028c  676e6564
000290  00      
000291  00                DCB      0
000292  00                DCB      0
000293  00                DCB      0
                  |L1.660|
000294  63686563          DCB      "check p->payload + p->len does not overflow pbuf",0
000298  6b20702d
00029c  3e706179
0002a0  6c6f6164
0002a4  202b2070
0002a8  2d3e6c65
0002ac  6e20646f
0002b0  6573206e
0002b4  6f74206f
0002b8  76657266
0002bc  6c6f7720
0002c0  70627566
0002c4  00      
0002c5  00                DCB      0
0002c6  00                DCB      0
0002c7  00                DCB      0
                  |L1.712|
0002c8  50425546          DCB      "PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",0
0002cc  5f504f4f
0002d0  4c5f4255
0002d4  4653495a
0002d8  45206d75
0002dc  73742062
0002e0  65206269
0002e4  67676572
0002e8  20746861
0002ec  6e204d45
0002f0  4d5f414c
0002f4  49474e4d
0002f8  454e5400
                  |L1.764|
0002fc  72656d5f          DCB      "rem_len < max_u16_t",0
000300  6c656e20
000304  3c206d61
000308  785f7531
00030c  365f7400
                  |L1.784|
000310  70627566          DCB      "pbuf_alloc: pbuf q->payload properly aligned",0
000314  5f616c6c
000318  6f633a20
00031c  70627566
000320  20712d3e
000324  7061796c
000328  6f616420
00032c  70726f70
000330  65726c79
000334  20616c69
000338  676e6564
00033c  00      
00033d  00                DCB      0
00033e  00                DCB      0
00033f  00                DCB      0
                  |L1.832|
000340  70627566          DCB      "pbuf_alloc: pbuf->payload properly aligned",0
000344  5f616c6c
000348  6f633a20
00034c  70627566
000350  2d3e7061
000354  796c6f61
000358  64207072
00035c  6f706572
000360  6c792061
000364  6c69676e
000368  656400  
00036b  00                DCB      0
                  |L1.876|
00036c  70627566          DCB      "pbuf_alloc: erroneous type",0
000370  5f616c6c
000374  6f633a20
000378  6572726f
00037c  6e656f75
000380  73207479
000384  706500  
000387  00                DCB      0

                          AREA ||i.pbuf_alloced_custom||, CODE, READONLY, ALIGN=2

                  pbuf_alloced_custom PROC
;;;366    struct pbuf*
;;;367    pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;368                        void *payload_mem, u16_t payload_mem_len)
;;;369    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  461c              MOV      r4,r3
00000c  e9dd9a08          LDRD     r9,r10,[sp,#0x20]
;;;370      u16_t offset;
;;;371      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));
000010  bf00              NOP      
000012  bf00              NOP      
;;;372    
;;;373      /* determine header offset */
;;;374      switch (l) {
000014  b137              CBZ      r7,|L2.36|
000016  2f01              CMP      r7,#1
000018  d006              BEQ      |L2.40|
00001a  2f02              CMP      r7,#2
00001c  d006              BEQ      |L2.44|
00001e  2f03              CMP      r7,#3
000020  d108              BNE      |L2.52|
000022  e005              B        |L2.48|
                  |L2.36|
;;;375      case PBUF_TRANSPORT:
;;;376        /* add room for transport (often TCP) layer header */
;;;377        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
000024  2536              MOVS     r5,#0x36
;;;378        break;
000026  e00b              B        |L2.64|
                  |L2.40|
;;;379      case PBUF_IP:
;;;380        /* add room for IP layer header */
;;;381        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
000028  2522              MOVS     r5,#0x22
;;;382        break;
00002a  e009              B        |L2.64|
                  |L2.44|
;;;383      case PBUF_LINK:
;;;384        /* add room for link layer header */
;;;385        offset = PBUF_LINK_HLEN;
00002c  250e              MOVS     r5,#0xe
;;;386        break;
00002e  e007              B        |L2.64|
                  |L2.48|
;;;387      case PBUF_RAW:
;;;388        offset = 0;
000030  2500              MOVS     r5,#0
;;;389        break;
000032  e005              B        |L2.64|
                  |L2.52|
;;;390      default:
;;;391        LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
000034  bf00              NOP      
000036  a014              ADR      r0,|L2.136|
000038  f7fffffe          BL       __2printf
00003c  bf00              NOP      
                  |L2.62|
00003e  e7fe              B        |L2.62|
                  |L2.64|
000040  bf00              NOP                            ;378
;;;392        return NULL;
;;;393      }
;;;394    
;;;395      if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
000042  1ce8              ADDS     r0,r5,#3
000044  f0200003          BIC      r0,r0,#3
000048  4430              ADD      r0,r0,r6
00004a  4550              CMP      r0,r10
00004c  dd04              BLE      |L2.88|
;;;396        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
00004e  bf00              NOP      
000050  bf00              NOP      
;;;397        return NULL;
000052  2000              MOVS     r0,#0
                  |L2.84|
;;;398      }
;;;399    
;;;400      p->pbuf.next = NULL;
;;;401      if (payload_mem != NULL) {
;;;402        p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
;;;403      } else {
;;;404        p->pbuf.payload = NULL;
;;;405      }
;;;406      p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
;;;407      p->pbuf.len = p->pbuf.tot_len = length;
;;;408      p->pbuf.type = type;
;;;409      p->pbuf.ref = 1;
;;;410      return &p->pbuf;
;;;411    }
000054  e8bd87f0          POP      {r4-r10,pc}
                  |L2.88|
000058  2000              MOVS     r0,#0                 ;400
00005a  6020              STR      r0,[r4,#0]            ;400
00005c  f1b90f00          CMP      r9,#0                 ;401
000060  d005              BEQ      |L2.110|
000062  1ce8              ADDS     r0,r5,#3              ;402
000064  f0200003          BIC      r0,r0,#3              ;402
000068  4448              ADD      r0,r0,r9              ;402
00006a  6060              STR      r0,[r4,#4]            ;402
00006c  e001              B        |L2.114|
                  |L2.110|
00006e  2000              MOVS     r0,#0                 ;404
000070  6060              STR      r0,[r4,#4]            ;404
                  |L2.114|
000072  2002              MOVS     r0,#2                 ;406
000074  7360              STRB     r0,[r4,#0xd]          ;406
000076  8126              STRH     r6,[r4,#8]            ;407
000078  8166              STRH     r6,[r4,#0xa]          ;407
00007a  f884800c          STRB     r8,[r4,#0xc]          ;408
00007e  2001              MOVS     r0,#1                 ;409
000080  81e0              STRH     r0,[r4,#0xe]          ;409
000082  4620              MOV      r0,r4                 ;410
000084  e7e6              B        |L2.84|
;;;412    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
                          ENDP

000086  0000              DCW      0x0000
                  |L2.136|
000088  70627566          DCB      "pbuf_alloced_custom: bad pbuf layer",0
00008c  5f616c6c
000090  6f636564
000094  5f637573
000098  746f6d3a
00009c  20626164
0000a0  20706275
0000a4  66206c61
0000a8  79657200

                          AREA ||i.pbuf_cat||, CODE, READONLY, ALIGN=2

                  pbuf_cat PROC
;;;744    void
;;;745    pbuf_cat(struct pbuf *h, struct pbuf *t)
000000  b570              PUSH     {r4-r6,lr}
;;;746    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;747      struct pbuf *p;
;;;748    
;;;749      LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
000006  bf00              NOP      
000008  b106              CBZ      r6,|L3.12|
00000a  b91d              CBNZ     r5,|L3.20|
                  |L3.12|
00000c  a014              ADR      r0,|L3.96|
00000e  f7fffffe          BL       __2printf
                  |L3.18|
;;;750                 ((h != NULL) && (t != NULL)), return;);
;;;751    
;;;752      /* proceed to last pbuf of chain */
;;;753      for (p = h; p->next != NULL; p = p->next) {
;;;754        /* add total length of second chain to all totals of first chain */
;;;755        p->tot_len += t->tot_len;
;;;756      }
;;;757      /* { p is last pbuf of first h chain, p->next == NULL } */
;;;758      LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
;;;759      LWIP_ASSERT("p->next == NULL", p->next == NULL);
;;;760      /* add total length of second chain to last pbuf total of first chain */
;;;761      p->tot_len += t->tot_len;
;;;762      /* chain last pbuf of head (p) with first of tail (t) */
;;;763      p->next = t;
;;;764      /* p->next now references t, but the caller will drop its reference to t,
;;;765       * so netto there is no change to the reference count of t.
;;;766       */
;;;767    }
000012  bd70              POP      {r4-r6,pc}
                  |L3.20|
000014  bf00              NOP                            ;749
000016  4634              MOV      r4,r6                 ;753
000018  e004              B        |L3.36|
                  |L3.26|
00001a  8920              LDRH     r0,[r4,#8]            ;755
00001c  8929              LDRH     r1,[r5,#8]            ;755
00001e  4408              ADD      r0,r0,r1              ;755
000020  8120              STRH     r0,[r4,#8]            ;755
000022  6824              LDR      r4,[r4,#0]            ;753
                  |L3.36|
000024  6820              LDR      r0,[r4,#0]            ;753
000026  2800              CMP      r0,#0                 ;753
000028  d1f7              BNE      |L3.26|
00002a  bf00              NOP                            ;758
00002c  8920              LDRH     r0,[r4,#8]            ;758
00002e  8961              LDRH     r1,[r4,#0xa]          ;758
000030  4288              CMP      r0,r1                 ;758
000032  d004              BEQ      |L3.62|
000034  a018              ADR      r0,|L3.152|
000036  f7fffffe          BL       __2printf
00003a  bf00              NOP                            ;758
                  |L3.60|
00003c  e7fe              B        |L3.60|
                  |L3.62|
00003e  bf00              NOP                            ;758
000040  bf00              NOP                            ;759
000042  6820              LDR      r0,[r4,#0]            ;759
000044  b120              CBZ      r0,|L3.80|
000046  a020              ADR      r0,|L3.200|
000048  f7fffffe          BL       __2printf
00004c  bf00              NOP                            ;759
                  |L3.78|
00004e  e7fe              B        |L3.78|
                  |L3.80|
000050  bf00              NOP                            ;759
000052  8920              LDRH     r0,[r4,#8]            ;761
000054  8929              LDRH     r1,[r5,#8]            ;761
000056  4408              ADD      r0,r0,r1              ;761
000058  8120              STRH     r0,[r4,#8]            ;761
00005a  6025              STR      r5,[r4,#0]            ;763
00005c  bf00              NOP      
00005e  e7d8              B        |L3.18|
;;;768    
                          ENDP

                  |L3.96|
000060  28682021          DCB      "(h != NULL) && (t != NULL) (programmer violates API)",0
000064  3d204e55
000068  4c4c2920
00006c  26262028
000070  7420213d
000074  204e554c
000078  4c292028
00007c  70726f67
000080  72616d6d
000084  65722076
000088  696f6c61
00008c  74657320
000090  41504929
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L3.152|
000098  702d3e74          DCB      "p->tot_len == p->len (of last pbuf in chain)",0
00009c  6f745f6c
0000a0  656e203d
0000a4  3d20702d
0000a8  3e6c656e
0000ac  20286f66
0000b0  206c6173
0000b4  74207062
0000b8  75662069
0000bc  6e206368
0000c0  61696e29
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L3.200|
0000c8  702d3e6e          DCB      "p->next == NULL",0
0000cc  65787420
0000d0  3d3d204e
0000d4  554c4c00

                          AREA ||i.pbuf_chain||, CODE, READONLY, ALIGN=1

                  pbuf_chain PROC
;;;785    void
;;;786    pbuf_chain(struct pbuf *h, struct pbuf *t)
000000  b570              PUSH     {r4-r6,lr}
;;;787    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;788      pbuf_cat(h, t);
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       pbuf_cat
;;;789      /* t is now referenced by h */
;;;790      pbuf_ref(t);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       pbuf_ref
;;;791      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
000014  bf00              NOP      
000016  bf00              NOP      
;;;792    }
000018  bd70              POP      {r4-r6,pc}
;;;793    
                          ENDP


                          AREA ||i.pbuf_clen||, CODE, READONLY, ALIGN=1

                  pbuf_clen PROC
;;;703    u8_t
;;;704    pbuf_clen(struct pbuf *p)
000000  4601              MOV      r1,r0
;;;705    {
;;;706      u8_t len;
;;;707    
;;;708      len = 0;
000002  2000              MOVS     r0,#0
;;;709      while (p != NULL) {
000004  e002              B        |L5.12|
                  |L5.6|
;;;710        ++len;
000006  1c42              ADDS     r2,r0,#1
000008  b2d0              UXTB     r0,r2
;;;711        p = p->next;
00000a  6809              LDR      r1,[r1,#0]
                  |L5.12|
00000c  2900              CMP      r1,#0                 ;709
00000e  d1fa              BNE      |L5.6|
;;;712      }
;;;713      return len;
;;;714    }
000010  4770              BX       lr
;;;715    
                          ENDP


                          AREA ||i.pbuf_coalesce||, CODE, READONLY, ALIGN=2

                  pbuf_coalesce PROC
;;;1009   struct pbuf*
;;;1010   pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1011   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1012     struct pbuf *q;
;;;1013     err_t err;
;;;1014     if (p->next == NULL) {
000008  6820              LDR      r0,[r4,#0]
00000a  b910              CBNZ     r0,|L6.18|
;;;1015       return p;
00000c  4620              MOV      r0,r4
                  |L6.14|
;;;1016     }
;;;1017     q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
;;;1018     if (q == NULL) {
;;;1019       /* @todo: what do we do now? */
;;;1020       return p;
;;;1021     }
;;;1022     err = pbuf_copy(q, p);
;;;1023     LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
;;;1024     pbuf_free(p);
;;;1025     return q;
;;;1026   }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L6.18|
000012  8921              LDRH     r1,[r4,#8]            ;1017
000014  2200              MOVS     r2,#0                 ;1017
000016  4638              MOV      r0,r7                 ;1017
000018  f7fffffe          BL       pbuf_alloc
00001c  4605              MOV      r5,r0                 ;1017
00001e  b90d              CBNZ     r5,|L6.36|
000020  4620              MOV      r0,r4                 ;1020
000022  e7f4              B        |L6.14|
                  |L6.36|
000024  4621              MOV      r1,r4                 ;1022
000026  4628              MOV      r0,r5                 ;1022
000028  f7fffffe          BL       pbuf_copy
00002c  4606              MOV      r6,r0                 ;1022
00002e  bf00              NOP                            ;1023
000030  b126              CBZ      r6,|L6.60|
000032  a005              ADR      r0,|L6.72|
000034  f7fffffe          BL       __2printf
000038  bf00              NOP                            ;1023
                  |L6.58|
00003a  e7fe              B        |L6.58|
                  |L6.60|
00003c  bf00              NOP                            ;1023
00003e  4620              MOV      r0,r4                 ;1024
000040  f7fffffe          BL       pbuf_free
000044  4628              MOV      r0,r5                 ;1025
000046  e7e2              B        |L6.14|
;;;1027   
                          ENDP

                  |L6.72|
000048  70627566          DCB      "pbuf_copy failed",0
00004c  5f636f70
000050  79206661
000054  696c6564
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.pbuf_copy||, CODE, READONLY, ALIGN=2

                  pbuf_copy PROC
;;;851    err_t
;;;852    pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;853    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;854      u16_t offset_to=0, offset_from=0, len;
000008  2600              MOVS     r6,#0
00000a  2700              MOVS     r7,#0
;;;855    
;;;856      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;857        (void*)p_to, (void*)p_from));
;;;858    
;;;859      /* is the target big enough to hold the source? */
;;;860      LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
000010  bf00              NOP      
000012  b125              CBZ      r5,|L7.30|
000014  b11c              CBZ      r4,|L7.30|
000016  8928              LDRH     r0,[r5,#8]
000018  8921              LDRH     r1,[r4,#8]
00001a  4288              CMP      r0,r1
00001c  da06              BGE      |L7.44|
                  |L7.30|
00001e  a038              ADR      r0,|L7.256|
000020  f7fffffe          BL       __2printf
000024  f06f000d          MVN      r0,#0xd
                  |L7.40|
;;;861                 (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);
;;;862    
;;;863      /* iterate through pbuf chain */
;;;864      do
;;;865      {
;;;866        /* copy one part of the original chain */
;;;867        if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
;;;868          /* complete current p_from fits into current p_to */
;;;869          len = p_from->len - offset_from;
;;;870        } else {
;;;871          /* current p_from does not fit into current p_to */
;;;872          len = p_to->len - offset_to;
;;;873        }
;;;874        MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
;;;875        offset_to += len;
;;;876        offset_from += len;
;;;877        LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
;;;878        LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
;;;879        if (offset_from >= p_from->len) {
;;;880          /* on to next p_from (if any) */
;;;881          offset_from = 0;
;;;882          p_from = p_from->next;
;;;883        }
;;;884        if (offset_to == p_to->len) {
;;;885          /* on to next p_to (if any) */
;;;886          offset_to = 0;
;;;887          p_to = p_to->next;
;;;888          LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
;;;889        }
;;;890    
;;;891        if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
;;;892          /* don't copy more than one packet! */
;;;893          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;894                     (p_from->next == NULL), return ERR_VAL;);
;;;895        }
;;;896        if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
;;;897          /* don't copy more than one packet! */
;;;898          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;899                      (p_to->next == NULL), return ERR_VAL;);
;;;900        }
;;;901      } while (p_from);
;;;902      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
;;;903      return ERR_OK;
;;;904    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L7.44|
00002c  bf00              NOP                            ;860
00002e  bf00              NOP                            ;864
                  |L7.48|
000030  8968              LDRH     r0,[r5,#0xa]          ;867
000032  1b80              SUBS     r0,r0,r6              ;867
000034  8961              LDRH     r1,[r4,#0xa]          ;867
000036  1bc9              SUBS     r1,r1,r7              ;867
000038  4288              CMP      r0,r1                 ;867
00003a  db04              BLT      |L7.70|
00003c  8960              LDRH     r0,[r4,#0xa]          ;869
00003e  1bc0              SUBS     r0,r0,r7              ;869
000040  fa1ff880          UXTH     r8,r0                 ;869
000044  e003              B        |L7.78|
                  |L7.70|
000046  8968              LDRH     r0,[r5,#0xa]          ;872
000048  1b80              SUBS     r0,r0,r6              ;872
00004a  fa1ff880          UXTH     r8,r0                 ;872
                  |L7.78|
00004e  6862              LDR      r2,[r4,#4]            ;874
000050  19d1              ADDS     r1,r2,r7              ;874
000052  686a              LDR      r2,[r5,#4]            ;874
000054  1990              ADDS     r0,r2,r6              ;874
000056  4642              MOV      r2,r8                 ;874
000058  f7fffffe          BL       __aeabi_memcpy
00005c  eb060008          ADD      r0,r6,r8              ;875
000060  b286              UXTH     r6,r0                 ;875
000062  eb070008          ADD      r0,r7,r8              ;876
000066  b287              UXTH     r7,r0                 ;876
000068  bf00              NOP                            ;877
00006a  8968              LDRH     r0,[r5,#0xa]          ;877
00006c  42b0              CMP      r0,r6                 ;877
00006e  da04              BGE      |L7.122|
000070  a02f              ADR      r0,|L7.304|
000072  f7fffffe          BL       __2printf
000076  bf00              NOP                            ;877
                  |L7.120|
000078  e7fe              B        |L7.120|
                  |L7.122|
00007a  bf00              NOP                            ;877
00007c  bf00              NOP                            ;878
00007e  8960              LDRH     r0,[r4,#0xa]          ;878
000080  42b8              CMP      r0,r7                 ;878
000082  da04              BGE      |L7.142|
000084  a030              ADR      r0,|L7.328|
000086  f7fffffe          BL       __2printf
00008a  bf00              NOP                            ;878
                  |L7.140|
00008c  e7fe              B        |L7.140|
                  |L7.142|
00008e  bf00              NOP                            ;878
000090  8960              LDRH     r0,[r4,#0xa]          ;879
000092  42b8              CMP      r0,r7                 ;879
000094  dc01              BGT      |L7.154|
000096  2700              MOVS     r7,#0                 ;881
000098  6824              LDR      r4,[r4,#0]            ;882
                  |L7.154|
00009a  8968              LDRH     r0,[r5,#0xa]          ;884
00009c  42b0              CMP      r0,r6                 ;884
00009e  d10b              BNE      |L7.184|
0000a0  2600              MOVS     r6,#0                 ;886
0000a2  682d              LDR      r5,[r5,#0]            ;887
0000a4  bf00              NOP                            ;888
0000a6  b935              CBNZ     r5,|L7.182|
0000a8  b12c              CBZ      r4,|L7.182|
0000aa  a02e              ADR      r0,|L7.356|
0000ac  f7fffffe          BL       __2printf
0000b0  f06f000d          MVN      r0,#0xd               ;888
0000b4  e7b8              B        |L7.40|
                  |L7.182|
0000b6  bf00              NOP                            ;888
                  |L7.184|
0000b8  b16c              CBZ      r4,|L7.214|
0000ba  8960              LDRH     r0,[r4,#0xa]          ;891
0000bc  8921              LDRH     r1,[r4,#8]            ;891
0000be  4288              CMP      r0,r1                 ;891
0000c0  d109              BNE      |L7.214|
0000c2  bf00              NOP                            ;893
0000c4  6820              LDR      r0,[r4,#0]            ;893
0000c6  b128              CBZ      r0,|L7.212|
0000c8  a02a              ADR      r0,|L7.372|
0000ca  f7fffffe          BL       __2printf
0000ce  f06f0005          MVN      r0,#5                 ;893
0000d2  e7a9              B        |L7.40|
                  |L7.212|
0000d4  bf00              NOP                            ;893
                  |L7.214|
0000d6  b16d              CBZ      r5,|L7.244|
0000d8  8968              LDRH     r0,[r5,#0xa]          ;896
0000da  8929              LDRH     r1,[r5,#8]            ;896
0000dc  4288              CMP      r0,r1                 ;896
0000de  d109              BNE      |L7.244|
0000e0  bf00              NOP                            ;898
0000e2  6828              LDR      r0,[r5,#0]            ;898
0000e4  b128              CBZ      r0,|L7.242|
0000e6  a023              ADR      r0,|L7.372|
0000e8  f7fffffe          BL       __2printf
0000ec  f06f0005          MVN      r0,#5                 ;898
0000f0  e79a              B        |L7.40|
                  |L7.242|
0000f2  bf00              NOP                            ;898
                  |L7.244|
0000f4  2c00              CMP      r4,#0                 ;901
0000f6  d19b              BNE      |L7.48|
0000f8  bf00              NOP                            ;902
0000fa  bf00              NOP                            ;902
0000fc  2000              MOVS     r0,#0                 ;903
0000fe  e793              B        |L7.40|
;;;905    
                          ENDP

                  |L7.256|
000100  70627566          DCB      "pbuf_copy: target not big enough to hold source",0
000104  5f636f70
000108  793a2074
00010c  61726765
000110  74206e6f
000114  74206269
000118  6720656e
00011c  6f756768
000120  20746f20
000124  686f6c64
000128  20736f75
00012c  72636500
                  |L7.304|
000130  6f666673          DCB      "offset_to <= p_to->len",0
000134  65745f74
000138  6f203c3d
00013c  20705f74
000140  6f2d3e6c
000144  656e00  
000147  00                DCB      0
                  |L7.328|
000148  6f666673          DCB      "offset_from <= p_from->len",0
00014c  65745f66
000150  726f6d20
000154  3c3d2070
000158  5f66726f
00015c  6d2d3e6c
000160  656e00  
000163  00                DCB      0
                  |L7.356|
000164  705f746f          DCB      "p_to != NULL",0
000168  20213d20
00016c  4e554c4c
000170  00      
000171  00                DCB      0
000172  00                DCB      0
000173  00                DCB      0
                  |L7.372|
000174  70627566          DCB      "pbuf_copy() does not allow packet queues!\n",0
000178  5f636f70
00017c  79282920
000180  646f6573
000184  206e6f74
000188  20616c6c
00018c  6f772070
000190  61636b65
000194  74207175
000198  65756573
00019c  210a00  
00019f  00                DCB      0

                          AREA ||i.pbuf_copy_partial||, CODE, READONLY, ALIGN=2

                  pbuf_copy_partial PROC
;;;917    u16_t
;;;918    pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;919    {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
00000a  461d              MOV      r5,r3
;;;920      struct pbuf *p;
;;;921      u16_t left;
;;;922      u16_t buf_copy_len;
;;;923      u16_t copied_total = 0;
00000c  f04f0b00          MOV      r11,#0
;;;924    
;;;925      LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
000010  bf00              NOP      
000012  f1b80f00          CMP      r8,#0
000016  d105              BNE      |L8.36|
000018  a021              ADR      r0,|L8.160|
00001a  f7fffffe          BL       __2printf
00001e  2000              MOVS     r0,#0
                  |L8.32|
;;;926      LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
;;;927    
;;;928      left = 0;
;;;929    
;;;930      if((buf == NULL) || (dataptr == NULL)) {
;;;931        return 0;
;;;932      }
;;;933    
;;;934      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;935      for(p = buf; len != 0 && p != NULL; p = p->next) {
;;;936        if ((offset != 0) && (offset >= p->len)) {
;;;937          /* don't copy from this buffer -> on to the next */
;;;938          offset -= p->len;
;;;939        } else {
;;;940          /* copy from this buffer. maybe only partially. */
;;;941          buf_copy_len = p->len - offset;
;;;942          if (buf_copy_len > len)
;;;943              buf_copy_len = len;
;;;944          /* copy the necessary parts of the buffer */
;;;945          MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
;;;946          copied_total += buf_copy_len;
;;;947          left += buf_copy_len;
;;;948          len -= buf_copy_len;
;;;949          offset = 0;
;;;950        }
;;;951      }
;;;952      return copied_total;
;;;953    }
000020  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.36|
000024  bf00              NOP                            ;925
000026  bf00              NOP                            ;926
000028  f1b90f00          CMP      r9,#0                 ;926
00002c  d104              BNE      |L8.56|
00002e  a024              ADR      r0,|L8.192|
000030  f7fffffe          BL       __2printf
000034  2000              MOVS     r0,#0                 ;926
000036  e7f3              B        |L8.32|
                  |L8.56|
000038  bf00              NOP                            ;926
00003a  f04f0a00          MOV      r10,#0                ;928
00003e  f1b80f00          CMP      r8,#0                 ;930
000042  d002              BEQ      |L8.74|
000044  f1b90f00          CMP      r9,#0                 ;930
000048  d101              BNE      |L8.78|
                  |L8.74|
00004a  2000              MOVS     r0,#0                 ;931
00004c  e7e8              B        |L8.32|
                  |L8.78|
00004e  4644              MOV      r4,r8                 ;935
000050  e020              B        |L8.148|
                  |L8.82|
000052  b135              CBZ      r5,|L8.98|
000054  8960              LDRH     r0,[r4,#0xa]          ;936
000056  42a8              CMP      r0,r5                 ;936
000058  dc03              BGT      |L8.98|
00005a  8960              LDRH     r0,[r4,#0xa]          ;938
00005c  1a28              SUBS     r0,r5,r0              ;938
00005e  b285              UXTH     r5,r0                 ;938
000060  e017              B        |L8.146|
                  |L8.98|
000062  8960              LDRH     r0,[r4,#0xa]          ;941
000064  1b40              SUBS     r0,r0,r5              ;941
000066  b287              UXTH     r7,r0                 ;941
000068  42b7              CMP      r7,r6                 ;942
00006a  dd00              BLE      |L8.110|
00006c  4637              MOV      r7,r6                 ;943
                  |L8.110|
00006e  6862              LDR      r2,[r4,#4]            ;945
000070  1951              ADDS     r1,r2,r5              ;945
000072  eb09000a          ADD      r0,r9,r10             ;945
000076  463a              MOV      r2,r7                 ;945
000078  f7fffffe          BL       __aeabi_memcpy
00007c  eb0b0007          ADD      r0,r11,r7             ;946
000080  fa1ffb80          UXTH     r11,r0                ;946
000084  eb0a0007          ADD      r0,r10,r7             ;947
000088  fa1ffa80          UXTH     r10,r0                ;947
00008c  1bf0              SUBS     r0,r6,r7              ;948
00008e  b286              UXTH     r6,r0                 ;948
000090  2500              MOVS     r5,#0                 ;949
                  |L8.146|
000092  6824              LDR      r4,[r4,#0]            ;935
                  |L8.148|
000094  b10e              CBZ      r6,|L8.154|
000096  2c00              CMP      r4,#0                 ;935
000098  d1db              BNE      |L8.82|
                  |L8.154|
00009a  4658              MOV      r0,r11                ;952
00009c  e7c0              B        |L8.32|
;;;954    
                          ENDP

00009e  0000              DCW      0x0000
                  |L8.160|
0000a0  70627566          DCB      "pbuf_copy_partial: invalid buf",0
0000a4  5f636f70
0000a8  795f7061
0000ac  72746961
0000b0  6c3a2069
0000b4  6e76616c
0000b8  69642062
0000bc  756600  
0000bf  00                DCB      0
                  |L8.192|
0000c0  70627566          DCB      "pbuf_copy_partial: invalid dataptr",0
0000c4  5f636f70
0000c8  795f7061
0000cc  72746961
0000d0  6c3a2069
0000d4  6e76616c
0000d8  69642064
0000dc  61746170
0000e0  747200  
0000e3  00                DCB      0

                          AREA ||i.pbuf_dechain||, CODE, READONLY, ALIGN=2

                  pbuf_dechain PROC
;;;802    struct pbuf *
;;;803    pbuf_dechain(struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;804    {
000002  4604              MOV      r4,r0
;;;805      struct pbuf *q;
;;;806      u8_t tail_gone = 1;
000004  2601              MOVS     r6,#1
;;;807      /* tail */
;;;808      q = p->next;
000006  6825              LDR      r5,[r4,#0]
;;;809      /* pbuf has successor in chain? */
;;;810      if (q != NULL) {
000008  b1f5              CBZ      r5,|L9.72|
;;;811        /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;812        LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
00000a  bf00              NOP      
00000c  8920              LDRH     r0,[r4,#8]
00000e  8961              LDRH     r1,[r4,#0xa]
000010  1a40              SUBS     r0,r0,r1
000012  8929              LDRH     r1,[r5,#8]
000014  4288              CMP      r0,r1
000016  d004              BEQ      |L9.34|
000018  a014              ADR      r0,|L9.108|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L9.32|
000020  e7fe              B        |L9.32|
                  |L9.34|
000022  bf00              NOP      
;;;813        /* enforce invariant if assertion is disabled */
;;;814        q->tot_len = p->tot_len - p->len;
000024  8920              LDRH     r0,[r4,#8]
000026  8961              LDRH     r1,[r4,#0xa]
000028  1a40              SUBS     r0,r0,r1
00002a  8128              STRH     r0,[r5,#8]
;;;815        /* decouple pbuf from remainder */
;;;816        p->next = NULL;
00002c  2000              MOVS     r0,#0
00002e  6020              STR      r0,[r4,#0]
;;;817        /* total length of pbuf p is its own length only */
;;;818        p->tot_len = p->len;
000030  8960              LDRH     r0,[r4,#0xa]
000032  8120              STRH     r0,[r4,#8]
;;;819        /* q is no longer referenced by p, free it */
;;;820        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
000034  bf00              NOP      
000036  bf00              NOP      
;;;821        tail_gone = pbuf_free(q);
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       pbuf_free
00003e  4606              MOV      r6,r0
;;;822        if (tail_gone > 0) {
000040  2e00              CMP      r6,#0
000042  dd01              BLE      |L9.72|
;;;823          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE,
000044  bf00              NOP      
000046  bf00              NOP      
                  |L9.72|
;;;824                      ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
;;;825        }
;;;826        /* return remaining tail or NULL if deallocated */
;;;827      }
;;;828      /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;829      LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
000048  bf00              NOP      
00004a  8920              LDRH     r0,[r4,#8]
00004c  8961              LDRH     r1,[r4,#0xa]
00004e  4288              CMP      r0,r1
000050  d004              BEQ      |L9.92|
000052  a00f              ADR      r0,|L9.144|
000054  f7fffffe          BL       __2printf
000058  bf00              NOP      
                  |L9.90|
00005a  e7fe              B        |L9.90|
                  |L9.92|
00005c  bf00              NOP      
;;;830      return ((tail_gone > 0) ? NULL : q);
00005e  2e00              CMP      r6,#0
000060  dd01              BLE      |L9.102|
000062  2000              MOVS     r0,#0
                  |L9.100|
;;;831    }
000064  bd70              POP      {r4-r6,pc}
                  |L9.102|
000066  4628              MOV      r0,r5                 ;830
000068  e7fc              B        |L9.100|
;;;832    
                          ENDP

00006a  0000              DCW      0x0000
                  |L9.108|
00006c  702d3e74          DCB      "p->tot_len == p->len + q->tot_len",0
000070  6f745f6c
000074  656e203d
000078  3d20702d
00007c  3e6c656e
000080  202b2071
000084  2d3e746f
000088  745f6c65
00008c  6e00    
00008e  00                DCB      0
00008f  00                DCB      0
                  |L9.144|
000090  702d3e74          DCB      "p->tot_len == p->len",0
000094  6f745f6c
000098  656e203d
00009c  3d20702d
0000a0  3e6c656e
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0

                          AREA ||i.pbuf_free||, CODE, READONLY, ALIGN=2

                  pbuf_free PROC
;;;617    u8_t
;;;618    pbuf_free(struct pbuf *p)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;619    {
000004  4604              MOV      r4,r0
;;;620      u16_t type;
;;;621      struct pbuf *q;
;;;622      u8_t count;
;;;623    
;;;624      if (p == NULL) {
000006  b964              CBNZ     r4,|L10.34|
;;;625        LWIP_ASSERT("p != NULL", p != NULL);
000008  bf00              NOP      
00000a  b924              CBNZ     r4,|L10.22|
00000c  a035              ADR      r0,|L10.228|
00000e  f7fffffe          BL       __2printf
000012  bf00              NOP      
                  |L10.20|
000014  e7fe              B        |L10.20|
                  |L10.22|
000016  bf00              NOP      
;;;626        /* if assertions are disabled, proceed with debug output */
;;;627        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
000018  bf00              NOP      
00001a  bf00              NOP      
;;;628          ("pbuf_free(p == NULL) was called.\n"));
;;;629        return 0;
00001c  2000              MOVS     r0,#0
                  |L10.30|
;;;630      }
;;;631      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));
;;;632    
;;;633      PERF_START;
;;;634    
;;;635      LWIP_ASSERT("pbuf_free: sane type",
;;;636        p->type == PBUF_RAM || p->type == PBUF_ROM ||
;;;637        p->type == PBUF_REF || p->type == PBUF_POOL);
;;;638    
;;;639      count = 0;
;;;640      /* de-allocate all consecutive pbufs from the head of the chain that
;;;641       * obtain a zero reference count after decrementing*/
;;;642      while (p != NULL) {
;;;643        u16_t ref;
;;;644        SYS_ARCH_DECL_PROTECT(old_level);
;;;645        /* Since decrementing ref cannot be guaranteed to be a single machine operation
;;;646         * we must protect it. We put the new ref into a local variable to prevent
;;;647         * further protection. */
;;;648        SYS_ARCH_PROTECT(old_level);
;;;649        /* all pbufs in a chain are referenced at least once */
;;;650        LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
;;;651        /* decrease reference count (number of pointers to pbuf) */
;;;652        ref = --(p->ref);
;;;653        SYS_ARCH_UNPROTECT(old_level);
;;;654        /* this pbuf is no longer referenced to? */
;;;655        if (ref == 0) {
;;;656          /* remember next pbuf in chain for next iteration */
;;;657          q = p->next;
;;;658          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
;;;659          type = p->type;
;;;660    #if LWIP_SUPPORT_CUSTOM_PBUF
;;;661          /* is this a custom pbuf? */
;;;662          if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
;;;663            struct pbuf_custom *pc = (struct pbuf_custom*)p;
;;;664            LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
;;;665            pc->custom_free_function(p);
;;;666          } else
;;;667    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
;;;668          {
;;;669            /* is this a pbuf from the pool? */
;;;670            if (type == PBUF_POOL) {
;;;671              memp_free(MEMP_PBUF_POOL, p);
;;;672            /* is this a ROM or RAM referencing pbuf? */
;;;673            } else if (type == PBUF_ROM || type == PBUF_REF) {
;;;674              memp_free(MEMP_PBUF, p);
;;;675            /* type == PBUF_RAM */
;;;676            } else {
;;;677              mem_free(p);
;;;678            }
;;;679          }
;;;680          count++;
;;;681          /* proceed to next pbuf */
;;;682          p = q;
;;;683        /* p->ref > 0, this pbuf is still referenced to */
;;;684        /* (and so the remaining pbufs in chain as well) */
;;;685        } else {
;;;686          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
;;;687          /* stop walking through the chain */
;;;688          p = NULL;
;;;689        }
;;;690      }
;;;691      PERF_STOP("pbuf_free");
;;;692      /* return number of de-allocated pbufs */
;;;693      return count;
;;;694    }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L10.34|
000022  bf00              NOP                            ;631
000024  bf00              NOP                            ;631
000026  bf00              NOP                            ;635
000028  7b20              LDRB     r0,[r4,#0xc]          ;635
00002a  b168              CBZ      r0,|L10.72|
00002c  7b20              LDRB     r0,[r4,#0xc]          ;635
00002e  2801              CMP      r0,#1                 ;635
000030  d00a              BEQ      |L10.72|
000032  7b20              LDRB     r0,[r4,#0xc]          ;635
000034  2802              CMP      r0,#2                 ;635
000036  d007              BEQ      |L10.72|
000038  7b20              LDRB     r0,[r4,#0xc]          ;635
00003a  2803              CMP      r0,#3                 ;635
00003c  d004              BEQ      |L10.72|
00003e  a02c              ADR      r0,|L10.240|
000040  f7fffffe          BL       __2printf
000044  bf00              NOP                            ;635
                  |L10.70|
000046  e7fe              B        |L10.70|
                  |L10.72|
000048  bf00              NOP                            ;635
00004a  2600              MOVS     r6,#0                 ;639
00004c  e045              B        |L10.218|
                  |L10.78|
00004e  bf00              NOP                            ;650
000050  89e0              LDRH     r0,[r4,#0xe]          ;650
000052  2800              CMP      r0,#0                 ;650
000054  dc04              BGT      |L10.96|
000056  a02c              ADR      r0,|L10.264|
000058  f7fffffe          BL       __2printf
00005c  bf00              NOP                            ;650
                  |L10.94|
00005e  e7fe              B        |L10.94|
                  |L10.96|
000060  bf00              NOP                            ;650
000062  89e0              LDRH     r0,[r4,#0xe]          ;652
000064  1e40              SUBS     r0,r0,#1              ;652
000066  fa1ff880          UXTH     r8,r0                 ;652
00006a  f8a4800e          STRH     r8,[r4,#0xe]          ;652
00006e  f1b80f00          CMP      r8,#0                 ;655
000072  d12e              BNE      |L10.210|
000074  6827              LDR      r7,[r4,#0]            ;657
000076  bf00              NOP                            ;658
000078  bf00              NOP                            ;658
00007a  7b25              LDRB     r5,[r4,#0xc]          ;659
00007c  7b60              LDRB     r0,[r4,#0xd]          ;662
00007e  f0000002          AND      r0,r0,#2              ;662
000082  b178              CBZ      r0,|L10.164|
000084  46a1              MOV      r9,r4                 ;663
000086  bf00              NOP                            ;664
000088  f8d90010          LDR      r0,[r9,#0x10]         ;664
00008c  b920              CBNZ     r0,|L10.152|
00008e  a024              ADR      r0,|L10.288|
000090  f7fffffe          BL       __2printf
000094  bf00              NOP                            ;664
                  |L10.150|
000096  e7fe              B        |L10.150|
                  |L10.152|
000098  bf00              NOP                            ;664
00009a  4620              MOV      r0,r4                 ;665
00009c  f8d91010          LDR      r1,[r9,#0x10]         ;665
0000a0  4788              BLX      r1                    ;665
0000a2  e012              B        |L10.202|
                  |L10.164|
0000a4  2d03              CMP      r5,#3                 ;670
0000a6  d104              BNE      |L10.178|
0000a8  4621              MOV      r1,r4                 ;671
0000aa  2009              MOVS     r0,#9                 ;671
0000ac  f7fffffe          BL       memp_free
0000b0  e00b              B        |L10.202|
                  |L10.178|
0000b2  2d01              CMP      r5,#1                 ;673
0000b4  d001              BEQ      |L10.186|
0000b6  2d02              CMP      r5,#2                 ;673
0000b8  d104              BNE      |L10.196|
                  |L10.186|
0000ba  4621              MOV      r1,r4                 ;674
0000bc  2008              MOVS     r0,#8                 ;674
0000be  f7fffffe          BL       memp_free
0000c2  e002              B        |L10.202|
                  |L10.196|
0000c4  4620              MOV      r0,r4                 ;677
0000c6  f7fffffe          BL       mem_free
                  |L10.202|
0000ca  1c70              ADDS     r0,r6,#1              ;680
0000cc  b2c6              UXTB     r6,r0                 ;680
0000ce  463c              MOV      r4,r7                 ;682
0000d0  e002              B        |L10.216|
                  |L10.210|
0000d2  bf00              NOP                            ;686
0000d4  bf00              NOP                            ;686
0000d6  2400              MOVS     r4,#0                 ;688
                  |L10.216|
0000d8  bf00              NOP                            ;690
                  |L10.218|
0000da  2c00              CMP      r4,#0                 ;642
0000dc  d1b7              BNE      |L10.78|
0000de  4630              MOV      r0,r6                 ;693
0000e0  e79d              B        |L10.30|
;;;695    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L10.228|
0000e4  7020213d          DCB      "p != NULL",0
0000e8  204e554c
0000ec  4c00    
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L10.240|
0000f0  70627566          DCB      "pbuf_free: sane type",0
0000f4  5f667265
0000f8  653a2073
0000fc  616e6520
000100  74797065
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0
                  |L10.264|
000108  70627566          DCB      "pbuf_free: p->ref > 0",0
00010c  5f667265
000110  653a2070
000114  2d3e7265
000118  66203e20
00011c  3000    
00011e  00                DCB      0
00011f  00                DCB      0
                  |L10.288|
000120  70632d3e          DCB      "pc->custom_free_function != NULL",0
000124  63757374
000128  6f6d5f66
00012c  7265655f
000130  66756e63
000134  74696f6e
000138  20213d20
00013c  4e554c4c
000140  00      
000141  00                DCB      0
000142  00                DCB      0
000143  00                DCB      0

                          AREA ||i.pbuf_free_ooseq||, CODE, READONLY, ALIGN=2

                  pbuf_free_ooseq PROC
;;;117    void
;;;118    pbuf_free_ooseq(void)
000000  b510              PUSH     {r4,lr}
;;;119    {
;;;120      struct tcp_pcb* pcb;
;;;121      SYS_ARCH_DECL_PROTECT(old_level);
;;;122    
;;;123      SYS_ARCH_PROTECT(old_level);
;;;124      pbuf_free_ooseq_pending = 0;
000002  2000              MOVS     r0,#0
000004  4909              LDR      r1,|L11.44|
000006  7008              STRB     r0,[r1,#0]
;;;125      SYS_ARCH_UNPROTECT(old_level);
;;;126    
;;;127      for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
000008  4809              LDR      r0,|L11.48|
00000a  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
00000c  e00a              B        |L11.36|
                  |L11.14|
;;;128        if (NULL != pcb->ooseq) {
00000e  6f60              LDR      r0,[r4,#0x74]
000010  b138              CBZ      r0,|L11.34|
;;;129          /** Free the ooseq pbufs of one PCB only */
;;;130          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
000012  bf00              NOP      
000014  bf00              NOP      
;;;131          tcp_segs_free(pcb->ooseq);
000016  6f60              LDR      r0,[r4,#0x74]
000018  f7fffffe          BL       tcp_segs_free
;;;132          pcb->ooseq = NULL;
00001c  2000              MOVS     r0,#0
00001e  6760              STR      r0,[r4,#0x74]
                  |L11.32|
;;;133          return;
;;;134        }
;;;135      }
;;;136    }
000020  bd10              POP      {r4,pc}
                  |L11.34|
000022  68e4              LDR      r4,[r4,#0xc]          ;127
                  |L11.36|
000024  2c00              CMP      r4,#0                 ;127
000026  d1f2              BNE      |L11.14|
000028  bf00              NOP      
00002a  e7f9              B        |L11.32|
;;;137    
                          ENDP

                  |L11.44|
                          DCD      pbuf_free_ooseq_pending
                  |L11.48|
                          DCD      tcp_active_pcbs

                          AREA ||i.pbuf_get_at||, CODE, READONLY, ALIGN=1

                  pbuf_get_at PROC
;;;1076   u8_t
;;;1077   pbuf_get_at(struct pbuf* p, u16_t offset)
000000  b510              PUSH     {r4,lr}
;;;1078   {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;1079     u16_t copy_from = offset;
000006  4622              MOV      r2,r4
;;;1080     struct pbuf* q = p;
000008  4619              MOV      r1,r3
;;;1081   
;;;1082     /* get the correct pbuf */
;;;1083     while ((q != NULL) && (q->len <= copy_from)) {
00000a  e003              B        |L12.20|
                  |L12.12|
;;;1084       copy_from -= q->len;
00000c  8948              LDRH     r0,[r1,#0xa]
00000e  1a10              SUBS     r0,r2,r0
000010  b282              UXTH     r2,r0
;;;1085       q = q->next;
000012  6809              LDR      r1,[r1,#0]
                  |L12.20|
000014  b111              CBZ      r1,|L12.28|
000016  8948              LDRH     r0,[r1,#0xa]          ;1083
000018  4290              CMP      r0,r2                 ;1083
00001a  ddf7              BLE      |L12.12|
                  |L12.28|
;;;1086     }
;;;1087     /* return requested data if pbuf is OK */
;;;1088     if ((q != NULL) && (q->len > copy_from)) {
00001c  b129              CBZ      r1,|L12.42|
00001e  8948              LDRH     r0,[r1,#0xa]
000020  4290              CMP      r0,r2
000022  dd02              BLE      |L12.42|
;;;1089       return ((u8_t*)q->payload)[copy_from];
000024  6848              LDR      r0,[r1,#4]
000026  5c80              LDRB     r0,[r0,r2]
                  |L12.40|
;;;1090     }
;;;1091     return 0;
;;;1092   }
000028  bd10              POP      {r4,pc}
                  |L12.42|
00002a  2000              MOVS     r0,#0                 ;1091
00002c  e7fc              B        |L12.40|
;;;1093   
                          ENDP


                          AREA ||i.pbuf_header||, CODE, READONLY, ALIGN=2

                  pbuf_header PROC
;;;510    u8_t
;;;511    pbuf_header(struct pbuf *p, s16_t header_size_increment)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;512    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;513      u16_t type;
;;;514      void *payload;
;;;515      u16_t increment_magnitude;
;;;516    
;;;517      LWIP_ASSERT("p != NULL", p != NULL);
000008  bf00              NOP      
00000a  b924              CBNZ     r4,|L13.22|
00000c  a026              ADR      r0,|L13.168|
00000e  f7fffffe          BL       __2printf
000012  bf00              NOP      
                  |L13.20|
000014  e7fe              B        |L13.20|
                  |L13.22|
000016  bf00              NOP      
;;;518      if ((header_size_increment == 0) || (p == NULL)) {
000018  b105              CBZ      r5,|L13.28|
00001a  b914              CBNZ     r4,|L13.34|
                  |L13.28|
;;;519        return 0;
00001c  2000              MOVS     r0,#0
                  |L13.30|
;;;520      }
;;;521     
;;;522      if (header_size_increment < 0){
;;;523        increment_magnitude = -header_size_increment;
;;;524        /* Check that we aren't going to move off the end of the pbuf */
;;;525        LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
;;;526      } else {
;;;527        increment_magnitude = header_size_increment;
;;;528    #if 0
;;;529        /* Can't assert these as some callers speculatively call
;;;530             pbuf_header() to see if it's OK.  Will return 1 below instead. */
;;;531        /* Check that we've got the correct type of pbuf to work with */
;;;532        LWIP_ASSERT("p->type == PBUF_RAM || p->type == PBUF_POOL", 
;;;533                    p->type == PBUF_RAM || p->type == PBUF_POOL);
;;;534        /* Check that we aren't going to move off the beginning of the pbuf */
;;;535        LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
;;;536                    (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
;;;537    #endif
;;;538      }
;;;539    
;;;540      type = p->type;
;;;541      /* remember current payload pointer */
;;;542      payload = p->payload;
;;;543    
;;;544      /* pbuf types containing payloads? */
;;;545      if (type == PBUF_RAM || type == PBUF_POOL) {
;;;546        /* set new payload pointer */
;;;547        p->payload = (u8_t *)p->payload - header_size_increment;
;;;548        /* boundary check fails? */
;;;549        if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
;;;550          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;551            ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
;;;552            (void *)p->payload, (void *)(p + 1)));
;;;553          /* restore old payload pointer */
;;;554          p->payload = payload;
;;;555          /* bail out unsuccesfully */
;;;556          return 1;
;;;557        }
;;;558      /* pbuf types refering to external payloads? */
;;;559      } else if (type == PBUF_REF || type == PBUF_ROM) {
;;;560        /* hide a header in the payload? */
;;;561        if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
;;;562          /* increase payload pointer */
;;;563          p->payload = (u8_t *)p->payload - header_size_increment;
;;;564        } else {
;;;565          /* cannot expand payload to front (yet!)
;;;566           * bail out unsuccesfully */
;;;567          return 1;
;;;568        }
;;;569      } else {
;;;570        /* Unknown type */
;;;571        LWIP_ASSERT("bad pbuf type", 0);
;;;572        return 1;
;;;573      }
;;;574      /* modify pbuf length fields */
;;;575      p->len += header_size_increment;
;;;576      p->tot_len += header_size_increment;
;;;577    
;;;578      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
;;;579        (void *)payload, (void *)p->payload, header_size_increment));
;;;580    
;;;581      return 0;
;;;582    }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L13.34|
000022  2d00              CMP      r5,#0                 ;522
000024  da0b              BGE      |L13.62|
000026  4268              RSBS     r0,r5,#0              ;523
000028  b287              UXTH     r7,r0                 ;523
00002a  bf00              NOP                            ;525
00002c  8960              LDRH     r0,[r4,#0xa]          ;525
00002e  42b8              CMP      r0,r7                 ;525
000030  da04              BGE      |L13.60|
000032  a020              ADR      r0,|L13.180|
000034  f7fffffe          BL       __2printf
000038  2001              MOVS     r0,#1                 ;525
00003a  e7f0              B        |L13.30|
                  |L13.60|
00003c  e000              B        |L13.64|
                  |L13.62|
00003e  b2af              UXTH     r7,r5                 ;527
                  |L13.64|
000040  7b26              LDRB     r6,[r4,#0xc]          ;540
000042  f8d48004          LDR      r8,[r4,#4]            ;542
000046  b10e              CBZ      r6,|L13.76|
000048  2e03              CMP      r6,#3                 ;545
00004a  d10d              BNE      |L13.104|
                  |L13.76|
00004c  6860              LDR      r0,[r4,#4]            ;547
00004e  1b40              SUBS     r0,r0,r5              ;547
000050  6060              STR      r0,[r4,#4]            ;547
000052  f1040010          ADD      r0,r4,#0x10           ;549
000056  6861              LDR      r1,[r4,#4]            ;549
000058  4281              CMP      r1,r0                 ;549
00005a  d21a              BCS      |L13.146|
00005c  bf00              NOP                            ;550
00005e  bf00              NOP                            ;550
000060  f8c48004          STR      r8,[r4,#4]            ;554
000064  2001              MOVS     r0,#1                 ;556
000066  e7da              B        |L13.30|
                  |L13.104|
000068  2e02              CMP      r6,#2                 ;559
00006a  d001              BEQ      |L13.112|
00006c  2e01              CMP      r6,#1                 ;559
00006e  d10a              BNE      |L13.134|
                  |L13.112|
000070  2d00              CMP      r5,#0                 ;561
000072  da06              BGE      |L13.130|
000074  8960              LDRH     r0,[r4,#0xa]          ;561
000076  42b8              CMP      r0,r7                 ;561
000078  db03              BLT      |L13.130|
00007a  6860              LDR      r0,[r4,#4]            ;563
00007c  1b40              SUBS     r0,r0,r5              ;563
00007e  6060              STR      r0,[r4,#4]            ;563
000080  e007              B        |L13.146|
                  |L13.130|
000082  2001              MOVS     r0,#1                 ;567
000084  e7cb              B        |L13.30|
                  |L13.134|
000086  bf00              NOP                            ;571
000088  a012              ADR      r0,|L13.212|
00008a  f7fffffe          BL       __2printf
00008e  bf00              NOP                            ;571
                  |L13.144|
000090  e7fe              B        |L13.144|
                  |L13.146|
000092  8960              LDRH     r0,[r4,#0xa]          ;575
000094  4428              ADD      r0,r0,r5              ;575
000096  8160              STRH     r0,[r4,#0xa]          ;575
000098  8920              LDRH     r0,[r4,#8]            ;576
00009a  4428              ADD      r0,r0,r5              ;576
00009c  8120              STRH     r0,[r4,#8]            ;576
00009e  bf00              NOP                            ;578
0000a0  bf00              NOP                            ;578
0000a2  2000              MOVS     r0,#0                 ;581
0000a4  e7bb              B        |L13.30|
;;;583    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L13.168|
0000a8  7020213d          DCB      "p != NULL",0
0000ac  204e554c
0000b0  4c00    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L13.180|
0000b4  696e6372          DCB      "increment_magnitude <= p->len",0
0000b8  656d656e
0000bc  745f6d61
0000c0  676e6974
0000c4  75646520
0000c8  3c3d2070
0000cc  2d3e6c65
0000d0  6e00    
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L13.212|
0000d4  62616420          DCB      "bad pbuf type",0
0000d8  70627566
0000dc  20747970
0000e0  6500    
0000e2  00                DCB      0
0000e3  00                DCB      0

                          AREA ||i.pbuf_memcmp||, CODE, READONLY, ALIGN=1

                  pbuf_memcmp PROC
;;;1103   u16_t
;;;1104   pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1105   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
;;;1106     u16_t start = offset;
00000c  4646              MOV      r6,r8
;;;1107     struct pbuf* q = p;
00000e  463c              MOV      r4,r7
;;;1108   
;;;1109     /* get the correct pbuf */
;;;1110     while ((q != NULL) && (q->len <= start)) {
000010  e003              B        |L14.26|
                  |L14.18|
;;;1111       start -= q->len;
000012  8960              LDRH     r0,[r4,#0xa]
000014  1a30              SUBS     r0,r6,r0
000016  b286              UXTH     r6,r0
;;;1112       q = q->next;
000018  6824              LDR      r4,[r4,#0]
                  |L14.26|
00001a  b114              CBZ      r4,|L14.34|
00001c  8960              LDRH     r0,[r4,#0xa]          ;1110
00001e  42b0              CMP      r0,r6                 ;1110
000020  ddf7              BLE      |L14.18|
                  |L14.34|
;;;1113     }
;;;1114     /* return requested data if pbuf is OK */
;;;1115     if ((q != NULL) && (q->len > start)) {
000022  b1d4              CBZ      r4,|L14.90|
000024  8960              LDRH     r0,[r4,#0xa]
000026  42b0              CMP      r0,r6
000028  dd17              BLE      |L14.90|
;;;1116       u16_t i;
;;;1117       for(i = 0; i < n; i++) {
00002a  2500              MOVS     r5,#0
00002c  e011              B        |L14.82|
                  |L14.46|
;;;1118         u8_t a = pbuf_get_at(q, start + i);
00002e  1970              ADDS     r0,r6,r5
000030  b281              UXTH     r1,r0
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       pbuf_get_at
000038  4683              MOV      r11,r0
;;;1119         u8_t b = ((u8_t*)s2)[i];
00003a  f8190005          LDRB     r0,[r9,r5]
00003e  9000              STR      r0,[sp,#0]
;;;1120         if (a != b) {
000040  9800              LDR      r0,[sp,#0]
000042  4583              CMP      r11,r0
000044  d003              BEQ      |L14.78|
;;;1121           return i+1;
000046  1c68              ADDS     r0,r5,#1
000048  b280              UXTH     r0,r0
                  |L14.74|
;;;1122         }
;;;1123       }
;;;1124       return 0;
;;;1125     }
;;;1126     return 0xffff;
;;;1127   }
00004a  e8bd8ff8          POP      {r3-r11,pc}
                  |L14.78|
00004e  1c68              ADDS     r0,r5,#1              ;1117
000050  b285              UXTH     r5,r0                 ;1117
                  |L14.82|
000052  4555              CMP      r5,r10                ;1117
000054  dbeb              BLT      |L14.46|
000056  2000              MOVS     r0,#0                 ;1124
000058  e7f7              B        |L14.74|
                  |L14.90|
00005a  f64f70ff          MOV      r0,#0xffff            ;1126
00005e  e7f4              B        |L14.74|
;;;1128   
                          ENDP


                          AREA ||i.pbuf_memfind||, CODE, READONLY, ALIGN=1

                  pbuf_memfind PROC
;;;1139   u16_t
;;;1140   pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1141   {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;1142     u16_t i;
;;;1143     u16_t max = p->tot_len - mem_len;
00000c  8930              LDRH     r0,[r6,#8]
00000e  1b40              SUBS     r0,r0,r5
000010  fa1ffa80          UXTH     r10,r0
;;;1144     if (p->tot_len >= mem_len + start_offset) {
000014  8930              LDRH     r0,[r6,#8]
000016  19e9              ADDS     r1,r5,r7
000018  4288              CMP      r0,r1
00001a  db14              BLT      |L15.70|
;;;1145       for(i = start_offset; i <= max; ) {
00001c  463c              MOV      r4,r7
00001e  e010              B        |L15.66|
                  |L15.32|
;;;1146         u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
000020  462b              MOV      r3,r5
000022  4642              MOV      r2,r8
000024  4621              MOV      r1,r4
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       pbuf_memcmp
00002c  4681              MOV      r9,r0
;;;1147         if (plus == 0) {
00002e  f1b90f00          CMP      r9,#0
000032  d102              BNE      |L15.58|
;;;1148           return i;
000034  4620              MOV      r0,r4
                  |L15.54|
;;;1149         } else {
;;;1150           i += plus;
;;;1151         }
;;;1152       }
;;;1153     }
;;;1154     return 0xFFFF;
;;;1155   }
000036  e8bd87f0          POP      {r4-r10,pc}
                  |L15.58|
00003a  eb040009          ADD      r0,r4,r9              ;1150
00003e  b284              UXTH     r4,r0                 ;1150
000040  bf00              NOP                            ;1152
                  |L15.66|
000042  4554              CMP      r4,r10                ;1145
000044  ddec              BLE      |L15.32|
                  |L15.70|
000046  f64f70ff          MOV      r0,#0xffff            ;1154
00004a  e7f4              B        |L15.54|
;;;1156   
                          ENDP


                          AREA ||i.pbuf_pool_is_empty||, CODE, READONLY, ALIGN=2

                  pbuf_pool_is_empty PROC
;;;151    static void
;;;152    pbuf_pool_is_empty(void)
000000  2001              MOVS     r0,#1
;;;153    {
;;;154    #ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
;;;155      SYS_ARCH_DECL_PROTECT(old_level);
;;;156      SYS_ARCH_PROTECT(old_level);
;;;157      pbuf_free_ooseq_pending = 1;
000002  4901              LDR      r1,|L16.8|
000004  7008              STRB     r0,[r1,#0]
;;;158      SYS_ARCH_UNPROTECT(old_level);
;;;159    #else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;160      u8_t queued;
;;;161      SYS_ARCH_DECL_PROTECT(old_level);
;;;162      SYS_ARCH_PROTECT(old_level);
;;;163      queued = pbuf_free_ooseq_pending;
;;;164      pbuf_free_ooseq_pending = 1;
;;;165      SYS_ARCH_UNPROTECT(old_level);
;;;166    
;;;167      if(!queued) {
;;;168        /* queue a call to pbuf_free_ooseq if not already queued */
;;;169        PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
;;;170      }
;;;171    #endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;172    }
000006  4770              BX       lr
;;;173    #endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */
                          ENDP

                  |L16.8|
                          DCD      pbuf_free_ooseq_pending

                          AREA ||i.pbuf_realloc||, CODE, READONLY, ALIGN=2

                  pbuf_realloc PROC
;;;429    void
;;;430    pbuf_realloc(struct pbuf *p, u16_t new_len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;431    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;432      struct pbuf *q;
;;;433      u16_t rem_len; /* remaining length */
;;;434      s32_t grow;
;;;435    
;;;436      LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
000008  bf00              NOP      
00000a  b925              CBNZ     r5,|L17.22|
00000c  a030              ADR      r0,|L17.208|
00000e  f7fffffe          BL       __2printf
000012  bf00              NOP      
                  |L17.20|
000014  e7fe              B        |L17.20|
                  |L17.22|
000016  bf00              NOP      
;;;437      LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
000018  bf00              NOP      
00001a  7b28              LDRB     r0,[r5,#0xc]
00001c  2803              CMP      r0,#3
00001e  d00c              BEQ      |L17.58|
000020  7b28              LDRB     r0,[r5,#0xc]
000022  2801              CMP      r0,#1
000024  d009              BEQ      |L17.58|
000026  7b28              LDRB     r0,[r5,#0xc]
000028  b138              CBZ      r0,|L17.58|
00002a  7b28              LDRB     r0,[r5,#0xc]
00002c  2802              CMP      r0,#2
00002e  d004              BEQ      |L17.58|
000030  a02d              ADR      r0,|L17.232|
000032  f7fffffe          BL       __2printf
000036  bf00              NOP      
                  |L17.56|
000038  e7fe              B        |L17.56|
                  |L17.58|
00003a  bf00              NOP      
;;;438                  p->type == PBUF_ROM ||
;;;439                  p->type == PBUF_RAM ||
;;;440                  p->type == PBUF_REF);
;;;441    
;;;442      /* desired length larger than current length? */
;;;443      if (new_len >= p->tot_len) {
00003c  8928              LDRH     r0,[r5,#8]
00003e  42b8              CMP      r0,r7
000040  dc01              BGT      |L17.70|
                  |L17.66|
;;;444        /* enlarging not yet supported */
;;;445        return;
;;;446      }
;;;447    
;;;448      /* the pbuf chain grows by (new_len - p->tot_len) bytes
;;;449       * (which may be negative in case of shrinking) */
;;;450      grow = new_len - p->tot_len;
;;;451    
;;;452      /* first, step over any pbufs that should remain in the chain */
;;;453      rem_len = new_len;
;;;454      q = p;
;;;455      /* should this pbuf be kept? */
;;;456      while (rem_len > q->len) {
;;;457        /* decrease remaining length by pbuf length */
;;;458        rem_len -= q->len;
;;;459        /* decrease total length indicator */
;;;460        LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
;;;461        q->tot_len += (u16_t)grow;
;;;462        /* proceed to next pbuf in chain */
;;;463        q = q->next;
;;;464        LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
;;;465      }
;;;466      /* we have now reached the new last pbuf (in q) */
;;;467      /* rem_len == desired length for pbuf q */
;;;468    
;;;469      /* shrink allocated memory for PBUF_RAM */
;;;470      /* (other types merely adjust their length fields */
;;;471      if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
;;;472        /* reallocate and adjust the length of the pbuf that will be split */
;;;473        q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
;;;474        LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
;;;475      }
;;;476      /* adjust length fields for new last pbuf */
;;;477      q->len = rem_len;
;;;478      q->tot_len = q->len;
;;;479    
;;;480      /* any remaining pbufs in chain? */
;;;481      if (q->next != NULL) {
;;;482        /* free remaining pbufs in chain */
;;;483        pbuf_free(q->next);
;;;484      }
;;;485      /* q is last packet in chain */
;;;486      q->next = NULL;
;;;487    
;;;488    }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L17.70|
000046  8928              LDRH     r0,[r5,#8]            ;450
000048  eba70800          SUB      r8,r7,r0              ;450
00004c  463e              MOV      r6,r7                 ;453
00004e  462c              MOV      r4,r5                 ;454
000050  e019              B        |L17.134|
                  |L17.82|
000052  8960              LDRH     r0,[r4,#0xa]          ;458
000054  1a30              SUBS     r0,r6,r0              ;458
000056  b286              UXTH     r6,r0                 ;458
000058  bf00              NOP                            ;460
00005a  f64f70ff          MOV      r0,#0xffff            ;460
00005e  4580              CMP      r8,r0                 ;460
000060  db04              BLT      |L17.108|
000062  a028              ADR      r0,|L17.260|
000064  f7fffffe          BL       __2printf
000068  bf00              NOP                            ;460
                  |L17.106|
00006a  e7fe              B        |L17.106|
                  |L17.108|
00006c  bf00              NOP                            ;460
00006e  8920              LDRH     r0,[r4,#8]            ;461
000070  4440              ADD      r0,r0,r8              ;461
000072  8120              STRH     r0,[r4,#8]            ;461
000074  6824              LDR      r4,[r4,#0]            ;463
000076  bf00              NOP                            ;464
000078  b924              CBNZ     r4,|L17.132|
00007a  a027              ADR      r0,|L17.280|
00007c  f7fffffe          BL       __2printf
000080  bf00              NOP                            ;464
                  |L17.130|
000082  e7fe              B        |L17.130|
                  |L17.132|
000084  bf00              NOP                            ;464
                  |L17.134|
000086  8960              LDRH     r0,[r4,#0xa]          ;456
000088  42b0              CMP      r0,r6                 ;456
00008a  dbe2              BLT      |L17.82|
00008c  7b20              LDRB     r0,[r4,#0xc]          ;471
00008e  b990              CBNZ     r0,|L17.182|
000090  8960              LDRH     r0,[r4,#0xa]          ;471
000092  42b0              CMP      r0,r6                 ;471
000094  d00f              BEQ      |L17.182|
000096  88a0              LDRH     r0,[r4,#4]            ;473
000098  1b00              SUBS     r0,r0,r4              ;473
00009a  4430              ADD      r0,r0,r6              ;473
00009c  b281              UXTH     r1,r0                 ;473
00009e  4620              MOV      r0,r4                 ;473
0000a0  f7fffffe          BL       mem_trim
0000a4  4604              MOV      r4,r0                 ;473
0000a6  bf00              NOP                            ;474
0000a8  b924              CBNZ     r4,|L17.180|
0000aa  a021              ADR      r0,|L17.304|
0000ac  f7fffffe          BL       __2printf
0000b0  bf00              NOP                            ;474
                  |L17.178|
0000b2  e7fe              B        |L17.178|
                  |L17.180|
0000b4  bf00              NOP                            ;474
                  |L17.182|
0000b6  8166              STRH     r6,[r4,#0xa]          ;477
0000b8  8960              LDRH     r0,[r4,#0xa]          ;478
0000ba  8120              STRH     r0,[r4,#8]            ;478
0000bc  6820              LDR      r0,[r4,#0]            ;481
0000be  b110              CBZ      r0,|L17.198|
0000c0  6820              LDR      r0,[r4,#0]            ;483
0000c2  f7fffffe          BL       pbuf_free
                  |L17.198|
0000c6  2000              MOVS     r0,#0                 ;486
0000c8  6020              STR      r0,[r4,#0]            ;486
0000ca  bf00              NOP      
0000cc  e7b9              B        |L17.66|
;;;489    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L17.208|
0000d0  70627566          DCB      "pbuf_realloc: p != NULL",0
0000d4  5f726561
0000d8  6c6c6f63
0000dc  3a207020
0000e0  213d204e
0000e4  554c4c00
                  |L17.232|
0000e8  70627566          DCB      "pbuf_realloc: sane p->type",0
0000ec  5f726561
0000f0  6c6c6f63
0000f4  3a207361
0000f8  6e652070
0000fc  2d3e7479
000100  706500  
000103  00                DCB      0
                  |L17.260|
000104  67726f77          DCB      "grow < max_u16_t",0
000108  203c206d
00010c  61785f75
000110  31365f74
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
                  |L17.280|
000118  70627566          DCB      "pbuf_realloc: q != NULL",0
00011c  5f726561
000120  6c6c6f63
000124  3a207120
000128  213d204e
00012c  554c4c00
                  |L17.304|
000130  6d656d5f          DCB      "mem_trim returned q == NULL",0
000134  7472696d
000138  20726574
00013c  75726e65
000140  64207120
000144  3d3d204e
000148  554c4c00

                          AREA ||i.pbuf_ref||, CODE, READONLY, ALIGN=1

                  pbuf_ref PROC
;;;722    void
;;;723    pbuf_ref(struct pbuf *p)
000000  b110              CBZ      r0,|L18.8|
;;;724    {
;;;725      SYS_ARCH_DECL_PROTECT(old_level);
;;;726      /* pbuf given? */
;;;727      if (p != NULL) {
;;;728        SYS_ARCH_PROTECT(old_level);
;;;729        ++(p->ref);
000002  89c1              LDRH     r1,[r0,#0xe]
000004  1c49              ADDS     r1,r1,#1
000006  81c1              STRH     r1,[r0,#0xe]
                  |L18.8|
;;;730        SYS_ARCH_UNPROTECT(old_level);
;;;731      }
;;;732    }
000008  4770              BX       lr
;;;733    
                          ENDP


                          AREA ||i.pbuf_strstr||, CODE, READONLY, ALIGN=1

                  pbuf_strstr PROC
;;;1167   u16_t
;;;1168   pbuf_strstr(struct pbuf* p, const char* substr)
000000  b570              PUSH     {r4-r6,lr}
;;;1169   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;1170     size_t substr_len;
;;;1171     if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
000006  b134              CBZ      r4,|L19.22|
000008  7820              LDRB     r0,[r4,#0]
00000a  b120              CBZ      r0,|L19.22|
00000c  8930              LDRH     r0,[r6,#8]
00000e  f64f71ff          MOV      r1,#0xffff
000012  4288              CMP      r0,r1
000014  d102              BNE      |L19.28|
                  |L19.22|
;;;1172       return 0xFFFF;
000016  f64f70ff          MOV      r0,#0xffff
                  |L19.26|
;;;1173     }
;;;1174     substr_len = strlen(substr);
;;;1175     if (substr_len >= 0xFFFF) {
;;;1176       return 0xFFFF;
;;;1177     }
;;;1178     return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
;;;1179   }
00001a  bd70              POP      {r4-r6,pc}
                  |L19.28|
00001c  4620              MOV      r0,r4                 ;1174
00001e  f7fffffe          BL       strlen
000022  4605              MOV      r5,r0                 ;1174
000024  f64f70ff          MOV      r0,#0xffff            ;1175
000028  4285              CMP      r5,r0                 ;1175
00002a  d300              BCC      |L19.46|
00002c  e7f5              B        |L19.26|
                  |L19.46|
00002e  b2aa              UXTH     r2,r5                 ;1178
000030  2300              MOVS     r3,#0                 ;1178
000032  4621              MOV      r1,r4                 ;1178
000034  4630              MOV      r0,r6                 ;1178
000036  f7fffffe          BL       pbuf_memfind
00003a  e7ee              B        |L19.26|
                          ENDP


                          AREA ||i.pbuf_take||, CODE, READONLY, ALIGN=2

                  pbuf_take PROC
;;;965    err_t
;;;966    pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;967    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;968      struct pbuf *p;
;;;969      u16_t buf_copy_len;
;;;970      u16_t total_copy_len = len;
00000a  4646              MOV      r6,r8
;;;971      u16_t copied_total = 0;
00000c  f04f0a00          MOV      r10,#0
;;;972    
;;;973      LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
000010  bf00              NOP      
000012  b92d              CBNZ     r5,|L20.32|
000014  a021              ADR      r0,|L20.156|
000016  f7fffffe          BL       __2printf
00001a  2000              MOVS     r0,#0
                  |L20.28|
;;;974      LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
;;;975    
;;;976      if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
;;;977        return ERR_ARG;
;;;978      }
;;;979    
;;;980      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;981      for(p = buf; total_copy_len != 0; p = p->next) {
;;;982        LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
;;;983        buf_copy_len = total_copy_len;
;;;984        if (buf_copy_len > p->len) {
;;;985          /* this pbuf cannot hold all remaining data */
;;;986          buf_copy_len = p->len;
;;;987        }
;;;988        /* copy the necessary parts of the buffer */
;;;989        MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
;;;990        total_copy_len -= buf_copy_len;
;;;991        copied_total += buf_copy_len;
;;;992      }
;;;993      LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
;;;994      return ERR_OK;
;;;995    }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L20.32|
000020  bf00              NOP                            ;973
000022  bf00              NOP                            ;974
000024  b927              CBNZ     r7,|L20.48|
000026  a023              ADR      r0,|L20.180|
000028  f7fffffe          BL       __2printf
00002c  2000              MOVS     r0,#0                 ;974
00002e  e7f5              B        |L20.28|
                  |L20.48|
000030  bf00              NOP                            ;974
000032  b11d              CBZ      r5,|L20.60|
000034  b117              CBZ      r7,|L20.60|
000036  8928              LDRH     r0,[r5,#8]            ;976
000038  4540              CMP      r0,r8                 ;976
00003a  da02              BGE      |L20.66|
                  |L20.60|
00003c  f06f000d          MVN      r0,#0xd               ;977
000040  e7ec              B        |L20.28|
                  |L20.66|
000042  462c              MOV      r4,r5                 ;981
000044  e01b              B        |L20.126|
                  |L20.70|
000046  bf00              NOP                            ;982
000048  b924              CBNZ     r4,|L20.84|
00004a  a021              ADR      r0,|L20.208|
00004c  f7fffffe          BL       __2printf
000050  bf00              NOP                            ;982
                  |L20.82|
000052  e7fe              B        |L20.82|
                  |L20.84|
000054  bf00              NOP                            ;982
000056  46b1              MOV      r9,r6                 ;983
000058  8960              LDRH     r0,[r4,#0xa]          ;984
00005a  4548              CMP      r0,r9                 ;984
00005c  da01              BGE      |L20.98|
00005e  f8b4900a          LDRH     r9,[r4,#0xa]          ;986
                  |L20.98|
000062  eb07010a          ADD      r1,r7,r10             ;989
000066  464a              MOV      r2,r9                 ;989
000068  6860              LDR      r0,[r4,#4]            ;989
00006a  f7fffffe          BL       __aeabi_memcpy
00006e  eba60009          SUB      r0,r6,r9              ;990
000072  b286              UXTH     r6,r0                 ;990
000074  eb0a0009          ADD      r0,r10,r9             ;991
000078  fa1ffa80          UXTH     r10,r0                ;991
00007c  6824              LDR      r4,[r4,#0]            ;981
                  |L20.126|
00007e  2e00              CMP      r6,#0                 ;981
000080  d1e1              BNE      |L20.70|
000082  bf00              NOP                            ;993
000084  b90e              CBNZ     r6,|L20.138|
000086  45c2              CMP      r10,r8                ;993
000088  d004              BEQ      |L20.148|
                  |L20.138|
00008a  a017              ADR      r0,|L20.232|
00008c  f7fffffe          BL       __2printf
000090  bf00              NOP                            ;993
                  |L20.146|
000092  e7fe              B        |L20.146|
                  |L20.148|
000094  bf00              NOP                            ;993
000096  2000              MOVS     r0,#0                 ;994
000098  e7c0              B        |L20.28|
;;;996    
                          ENDP

00009a  0000              DCW      0x0000
                  |L20.156|
00009c  70627566          DCB      "pbuf_take: invalid buf",0
0000a0  5f74616b
0000a4  653a2069
0000a8  6e76616c
0000ac  69642062
0000b0  756600  
0000b3  00                DCB      0
                  |L20.180|
0000b4  70627566          DCB      "pbuf_take: invalid dataptr",0
0000b8  5f74616b
0000bc  653a2069
0000c0  6e76616c
0000c4  69642064
0000c8  61746170
0000cc  747200  
0000cf  00                DCB      0
                  |L20.208|
0000d0  70627566          DCB      "pbuf_take: invalid pbuf",0
0000d4  5f74616b
0000d8  653a2069
0000dc  6e76616c
0000e0  69642070
0000e4  62756600
                  |L20.232|
0000e8  64696420          DCB      "did not copy all data",0
0000ec  6e6f7420
0000f0  636f7079
0000f4  20616c6c
0000f8  20646174
0000fc  6100    
0000fe  00                DCB      0
0000ff  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=0

                  pbuf_free_ooseq_pending
000000  00                DCB      0x00
