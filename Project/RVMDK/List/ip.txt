; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\ip.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\ip.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IE:\git_projects\enc28j60-for-uip\Project\RVMDK\RTE -I"D:\Program Files\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\ip.crf ..\..\lwip\src\core\ipv4\ip.c]
                          THUMB

                          AREA ||i.ip_input||, CODE, READONLY, ALIGN=2

                  ip_input PROC
;;;304    err_t
;;;305    ip_input(struct pbuf *p, struct netif *inp)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;306    {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
;;;307      struct ip_hdr *iphdr;
;;;308      struct netif *netif;
;;;309      u16_t iphdr_hlen;
;;;310      u16_t iphdr_len;
;;;311    #if IP_ACCEPT_LINK_LAYER_ADDRESSING
;;;312      int check_ip_src=1;
;;;313    #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
;;;314    
;;;315      IP_STATS_INC(ip.recv);
000008  4896              LDR      r0,|L1.612|
00000a  f8b0004a          LDRH     r0,[r0,#0x4a]
00000e  1c40              ADDS     r0,r0,#1
000010  b281              UXTH     r1,r0
000012  4894              LDR      r0,|L1.612|
000014  f8a0104a          STRH     r1,[r0,#0x4a]
;;;316      snmp_inc_ipinreceives();
;;;317    
;;;318      /* identify the IP header */
;;;319      iphdr = (struct ip_hdr *)p->payload;
000018  6875              LDR      r5,[r6,#4]
;;;320      if (IPH_V(iphdr) != 4) {
00001a  7828              LDRB     r0,[r5,#0]
00001c  2104              MOVS     r1,#4
00001e  ebb11f20          CMP      r1,r0,ASR #4
000022  d016              BEQ      |L1.82|
;;;321        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
000024  bf00              NOP      
000026  bf00              NOP      
;;;322        ip_debug_print(p);
;;;323        pbuf_free(p);
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       pbuf_free
;;;324        IP_STATS_INC(ip.err);
00002e  488d              LDR      r0,|L1.612|
000030  f8b0005c          LDRH     r0,[r0,#0x5c]
000034  1c40              ADDS     r0,r0,#1
000036  b281              UXTH     r1,r0
000038  488a              LDR      r0,|L1.612|
00003a  f8a0105c          STRH     r1,[r0,#0x5c]
;;;325        IP_STATS_INC(ip.drop);
00003e  f8b0004e          LDRH     r0,[r0,#0x4e]
000042  1c40              ADDS     r0,r0,#1
000044  b281              UXTH     r1,r0
000046  4887              LDR      r0,|L1.612|
000048  f8a0104e          STRH     r1,[r0,#0x4e]
;;;326        snmp_inc_ipinhdrerrors();
;;;327        return ERR_OK;
00004c  2000              MOVS     r0,#0
                  |L1.78|
;;;328      }
;;;329    
;;;330    #ifdef LWIP_HOOK_IP4_INPUT
;;;331      if (LWIP_HOOK_IP4_INPUT(p, inp)) {
;;;332        /* the packet has been eaten */
;;;333        return ERR_OK;
;;;334      }
;;;335    #endif
;;;336    
;;;337      /* obtain IP header length in number of 32-bit words */
;;;338      iphdr_hlen = IPH_HL(iphdr);
;;;339      /* calculate IP header length in bytes */
;;;340      iphdr_hlen *= 4;
;;;341      /* obtain ip length in bytes */
;;;342      iphdr_len = ntohs(IPH_LEN(iphdr));
;;;343    
;;;344      /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
;;;345      if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
;;;346        if (iphdr_hlen > p->len) {
;;;347          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;348            ("IP header (len %"U16_F") does not fit in first pbuf (len %"U16_F"), IP packet dropped.\n",
;;;349            iphdr_hlen, p->len));
;;;350        }
;;;351        if (iphdr_len > p->tot_len) {
;;;352          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;353            ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
;;;354            iphdr_len, p->tot_len));
;;;355        }
;;;356        /* free (drop) packet pbufs */
;;;357        pbuf_free(p);
;;;358        IP_STATS_INC(ip.lenerr);
;;;359        IP_STATS_INC(ip.drop);
;;;360        snmp_inc_ipindiscards();
;;;361        return ERR_OK;
;;;362      }
;;;363    
;;;364      /* verify checksum */
;;;365    #if CHECKSUM_CHECK_IP
;;;366      if (inet_chksum(iphdr, iphdr_hlen) != 0) {
;;;367    
;;;368        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;369          ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
;;;370        ip_debug_print(p);
;;;371        pbuf_free(p);
;;;372        IP_STATS_INC(ip.chkerr);
;;;373        IP_STATS_INC(ip.drop);
;;;374        snmp_inc_ipinhdrerrors();
;;;375        return ERR_OK;
;;;376      }
;;;377    #endif
;;;378    
;;;379      /* Trim pbuf. This should have been done at the netif layer,
;;;380       * but we'll do it anyway just to be sure that its done. */
;;;381      pbuf_realloc(p, iphdr_len);
;;;382    
;;;383      /* copy IP addresses to aligned ip_addr_t */
;;;384      ip_addr_copy(current_iphdr_dest, iphdr->dest);
;;;385      ip_addr_copy(current_iphdr_src, iphdr->src);
;;;386    
;;;387      /* match packet against an interface, i.e. is this packet for us? */
;;;388    #if LWIP_IGMP
;;;389      if (ip_addr_ismulticast(&current_iphdr_dest)) {
;;;390        if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, &current_iphdr_dest))) {
;;;391          netif = inp;
;;;392        } else {
;;;393          netif = NULL;
;;;394        }
;;;395      } else
;;;396    #endif /* LWIP_IGMP */
;;;397      {
;;;398        /* start trying with inp. if that's not acceptable, start walking the
;;;399           list of configured netifs.
;;;400           'first' is used as a boolean to mark whether we started walking the list */
;;;401        int first = 1;
;;;402        netif = inp;
;;;403        do {
;;;404          LWIP_DEBUGF(IP_DEBUG, ("ip_input: iphdr->dest 0x%"X32_F" netif->ip_addr 0x%"X32_F" (0x%"X32_F", 0x%"X32_F", 0x%"X32_F")\n",
;;;405              ip4_addr_get_u32(&iphdr->dest), ip4_addr_get_u32(&netif->ip_addr),
;;;406              ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(&netif->netmask),
;;;407              ip4_addr_get_u32(&netif->ip_addr) & ip4_addr_get_u32(&netif->netmask),
;;;408              ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));
;;;409    
;;;410          /* interface is up and configured? */
;;;411          if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
;;;412            /* unicast to this interface address? */
;;;413            if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
;;;414                /* or broadcast on this interface network address? */
;;;415                ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
;;;416              LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
;;;417                  netif->name[0], netif->name[1]));
;;;418              /* break out of for loop */
;;;419              break;
;;;420            }
;;;421    #if LWIP_AUTOIP
;;;422            /* connections to link-local addresses must persist after changing
;;;423               the netif's address (RFC3927 ch. 1.9) */
;;;424            if ((netif->autoip != NULL) &&
;;;425                ip_addr_cmp(&current_iphdr_dest, &(netif->autoip->llipaddr))) {
;;;426              LWIP_DEBUGF(IP_DEBUG, ("ip_input: LLA packet accepted on interface %c%c\n",
;;;427                  netif->name[0], netif->name[1]));
;;;428              /* break out of for loop */
;;;429              break;
;;;430            }
;;;431    #endif /* LWIP_AUTOIP */
;;;432          }
;;;433          if (first) {
;;;434            first = 0;
;;;435            netif = netif_list;
;;;436          } else {
;;;437            netif = netif->next;
;;;438          }
;;;439          if (netif == inp) {
;;;440            netif = netif->next;
;;;441          }
;;;442        } while(netif != NULL);
;;;443      }
;;;444    
;;;445    #if IP_ACCEPT_LINK_LAYER_ADDRESSING
;;;446      /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
;;;447       * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
;;;448       * According to RFC 1542 section 3.1.1, referred by RFC 2131).
;;;449       *
;;;450       * If you want to accept private broadcast communication while a netif is down,
;;;451       * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
;;;452       *
;;;453       * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
;;;454       */
;;;455      if (netif == NULL) {
;;;456        /* remote port is DHCP server? */
;;;457        if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
;;;458          struct udp_hdr *udphdr = (struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen);
;;;459          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
;;;460            ntohs(udphdr->dest)));
;;;461          if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
;;;462            LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: DHCP packet accepted.\n"));
;;;463            netif = inp;
;;;464            check_ip_src = 0;
;;;465          }
;;;466        }
;;;467      }
;;;468    #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
;;;469    
;;;470      /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
;;;471    #if IP_ACCEPT_LINK_LAYER_ADDRESSING
;;;472      /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
;;;473      if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
;;;474    #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
;;;475      {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
;;;476             (ip_addr_ismulticast(&current_iphdr_src))) {
;;;477          /* packet source is not valid */
;;;478          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
;;;479          /* free (drop) packet pbufs */
;;;480          pbuf_free(p);
;;;481          IP_STATS_INC(ip.drop);
;;;482          snmp_inc_ipinaddrerrors();
;;;483          snmp_inc_ipindiscards();
;;;484          return ERR_OK;
;;;485        }
;;;486      }
;;;487    
;;;488      /* packet not for us? */
;;;489      if (netif == NULL) {
;;;490        /* packet not for us, route or discard */
;;;491        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: packet not for us.\n"));
;;;492    #if IP_FORWARD
;;;493        /* non-broadcast packet? */
;;;494        if (!ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
;;;495          /* try to forward IP packet on (other) interfaces */
;;;496          ip_forward(p, iphdr, inp);
;;;497        } else
;;;498    #endif /* IP_FORWARD */
;;;499        {
;;;500          snmp_inc_ipinaddrerrors();
;;;501          snmp_inc_ipindiscards();
;;;502        }
;;;503        pbuf_free(p);
;;;504        return ERR_OK;
;;;505      }
;;;506      /* packet consists of multiple fragments? */
;;;507      if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
;;;508    #if IP_REASSEMBLY /* packet fragment reassembly code present? */
;;;509        LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
;;;510          ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
;;;511        /* reassemble the packet*/
;;;512        p = ip_reass(p);
;;;513        /* packet not fully reassembled yet? */
;;;514        if (p == NULL) {
;;;515          return ERR_OK;
;;;516        }
;;;517        iphdr = (struct ip_hdr *)p->payload;
;;;518    #else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
;;;519        pbuf_free(p);
;;;520        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since it was fragmented (0x%"X16_F") (while IP_REASSEMBLY == 0).\n",
;;;521          ntohs(IPH_OFFSET(iphdr))));
;;;522        IP_STATS_INC(ip.opterr);
;;;523        IP_STATS_INC(ip.drop);
;;;524        /* unsupported protocol feature */
;;;525        snmp_inc_ipinunknownprotos();
;;;526        return ERR_OK;
;;;527    #endif /* IP_REASSEMBLY */
;;;528      }
;;;529    
;;;530    #if IP_OPTIONS_ALLOWED == 0 /* no support for IP options in the IP header? */
;;;531    
;;;532    #if LWIP_IGMP
;;;533      /* there is an extra "router alert" option in IGMP messages which we allow for but do not police */
;;;534      if((iphdr_hlen > IP_HLEN) &&  (IPH_PROTO(iphdr) != IP_PROTO_IGMP)) {
;;;535    #else
;;;536      if (iphdr_hlen > IP_HLEN) {
;;;537    #endif /* LWIP_IGMP */
;;;538        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since there were IP options (while IP_OPTIONS_ALLOWED == 0).\n"));
;;;539        pbuf_free(p);
;;;540        IP_STATS_INC(ip.opterr);
;;;541        IP_STATS_INC(ip.drop);
;;;542        /* unsupported protocol feature */
;;;543        snmp_inc_ipinunknownprotos();
;;;544        return ERR_OK;
;;;545      }
;;;546    #endif /* IP_OPTIONS_ALLOWED == 0 */
;;;547    
;;;548      /* send to upper layers */
;;;549      LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
;;;550      ip_debug_print(p);
;;;551      LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));
;;;552    
;;;553      current_netif = inp;
;;;554      current_header = iphdr;
;;;555    
;;;556    #if LWIP_RAW
;;;557      /* raw input did not eat the packet? */
;;;558      if (raw_input(p, inp) == 0)
;;;559    #endif /* LWIP_RAW */
;;;560      {
;;;561        switch (IPH_PROTO(iphdr)) {
;;;562    #if LWIP_UDP
;;;563        case IP_PROTO_UDP:
;;;564    #if LWIP_UDPLITE
;;;565        case IP_PROTO_UDPLITE:
;;;566    #endif /* LWIP_UDPLITE */
;;;567          snmp_inc_ipindelivers();
;;;568          udp_input(p, inp);
;;;569          break;
;;;570    #endif /* LWIP_UDP */
;;;571    #if LWIP_TCP
;;;572        case IP_PROTO_TCP:
;;;573          snmp_inc_ipindelivers();
;;;574          tcp_input(p, inp);
;;;575          break;
;;;576    #endif /* LWIP_TCP */
;;;577    #if LWIP_ICMP
;;;578        case IP_PROTO_ICMP:
;;;579          snmp_inc_ipindelivers();
;;;580          icmp_input(p, inp);
;;;581          break;
;;;582    #endif /* LWIP_ICMP */
;;;583    #if LWIP_IGMP
;;;584        case IP_PROTO_IGMP:
;;;585          igmp_input(p, inp, &current_iphdr_dest);
;;;586          break;
;;;587    #endif /* LWIP_IGMP */
;;;588        default:
;;;589    #if LWIP_ICMP
;;;590          /* send ICMP destination protocol unreachable unless is was a broadcast */
;;;591          if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
;;;592              !ip_addr_ismulticast(&current_iphdr_dest)) {
;;;593            p->payload = iphdr;
;;;594            icmp_dest_unreach(p, ICMP_DUR_PROTO);
;;;595          }
;;;596    #endif /* LWIP_ICMP */
;;;597          pbuf_free(p);
;;;598    
;;;599          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));
;;;600    
;;;601          IP_STATS_INC(ip.proterr);
;;;602          IP_STATS_INC(ip.drop);
;;;603          snmp_inc_ipinunknownprotos();
;;;604        }
;;;605      }
;;;606    
;;;607      current_netif = NULL;
;;;608      current_header = NULL;
;;;609      ip_addr_set_any(&current_iphdr_src);
;;;610      ip_addr_set_any(&current_iphdr_dest);
;;;611    
;;;612      return ERR_OK;
;;;613    }
00004e  e8bd87f0          POP      {r4-r10,pc}
                  |L1.82|
000052  7828              LDRB     r0,[r5,#0]            ;338
000054  f000070f          AND      r7,r0,#0xf            ;338
000058  f64f70ff          MOV      r0,#0xffff            ;340
00005c  ea000787          AND      r7,r0,r7,LSL #2       ;340
000060  8868              LDRH     r0,[r5,#2]            ;342
000062  f7fffffe          BL       lwip_ntohs
000066  4680              MOV      r8,r0                 ;342
000068  8970              LDRH     r0,[r6,#0xa]          ;345
00006a  42b8              CMP      r0,r7                 ;345
00006c  db02              BLT      |L1.116|
00006e  8930              LDRH     r0,[r6,#8]            ;345
000070  4540              CMP      r0,r8                 ;345
000072  da1d              BGE      |L1.176|
                  |L1.116|
000074  8970              LDRH     r0,[r6,#0xa]          ;346
000076  42b8              CMP      r0,r7                 ;346
000078  da01              BGE      |L1.126|
00007a  bf00              NOP                            ;347
00007c  bf00              NOP                            ;347
                  |L1.126|
00007e  8930              LDRH     r0,[r6,#8]            ;351
000080  4540              CMP      r0,r8                 ;351
000082  da01              BGE      |L1.136|
000084  bf00              NOP                            ;352
000086  bf00              NOP                            ;352
                  |L1.136|
000088  4630              MOV      r0,r6                 ;357
00008a  f7fffffe          BL       pbuf_free
00008e  4875              LDR      r0,|L1.612|
000090  f8b00052          LDRH     r0,[r0,#0x52]         ;358
000094  1c40              ADDS     r0,r0,#1              ;358
000096  b281              UXTH     r1,r0                 ;358
000098  4872              LDR      r0,|L1.612|
00009a  f8a01052          STRH     r1,[r0,#0x52]         ;358
00009e  f8b0004e          LDRH     r0,[r0,#0x4e]         ;359
0000a2  1c40              ADDS     r0,r0,#1              ;359
0000a4  b281              UXTH     r1,r0                 ;359
0000a6  486f              LDR      r0,|L1.612|
0000a8  f8a0104e          STRH     r1,[r0,#0x4e]         ;359
0000ac  2000              MOVS     r0,#0                 ;361
0000ae  e7ce              B        |L1.78|
                  |L1.176|
0000b0  4639              MOV      r1,r7                 ;366
0000b2  4628              MOV      r0,r5                 ;366
0000b4  f7fffffe          BL       inet_chksum
0000b8  b1a8              CBZ      r0,|L1.230|
0000ba  bf00              NOP                            ;368
0000bc  bf00              NOP                            ;368
0000be  4630              MOV      r0,r6                 ;371
0000c0  f7fffffe          BL       pbuf_free
0000c4  4867              LDR      r0,|L1.612|
0000c6  f8b00050          LDRH     r0,[r0,#0x50]         ;372
0000ca  1c40              ADDS     r0,r0,#1              ;372
0000cc  b281              UXTH     r1,r0                 ;372
0000ce  4865              LDR      r0,|L1.612|
0000d0  f8a01050          STRH     r1,[r0,#0x50]         ;372
0000d4  f8b0004e          LDRH     r0,[r0,#0x4e]         ;373
0000d8  1c40              ADDS     r0,r0,#1              ;373
0000da  b281              UXTH     r1,r0                 ;373
0000dc  4861              LDR      r0,|L1.612|
0000de  f8a0104e          STRH     r1,[r0,#0x4e]         ;373
0000e2  2000              MOVS     r0,#0                 ;375
0000e4  e7b3              B        |L1.78|
                  |L1.230|
0000e6  4641              MOV      r1,r8                 ;381
0000e8  4630              MOV      r0,r6                 ;381
0000ea  f7fffffe          BL       pbuf_realloc
0000ee  6928              LDR      r0,[r5,#0x10]         ;384
0000f0  495d              LDR      r1,|L1.616|
0000f2  6008              STR      r0,[r1,#0]            ;384  ; current_iphdr_dest
0000f4  68e8              LDR      r0,[r5,#0xc]          ;385
0000f6  495d              LDR      r1,|L1.620|
0000f8  6008              STR      r0,[r1,#0]            ;385  ; current_iphdr_src
0000fa  f04f0a01          MOV      r10,#1                ;401
0000fe  464c              MOV      r4,r9                 ;402
000100  bf00              NOP                            ;403
                  |L1.258|
000102  bf00              NOP                            ;404
000104  bf00              NOP                            ;404
000106  f8940029          LDRB     r0,[r4,#0x29]         ;411
00010a  f0000001          AND      r0,r0,#1              ;411
00010e  b188              CBZ      r0,|L1.308|
000110  1d20              ADDS     r0,r4,#4              ;411
000112  b178              CBZ      r0,|L1.308|
000114  6860              LDR      r0,[r4,#4]            ;411
000116  b168              CBZ      r0,|L1.308|
000118  4853              LDR      r0,|L1.616|
00011a  6800              LDR      r0,[r0,#0]            ;413  ; current_iphdr_dest
00011c  6861              LDR      r1,[r4,#4]            ;413
00011e  4288              CMP      r0,r1                 ;413
000120  d005              BEQ      |L1.302|
000122  4951              LDR      r1,|L1.616|
000124  6808              LDR      r0,[r1,#0]            ;415  ; current_iphdr_dest
000126  4621              MOV      r1,r4                 ;415
000128  f7fffffe          BL       ip4_addr_isbroadcast
00012c  b110              CBZ      r0,|L1.308|
                  |L1.302|
00012e  bf00              NOP                            ;416
000130  bf00              NOP                            ;416
000132  e00d              B        |L1.336|
                  |L1.308|
000134  f1ba0f00          CMP      r10,#0                ;433
000138  d004              BEQ      |L1.324|
00013a  f04f0a00          MOV      r10,#0                ;434
00013e  484c              LDR      r0,|L1.624|
000140  6804              LDR      r4,[r0,#0]            ;435  ; netif_list
000142  e000              B        |L1.326|
                  |L1.324|
000144  6824              LDR      r4,[r4,#0]            ;437
                  |L1.326|
000146  454c              CMP      r4,r9                 ;439
000148  d100              BNE      |L1.332|
00014a  6824              LDR      r4,[r4,#0]            ;440
                  |L1.332|
00014c  2c00              CMP      r4,#0                 ;442
00014e  d1d8              BNE      |L1.258|
                  |L1.336|
000150  bf00              NOP                            ;419
000152  4946              LDR      r1,|L1.620|
000154  6808              LDR      r0,[r1,#0]            ;475  ; current_iphdr_src
000156  4649              MOV      r1,r9                 ;475
000158  f7fffffe          BL       ip4_addr_isbroadcast
00015c  b928              CBNZ     r0,|L1.362|
00015e  4843              LDR      r0,|L1.620|
000160  7800              LDRB     r0,[r0,#0]            ;476  ; current_iphdr_src
000162  f00000f0          AND      r0,r0,#0xf0           ;476
000166  28e0              CMP      r0,#0xe0              ;476
000168  d10e              BNE      |L1.392|
                  |L1.362|
00016a  bf00              NOP                            ;478
00016c  bf00              NOP                            ;478
00016e  4630              MOV      r0,r6                 ;480
000170  f7fffffe          BL       pbuf_free
000174  483b              LDR      r0,|L1.612|
000176  f8b0004e          LDRH     r0,[r0,#0x4e]         ;481
00017a  1c40              ADDS     r0,r0,#1              ;481
00017c  b281              UXTH     r1,r0                 ;481
00017e  4839              LDR      r0,|L1.612|
000180  f8a0104e          STRH     r1,[r0,#0x4e]         ;481
000184  2000              MOVS     r0,#0                 ;484
000186  e762              B        |L1.78|
                  |L1.392|
000188  b934              CBNZ     r4,|L1.408|
00018a  bf00              NOP                            ;491
00018c  bf00              NOP                            ;491
00018e  4630              MOV      r0,r6                 ;503
000190  f7fffffe          BL       pbuf_free
000194  2000              MOVS     r0,#0                 ;504
000196  e75a              B        |L1.78|
                  |L1.408|
000198  88e8              LDRH     r0,[r5,#6]            ;507
00019a  f64f713f          MOV      r1,#0xff3f            ;507
00019e  4008              ANDS     r0,r0,r1              ;507
0001a0  b148              CBZ      r0,|L1.438|
0001a2  bf00              NOP                            ;509
0001a4  bf00              NOP                            ;509
0001a6  4630              MOV      r0,r6                 ;512
0001a8  f7fffffe          BL       ip_reass
0001ac  4606              MOV      r6,r0                 ;512
0001ae  b90e              CBNZ     r6,|L1.436|
0001b0  2000              MOVS     r0,#0                 ;515
0001b2  e74c              B        |L1.78|
                  |L1.436|
0001b4  6875              LDR      r5,[r6,#4]            ;517
                  |L1.438|
0001b6  bf00              NOP                            ;549
0001b8  bf00              NOP                            ;549
0001ba  bf00              NOP                            ;551
0001bc  bf00              NOP                            ;551
0001be  482d              LDR      r0,|L1.628|
0001c0  f8c09000          STR      r9,[r0,#0]            ;553  ; current_netif
0001c4  482c              LDR      r0,|L1.632|
0001c6  6005              STR      r5,[r0,#0]            ;554  ; current_header
0001c8  4649              MOV      r1,r9                 ;558
0001ca  4630              MOV      r0,r6                 ;558
0001cc  f7fffffe          BL       raw_input
0001d0  bbe0              CBNZ     r0,|L1.588|
0001d2  7a68              LDRB     r0,[r5,#9]            ;561
0001d4  2801              CMP      r0,#1                 ;561
0001d6  d00d              BEQ      |L1.500|
0001d8  2806              CMP      r0,#6                 ;561
0001da  d006              BEQ      |L1.490|
0001dc  2811              CMP      r0,#0x11              ;561
0001de  d10e              BNE      |L1.510|
0001e0  4649              MOV      r1,r9                 ;568
0001e2  4630              MOV      r0,r6                 ;568
0001e4  f7fffffe          BL       udp_input
0001e8  e02f              B        |L1.586|
                  |L1.490|
0001ea  4649              MOV      r1,r9                 ;574
0001ec  4630              MOV      r0,r6                 ;574
0001ee  f7fffffe          BL       tcp_input
0001f2  e02a              B        |L1.586|
                  |L1.500|
0001f4  4649              MOV      r1,r9                 ;580
0001f6  4630              MOV      r0,r6                 ;580
0001f8  f7fffffe          BL       icmp_input
0001fc  e025              B        |L1.586|
                  |L1.510|
0001fe  491a              LDR      r1,|L1.616|
000200  6808              LDR      r0,[r1,#0]            ;591  ; current_iphdr_dest
000202  4649              MOV      r1,r9                 ;591
000204  f7fffffe          BL       ip4_addr_isbroadcast
000208  b950              CBNZ     r0,|L1.544|
00020a  4817              LDR      r0,|L1.616|
00020c  7800              LDRB     r0,[r0,#0]            ;592  ; current_iphdr_dest
00020e  f00000f0          AND      r0,r0,#0xf0           ;592
000212  28e0              CMP      r0,#0xe0              ;592
000214  d004              BEQ      |L1.544|
000216  6075              STR      r5,[r6,#4]            ;593
000218  2102              MOVS     r1,#2                 ;594
00021a  4630              MOV      r0,r6                 ;594
00021c  f7fffffe          BL       icmp_dest_unreach
                  |L1.544|
000220  4630              MOV      r0,r6                 ;597
000222  f7fffffe          BL       pbuf_free
000226  bf00              NOP                            ;599
000228  bf00              NOP                            ;599
00022a  480e              LDR      r0,|L1.612|
00022c  f8b00058          LDRH     r0,[r0,#0x58]         ;601
000230  1c40              ADDS     r0,r0,#1              ;601
000232  b281              UXTH     r1,r0                 ;601
000234  480b              LDR      r0,|L1.612|
000236  f8a01058          STRH     r1,[r0,#0x58]         ;601
00023a  f8b0004e          LDRH     r0,[r0,#0x4e]         ;602
00023e  1c40              ADDS     r0,r0,#1              ;602
000240  b281              UXTH     r1,r0                 ;602
000242  4808              LDR      r0,|L1.612|
000244  f8a0104e          STRH     r1,[r0,#0x4e]         ;602
000248  bf00              NOP                            ;561
                  |L1.586|
00024a  bf00              NOP                            ;569
                  |L1.588|
00024c  2000              MOVS     r0,#0                 ;607
00024e  4909              LDR      r1,|L1.628|
000250  6008              STR      r0,[r1,#0]            ;607  ; current_netif
000252  4909              LDR      r1,|L1.632|
000254  6008              STR      r0,[r1,#0]            ;608  ; current_header
000256  4905              LDR      r1,|L1.620|
000258  6008              STR      r0,[r1,#0]            ;609  ; current_iphdr_src
00025a  4903              LDR      r1,|L1.616|
00025c  6008              STR      r0,[r1,#0]            ;610  ; current_iphdr_dest
00025e  bf00              NOP                            ;612
000260  e6f5              B        |L1.78|
;;;614    
                          ENDP

000262  0000              DCW      0x0000
                  |L1.612|
                          DCD      lwip_stats
                  |L1.616|
                          DCD      current_iphdr_dest
                  |L1.620|
                          DCD      current_iphdr_src
                  |L1.624|
                          DCD      netif_list
                  |L1.628|
                          DCD      current_netif
                  |L1.632|
                          DCD      current_header

                          AREA ||i.ip_output||, CODE, READONLY, ALIGN=2

                  ip_output PROC
;;;817    err_t
;;;818    ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;819              u8_t ttl, u8_t tos, u8_t proto)
;;;820    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
;;;821      struct netif *netif;
;;;822    
;;;823      /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
;;;824         gets altered as the packet is passed down the stack */
;;;825      LWIP_ASSERT("p->ref == 1", p->ref == 1);
000010  bf00              NOP      
000012  89e8              LDRH     r0,[r5,#0xe]
000014  2801              CMP      r0,#1
000016  d004              BEQ      |L2.34|
000018  a010              ADR      r0,|L2.92|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L2.32|
000020  e7fe              B        |L2.32|
                  |L2.34|
000022  bf00              NOP      
;;;826    
;;;827      if ((netif = ip_route(dest)) == NULL) {
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       ip_route
00002a  1e04              SUBS     r4,r0,#0
00002c  d10c              BNE      |L2.72|
;;;828        LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
00002e  bf00              NOP      
000030  bf00              NOP      
;;;829          ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
;;;830        IP_STATS_INC(ip.rterr);
000032  480d              LDR      r0,|L2.104|
000034  f8b00056          LDRH     r0,[r0,#0x56]
000038  1c40              ADDS     r0,r0,#1
00003a  b281              UXTH     r1,r0
00003c  480a              LDR      r0,|L2.104|
00003e  f8a01056          STRH     r1,[r0,#0x56]
;;;831        return ERR_RTE;
000042  1f20              SUBS     r0,r4,#4
                  |L2.68|
;;;832      }
;;;833    
;;;834      return ip_output_if(p, src, dest, ttl, tos, proto, netif);
;;;835    }
000044  e8bd8ffe          POP      {r1-r11,pc}
                  |L2.72|
000048  4643              MOV      r3,r8                 ;834
00004a  4632              MOV      r2,r6                 ;834
00004c  4639              MOV      r1,r7                 ;834
00004e  4628              MOV      r0,r5                 ;834
000050  e9cd9a00          STRD     r9,r10,[sp,#0]        ;834
000054  9402              STR      r4,[sp,#8]            ;834
000056  f7fffffe          BL       ip_output_if
00005a  e7f3              B        |L2.68|
;;;836    
                          ENDP

                  |L2.92|
00005c  702d3e72          DCB      "p->ref == 1",0
000060  6566203d
000064  3d203100
                  |L2.104|
                          DCD      lwip_stats

                          AREA ||i.ip_output_if||, CODE, READONLY, ALIGN=2

                  ip_output_if PROC
;;;640    err_t
;;;641    ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;642                 u8_t ttl, u8_t tos,
;;;643                 u8_t proto, struct netif *netif)
;;;644    {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
00000c  9f0c              LDR      r7,[sp,#0x30]
;;;645    #if IP_OPTIONS_SEND
;;;646      return ip_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
;;;647    }
;;;648    
;;;649    /**
;;;650     * Same as ip_output_if() but with the possibility to include IP options:
;;;651     *
;;;652     * @ param ip_options pointer to the IP options, copied into the IP header
;;;653     * @ param optlen length of ip_options
;;;654     */
;;;655    err_t ip_output_if_opt(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
;;;656           u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
;;;657           u16_t optlen)
;;;658    {
;;;659    #endif /* IP_OPTIONS_SEND */
;;;660      struct ip_hdr *iphdr;
;;;661      ip_addr_t dest_addr;
;;;662    #if CHECKSUM_GEN_IP_INLINE
;;;663      u32_t chk_sum = 0;
00000e  2500              MOVS     r5,#0
;;;664    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;665    
;;;666      /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
;;;667         gets altered as the packet is passed down the stack */
;;;668      LWIP_ASSERT("p->ref == 1", p->ref == 1);
000010  bf00              NOP      
000012  89f0              LDRH     r0,[r6,#0xe]
000014  2801              CMP      r0,#1
000016  d004              BEQ      |L3.34|
000018  a053              ADR      r0,|L3.360|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L3.32|
000020  e7fe              B        |L3.32|
                  |L3.34|
000022  bf00              NOP      
;;;669    
;;;670      snmp_inc_ipoutrequests();
;;;671    
;;;672      /* Should the IP header be generated or is it already included in p? */
;;;673      if (dest != IP_HDRINCL) {
000024  f1b90f00          CMP      r9,#0
000028  d070              BEQ      |L3.268|
;;;674        u16_t ip_hlen = IP_HLEN;
00002a  f04f0b14          MOV      r11,#0x14
;;;675    #if IP_OPTIONS_SEND
;;;676        u16_t optlen_aligned = 0;
;;;677        if (optlen != 0) {
;;;678    #if CHECKSUM_GEN_IP_INLINE
;;;679          int i;
;;;680    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;681          /* round up to a multiple of 4 */
;;;682          optlen_aligned = ((optlen + 3) & ~3);
;;;683          ip_hlen += optlen_aligned;
;;;684          /* First write in the IP options */
;;;685          if (pbuf_header(p, optlen_aligned)) {
;;;686            LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output_if_opt: not enough room for IP options in pbuf\n"));
;;;687            IP_STATS_INC(ip.err);
;;;688            snmp_inc_ipoutdiscards();
;;;689            return ERR_BUF;
;;;690          }
;;;691          MEMCPY(p->payload, ip_options, optlen);
;;;692          if (optlen < optlen_aligned) {
;;;693            /* zero the remaining bytes */
;;;694            memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
;;;695          }
;;;696    #if CHECKSUM_GEN_IP_INLINE
;;;697          for (i = 0; i < optlen_aligned/2; i++) {
;;;698            chk_sum += ((u16_t*)p->payload)[i];
;;;699          }
;;;700    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;701        }
;;;702    #endif /* IP_OPTIONS_SEND */
;;;703        /* generate IP header */
;;;704        if (pbuf_header(p, IP_HLEN)) {
00002e  2114              MOVS     r1,#0x14
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       pbuf_header
000036  b168              CBZ      r0,|L3.84|
;;;705          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));
000038  bf00              NOP      
00003a  bf00              NOP      
;;;706    
;;;707          IP_STATS_INC(ip.err);
00003c  484d              LDR      r0,|L3.372|
00003e  f8b0005c          LDRH     r0,[r0,#0x5c]
000042  1c40              ADDS     r0,r0,#1
000044  b281              UXTH     r1,r0
000046  484b              LDR      r0,|L3.372|
000048  f8a0105c          STRH     r1,[r0,#0x5c]
;;;708          snmp_inc_ipoutdiscards();
;;;709          return ERR_BUF;
00004c  f06f0001          MVN      r0,#1
                  |L3.80|
;;;710        }
;;;711    
;;;712        iphdr = (struct ip_hdr *)p->payload;
;;;713        LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
;;;714                   (p->len >= sizeof(struct ip_hdr)));
;;;715    
;;;716        IPH_TTL_SET(iphdr, ttl);
;;;717        IPH_PROTO_SET(iphdr, proto);
;;;718    #if CHECKSUM_GEN_IP_INLINE
;;;719        chk_sum += LWIP_MAKE_U16(proto, ttl);
;;;720    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;721    
;;;722        /* dest cannot be NULL here */
;;;723        ip_addr_copy(iphdr->dest, *dest);
;;;724    #if CHECKSUM_GEN_IP_INLINE
;;;725        chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
;;;726        chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
;;;727    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;728    
;;;729        IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
;;;730        IPH_TOS_SET(iphdr, tos);
;;;731    #if CHECKSUM_GEN_IP_INLINE
;;;732        chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
;;;733    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;734        IPH_LEN_SET(iphdr, htons(p->tot_len));
;;;735    #if CHECKSUM_GEN_IP_INLINE
;;;736        chk_sum += iphdr->_len;
;;;737    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;738        IPH_OFFSET_SET(iphdr, 0);
;;;739        IPH_ID_SET(iphdr, htons(ip_id));
;;;740    #if CHECKSUM_GEN_IP_INLINE
;;;741        chk_sum += iphdr->_id;
;;;742    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;743        ++ip_id;
;;;744    
;;;745        if (ip_addr_isany(src)) {
;;;746          ip_addr_copy(iphdr->src, netif->ip_addr);
;;;747        } else {
;;;748          /* src cannot be NULL here */
;;;749          ip_addr_copy(iphdr->src, *src);
;;;750        }
;;;751    
;;;752    #if CHECKSUM_GEN_IP_INLINE
;;;753        chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
;;;754        chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
;;;755        chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
;;;756        chk_sum = (chk_sum >> 16) + chk_sum;
;;;757        chk_sum = ~chk_sum;
;;;758        iphdr->_chksum = chk_sum; /* network order */
;;;759    #else /* CHECKSUM_GEN_IP_INLINE */
;;;760        IPH_CHKSUM_SET(iphdr, 0);
;;;761    #if CHECKSUM_GEN_IP
;;;762        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
;;;763    #endif
;;;764    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;765      } else {
;;;766        /* IP header already included in p */
;;;767        iphdr = (struct ip_hdr *)p->payload;
;;;768        ip_addr_copy(dest_addr, iphdr->dest);
;;;769        dest = &dest_addr;
;;;770      }
;;;771    
;;;772      IP_STATS_INC(ip.xmit);
;;;773    
;;;774      LWIP_DEBUGF(IP_DEBUG, ("ip_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], netif->num));
;;;775      ip_debug_print(p);
;;;776    
;;;777    #if ENABLE_LOOPBACK
;;;778      if (ip_addr_cmp(dest, &netif->ip_addr)) {
;;;779        /* Packet to self, enqueue it for loopback */
;;;780        LWIP_DEBUGF(IP_DEBUG, ("netif_loop_output()"));
;;;781        return netif_loop_output(netif, p, dest);
;;;782      }
;;;783    #if LWIP_IGMP
;;;784      if ((p->flags & PBUF_FLAG_MCASTLOOP) != 0) {
;;;785        netif_loop_output(netif, p, dest);
;;;786      }
;;;787    #endif /* LWIP_IGMP */
;;;788    #endif /* ENABLE_LOOPBACK */
;;;789    #if IP_FRAG
;;;790      /* don't fragment if interface has mtu set to 0 [loopif] */
;;;791      if (netif->mtu && (p->tot_len > netif->mtu)) {
;;;792        return ip_frag(p, netif, dest);
;;;793      }
;;;794    #endif /* IP_FRAG */
;;;795    
;;;796      LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
;;;797      return netif->output(netif, p, dest);
;;;798    }
000050  e8bd8ff8          POP      {r3-r11,pc}
                  |L3.84|
000054  6874              LDR      r4,[r6,#4]            ;712
000056  bf00              NOP                            ;713
000058  8970              LDRH     r0,[r6,#0xa]          ;713
00005a  2814              CMP      r0,#0x14              ;713
00005c  d204              BCS      |L3.104|
00005e  a046              ADR      r0,|L3.376|
000060  f7fffffe          BL       __2printf
000064  bf00              NOP                            ;713
                  |L3.102|
000066  e7fe              B        |L3.102|
                  |L3.104|
000068  bf00              NOP                            ;713
00006a  f884a008          STRB     r10,[r4,#8]           ;716
00006e  980b              LDR      r0,[sp,#0x2c]         ;717
000070  7260              STRB     r0,[r4,#9]            ;717
000072  980b              LDR      r0,[sp,#0x2c]         ;719
000074  ea4a2000          ORR      r0,r10,r0,LSL #8      ;719
000078  4405              ADD      r5,r5,r0              ;719
00007a  f8d90000          LDR      r0,[r9,#0]            ;723
00007e  6120              STR      r0,[r4,#0x10]         ;723
000080  8a20              LDRH     r0,[r4,#0x10]         ;725
000082  b280              UXTH     r0,r0                 ;725
000084  4405              ADD      r5,r5,r0              ;725
000086  6920              LDR      r0,[r4,#0x10]         ;726
000088  eb054510          ADD      r5,r5,r0,LSR #16      ;726
00008c  4658              MOV      r0,r11                ;729
00008e  ea4f71eb          ASR      r1,r11,#31            ;729
000092  eb0b7191          ADD      r1,r11,r1,LSR #30     ;729
000096  f3c10187          UBFX     r1,r1,#2,#8           ;729
00009a  f0410140          ORR      r1,r1,#0x40           ;729
00009e  7021              STRB     r1,[r4,#0]            ;729
0000a0  980a              LDR      r0,[sp,#0x28]         ;730
0000a2  7060              STRB     r0,[r4,#1]            ;730
0000a4  7821              LDRB     r1,[r4,#0]            ;732
0000a6  980a              LDR      r0,[sp,#0x28]         ;732
0000a8  ea412000          ORR      r0,r1,r0,LSL #8       ;732
0000ac  4405              ADD      r5,r5,r0              ;732
0000ae  8930              LDRH     r0,[r6,#8]            ;734
0000b0  f7fffffe          BL       lwip_htons
0000b4  8060              STRH     r0,[r4,#2]            ;734
0000b6  8860              LDRH     r0,[r4,#2]            ;736
0000b8  4405              ADD      r5,r5,r0              ;736
0000ba  2000              MOVS     r0,#0                 ;738
0000bc  80e0              STRH     r0,[r4,#6]            ;738
0000be  483a              LDR      r0,|L3.424|
0000c0  8800              LDRH     r0,[r0,#0]            ;739  ; ip_id
0000c2  f7fffffe          BL       lwip_htons
0000c6  80a0              STRH     r0,[r4,#4]            ;739
0000c8  88a0              LDRH     r0,[r4,#4]            ;741
0000ca  4405              ADD      r5,r5,r0              ;741
0000cc  4836              LDR      r0,|L3.424|
0000ce  8800              LDRH     r0,[r0,#0]            ;743  ; ip_id
0000d0  1c40              ADDS     r0,r0,#1              ;743
0000d2  4935              LDR      r1,|L3.424|
0000d4  8008              STRH     r0,[r1,#0]            ;743
0000d6  f1b80f00          CMP      r8,#0                 ;745
0000da  d002              BEQ      |L3.226|
0000dc  f8d80000          LDR      r0,[r8,#0]            ;745
0000e0  b910              CBNZ     r0,|L3.232|
                  |L3.226|
0000e2  6878              LDR      r0,[r7,#4]            ;746
0000e4  60e0              STR      r0,[r4,#0xc]          ;746
0000e6  e002              B        |L3.238|
                  |L3.232|
0000e8  f8d80000          LDR      r0,[r8,#0]            ;749
0000ec  60e0              STR      r0,[r4,#0xc]          ;749
                  |L3.238|
0000ee  89a0              LDRH     r0,[r4,#0xc]          ;753
0000f0  b280              UXTH     r0,r0                 ;753
0000f2  4405              ADD      r5,r5,r0              ;753
0000f4  68e0              LDR      r0,[r4,#0xc]          ;754
0000f6  eb054510          ADD      r5,r5,r0,LSR #16      ;754
0000fa  b2a8              UXTH     r0,r5                 ;755
0000fc  eb004515          ADD      r5,r0,r5,LSR #16      ;755
000100  eb054515          ADD      r5,r5,r5,LSR #16      ;756
000104  43ed              MVNS     r5,r5                 ;757
000106  8165              STRH     r5,[r4,#0xa]          ;758
000108  e004              B        |L3.276|
00010a  e7ff              B        |L3.268|
                  |L3.268|
00010c  6874              LDR      r4,[r6,#4]            ;767
00010e  6920              LDR      r0,[r4,#0x10]         ;768
000110  9000              STR      r0,[sp,#0]            ;768
000112  46e9              MOV      r9,sp                 ;769
                  |L3.276|
000114  4817              LDR      r0,|L3.372|
000116  f8b00048          LDRH     r0,[r0,#0x48]         ;772  ; lwip_stats
00011a  1c40              ADDS     r0,r0,#1              ;772
00011c  4915              LDR      r1,|L3.372|
00011e  f8a10048          STRH     r0,[r1,#0x48]         ;772
000122  bf00              NOP                            ;774
000124  bf00              NOP                            ;774
000126  f8d90000          LDR      r0,[r9,#0]            ;778
00012a  6879              LDR      r1,[r7,#4]            ;778
00012c  4288              CMP      r0,r1                 ;778
00012e  d107              BNE      |L3.320|
000130  bf00              NOP                            ;780
000132  bf00              NOP                            ;780
000134  464a              MOV      r2,r9                 ;781
000136  4631              MOV      r1,r6                 ;781
000138  4638              MOV      r0,r7                 ;781
00013a  f7fffffe          BL       netif_loop_output
00013e  e787              B        |L3.80|
                  |L3.320|
000140  8c38              LDRH     r0,[r7,#0x20]         ;791
000142  b148              CBZ      r0,|L3.344|
000144  8930              LDRH     r0,[r6,#8]            ;791
000146  8c39              LDRH     r1,[r7,#0x20]         ;791
000148  4288              CMP      r0,r1                 ;791
00014a  dd05              BLE      |L3.344|
00014c  464a              MOV      r2,r9                 ;792
00014e  4639              MOV      r1,r7                 ;792
000150  4630              MOV      r0,r6                 ;792
000152  f7fffffe          BL       ip_frag
000156  e77b              B        |L3.80|
                  |L3.344|
000158  bf00              NOP                            ;796
00015a  bf00              NOP                            ;796
00015c  464a              MOV      r2,r9                 ;797
00015e  4631              MOV      r1,r6                 ;797
000160  4638              MOV      r0,r7                 ;797
000162  697b              LDR      r3,[r7,#0x14]         ;797
000164  4798              BLX      r3                    ;797
000166  e773              B        |L3.80|
;;;799    
                          ENDP

                  |L3.360|
000168  702d3e72          DCB      "p->ref == 1",0
00016c  6566203d
000170  3d203100
                  |L3.372|
                          DCD      lwip_stats
                  |L3.376|
000178  63686563          DCB      "check that first pbuf can hold struct ip_hdr",0
00017c  6b207468
000180  61742066
000184  69727374
000188  20706275
00018c  66206361
000190  6e20686f
000194  6c642073
000198  74727563
00019c  74206970
0001a0  5f686472
0001a4  00      
0001a5  00                DCB      0
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L3.424|
                          DCD      ip_id

                          AREA ||i.ip_route||, CODE, READONLY, ALIGN=2

                  ip_route PROC
;;;123    struct netif *
;;;124    ip_route(ip_addr_t *dest)
000000  b510              PUSH     {r4,lr}
;;;125    {
000002  4602              MOV      r2,r0
;;;126      struct netif *netif;
;;;127    
;;;128    #ifdef LWIP_HOOK_IP4_ROUTE
;;;129      netif = LWIP_HOOK_IP4_ROUTE(dest);
;;;130      if (netif != NULL) {
;;;131        return netif;
;;;132      }
;;;133    #endif
;;;134    
;;;135      /* iterate through netifs */
;;;136      for (netif = netif_list; netif != NULL; netif = netif->next) {
000004  4816              LDR      r0,|L4.96|
000006  6801              LDR      r1,[r0,#0]  ; netif_list
000008  e00f              B        |L4.42|
                  |L4.10|
;;;137        /* network mask matches? */
;;;138        if (netif_is_up(netif)) {
00000a  f8910029          LDRB     r0,[r1,#0x29]
00000e  f0000001          AND      r0,r0,#1
000012  b148              CBZ      r0,|L4.40|
;;;139          if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
000014  6810              LDR      r0,[r2,#0]
000016  688b              LDR      r3,[r1,#8]
000018  4018              ANDS     r0,r0,r3
00001a  e9d13401          LDRD     r3,r4,[r1,#4]
00001e  4023              ANDS     r3,r3,r4
000020  4298              CMP      r0,r3
000022  d101              BNE      |L4.40|
;;;140            /* return netif on which to forward IP packet */
;;;141            return netif;
000024  4608              MOV      r0,r1
                  |L4.38|
;;;142          }
;;;143        }
;;;144      }
;;;145      if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
;;;146        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;147          ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
;;;148        IP_STATS_INC(ip.rterr);
;;;149        snmp_inc_ipoutnoroutes();
;;;150        return NULL;
;;;151      }
;;;152      /* no matching netif found, use default netif */
;;;153      return netif_default;
;;;154    }
000026  bd10              POP      {r4,pc}
                  |L4.40|
000028  6809              LDR      r1,[r1,#0]            ;136
                  |L4.42|
00002a  2900              CMP      r1,#0                 ;136
00002c  d1ed              BNE      |L4.10|
00002e  480d              LDR      r0,|L4.100|
000030  6800              LDR      r0,[r0,#0]            ;145  ; netif_default
000032  b130              CBZ      r0,|L4.66|
000034  480b              LDR      r0,|L4.100|
000036  6800              LDR      r0,[r0,#0]            ;145  ; netif_default
000038  f8900029          LDRB     r0,[r0,#0x29]         ;145
00003c  f0000001          AND      r0,r0,#1              ;145
000040  b958              CBNZ     r0,|L4.90|
                  |L4.66|
000042  bf00              NOP                            ;146
000044  bf00              NOP                            ;146
000046  4808              LDR      r0,|L4.104|
000048  f8b00056          LDRH     r0,[r0,#0x56]         ;148
00004c  1c40              ADDS     r0,r0,#1              ;148
00004e  b283              UXTH     r3,r0                 ;148
000050  4805              LDR      r0,|L4.104|
000052  f8a03056          STRH     r3,[r0,#0x56]         ;148
000056  2000              MOVS     r0,#0                 ;150
000058  e7e5              B        |L4.38|
                  |L4.90|
00005a  4802              LDR      r0,|L4.100|
00005c  6800              LDR      r0,[r0,#0]            ;153  ; netif_default
00005e  e7e2              B        |L4.38|
;;;155    
                          ENDP

                  |L4.96|
                          DCD      netif_list
                  |L4.100|
                          DCD      netif_default
                  |L4.104|
                          DCD      lwip_stats

                          AREA ||.data||, DATA, ALIGN=2

                  current_netif
                          DCD      0x00000000
                  current_header
                          DCD      0x00000000
                  current_iphdr_src
                          DCD      0x00000000
                  current_iphdr_dest
                          DCD      0x00000000
                  ip_id
000010  0000              DCB      0x00,0x00
