; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\etharp.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\etharp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IC:\Users\Administrator\Desktop\lwip.practise\example6-1\Project\RVMDK\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\etharp.crf ..\..\lwip\src\netif\etharp.c]
                          THUMB

                          AREA ||i.etharp_arp_input||, CODE, READONLY, ALIGN=2

                  etharp_arp_input PROC
;;;687    static void
;;;688    etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;689    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;690      struct etharp_hdr *hdr;
;;;691      struct eth_hdr *ethhdr;
;;;692      /* these are aligned properly, whereas the ARP header fields might not be */
;;;693      ip_addr_t sipaddr, dipaddr;
;;;694      u8_t for_us;
;;;695    #if LWIP_AUTOIP
;;;696      const u8_t * ethdst_hwaddr;
;;;697    #endif /* LWIP_AUTOIP */
;;;698    
;;;699      LWIP_ERROR("netif != NULL", (netif != NULL), return;);
00000a  bf00              NOP      
00000c  b925              CBNZ     r5,|L1.24|
00000e  a05e              ADR      r0,|L1.392|
000010  f7fffffe          BL       __2printf
                  |L1.20|
;;;700    
;;;701      /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
;;;702         since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
;;;703      if (p->len < SIZEOF_ETHARP_PACKET) {
;;;704        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;705          ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
;;;706          (s16_t)SIZEOF_ETHARP_PACKET));
;;;707        ETHARP_STATS_INC(etharp.lenerr);
;;;708        ETHARP_STATS_INC(etharp.drop);
;;;709        pbuf_free(p);
;;;710        return;
;;;711      }
;;;712    
;;;713      ethhdr = (struct eth_hdr *)p->payload;
;;;714      hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
;;;715    #if ETHARP_SUPPORT_VLAN
;;;716      if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
;;;717        hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
;;;718      }
;;;719    #endif /* ETHARP_SUPPORT_VLAN */
;;;720    
;;;721      /* RFC 826 "Packet Reception": */
;;;722      if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
;;;723          (hdr->hwlen != ETHARP_HWADDR_LEN) ||
;;;724          (hdr->protolen != sizeof(ip_addr_t)) ||
;;;725          (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
;;;726        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;727          ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
;;;728          hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
;;;729        ETHARP_STATS_INC(etharp.proterr);
;;;730        ETHARP_STATS_INC(etharp.drop);
;;;731        pbuf_free(p);
;;;732        return;
;;;733      }
;;;734      ETHARP_STATS_INC(etharp.recv);
;;;735    
;;;736    #if LWIP_AUTOIP
;;;737      /* We have to check if a host already has configured our random
;;;738       * created link local address and continously check if there is
;;;739       * a host with this IP-address so we can detect collisions */
;;;740      autoip_arp_reply(netif, hdr);
;;;741    #endif /* LWIP_AUTOIP */
;;;742    
;;;743      /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;744       * structure packing (not using structure copy which breaks strict-aliasing rules). */
;;;745      IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
;;;746      IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
;;;747    
;;;748      /* this interface is not configured? */
;;;749      if (ip_addr_isany(&netif->ip_addr)) {
;;;750        for_us = 0;
;;;751      } else {
;;;752        /* ARP packet directed to us? */
;;;753        for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
;;;754      }
;;;755    
;;;756      /* ARP message directed to us?
;;;757          -> add IP address in ARP cache; assume requester wants to talk to us,
;;;758             can result in directly sending the queued packets for this host.
;;;759         ARP message not directed to us?
;;;760          ->  update the source IP address in the cache, if present */
;;;761      etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
;;;762                       for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
;;;763    
;;;764      /* now act on the message itself */
;;;765      switch (hdr->opcode) {
;;;766      /* ARP request? */
;;;767      case PP_HTONS(ARP_REQUEST):
;;;768        /* ARP request. If it asked for our address, we send out a
;;;769         * reply. In any case, we time-stamp any existing ARP entry,
;;;770         * and possiby send out an IP packet that was queued on it. */
;;;771    
;;;772        LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
;;;773        /* ARP request for our address? */
;;;774        if (for_us) {
;;;775    
;;;776          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
;;;777          /* Re-use pbuf to send ARP reply.
;;;778             Since we are re-using an existing pbuf, we can't call etharp_raw since
;;;779             that would allocate a new pbuf. */
;;;780          hdr->opcode = htons(ARP_REPLY);
;;;781    
;;;782          IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
;;;783          IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
;;;784    
;;;785          LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;786                      (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;787    #if LWIP_AUTOIP
;;;788          /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;789           * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;790           * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;791          ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
;;;792    #endif /* LWIP_AUTOIP */
;;;793    
;;;794          ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
;;;795    #if LWIP_AUTOIP
;;;796          ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;797    #else  /* LWIP_AUTOIP */
;;;798          ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
;;;799    #endif /* LWIP_AUTOIP */
;;;800          ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
;;;801          ETHADDR16_COPY(&ethhdr->src, ethaddr);
;;;802    
;;;803          /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
;;;804             are already correct, we tested that before */
;;;805    
;;;806          /* return ARP reply */
;;;807          netif->linkoutput(netif, p);
;;;808        /* we are not configured? */
;;;809        } else if (ip_addr_isany(&netif->ip_addr)) {
;;;810          /* { for_us == 0 and netif->ip_addr.addr == 0 } */
;;;811          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: we are unconfigured, ARP request ignored.\n"));
;;;812        /* request was not directed to us */
;;;813        } else {
;;;814          /* { for_us == 0 and netif->ip_addr.addr != 0 } */
;;;815          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
;;;816        }
;;;817        break;
;;;818      case PP_HTONS(ARP_REPLY):
;;;819        /* ARP reply. We already updated the ARP cache earlier. */
;;;820        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP reply\n"));
;;;821    #if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
;;;822        /* DHCP wants to know about ARP replies from any host with an
;;;823         * IP address also offered to us by the DHCP server. We do not
;;;824         * want to take a duplicate IP address on a single network.
;;;825         * @todo How should we handle redundant (fail-over) interfaces? */
;;;826        dhcp_arp_reply(netif, &sipaddr);
;;;827    #endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
;;;828        break;
;;;829      default:
;;;830        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
;;;831        ETHARP_STATS_INC(etharp.err);
;;;832        break;
;;;833      }
;;;834      /* free ARP packet */
;;;835      pbuf_free(p);
;;;836    }
000014  e8bd87fc          POP      {r2-r10,pc}
                  |L1.24|
000018  bf00              NOP                            ;699
00001a  8970              LDRH     r0,[r6,#0xa]          ;703
00001c  282a              CMP      r0,#0x2a              ;703
00001e  da10              BGE      |L1.66|
000020  bf00              NOP                            ;704
000022  bf00              NOP                            ;704
000024  485c              LDR      r0,|L1.408|
000026  8c40              LDRH     r0,[r0,#0x22]         ;707
000028  1c40              ADDS     r0,r0,#1              ;707
00002a  b281              UXTH     r1,r0                 ;707
00002c  485a              LDR      r0,|L1.408|
00002e  8441              STRH     r1,[r0,#0x22]         ;707
000030  8bc0              LDRH     r0,[r0,#0x1e]         ;708
000032  1c40              ADDS     r0,r0,#1              ;708
000034  b281              UXTH     r1,r0                 ;708
000036  4858              LDR      r0,|L1.408|
000038  83c1              STRH     r1,[r0,#0x1e]         ;708
00003a  4630              MOV      r0,r6                 ;709
00003c  f7fffffe          BL       pbuf_free
000040  e7e8              B        |L1.20|
                  |L1.66|
000042  6877              LDR      r7,[r6,#4]            ;713
000044  f107040e          ADD      r4,r7,#0xe            ;714
000048  8820              LDRH     r0,[r4,#0]            ;722
00004a  f5b07f80          CMP      r0,#0x100             ;722
00004e  d108              BNE      |L1.98|
000050  7920              LDRB     r0,[r4,#4]            ;723
000052  2806              CMP      r0,#6                 ;723
000054  d105              BNE      |L1.98|
000056  7960              LDRB     r0,[r4,#5]            ;724
000058  2804              CMP      r0,#4                 ;724
00005a  d102              BNE      |L1.98|
00005c  8860              LDRH     r0,[r4,#2]            ;725
00005e  2808              CMP      r0,#8                 ;725
000060  d010              BEQ      |L1.132|
                  |L1.98|
000062  bf00              NOP                            ;726
000064  bf00              NOP                            ;726
000066  484c              LDR      r0,|L1.408|
000068  8d00              LDRH     r0,[r0,#0x28]         ;729
00006a  1c40              ADDS     r0,r0,#1              ;729
00006c  b281              UXTH     r1,r0                 ;729
00006e  484a              LDR      r0,|L1.408|
000070  8501              STRH     r1,[r0,#0x28]         ;729
000072  8bc0              LDRH     r0,[r0,#0x1e]         ;730
000074  1c40              ADDS     r0,r0,#1              ;730
000076  b281              UXTH     r1,r0                 ;730
000078  4847              LDR      r0,|L1.408|
00007a  83c1              STRH     r1,[r0,#0x1e]         ;730
00007c  4630              MOV      r0,r6                 ;731
00007e  f7fffffe          BL       pbuf_free
000082  e7c7              B        |L1.20|
                  |L1.132|
000084  4844              LDR      r0,|L1.408|
000086  8b40              LDRH     r0,[r0,#0x1a]         ;734
000088  1c40              ADDS     r0,r0,#1              ;734
00008a  b281              UXTH     r1,r0                 ;734
00008c  4842              LDR      r0,|L1.408|
00008e  8341              STRH     r1,[r0,#0x1a]         ;734
000090  f8d4000e          LDR      r0,[r4,#0xe]          ;745
000094  9001              STR      r0,[sp,#4]            ;745
000096  69a0              LDR      r0,[r4,#0x18]         ;746
000098  9000              STR      r0,[sp,#0]            ;746
00009a  1d28              ADDS     r0,r5,#4              ;749
00009c  b108              CBZ      r0,|L1.162|
00009e  6868              LDR      r0,[r5,#4]            ;749
0000a0  b910              CBNZ     r0,|L1.168|
                  |L1.162|
0000a2  f04f0900          MOV      r9,#0                 ;750
0000a6  e007              B        |L1.184|
                  |L1.168|
0000a8  9800              LDR      r0,[sp,#0]            ;753
0000aa  6869              LDR      r1,[r5,#4]            ;753
0000ac  4288              CMP      r0,r1                 ;753
0000ae  d101              BNE      |L1.180|
0000b0  2001              MOVS     r0,#1                 ;753
0000b2  e000              B        |L1.182|
                  |L1.180|
0000b4  2000              MOVS     r0,#0                 ;753
                  |L1.182|
0000b6  4681              MOV      r9,r0                 ;753
                  |L1.184|
0000b8  f1b90f00          CMP      r9,#0                 ;761
0000bc  d001              BEQ      |L1.194|
0000be  2001              MOVS     r0,#1                 ;762
0000c0  e000              B        |L1.196|
                  |L1.194|
0000c2  2002              MOVS     r0,#2                 ;762
                  |L1.196|
0000c4  4603              MOV      r3,r0                 ;762
0000c6  f1040208          ADD      r2,r4,#8              ;762
0000ca  a901              ADD      r1,sp,#4              ;762
0000cc  4628              MOV      r0,r5                 ;762
0000ce  f7fffffe          BL       etharp_update_arp_entry
0000d2  88e0              LDRH     r0,[r4,#6]            ;765
0000d4  f5b07f80          CMP      r0,#0x100             ;765
0000d8  d003              BEQ      |L1.226|
0000da  f5b07f00          CMP      r0,#0x200             ;765
0000de  d143              BNE      |L1.360|
0000e0  e03f              B        |L1.354|
                  |L1.226|
0000e2  bf00              NOP                            ;772
0000e4  bf00              NOP                            ;772
0000e6  f1b90f00          CMP      r9,#0                 ;774
0000ea  d031              BEQ      |L1.336|
0000ec  bf00              NOP                            ;776
0000ee  bf00              NOP                            ;776
0000f0  2002              MOVS     r0,#2                 ;780
0000f2  f7fffffe          BL       lwip_htons
0000f6  80e0              STRH     r0,[r4,#6]            ;780
0000f8  f8d4000e          LDR      r0,[r4,#0xe]          ;782
0000fc  61a0              STR      r0,[r4,#0x18]         ;782
0000fe  6868              LDR      r0,[r5,#4]            ;783
000100  f8c4000e          STR      r0,[r4,#0xe]          ;783
000104  bf00              NOP                            ;785
000106  f8950022          LDRB     r0,[r5,#0x22]         ;785
00010a  2806              CMP      r0,#6                 ;785
00010c  d004              BEQ      |L1.280|
00010e  4823              LDR      r0,|L1.412|
000110  f7fffffe          BL       __2printf
000114  bf00              NOP                            ;785
                  |L1.278|
000116  e7fe              B        |L1.278|
                  |L1.280|
000118  bf00              NOP                            ;785
00011a  68a0              LDR      r0,[r4,#8]            ;794
00011c  f8c40012          STR      r0,[r4,#0x12]         ;794
000120  89a0              LDRH     r0,[r4,#0xc]          ;794
000122  82e0              STRH     r0,[r4,#0x16]         ;794
000124  68a0              LDR      r0,[r4,#8]            ;798
000126  6038              STR      r0,[r7,#0]            ;798
000128  89a0              LDRH     r0,[r4,#0xc]          ;798
00012a  80b8              STRH     r0,[r7,#4]            ;798
00012c  f8d80000          LDR      r0,[r8,#0]            ;800
000130  60a0              STR      r0,[r4,#8]            ;800
000132  f8b80004          LDRH     r0,[r8,#4]            ;800
000136  81a0              STRH     r0,[r4,#0xc]          ;800
000138  f8d80000          LDR      r0,[r8,#0]            ;801
00013c  f8c70006          STR      r0,[r7,#6]            ;801
000140  f8b80004          LDRH     r0,[r8,#4]            ;801
000144  8178              STRH     r0,[r7,#0xa]          ;801
000146  4631              MOV      r1,r6                 ;807
000148  4628              MOV      r0,r5                 ;807
00014a  69aa              LDR      r2,[r5,#0x18]         ;807
00014c  4790              BLX      r2                    ;807
00014e  e007              B        |L1.352|
                  |L1.336|
000150  1d28              ADDS     r0,r5,#4              ;809
000152  b108              CBZ      r0,|L1.344|
000154  6868              LDR      r0,[r5,#4]            ;809
000156  b908              CBNZ     r0,|L1.348|
                  |L1.344|
000158  bf00              NOP                            ;811
00015a  e001              B        |L1.352|
                  |L1.348|
00015c  bf00              NOP                            ;815
00015e  bf00              NOP                            ;815
                  |L1.352|
000160  e00b              B        |L1.378|
                  |L1.354|
000162  bf00              NOP                            ;820
000164  bf00              NOP                            ;820
000166  e008              B        |L1.378|
                  |L1.360|
000168  bf00              NOP                            ;830
00016a  bf00              NOP                            ;830
00016c  480a              LDR      r0,|L1.408|
00016e  8d80              LDRH     r0,[r0,#0x2c]         ;831
000170  1c40              ADDS     r0,r0,#1              ;831
000172  b281              UXTH     r1,r0                 ;831
000174  4808              LDR      r0,|L1.408|
000176  8581              STRH     r1,[r0,#0x2c]         ;831
000178  bf00              NOP                            ;832
                  |L1.378|
00017a  bf00              NOP                            ;817
00017c  4630              MOV      r0,r6                 ;835
00017e  f7fffffe          BL       pbuf_free
000182  bf00              NOP      
000184  e746              B        |L1.20|
;;;837    
                          ENDP

000186  0000              DCW      0x0000
                  |L1.392|
000188  6e657469          DCB      "netif != NULL",0
00018c  6620213d
000190  204e554c
000194  4c00    
000196  00                DCB      0
000197  00                DCB      0
                  |L1.408|
                          DCD      lwip_stats
                  |L1.412|
                          DCD      ||.conststring||

                          AREA ||i.etharp_cleanup_netif||, CODE, READONLY, ALIGN=2

                  etharp_cleanup_netif PROC
;;;578     */
;;;579    void etharp_cleanup_netif(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;580    {
000002  4605              MOV      r5,r0
;;;581      u8_t i;
;;;582    
;;;583      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
000004  2400              MOVS     r4,#0
000006  e012              B        |L2.46|
                  |L2.8|
;;;584        u8_t state = arp_table[i].state;
000008  eb040084          ADD      r0,r4,r4,LSL #2
00000c  4909              LDR      r1,|L2.52|
00000e  eb010080          ADD      r0,r1,r0,LSL #2
000012  7c86              LDRB     r6,[r0,#0x12]
;;;585        if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
000014  b14e              CBZ      r6,|L2.42|
000016  eb040084          ADD      r0,r4,r4,LSL #2
00001a  eb010080          ADD      r0,r1,r0,LSL #2
00001e  6880              LDR      r0,[r0,#8]
000020  42a8              CMP      r0,r5
000022  d102              BNE      |L2.42|
;;;586          etharp_free_entry(i);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       etharp_free_entry
                  |L2.42|
00002a  1c60              ADDS     r0,r4,#1              ;583
00002c  b2c4              UXTB     r4,r0                 ;583
                  |L2.46|
00002e  2c0a              CMP      r4,#0xa               ;583
000030  dbea              BLT      |L2.8|
;;;587        }
;;;588      }
;;;589    }
000032  bd70              POP      {r4-r6,pc}
;;;590    
                          ENDP

                  |L2.52|
                          DCD      arp_table

                          AREA ||i.etharp_find_addr||, CODE, READONLY, ALIGN=2

                  etharp_find_addr PROC
;;;602    s8_t
;;;603    etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;604             struct eth_addr **eth_ret, ip_addr_t **ip_ret)
;;;605    {
000004  4680              MOV      r8,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;606      s8_t i;
;;;607    
;;;608      LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
00000c  bf00              NOP      
00000e  b105              CBZ      r5,|L3.18|
000010  b926              CBNZ     r6,|L3.28|
                  |L3.18|
000012  a013              ADR      r0,|L3.96|
000014  f7fffffe          BL       __2printf
000018  bf00              NOP      
                  |L3.26|
00001a  e7fe              B        |L3.26|
                  |L3.28|
00001c  bf00              NOP      
;;;609        eth_ret != NULL && ip_ret != NULL);
;;;610    
;;;611      LWIP_UNUSED_ARG(netif);
;;;612    
;;;613      i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
00001e  2102              MOVS     r1,#2
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       etharp_find_entry
000026  4604              MOV      r4,r0
;;;614      if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
000028  2c00              CMP      r4,#0
00002a  db16              BLT      |L3.90|
00002c  eb040084          ADD      r0,r4,r4,LSL #2
000030  4914              LDR      r1,|L3.132|
000032  eb010080          ADD      r0,r1,r0,LSL #2
000036  7c80              LDRB     r0,[r0,#0x12]
000038  2802              CMP      r0,#2
00003a  db0e              BLT      |L3.90|
;;;615          *eth_ret = &arp_table[i].ethaddr;
00003c  eb040084          ADD      r0,r4,r4,LSL #2
000040  eb010080          ADD      r0,r1,r0,LSL #2
000044  300c              ADDS     r0,r0,#0xc
000046  6028              STR      r0,[r5,#0]
;;;616          *ip_ret = &arp_table[i].ipaddr;
000048  eb040084          ADD      r0,r4,r4,LSL #2
00004c  eb010080          ADD      r0,r1,r0,LSL #2
000050  1d00              ADDS     r0,r0,#4
000052  6030              STR      r0,[r6,#0]
;;;617          return i;
000054  4620              MOV      r0,r4
                  |L3.86|
;;;618      }
;;;619      return -1;
;;;620    }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L3.90|
00005a  f04f30ff          MOV      r0,#0xffffffff        ;619
00005e  e7fa              B        |L3.86|
;;;621    
                          ENDP

                  |L3.96|
000060  6574685f          DCB      "eth_ret != NULL && ip_ret != NULL",0
000064  72657420
000068  213d204e
00006c  554c4c20
000070  26262069
000074  705f7265
000078  7420213d
00007c  204e554c
000080  4c00    
000082  00                DCB      0
000083  00                DCB      0
                  |L3.132|
                          DCD      arp_table

                          AREA ||i.etharp_find_entry||, CODE, READONLY, ALIGN=2

                  etharp_find_entry PROC
;;;265    static s8_t
;;;266    etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;267    {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;268      s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
000008  f04f090a          MOV      r9,#0xa
00000c  46ca              MOV      r10,r9
;;;269      s8_t empty = ARP_TABLE_SIZE;
00000e  270a              MOVS     r7,#0xa
;;;270      u8_t i = 0, age_pending = 0, age_stable = 0;
000010  2400              MOVS     r4,#0
000012  2000              MOVS     r0,#0
000014  9002              STR      r0,[sp,#8]
000016  9001              STR      r0,[sp,#4]
;;;271      /* oldest entry with packets on queue */
;;;272      s8_t old_queue = ARP_TABLE_SIZE;
000018  46bb              MOV      r11,r7
;;;273      /* its age */
;;;274      u8_t age_queue = 0;
00001a  9000              STR      r0,[sp,#0]
;;;275    
;;;276      /**
;;;277       * a) do a search through the cache, remember candidates
;;;278       * b) select candidate entry
;;;279       * c) create new entry
;;;280       */
;;;281    
;;;282      /* a) in a single search sweep, do all of this
;;;283       * 1) remember the first empty entry (if any)
;;;284       * 2) remember the oldest stable entry (if any)
;;;285       * 3) remember the oldest pending entry without queued packets (if any)
;;;286       * 4) remember the oldest pending entry with queued packets (if any)
;;;287       * 5) search for a matching IP entry, either pending or stable
;;;288       *    until 5 matches, or all entries are searched for.
;;;289       */
;;;290    
;;;291      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
00001c  bf00              NOP      
00001e  e06b              B        |L4.248|
                  |L4.32|
;;;292        u8_t state = arp_table[i].state;
000020  eb040084          ADD      r0,r4,r4,LSL #2
000024  496c              LDR      r1,|L4.472|
000026  eb010080          ADD      r0,r1,r0,LSL #2
00002a  7c85              LDRB     r5,[r0,#0x12]
;;;293        /* no empty entry found yet and now we do find one? */
;;;294        if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
00002c  2f0a              CMP      r7,#0xa
00002e  d104              BNE      |L4.58|
000030  b91d              CBNZ     r5,|L4.58|
;;;295          LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
000032  bf00              NOP      
000034  bf00              NOP      
;;;296          /* remember first empty entry */
;;;297          empty = i;
000036  b267              SXTB     r7,r4
000038  e05c              B        |L4.244|
                  |L4.58|
;;;298        } else if (state != ETHARP_STATE_EMPTY) {
00003a  2d00              CMP      r5,#0
00003c  d05a              BEQ      |L4.244|
;;;299          LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
00003e  bf00              NOP      
000040  2d01              CMP      r5,#1
000042  d006              BEQ      |L4.82|
000044  2d02              CMP      r5,#2
000046  da04              BGE      |L4.82|
000048  a064              ADR      r0,|L4.476|
00004a  f7fffffe          BL       __2printf
00004e  bf00              NOP      
                  |L4.80|
000050  e7fe              B        |L4.80|
                  |L4.82|
000052  bf00              NOP      
;;;300            state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
;;;301          /* if given, does IP address match IP address in ARP entry? */
;;;302          if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
000054  b16e              CBZ      r6,|L4.114|
000056  eb040184          ADD      r1,r4,r4,LSL #2
00005a  4a5f              LDR      r2,|L4.472|
00005c  eb020181          ADD      r1,r2,r1,LSL #2
000060  6830              LDR      r0,[r6,#0]
000062  6849              LDR      r1,[r1,#4]
000064  4288              CMP      r0,r1
000066  d104              BNE      |L4.114|
;;;303            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
000068  bf00              NOP      
00006a  bf00              NOP      
;;;304            /* found exact IP address match, simply bail out */
;;;305            return i;
00006c  b260              SXTB     r0,r4
                  |L4.110|
;;;306          }
;;;307          /* pending entry? */
;;;308          if (state == ETHARP_STATE_PENDING) {
;;;309            /* pending with queued packets? */
;;;310            if (arp_table[i].q != NULL) {
;;;311              if (arp_table[i].ctime >= age_queue) {
;;;312                old_queue = i;
;;;313                age_queue = arp_table[i].ctime;
;;;314              }
;;;315            } else
;;;316            /* pending without queued packets? */
;;;317            {
;;;318              if (arp_table[i].ctime >= age_pending) {
;;;319                old_pending = i;
;;;320                age_pending = arp_table[i].ctime;
;;;321              }
;;;322            }
;;;323          /* stable entry? */
;;;324          } else if (state >= ETHARP_STATE_STABLE) {
;;;325    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;326            /* don't record old_stable for static entries since they never expire */
;;;327            if (state < ETHARP_STATE_STATIC)
;;;328    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;329            {
;;;330              /* remember entry with oldest stable entry in oldest, its age in maxtime */
;;;331              if (arp_table[i].ctime >= age_stable) {
;;;332                old_stable = i;
;;;333                age_stable = arp_table[i].ctime;
;;;334              }
;;;335            }
;;;336          }
;;;337        }
;;;338      }
;;;339      /* { we have no match } => try to create a new entry */
;;;340       
;;;341      /* don't create new entry, only search? */
;;;342      if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
;;;343          /* or no empty entry found and not allowed to recycle? */
;;;344          ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
;;;345        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
;;;346        return (s8_t)ERR_MEM;
;;;347      }
;;;348      
;;;349      /* b) choose the least destructive entry to recycle:
;;;350       * 1) empty entry
;;;351       * 2) oldest stable entry
;;;352       * 3) oldest pending entry without queued packets
;;;353       * 4) oldest pending entry with queued packets
;;;354       * 
;;;355       * { ETHARP_FLAG_TRY_HARD is set at this point }
;;;356       */ 
;;;357    
;;;358      /* 1) empty entry available? */
;;;359      if (empty < ARP_TABLE_SIZE) {
;;;360        i = empty;
;;;361        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
;;;362      } else {
;;;363        /* 2) found recyclable stable entry? */
;;;364        if (old_stable < ARP_TABLE_SIZE) {
;;;365          /* recycle oldest stable*/
;;;366          i = old_stable;
;;;367          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
;;;368          /* no queued packets should exist on stable entries */
;;;369          LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
;;;370        /* 3) found recyclable pending entry without queued packets? */
;;;371        } else if (old_pending < ARP_TABLE_SIZE) {
;;;372          /* recycle oldest pending */
;;;373          i = old_pending;
;;;374          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
;;;375        /* 4) found recyclable pending entry with queued packets? */
;;;376        } else if (old_queue < ARP_TABLE_SIZE) {
;;;377          /* recycle oldest pending (queued packets are free in etharp_free_entry) */
;;;378          i = old_queue;
;;;379          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
;;;380          /* no empty or recyclable entries found */
;;;381        } else {
;;;382          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
;;;383          return (s8_t)ERR_MEM;
;;;384        }
;;;385    
;;;386        /* { empty or recyclable entry found } */
;;;387        LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;388        etharp_free_entry(i);
;;;389      }
;;;390    
;;;391      LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;392      LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
;;;393        arp_table[i].state == ETHARP_STATE_EMPTY);
;;;394    
;;;395      /* IP address given? */
;;;396      if (ipaddr != NULL) {
;;;397        /* set IP address */
;;;398        ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
;;;399      }
;;;400      arp_table[i].ctime = 0;
;;;401      return (err_t)i;
;;;402    }
00006e  e8bd8ffe          POP      {r1-r11,pc}
                  |L4.114|
000072  2d01              CMP      r5,#1                 ;308
000074  d12a              BNE      |L4.204|
000076  eb040084          ADD      r0,r4,r4,LSL #2       ;310
00007a  4957              LDR      r1,|L4.472|
00007c  f8510020          LDR      r0,[r1,r0,LSL #2]     ;310
000080  b188              CBZ      r0,|L4.166|
000082  eb040084          ADD      r0,r4,r4,LSL #2       ;311
000086  eb010080          ADD      r0,r1,r0,LSL #2       ;311
00008a  7cc1              LDRB     r1,[r0,#0x13]         ;311
00008c  9800              LDR      r0,[sp,#0]            ;311
00008e  4281              CMP      r1,r0                 ;311
000090  db30              BLT      |L4.244|
000092  fa4ffb84          SXTB     r11,r4                ;312
000096  eb040084          ADD      r0,r4,r4,LSL #2       ;313
00009a  494f              LDR      r1,|L4.472|
00009c  eb010080          ADD      r0,r1,r0,LSL #2       ;313
0000a0  7cc0              LDRB     r0,[r0,#0x13]         ;313
0000a2  9000              STR      r0,[sp,#0]            ;313
0000a4  e026              B        |L4.244|
                  |L4.166|
0000a6  eb040084          ADD      r0,r4,r4,LSL #2       ;318
0000aa  494b              LDR      r1,|L4.472|
0000ac  eb010080          ADD      r0,r1,r0,LSL #2       ;318
0000b0  7cc1              LDRB     r1,[r0,#0x13]         ;318
0000b2  9802              LDR      r0,[sp,#8]            ;318
0000b4  4281              CMP      r1,r0                 ;318
0000b6  db1d              BLT      |L4.244|
0000b8  fa4ff984          SXTB     r9,r4                 ;319
0000bc  eb040084          ADD      r0,r4,r4,LSL #2       ;320
0000c0  4945              LDR      r1,|L4.472|
0000c2  eb010080          ADD      r0,r1,r0,LSL #2       ;320
0000c6  7cc0              LDRB     r0,[r0,#0x13]         ;320
0000c8  9002              STR      r0,[sp,#8]            ;320
0000ca  e013              B        |L4.244|
                  |L4.204|
0000cc  2d02              CMP      r5,#2                 ;324
0000ce  db11              BLT      |L4.244|
0000d0  eb040084          ADD      r0,r4,r4,LSL #2       ;331
0000d4  4940              LDR      r1,|L4.472|
0000d6  eb010080          ADD      r0,r1,r0,LSL #2       ;331
0000da  7cc1              LDRB     r1,[r0,#0x13]         ;331
0000dc  9801              LDR      r0,[sp,#4]            ;331
0000de  4281              CMP      r1,r0                 ;331
0000e0  db08              BLT      |L4.244|
0000e2  fa4ffa84          SXTB     r10,r4                ;332
0000e6  eb040084          ADD      r0,r4,r4,LSL #2       ;333
0000ea  493b              LDR      r1,|L4.472|
0000ec  eb010080          ADD      r0,r1,r0,LSL #2       ;333
0000f0  7cc0              LDRB     r0,[r0,#0x13]         ;333
0000f2  9001              STR      r0,[sp,#4]            ;333
                  |L4.244|
0000f4  1c60              ADDS     r0,r4,#1              ;291
0000f6  b2c4              UXTB     r4,r0                 ;291
                  |L4.248|
0000f8  2c0a              CMP      r4,#0xa               ;291
0000fa  db91              BLT      |L4.32|
0000fc  f0080002          AND      r0,r8,#2              ;342
000100  b920              CBNZ     r0,|L4.268|
000102  2f0a              CMP      r7,#0xa               ;344
000104  d107              BNE      |L4.278|
000106  f0080001          AND      r0,r8,#1              ;344
00010a  b920              CBNZ     r0,|L4.278|
                  |L4.268|
00010c  bf00              NOP                            ;345
00010e  bf00              NOP                            ;345
000110  f04f30ff          MOV      r0,#0xffffffff        ;346
000114  e7ab              B        |L4.110|
                  |L4.278|
000116  2f0a              CMP      r7,#0xa               ;359
000118  da02              BGE      |L4.288|
00011a  b2fc              UXTB     r4,r7                 ;360
00011c  bf00              NOP                            ;361
00011e  e032              B        |L4.390|
                  |L4.288|
000120  f1ba0f0a          CMP      r10,#0xa              ;364
000124  da10              BGE      |L4.328|
000126  f00a04ff          AND      r4,r10,#0xff          ;366
00012a  bf00              NOP                            ;367
00012c  bf00              NOP                            ;367
00012e  bf00              NOP                            ;369
000130  eb040084          ADD      r0,r4,r4,LSL #2       ;369
000134  4928              LDR      r1,|L4.472|
000136  f8510020          LDR      r0,[r1,r0,LSL #2]     ;369
00013a  b120              CBZ      r0,|L4.326|
00013c  a037              ADR      r0,|L4.540|
00013e  f7fffffe          BL       __2printf
000142  bf00              NOP                            ;369
                  |L4.324|
000144  e7fe              B        |L4.324|
                  |L4.326|
000146  e012              B        |L4.366|
                  |L4.328|
000148  f1b90f0a          CMP      r9,#0xa               ;371
00014c  da03              BGE      |L4.342|
00014e  f00904ff          AND      r4,r9,#0xff           ;373
000152  bf00              NOP                            ;374
000154  e00b              B        |L4.366|
                  |L4.342|
000156  f1bb0f0a          CMP      r11,#0xa              ;376
00015a  da03              BGE      |L4.356|
00015c  f00b04ff          AND      r4,r11,#0xff          ;378
000160  bf00              NOP                            ;379
000162  e004              B        |L4.366|
                  |L4.356|
000164  bf00              NOP                            ;382
000166  bf00              NOP                            ;382
000168  f04f30ff          MOV      r0,#0xffffffff        ;383
00016c  e77f              B        |L4.110|
                  |L4.366|
00016e  bf00              NOP                            ;387
000170  2c0a              CMP      r4,#0xa               ;387
000172  db04              BLT      |L4.382|
000174  a02f              ADR      r0,|L4.564|
000176  f7fffffe          BL       __2printf
00017a  bf00              NOP                            ;387
                  |L4.380|
00017c  e7fe              B        |L4.380|
                  |L4.382|
00017e  bf00              NOP                            ;387
000180  4620              MOV      r0,r4                 ;388
000182  f7fffffe          BL       etharp_free_entry
                  |L4.390|
000186  bf00              NOP                            ;391
000188  2c0a              CMP      r4,#0xa               ;391
00018a  db04              BLT      |L4.406|
00018c  a029              ADR      r0,|L4.564|
00018e  f7fffffe          BL       __2printf
000192  bf00              NOP                            ;391
                  |L4.404|
000194  e7fe              B        |L4.404|
                  |L4.406|
000196  bf00              NOP                            ;391
000198  bf00              NOP                            ;392
00019a  eb040084          ADD      r0,r4,r4,LSL #2       ;392
00019e  490e              LDR      r1,|L4.472|
0001a0  eb010080          ADD      r0,r1,r0,LSL #2       ;392
0001a4  7c80              LDRB     r0,[r0,#0x12]         ;392
0001a6  b120              CBZ      r0,|L4.434|
0001a8  a027              ADR      r0,|L4.584|
0001aa  f7fffffe          BL       __2printf
0001ae  bf00              NOP                            ;392
                  |L4.432|
0001b0  e7fe              B        |L4.432|
                  |L4.434|
0001b2  bf00              NOP                            ;392
0001b4  b136              CBZ      r6,|L4.452|
0001b6  eb040184          ADD      r1,r4,r4,LSL #2       ;398
0001ba  4a07              LDR      r2,|L4.472|
0001bc  eb020181          ADD      r1,r2,r1,LSL #2       ;398
0001c0  6830              LDR      r0,[r6,#0]            ;398
0001c2  6048              STR      r0,[r1,#4]            ;398
                  |L4.452|
0001c4  2000              MOVS     r0,#0                 ;400
0001c6  eb040184          ADD      r1,r4,r4,LSL #2       ;400
0001ca  4a03              LDR      r2,|L4.472|
0001cc  eb020181          ADD      r1,r2,r1,LSL #2       ;400
0001d0  74c8              STRB     r0,[r1,#0x13]         ;400
0001d2  b260              SXTB     r0,r4                 ;401
0001d4  e74b              B        |L4.110|
;;;403    
                          ENDP

0001d6  0000              DCW      0x0000
                  |L4.472|
                          DCD      arp_table
                  |L4.476|
0001dc  73746174          DCB      "state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_"
0001e0  65203d3d
0001e4  20455448
0001e8  4152505f
0001ec  53544154
0001f0  455f5045
0001f4  4e44494e
0001f8  47207c7c
0001fc  20737461
000200  7465203e
000204  3d204554
000208  48415250
00020c  5f535441
000210  54455f  
000213  53544142          DCB      "STABLE",0
000217  4c4500  
00021a  00                DCB      0
00021b  00                DCB      0
                  |L4.540|
00021c  6172705f          DCB      "arp_table[i].q == NULL",0
000220  7461626c
000224  655b695d
000228  2e71203d
00022c  3d204e55
000230  4c4c00  
000233  00                DCB      0
                  |L4.564|
000234  69203c20          DCB      "i < ARP_TABLE_SIZE",0
000238  4152505f
00023c  5441424c
000240  455f5349
000244  5a4500  
000247  00                DCB      0
                  |L4.584|
000248  6172705f          DCB      "arp_table[i].state == ETHARP_STATE_EMPTY",0
00024c  7461626c
000250  655b695d
000254  2e737461
000258  7465203d
00025c  3d204554
000260  48415250
000264  5f535441
000268  54455f45
00026c  4d505459
000270  00      
000271  00                DCB      0
000272  00                DCB      0
000273  00                DCB      0

                          AREA ||i.etharp_free_entry||, CODE, READONLY, ALIGN=2

                  etharp_free_entry PROC
;;;176    static void
;;;177    etharp_free_entry(int i)
000000  b510              PUSH     {r4,lr}
;;;178    {
000002  4604              MOV      r4,r0
;;;179      /* remove from SNMP ARP index tree */
;;;180      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
;;;181      /* and empty packet queue */
;;;182      if (arp_table[i].q != NULL) {
000004  eb040084          ADD      r0,r4,r4,LSL #2
000008  4919              LDR      r1,|L5.112|
00000a  f8510020          LDR      r0,[r1,r0,LSL #2]
00000e  b170              CBZ      r0,|L5.46|
;;;183        /* remove all queued packets */
;;;184        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
000010  bf00              NOP      
000012  bf00              NOP      
;;;185        free_etharp_q(arp_table[i].q);
000014  eb040184          ADD      r1,r4,r4,LSL #2
000018  4a15              LDR      r2,|L5.112|
00001a  f8520021          LDR      r0,[r2,r1,LSL #2]
00001e  f7fffffe          BL       pbuf_free
;;;186        arp_table[i].q = NULL;
000022  2000              MOVS     r0,#0
000024  eb040184          ADD      r1,r4,r4,LSL #2
000028  4a11              LDR      r2,|L5.112|
00002a  f8420021          STR      r0,[r2,r1,LSL #2]
                  |L5.46|
;;;187      }
;;;188      /* recycle entry for re-use */
;;;189      arp_table[i].state = ETHARP_STATE_EMPTY;
00002e  2000              MOVS     r0,#0
000030  eb040184          ADD      r1,r4,r4,LSL #2
000034  4a0e              LDR      r2,|L5.112|
000036  eb020181          ADD      r1,r2,r1,LSL #2
00003a  7488              STRB     r0,[r1,#0x12]
;;;190    #ifdef LWIP_DEBUG
;;;191      /* for debugging, clean out the complete entry */
;;;192      arp_table[i].ctime = 0;
00003c  eb040184          ADD      r1,r4,r4,LSL #2
000040  eb020181          ADD      r1,r2,r1,LSL #2
000044  74c8              STRB     r0,[r1,#0x13]
;;;193      arp_table[i].netif = NULL;
000046  eb040184          ADD      r1,r4,r4,LSL #2
00004a  eb020181          ADD      r1,r2,r1,LSL #2
00004e  6088              STR      r0,[r1,#8]
;;;194      ip_addr_set_zero(&arp_table[i].ipaddr);
000050  eb040184          ADD      r1,r4,r4,LSL #2
000054  eb020181          ADD      r1,r2,r1,LSL #2
000058  6048              STR      r0,[r1,#4]
;;;195      arp_table[i].ethaddr = ethzero;
00005a  eb040084          ADD      r0,r4,r4,LSL #2
00005e  4611              MOV      r1,r2
000060  eb010080          ADD      r0,r1,r0,LSL #2
000064  4903              LDR      r1,|L5.116|
000066  680a              LDR      r2,[r1,#0]  ; ethzero
000068  60c2              STR      r2,[r0,#0xc]
00006a  8889              LDRH     r1,[r1,#4]  ; ethzero
00006c  8201              STRH     r1,[r0,#0x10]
;;;196    #endif /* LWIP_DEBUG */
;;;197    }
00006e  bd10              POP      {r4,pc}
;;;198    
                          ENDP

                  |L5.112|
                          DCD      arp_table
                  |L5.116|
                          DCD      ethzero

                          AREA ||i.etharp_output||, CODE, READONLY, ALIGN=2

                  etharp_output PROC
;;;878    err_t
;;;879    etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;880    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;881      struct eth_addr *dest;
;;;882      struct eth_addr mcastaddr;
;;;883      ip_addr_t *dst_addr = ipaddr;
00000a  46a9              MOV      r9,r5
;;;884    
;;;885      LWIP_ASSERT("netif != NULL", netif != NULL);
00000c  bf00              NOP      
00000e  b924              CBNZ     r4,|L6.26|
000010  a059              ADR      r0,|L6.376|
000012  f7fffffe          BL       __2printf
000016  bf00              NOP      
                  |L6.24|
000018  e7fe              B        |L6.24|
                  |L6.26|
00001a  bf00              NOP      
;;;886      LWIP_ASSERT("q != NULL", q != NULL);
00001c  bf00              NOP      
00001e  b927              CBNZ     r7,|L6.42|
000020  a059              ADR      r0,|L6.392|
000022  f7fffffe          BL       __2printf
000026  bf00              NOP      
                  |L6.40|
000028  e7fe              B        |L6.40|
                  |L6.42|
00002a  bf00              NOP      
;;;887      LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
00002c  bf00              NOP      
00002e  b925              CBNZ     r5,|L6.58|
000030  a058              ADR      r0,|L6.404|
000032  f7fffffe          BL       __2printf
000036  bf00              NOP      
                  |L6.56|
000038  e7fe              B        |L6.56|
                  |L6.58|
00003a  bf00              NOP      
;;;888    
;;;889      /* make room for Ethernet header - should not fail */
;;;890      if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
00003c  210e              MOVS     r1,#0xe
00003e  4638              MOV      r0,r7
000040  f7fffffe          BL       pbuf_header
000044  b150              CBZ      r0,|L6.92|
;;;891        /* bail out */
;;;892        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
000046  bf00              NOP      
000048  bf00              NOP      
;;;893          ("etharp_output: could not allocate room for header.\n"));
;;;894        LINK_STATS_INC(link.lenerr);
00004a  4856              LDR      r0,|L6.420|
00004c  8940              LDRH     r0,[r0,#0xa]  ; lwip_stats
00004e  1c40              ADDS     r0,r0,#1
000050  4954              LDR      r1,|L6.420|
000052  8148              STRH     r0,[r1,#0xa]
;;;895        return ERR_BUF;
000054  f06f0001          MVN      r0,#1
                  |L6.88|
;;;896      }
;;;897    
;;;898      /* Determine on destination hardware address. Broadcasts and multicasts
;;;899       * are special, other IP addresses are looked up in the ARP table. */
;;;900    
;;;901      /* broadcast destination IP address? */
;;;902      if (ip_addr_isbroadcast(ipaddr, netif)) {
;;;903        /* broadcast on Ethernet also */
;;;904        dest = (struct eth_addr *)&ethbroadcast;
;;;905      /* multicast destination IP address? */
;;;906      } else if (ip_addr_ismulticast(ipaddr)) {
;;;907        /* Hash IP multicast address to MAC address.*/
;;;908        mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
;;;909        mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
;;;910        mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
;;;911        mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
;;;912        mcastaddr.addr[4] = ip4_addr3(ipaddr);
;;;913        mcastaddr.addr[5] = ip4_addr4(ipaddr);
;;;914        /* destination Ethernet address is multicast */
;;;915        dest = &mcastaddr;
;;;916      /* unicast destination IP address? */
;;;917      } else {
;;;918        s8_t i;
;;;919        /* outside local network? if so, this can neither be a global broadcast nor
;;;920           a subnet broadcast. */
;;;921        if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
;;;922            !ip_addr_islinklocal(ipaddr)) {
;;;923    #if LWIP_AUTOIP
;;;924          struct ip_hdr *iphdr = (struct ip_hdr*)((u8_t*)q->payload +
;;;925            sizeof(struct eth_hdr));
;;;926          /* According to RFC 3297, chapter 2.6.2 (Forwarding Rules), a packet with
;;;927             a link-local source address must always be "directly to its destination
;;;928             on the same physical link. The host MUST NOT send the packet to any
;;;929             router for forwarding". */
;;;930          if (!ip_addr_islinklocal(&iphdr->src))
;;;931    #endif /* LWIP_AUTOIP */
;;;932          {
;;;933            /* interface has default gateway? */
;;;934            if (!ip_addr_isany(&netif->gw)) {
;;;935              /* send to hardware address of default gateway IP address */
;;;936              dst_addr = &(netif->gw);
;;;937            /* no default gateway available */
;;;938            } else {
;;;939              /* no route to destination error (default gateway missing) */
;;;940              return ERR_RTE;
;;;941            }
;;;942          }
;;;943        }
;;;944    #if LWIP_NETIF_HWADDRHINT
;;;945        if (netif->addr_hint != NULL) {
;;;946          /* per-pcb cached entry was given */
;;;947          u8_t etharp_cached_entry = *(netif->addr_hint);
;;;948          if (etharp_cached_entry < ARP_TABLE_SIZE) {
;;;949    #endif /* LWIP_NETIF_HWADDRHINT */
;;;950            if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
;;;951                (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
;;;952              /* the per-pcb-cached entry is stable and the right one! */
;;;953              ETHARP_STATS_INC(etharp.cachehit);
;;;954              return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
;;;955            }
;;;956    #if LWIP_NETIF_HWADDRHINT
;;;957          }
;;;958        }
;;;959    #endif /* LWIP_NETIF_HWADDRHINT */
;;;960    
;;;961        /* find stable entry: do this here since this is a critical path for
;;;962           throughput and etharp_find_entry() is kind of slow */
;;;963        for (i = 0; i < ARP_TABLE_SIZE; i++) {
;;;964          if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
;;;965              (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
;;;966            /* found an existing, stable entry */
;;;967            ETHARP_SET_HINT(netif, i);
;;;968            return etharp_output_to_arp_index(netif, q, i);
;;;969          }
;;;970        }
;;;971        /* no stable entry found, use the (slower) query function:
;;;972           queue on destination Ethernet address belonging to ipaddr */
;;;973        return etharp_query(netif, dst_addr, q);
;;;974      }
;;;975    
;;;976      /* continuation for multicast/broadcast destinations */
;;;977      /* obtain source Ethernet address of the given interface */
;;;978      /* send packet directly on the link */
;;;979      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
;;;980    }
000058  e8bd87fc          POP      {r2-r10,pc}
                  |L6.92|
00005c  4621              MOV      r1,r4                 ;902
00005e  6828              LDR      r0,[r5,#0]            ;902
000060  f7fffffe          BL       ip4_addr_isbroadcast
000064  b110              CBZ      r0,|L6.108|
000066  f8df8140          LDR      r8,|L6.424|
00006a  e07d              B        |L6.360|
                  |L6.108|
00006c  7828              LDRB     r0,[r5,#0]            ;906
00006e  f00000f0          AND      r0,r0,#0xf0           ;906
000072  28e0              CMP      r0,#0xe0              ;906
000074  d115              BNE      |L6.162|
000076  2001              MOVS     r0,#1                 ;908
000078  f88d0000          STRB     r0,[sp,#0]            ;908
00007c  2000              MOVS     r0,#0                 ;909
00007e  f88d0001          STRB     r0,[sp,#1]            ;909
000082  205e              MOVS     r0,#0x5e              ;910
000084  f88d0002          STRB     r0,[sp,#2]            ;910
000088  7868              LDRB     r0,[r5,#1]            ;911
00008a  f000007f          AND      r0,r0,#0x7f           ;911
00008e  f88d0003          STRB     r0,[sp,#3]            ;911
000092  78a8              LDRB     r0,[r5,#2]            ;912
000094  f88d0004          STRB     r0,[sp,#4]            ;912
000098  78e8              LDRB     r0,[r5,#3]            ;913
00009a  f88d0005          STRB     r0,[sp,#5]            ;913
00009e  46e8              MOV      r8,sp                 ;915
0000a0  e061              B        |L6.358|
                  |L6.162|
0000a2  6828              LDR      r0,[r5,#0]            ;921
0000a4  68a1              LDR      r1,[r4,#8]            ;921
0000a6  4008              ANDS     r0,r0,r1              ;921
0000a8  e9d41201          LDRD     r1,r2,[r4,#4]         ;921
0000ac  4011              ANDS     r1,r1,r2              ;921
0000ae  4288              CMP      r0,r1                 ;921
0000b0  d010              BEQ      |L6.212|
0000b2  8828              LDRH     r0,[r5,#0]            ;922
0000b4  b280              UXTH     r0,r0                 ;922
0000b6  f64f61a9          MOV      r1,#0xfea9            ;922
0000ba  4288              CMP      r0,r1                 ;922
0000bc  d00a              BEQ      |L6.212|
0000be  f104000c          ADD      r0,r4,#0xc            ;934
0000c2  b120              CBZ      r0,|L6.206|
0000c4  68e0              LDR      r0,[r4,#0xc]          ;934
0000c6  b110              CBZ      r0,|L6.206|
0000c8  f104090c          ADD      r9,r4,#0xc            ;936
0000cc  e002              B        |L6.212|
                  |L6.206|
0000ce  f06f0003          MVN      r0,#3                 ;940
0000d2  e7c1              B        |L6.88|
                  |L6.212|
0000d4  4835              LDR      r0,|L6.428|
0000d6  7800              LDRB     r0,[r0,#0]            ;950  ; etharp_cached_entry
0000d8  eb000080          ADD      r0,r0,r0,LSL #2       ;950
0000dc  4934              LDR      r1,|L6.432|
0000de  eb010080          ADD      r0,r1,r0,LSL #2       ;950
0000e2  7c80              LDRB     r0,[r0,#0x12]         ;950
0000e4  2802              CMP      r0,#2                 ;950
0000e6  db18              BLT      |L6.282|
0000e8  4930              LDR      r1,|L6.428|
0000ea  7809              LDRB     r1,[r1,#0]            ;951  ; etharp_cached_entry
0000ec  eb010181          ADD      r1,r1,r1,LSL #2       ;951
0000f0  4a2f              LDR      r2,|L6.432|
0000f2  eb020181          ADD      r1,r2,r1,LSL #2       ;951
0000f6  f8d90000          LDR      r0,[r9,#0]            ;951
0000fa  6849              LDR      r1,[r1,#4]            ;951
0000fc  4288              CMP      r0,r1                 ;951
0000fe  d10c              BNE      |L6.282|
000100  4828              LDR      r0,|L6.420|
000102  8dc0              LDRH     r0,[r0,#0x2e]         ;953
000104  1c40              ADDS     r0,r0,#1              ;953
000106  b281              UXTH     r1,r0                 ;953
000108  4826              LDR      r0,|L6.420|
00010a  85c1              STRH     r1,[r0,#0x2e]         ;953
00010c  4827              LDR      r0,|L6.428|
00010e  7802              LDRB     r2,[r0,#0]            ;954  ; etharp_cached_entry
000110  4639              MOV      r1,r7                 ;954
000112  4620              MOV      r0,r4                 ;954
000114  f7fffffe          BL       etharp_output_to_arp_index
000118  e79e              B        |L6.88|
                  |L6.282|
00011a  2600              MOVS     r6,#0                 ;963
00011c  e01b              B        |L6.342|
                  |L6.286|
00011e  eb060086          ADD      r0,r6,r6,LSL #2       ;964
000122  4923              LDR      r1,|L6.432|
000124  eb010080          ADD      r0,r1,r0,LSL #2       ;964
000128  7c80              LDRB     r0,[r0,#0x12]         ;964
00012a  2802              CMP      r0,#2                 ;964
00012c  db11              BLT      |L6.338|
00012e  eb060186          ADD      r1,r6,r6,LSL #2       ;965
000132  4a1f              LDR      r2,|L6.432|
000134  eb020181          ADD      r1,r2,r1,LSL #2       ;965
000138  f8d90000          LDR      r0,[r9,#0]            ;965
00013c  6849              LDR      r1,[r1,#4]            ;965
00013e  4288              CMP      r0,r1                 ;965
000140  d107              BNE      |L6.338|
000142  491a              LDR      r1,|L6.428|
000144  700e              STRB     r6,[r1,#0]            ;967
000146  b2f2              UXTB     r2,r6                 ;968
000148  4639              MOV      r1,r7                 ;968
00014a  4620              MOV      r0,r4                 ;968
00014c  f7fffffe          BL       etharp_output_to_arp_index
000150  e782              B        |L6.88|
                  |L6.338|
000152  1c70              ADDS     r0,r6,#1              ;963
000154  b246              SXTB     r6,r0                 ;963
                  |L6.342|
000156  2e0a              CMP      r6,#0xa               ;963
000158  dbe1              BLT      |L6.286|
00015a  463a              MOV      r2,r7                 ;973
00015c  4649              MOV      r1,r9                 ;973
00015e  4620              MOV      r0,r4                 ;973
000160  f7fffffe          BL       etharp_query
000164  e778              B        |L6.88|
                  |L6.358|
000166  bf00              NOP                            ;974
                  |L6.360|
000168  4643              MOV      r3,r8                 ;979
00016a  f1040223          ADD      r2,r4,#0x23           ;979
00016e  4639              MOV      r1,r7                 ;979
000170  4620              MOV      r0,r4                 ;979
000172  f7fffffe          BL       etharp_send_ip
000176  e76f              B        |L6.88|
;;;981    
                          ENDP

                  |L6.376|
000178  6e657469          DCB      "netif != NULL",0
00017c  6620213d
000180  204e554c
000184  4c00    
000186  00                DCB      0
000187  00                DCB      0
                  |L6.392|
000188  7120213d          DCB      "q != NULL",0
00018c  204e554c
000190  4c00    
000192  00                DCB      0
000193  00                DCB      0
                  |L6.404|
000194  69706164          DCB      "ipaddr != NULL",0
000198  64722021
00019c  3d204e55
0001a0  4c4c00  
0001a3  00                DCB      0
                  |L6.420|
                          DCD      lwip_stats
                  |L6.424|
                          DCD      ethbroadcast
                  |L6.428|
                          DCD      etharp_cached_entry
                  |L6.432|
                          DCD      arp_table

                          AREA ||i.etharp_output_to_arp_index||, CODE, READONLY, ALIGN=2

                  etharp_output_to_arp_index PROC
;;;841    static err_t
;;;842    etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
000000  b570              PUSH     {r4-r6,lr}
;;;843    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;844      LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
000008  bf00              NOP      
00000a  eb040084          ADD      r0,r4,r4,LSL #2
00000e  491d              LDR      r1,|L7.132|
000010  eb010080          ADD      r0,r1,r0,LSL #2
000014  7c80              LDRB     r0,[r0,#0x12]
000016  2802              CMP      r0,#2
000018  da04              BGE      |L7.36|
00001a  a01b              ADR      r0,|L7.136|
00001c  f7fffffe          BL       __2printf
000020  bf00              NOP      
                  |L7.34|
000022  e7fe              B        |L7.34|
                  |L7.36|
000024  bf00              NOP      
;;;845                  arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
;;;846      /* if arp table entry is about to expire: re-request it,
;;;847         but only if its state is ETHARP_STATE_STABLE to prevent flooding the
;;;848         network with ARP requests if this address is used frequently. */
;;;849      if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
000026  eb040084          ADD      r0,r4,r4,LSL #2
00002a  4916              LDR      r1,|L7.132|
00002c  eb010080          ADD      r0,r1,r0,LSL #2
000030  7c80              LDRB     r0,[r0,#0x12]
000032  2802              CMP      r0,#2
000034  d117              BNE      |L7.102|
;;;850          (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
000036  eb040084          ADD      r0,r4,r4,LSL #2
00003a  eb010080          ADD      r0,r1,r0,LSL #2
00003e  7cc0              LDRB     r0,[r0,#0x13]
000040  28e4              CMP      r0,#0xe4
000042  db10              BLT      |L7.102|
;;;851        if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
000044  eb040084          ADD      r0,r4,r4,LSL #2
000048  460a              MOV      r2,r1
00004a  eb020080          ADD      r0,r2,r0,LSL #2
00004e  1d01              ADDS     r1,r0,#4
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       etharp_request
000056  b930              CBNZ     r0,|L7.102|
;;;852          arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
000058  2003              MOVS     r0,#3
00005a  eb040184          ADD      r1,r4,r4,LSL #2
00005e  4a09              LDR      r2,|L7.132|
000060  eb020181          ADD      r1,r2,r1,LSL #2
000064  7488              STRB     r0,[r1,#0x12]
                  |L7.102|
;;;853        }
;;;854      }
;;;855      
;;;856      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
000066  eb040084          ADD      r0,r4,r4,LSL #2
00006a  4906              LDR      r1,|L7.132|
00006c  eb010080          ADD      r0,r1,r0,LSL #2
000070  f100030c          ADD      r3,r0,#0xc
000074  f1050223          ADD      r2,r5,#0x23
000078  4631              MOV      r1,r6
00007a  4628              MOV      r0,r5
00007c  f7fffffe          BL       etharp_send_ip
;;;857        &arp_table[arp_idx].ethaddr);
;;;858    }
000080  bd70              POP      {r4-r6,pc}
;;;859    
                          ENDP

000082  0000              DCW      0x0000
                  |L7.132|
                          DCD      arp_table
                  |L7.136|
000088  6172705f          DCB      "arp_table[arp_idx].state >= ETHARP_STATE_STABLE",0
00008c  7461626c
000090  655b6172
000094  705f6964
000098  785d2e73
00009c  74617465
0000a0  203e3d20
0000a4  45544841
0000a8  52505f53
0000ac  54415445
0000b0  5f535441
0000b4  424c4500

                          AREA ||i.etharp_query||, CODE, READONLY, ALIGN=2

                  etharp_query PROC
;;;1015   err_t
;;;1016   etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1017   {
000004  4680              MOV      r8,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;1018     struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
00000a  f1080923          ADD      r9,r8,#0x23
;;;1019     err_t result = ERR_MEM;
00000e  f04f3aff          MOV      r10,#0xffffffff
;;;1020     s8_t i; /* ARP entry index */
;;;1021   
;;;1022     /* non-unicast address? */
;;;1023     if (ip_addr_isbroadcast(ipaddr, netif) ||
000012  4641              MOV      r1,r8
000014  6838              LDR      r0,[r7,#0]
000016  f7fffffe          BL       ip4_addr_isbroadcast
00001a  b938              CBNZ     r0,|L8.44|
;;;1024         ip_addr_ismulticast(ipaddr) ||
00001c  7838              LDRB     r0,[r7,#0]
00001e  f00000f0          AND      r0,r0,#0xf0
000022  28e0              CMP      r0,#0xe0
000024  d002              BEQ      |L8.44|
;;;1025         ip_addr_isany(ipaddr)) {
000026  b10f              CBZ      r7,|L8.44|
000028  6838              LDR      r0,[r7,#0]
00002a  b928              CBNZ     r0,|L8.56|
                  |L8.44|
;;;1026       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;1027       return ERR_ARG;
000030  f06f000d          MVN      r0,#0xd
                  |L8.52|
;;;1028     }
;;;1029   
;;;1030     /* find entry in ARP cache, ask to create entry if queueing packet */
;;;1031     i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
;;;1032   
;;;1033     /* could not find or create entry? */
;;;1034     if (i < 0) {
;;;1035       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
;;;1036       if (q) {
;;;1037         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
;;;1038         ETHARP_STATS_INC(etharp.memerr);
;;;1039       }
;;;1040       return (err_t)i;
;;;1041     }
;;;1042   
;;;1043     /* mark a fresh entry as pending (we just sent a request) */
;;;1044     if (arp_table[i].state == ETHARP_STATE_EMPTY) {
;;;1045       arp_table[i].state = ETHARP_STATE_PENDING;
;;;1046     }
;;;1047   
;;;1048     /* { i is either a STABLE or (new or existing) PENDING entry } */
;;;1049     LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
;;;1050     ((arp_table[i].state == ETHARP_STATE_PENDING) ||
;;;1051      (arp_table[i].state >= ETHARP_STATE_STABLE)));
;;;1052   
;;;1053     /* do we have a pending entry? or an implicit query request? */
;;;1054     if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
;;;1055       /* try to resolve it; send out ARP request */
;;;1056       result = etharp_request(netif, ipaddr);
;;;1057       if (result != ERR_OK) {
;;;1058         /* ARP request couldn't be sent */
;;;1059         /* We don't re-send arp request in etharp_tmr, but we still queue packets,
;;;1060            since this failure could be temporary, and the next packet calling
;;;1061            etharp_query again could lead to sending the queued packets. */
;;;1062       }
;;;1063       if (q == NULL) {
;;;1064         return result;
;;;1065       }
;;;1066     }
;;;1067   
;;;1068     /* packet given? */
;;;1069     LWIP_ASSERT("q != NULL", q != NULL);
;;;1070     /* stable entry? */
;;;1071     if (arp_table[i].state >= ETHARP_STATE_STABLE) {
;;;1072       /* we have a valid IP->Ethernet address mapping */
;;;1073       ETHARP_SET_HINT(netif, i);
;;;1074       /* send the packet */
;;;1075       result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
;;;1076     /* pending entry? (either just created or already pending */
;;;1077     } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;1078       /* entry is still pending, queue the given packet 'q' */
;;;1079       struct pbuf *p;
;;;1080       int copy_needed = 0;
;;;1081       /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
;;;1082        * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
;;;1083        * PBUF_ROMs can be left as they are, since ROM must not get changed. */
;;;1084       p = q;
;;;1085       while (p) {
;;;1086         LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
;;;1087         if(p->type != PBUF_ROM) {
;;;1088           copy_needed = 1;
;;;1089           break;
;;;1090         }
;;;1091         p = p->next;
;;;1092       }
;;;1093       if(copy_needed) {
;;;1094         /* copy the whole packet into new pbufs */
;;;1095         p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
;;;1096         if(p != NULL) {
;;;1097           if (pbuf_copy(p, q) != ERR_OK) {
;;;1098             pbuf_free(p);
;;;1099             p = NULL;
;;;1100           }
;;;1101         }
;;;1102       } else {
;;;1103         /* referencing the old pbuf is enough */
;;;1104         p = q;
;;;1105         pbuf_ref(p);
;;;1106       }
;;;1107       /* packet could be taken over? */
;;;1108       if (p != NULL) {
;;;1109         /* queue packet ... */
;;;1110   #if ARP_QUEUEING
;;;1111         struct etharp_q_entry *new_entry;
;;;1112         /* allocate a new arp queue entry */
;;;1113         new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
;;;1114         if (new_entry != NULL) {
;;;1115           new_entry->next = 0;
;;;1116           new_entry->p = p;
;;;1117           if(arp_table[i].q != NULL) {
;;;1118             /* queue was already existent, append the new entry to the end */
;;;1119             struct etharp_q_entry *r;
;;;1120             r = arp_table[i].q;
;;;1121             while (r->next != NULL) {
;;;1122               r = r->next;
;;;1123             }
;;;1124             r->next = new_entry;
;;;1125           } else {
;;;1126             /* queue did not exist, first item in queue */
;;;1127             arp_table[i].q = new_entry;
;;;1128           }
;;;1129           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1130           result = ERR_OK;
;;;1131         } else {
;;;1132           /* the pool MEMP_ARP_QUEUE is empty */
;;;1133           pbuf_free(p);
;;;1134           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1135           result = ERR_MEM;
;;;1136         }
;;;1137   #else /* ARP_QUEUEING */
;;;1138         /* always queue one packet per ARP request only, freeing a previously queued packet */
;;;1139         if (arp_table[i].q != NULL) {
;;;1140           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1141           pbuf_free(arp_table[i].q);
;;;1142         }
;;;1143         arp_table[i].q = p;
;;;1144         result = ERR_OK;
;;;1145         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1146   #endif /* ARP_QUEUEING */
;;;1147       } else {
;;;1148         ETHARP_STATS_INC(etharp.memerr);
;;;1149         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1150         result = ERR_MEM;
;;;1151       }
;;;1152     }
;;;1153     return result;
;;;1154   }
000034  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.56|
000038  2101              MOVS     r1,#1                 ;1031
00003a  4638              MOV      r0,r7                 ;1031
00003c  f7fffffe          BL       etharp_find_entry
000040  4604              MOV      r4,r0                 ;1031
000042  2c00              CMP      r4,#0                 ;1034
000044  da0c              BGE      |L8.96|
000046  bf00              NOP                            ;1035
000048  bf00              NOP                            ;1035
00004a  b13e              CBZ      r6,|L8.92|
00004c  bf00              NOP                            ;1037
00004e  bf00              NOP                            ;1037
000050  485e              LDR      r0,|L8.460|
000052  8c80              LDRH     r0,[r0,#0x24]         ;1038
000054  1c40              ADDS     r0,r0,#1              ;1038
000056  b281              UXTH     r1,r0                 ;1038
000058  485c              LDR      r0,|L8.460|
00005a  8481              STRH     r1,[r0,#0x24]         ;1038
                  |L8.92|
00005c  4620              MOV      r0,r4                 ;1040
00005e  e7e9              B        |L8.52|
                  |L8.96|
000060  eb040084          ADD      r0,r4,r4,LSL #2       ;1044
000064  495a              LDR      r1,|L8.464|
000066  eb010080          ADD      r0,r1,r0,LSL #2       ;1044
00006a  7c80              LDRB     r0,[r0,#0x12]         ;1044
00006c  b930              CBNZ     r0,|L8.124|
00006e  2001              MOVS     r0,#1                 ;1045
000070  eb040184          ADD      r1,r4,r4,LSL #2       ;1045
000074  4a56              LDR      r2,|L8.464|
000076  eb020181          ADD      r1,r2,r1,LSL #2       ;1045
00007a  7488              STRB     r0,[r1,#0x12]         ;1045
                  |L8.124|
00007c  bf00              NOP                            ;1049
00007e  eb040084          ADD      r0,r4,r4,LSL #2       ;1049
000082  4953              LDR      r1,|L8.464|
000084  eb010080          ADD      r0,r1,r0,LSL #2       ;1049
000088  7c80              LDRB     r0,[r0,#0x12]         ;1049
00008a  2801              CMP      r0,#1                 ;1049
00008c  d00b              BEQ      |L8.166|
00008e  eb040084          ADD      r0,r4,r4,LSL #2       ;1049
000092  eb010080          ADD      r0,r1,r0,LSL #2       ;1049
000096  7c80              LDRB     r0,[r0,#0x12]         ;1049
000098  2802              CMP      r0,#2                 ;1049
00009a  da04              BGE      |L8.166|
00009c  a04d              ADR      r0,|L8.468|
00009e  f7fffffe          BL       __2printf
0000a2  bf00              NOP                            ;1049
                  |L8.164|
0000a4  e7fe              B        |L8.164|
                  |L8.166|
0000a6  bf00              NOP                            ;1049
0000a8  eb040084          ADD      r0,r4,r4,LSL #2       ;1054
0000ac  4948              LDR      r1,|L8.464|
0000ae  eb010080          ADD      r0,r1,r0,LSL #2       ;1054
0000b2  7c80              LDRB     r0,[r0,#0x12]         ;1054
0000b4  2801              CMP      r0,#1                 ;1054
0000b6  d000              BEQ      |L8.186|
0000b8  b93e              CBNZ     r6,|L8.202|
                  |L8.186|
0000ba  4639              MOV      r1,r7                 ;1056
0000bc  4640              MOV      r0,r8                 ;1056
0000be  f7fffffe          BL       etharp_request
0000c2  4682              MOV      r10,r0                ;1056
0000c4  b90e              CBNZ     r6,|L8.202|
0000c6  4650              MOV      r0,r10                ;1064
0000c8  e7b4              B        |L8.52|
                  |L8.202|
0000ca  bf00              NOP                            ;1069
0000cc  b926              CBNZ     r6,|L8.216|
0000ce  a04b              ADR      r0,|L8.508|
0000d0  f7fffffe          BL       __2printf
0000d4  bf00              NOP                            ;1069
                  |L8.214|
0000d6  e7fe              B        |L8.214|
                  |L8.216|
0000d8  bf00              NOP                            ;1069
0000da  eb040084          ADD      r0,r4,r4,LSL #2       ;1071
0000de  493c              LDR      r1,|L8.464|
0000e0  eb010080          ADD      r0,r1,r0,LSL #2       ;1071
0000e4  7c80              LDRB     r0,[r0,#0x12]         ;1071
0000e6  2802              CMP      r0,#2                 ;1071
0000e8  db0f              BLT      |L8.266|
0000ea  4947              LDR      r1,|L8.520|
0000ec  700c              STRB     r4,[r1,#0]            ;1073
0000ee  eb040084          ADD      r0,r4,r4,LSL #2       ;1075
0000f2  4937              LDR      r1,|L8.464|
0000f4  eb010080          ADD      r0,r1,r0,LSL #2       ;1075
0000f8  f100030c          ADD      r3,r0,#0xc            ;1075
0000fc  464a              MOV      r2,r9                 ;1075
0000fe  4631              MOV      r1,r6                 ;1075
000100  4640              MOV      r0,r8                 ;1075
000102  f7fffffe          BL       etharp_send_ip
000106  4682              MOV      r10,r0                ;1075
000108  e05e              B        |L8.456|
                  |L8.266|
00010a  eb040084          ADD      r0,r4,r4,LSL #2       ;1077
00010e  4930              LDR      r1,|L8.464|
000110  eb010080          ADD      r0,r1,r0,LSL #2       ;1077
000114  7c80              LDRB     r0,[r0,#0x12]         ;1077
000116  2801              CMP      r0,#1                 ;1077
000118  d156              BNE      |L8.456|
00011a  f04f0b00          MOV      r11,#0                ;1080
00011e  4635              MOV      r5,r6                 ;1084
000120  e013              B        |L8.330|
                  |L8.290|
000122  bf00              NOP                            ;1086
000124  8968              LDRH     r0,[r5,#0xa]          ;1086
000126  8929              LDRH     r1,[r5,#8]            ;1086
000128  4288              CMP      r0,r1                 ;1086
00012a  d106              BNE      |L8.314|
00012c  6828              LDR      r0,[r5,#0]            ;1086
00012e  b120              CBZ      r0,|L8.314|
000130  a036              ADR      r0,|L8.524|
000132  f7fffffe          BL       __2printf
000136  bf00              NOP                            ;1086
                  |L8.312|
000138  e7fe              B        |L8.312|
                  |L8.314|
00013a  bf00              NOP                            ;1086
00013c  7b28              LDRB     r0,[r5,#0xc]          ;1087
00013e  2801              CMP      r0,#1                 ;1087
000140  d002              BEQ      |L8.328|
000142  f04f0b01          MOV      r11,#1                ;1088
000146  e002              B        |L8.334|
                  |L8.328|
000148  682d              LDR      r5,[r5,#0]            ;1091
                  |L8.330|
00014a  2d00              CMP      r5,#0                 ;1085
00014c  d1e9              BNE      |L8.290|
                  |L8.334|
00014e  bf00              NOP                            ;1089
000150  f1bb0f00          CMP      r11,#0                ;1093
000154  d010              BEQ      |L8.376|
000156  8929              LDRH     r1,[r5,#8]            ;1095
000158  2200              MOVS     r2,#0                 ;1095
00015a  2003              MOVS     r0,#3                 ;1095
00015c  f7fffffe          BL       pbuf_alloc
000160  4605              MOV      r5,r0                 ;1095
000162  b16d              CBZ      r5,|L8.384|
000164  4631              MOV      r1,r6                 ;1097
000166  4628              MOV      r0,r5                 ;1097
000168  f7fffffe          BL       pbuf_copy
00016c  b140              CBZ      r0,|L8.384|
00016e  4628              MOV      r0,r5                 ;1098
000170  f7fffffe          BL       pbuf_free
000174  2500              MOVS     r5,#0                 ;1099
000176  e003              B        |L8.384|
                  |L8.376|
000178  4635              MOV      r5,r6                 ;1104
00017a  4628              MOV      r0,r5                 ;1105
00017c  f7fffffe          BL       pbuf_ref
                  |L8.384|
000180  b1bd              CBZ      r5,|L8.434|
000182  eb040084          ADD      r0,r4,r4,LSL #2       ;1139
000186  4912              LDR      r1,|L8.464|
000188  f8510020          LDR      r0,[r1,r0,LSL #2]     ;1139
00018c  b140              CBZ      r0,|L8.416|
00018e  bf00              NOP                            ;1140
000190  bf00              NOP                            ;1140
000192  eb040184          ADD      r1,r4,r4,LSL #2       ;1141
000196  4a0e              LDR      r2,|L8.464|
000198  f8520021          LDR      r0,[r2,r1,LSL #2]     ;1141
00019c  f7fffffe          BL       pbuf_free
                  |L8.416|
0001a0  eb040084          ADD      r0,r4,r4,LSL #2       ;1143
0001a4  490a              LDR      r1,|L8.464|
0001a6  f8415020          STR      r5,[r1,r0,LSL #2]     ;1143
0001aa  f04f0a00          MOV      r10,#0                ;1144
0001ae  bf00              NOP                            ;1145
0001b0  e009              B        |L8.454|
                  |L8.434|
0001b2  4806              LDR      r0,|L8.460|
0001b4  8c80              LDRH     r0,[r0,#0x24]         ;1148
0001b6  1c40              ADDS     r0,r0,#1              ;1148
0001b8  b281              UXTH     r1,r0                 ;1148
0001ba  4804              LDR      r0,|L8.460|
0001bc  8481              STRH     r1,[r0,#0x24]         ;1148
0001be  bf00              NOP                            ;1149
0001c0  bf00              NOP                            ;1149
0001c2  f04f3aff          MOV      r10,#0xffffffff       ;1150
                  |L8.454|
0001c6  bf00              NOP                            ;1152
                  |L8.456|
0001c8  4650              MOV      r0,r10                ;1153
0001ca  e733              B        |L8.52|
;;;1155   
                          ENDP

                  |L8.460|
                          DCD      lwip_stats
                  |L8.464|
                          DCD      arp_table
                  |L8.468|
0001d4  6172705f          DCB      "arp_table[i].state == PENDING or STABLE",0
0001d8  7461626c
0001dc  655b695d
0001e0  2e737461
0001e4  7465203d
0001e8  3d205045
0001ec  4e44494e
0001f0  47206f72
0001f4  20535441
0001f8  424c4500
                  |L8.508|
0001fc  7120213d          DCB      "q != NULL",0
000200  204e554c
000204  4c00    
000206  00                DCB      0
000207  00                DCB      0
                  |L8.520|
                          DCD      etharp_cached_entry
                  |L8.524|
00020c  6e6f2070          DCB      "no packet queues allowed!",0
000210  61636b65
000214  74207175
000218  65756573
00021c  20616c6c
000220  6f776564
000224  2100    
000226  00                DCB      0
000227  00                DCB      0

                          AREA ||i.etharp_raw||, CODE, READONLY, ALIGN=2

                  etharp_raw PROC
;;;1174   err_t
;;;1175   etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1176              const struct eth_addr *ethdst_addr,
;;;1177              const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
;;;1178              const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
;;;1179              const u16_t opcode)
;;;1180   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
00000c  f8ddb028          LDR      r11,[sp,#0x28]
;;;1181     struct pbuf *p;
;;;1182     err_t result = ERR_OK;
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;1183     struct eth_hdr *ethhdr;
;;;1184     struct etharp_hdr *hdr;
;;;1185   #if LWIP_AUTOIP
;;;1186     const u8_t * ethdst_hwaddr;
;;;1187   #endif /* LWIP_AUTOIP */
;;;1188   
;;;1189     LWIP_ASSERT("netif != NULL", netif != NULL);
000014  bf00              NOP      
000016  b927              CBNZ     r7,|L9.34|
000018  a039              ADR      r0,|L9.256|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L9.32|
000020  e7fe              B        |L9.32|
                  |L9.34|
000022  bf00              NOP      
;;;1190   
;;;1191     /* allocate a pbuf for the outgoing ARP request packet */
;;;1192     p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
000024  2200              MOVS     r2,#0
000026  212a              MOVS     r1,#0x2a
000028  2003              MOVS     r0,#3
00002a  f7fffffe          BL       pbuf_alloc
00002e  4605              MOV      r5,r0
;;;1193     /* could allocate a pbuf for an ARP request? */
;;;1194     if (p == NULL) {
000030  b95d              CBNZ     r5,|L9.74|
;;;1195       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
000032  bf00              NOP      
000034  bf00              NOP      
;;;1196         ("etharp_raw: could not allocate pbuf for ARP request.\n"));
;;;1197       ETHARP_STATS_INC(etharp.memerr);
000036  4836              LDR      r0,|L9.272|
000038  8c80              LDRH     r0,[r0,#0x24]
00003a  1c40              ADDS     r0,r0,#1
00003c  b281              UXTH     r1,r0
00003e  4834              LDR      r0,|L9.272|
000040  8481              STRH     r1,[r0,#0x24]
;;;1198       return ERR_MEM;
000042  f04f30ff          MOV      r0,#0xffffffff
                  |L9.70|
;;;1199     }
;;;1200     LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
;;;1201                 (p->len >= SIZEOF_ETHARP_PACKET));
;;;1202   
;;;1203     ethhdr = (struct eth_hdr *)p->payload;
;;;1204     hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
;;;1205     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
;;;1206     hdr->opcode = htons(opcode);
;;;1207   
;;;1208     LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;1209                 (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;1210   #if LWIP_AUTOIP
;;;1211     /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;1212      * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;1213      * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;1214     ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
;;;1215   #endif /* LWIP_AUTOIP */
;;;1216     /* Write the ARP MAC-Addresses */
;;;1217     ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
;;;1218     ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
;;;1219     /* Write the Ethernet MAC-Addresses */
;;;1220   #if LWIP_AUTOIP
;;;1221     ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;1222   #else  /* LWIP_AUTOIP */
;;;1223     ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
;;;1224   #endif /* LWIP_AUTOIP */
;;;1225     ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
;;;1226     /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;1227      * structure packing. */ 
;;;1228     IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
;;;1229     IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
;;;1230   
;;;1231     hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
;;;1232     hdr->proto = PP_HTONS(ETHTYPE_IP);
;;;1233     /* set hwlen and protolen */
;;;1234     hdr->hwlen = ETHARP_HWADDR_LEN;
;;;1235     hdr->protolen = sizeof(ip_addr_t);
;;;1236   
;;;1237     ethhdr->type = PP_HTONS(ETHTYPE_ARP);
;;;1238     /* send ARP query */
;;;1239     result = netif->linkoutput(netif, p);
;;;1240     ETHARP_STATS_INC(etharp.xmit);
;;;1241     /* free ARP query packet */
;;;1242     pbuf_free(p);
;;;1243     p = NULL;
;;;1244     /* could not allocate pbuf for ARP request */
;;;1245   
;;;1246     return result;
;;;1247   }
000046  e8bd8ff8          POP      {r3-r11,pc}
                  |L9.74|
00004a  bf00              NOP                            ;1200
00004c  8968              LDRH     r0,[r5,#0xa]          ;1200
00004e  282a              CMP      r0,#0x2a              ;1200
000050  da04              BGE      |L9.92|
000052  a030              ADR      r0,|L9.276|
000054  f7fffffe          BL       __2printf
000058  bf00              NOP                            ;1200
                  |L9.90|
00005a  e7fe              B        |L9.90|
                  |L9.92|
00005c  bf00              NOP                            ;1200
00005e  686e              LDR      r6,[r5,#4]            ;1203
000060  f106040e          ADD      r4,r6,#0xe            ;1204
000064  bf00              NOP                            ;1205
000066  bf00              NOP                            ;1205
000068  980d              LDR      r0,[sp,#0x34]         ;1206
00006a  f7fffffe          BL       lwip_htons
00006e  80e0              STRH     r0,[r4,#6]            ;1206
000070  bf00              NOP                            ;1208
000072  f8970022          LDRB     r0,[r7,#0x22]         ;1208
000076  2806              CMP      r0,#6                 ;1208
000078  d004              BEQ      |L9.132|
00007a  4833              LDR      r0,|L9.328|
00007c  f7fffffe          BL       __2printf
000080  bf00              NOP                            ;1208
                  |L9.130|
000082  e7fe              B        |L9.130|
                  |L9.132|
000084  bf00              NOP                            ;1208
000086  f8da0000          LDR      r0,[r10,#0]           ;1217
00008a  60a0              STR      r0,[r4,#8]            ;1217
00008c  f8ba0004          LDRH     r0,[r10,#4]           ;1217
000090  81a0              STRH     r0,[r4,#0xc]          ;1217
000092  980b              LDR      r0,[sp,#0x2c]         ;1218
000094  6801              LDR      r1,[r0,#0]            ;1218
000096  f8c41012          STR      r1,[r4,#0x12]         ;1218
00009a  8880              LDRH     r0,[r0,#4]            ;1218
00009c  82e0              STRH     r0,[r4,#0x16]         ;1218
00009e  f8d90000          LDR      r0,[r9,#0]            ;1223
0000a2  6030              STR      r0,[r6,#0]            ;1223
0000a4  f8b90004          LDRH     r0,[r9,#4]            ;1223
0000a8  80b0              STRH     r0,[r6,#4]            ;1223
0000aa  f8d80000          LDR      r0,[r8,#0]            ;1225
0000ae  f8c60006          STR      r0,[r6,#6]            ;1225
0000b2  f8b80004          LDRH     r0,[r8,#4]            ;1225
0000b6  8170              STRH     r0,[r6,#0xa]          ;1225
0000b8  f8db0000          LDR      r0,[r11,#0]           ;1228
0000bc  f8c4000e          STR      r0,[r4,#0xe]          ;1228
0000c0  980c              LDR      r0,[sp,#0x30]         ;1229
0000c2  6800              LDR      r0,[r0,#0]            ;1229
0000c4  61a0              STR      r0,[r4,#0x18]         ;1229
0000c6  f44f7080          MOV      r0,#0x100             ;1231
0000ca  8020              STRH     r0,[r4,#0]            ;1231
0000cc  2008              MOVS     r0,#8                 ;1232
0000ce  8060              STRH     r0,[r4,#2]            ;1232
0000d0  2006              MOVS     r0,#6                 ;1234
0000d2  7120              STRB     r0,[r4,#4]            ;1234
0000d4  2004              MOVS     r0,#4                 ;1235
0000d6  7160              STRB     r0,[r4,#5]            ;1235
0000d8  f44f60c1          MOV      r0,#0x608             ;1237
0000dc  81b0              STRH     r0,[r6,#0xc]          ;1237
0000de  4629              MOV      r1,r5                 ;1239
0000e0  4638              MOV      r0,r7                 ;1239
0000e2  69ba              LDR      r2,[r7,#0x18]         ;1239
0000e4  4790              BLX      r2                    ;1239
0000e6  9000              STR      r0,[sp,#0]            ;1239
0000e8  4809              LDR      r0,|L9.272|
0000ea  8b00              LDRH     r0,[r0,#0x18]         ;1240  ; lwip_stats
0000ec  1c40              ADDS     r0,r0,#1              ;1240
0000ee  4908              LDR      r1,|L9.272|
0000f0  8308              STRH     r0,[r1,#0x18]         ;1240
0000f2  4628              MOV      r0,r5                 ;1242
0000f4  f7fffffe          BL       pbuf_free
0000f8  2500              MOVS     r5,#0                 ;1243
0000fa  9800              LDR      r0,[sp,#0]            ;1246
0000fc  e7a3              B        |L9.70|
;;;1248   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L9.256|
000100  6e657469          DCB      "netif != NULL",0
000104  6620213d
000108  204e554c
00010c  4c00    
00010e  00                DCB      0
00010f  00                DCB      0
                  |L9.272|
                          DCD      lwip_stats
                  |L9.276|
000114  63686563          DCB      "check that first pbuf can hold struct etharp_hdr",0
000118  6b207468
00011c  61742066
000120  69727374
000124  20706275
000128  66206361
00012c  6e20686f
000130  6c642073
000134  74727563
000138  74206574
00013c  68617270
000140  5f686472
000144  00      
000145  00                DCB      0
000146  00                DCB      0
000147  00                DCB      0
                  |L9.328|
                          DCD      ||.conststring||

                          AREA ||i.etharp_request||, CODE, READONLY, ALIGN=2

                  etharp_request PROC
;;;1258   err_t
;;;1259   etharp_request(struct netif *netif, ip_addr_t *ipaddr)
000000  b57f              PUSH     {r0-r6,lr}
;;;1260   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1261     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
000006  bf00              NOP      
000008  bf00              NOP      
;;;1262     return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
00000a  2101              MOVS     r1,#1
00000c  4a06              LDR      r2,|L10.40|
00000e  1d20              ADDS     r0,r4,#4
000010  f1040323          ADD      r3,r4,#0x23
000014  e88d0025          STM      sp,{r0,r2,r5}
000018  9103              STR      r1,[sp,#0xc]
00001a  4a04              LDR      r2,|L10.44|
00001c  4619              MOV      r1,r3
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       etharp_raw
;;;1263                       (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
;;;1264                       ipaddr, ARP_REQUEST);
;;;1265   }
000024  b004              ADD      sp,sp,#0x10
000026  bd70              POP      {r4-r6,pc}
;;;1266   #endif /* LWIP_ARP */
                          ENDP

                  |L10.40|
                          DCD      ethzero
                  |L10.44|
                          DCD      ethbroadcast

                          AREA ||i.etharp_send_ip||, CODE, READONLY, ALIGN=2

                  etharp_send_ip PROC
;;;414    static err_t
;;;415    etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;416    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;417      struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
00000c  6875              LDR      r5,[r6,#4]
;;;418    
;;;419      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
00000e  bf00              NOP      
000010  f8940022          LDRB     r0,[r4,#0x22]
000014  2806              CMP      r0,#6
000016  d004              BEQ      |L11.34|
000018  480d              LDR      r0,|L11.80|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L11.32|
000020  e7fe              B        |L11.32|
                  |L11.34|
000022  bf00              NOP      
;;;420                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;421      ETHADDR32_COPY(&ethhdr->dest, dst);
000024  f8d80000          LDR      r0,[r8,#0]
000028  6028              STR      r0,[r5,#0]
00002a  f8b80004          LDRH     r0,[r8,#4]
00002e  80a8              STRH     r0,[r5,#4]
;;;422      ETHADDR16_COPY(&ethhdr->src, src);
000030  6838              LDR      r0,[r7,#0]
000032  f8c50006          STR      r0,[r5,#6]
000036  88b8              LDRH     r0,[r7,#4]
000038  8168              STRH     r0,[r5,#0xa]
;;;423      ethhdr->type = PP_HTONS(ETHTYPE_IP);
00003a  2008              MOVS     r0,#8
00003c  81a8              STRH     r0,[r5,#0xc]
;;;424      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
00003e  bf00              NOP      
000040  bf00              NOP      
;;;425      /* send the packet */
;;;426      return netif->linkoutput(netif, p);
000042  4631              MOV      r1,r6
000044  4620              MOV      r0,r4
000046  69a2              LDR      r2,[r4,#0x18]
000048  4790              BLX      r2
;;;427    }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;428    
                          ENDP

00004e  0000              DCW      0x0000
                  |L11.80|
                          DCD      ||.conststring||

                          AREA ||i.etharp_tmr||, CODE, READONLY, ALIGN=2

                  etharp_tmr PROC
;;;205    void
;;;206    etharp_tmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;207    {
;;;208      u8_t i;
;;;209    
;;;210      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
000002  bf00              NOP      
000004  bf00              NOP      
;;;211      /* remove expired entries from the ARP table */
;;;212      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
000006  2400              MOVS     r4,#0
000008  e03f              B        |L12.138|
                  |L12.10|
;;;213        u8_t state = arp_table[i].state;
00000a  eb040084          ADD      r0,r4,r4,LSL #2
00000e  4920              LDR      r1,|L12.144|
000010  eb010080          ADD      r0,r1,r0,LSL #2
000014  7c85              LDRB     r5,[r0,#0x12]
;;;214        if (state != ETHARP_STATE_EMPTY
000016  b335              CBZ      r5,|L12.102|
;;;215    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;216          && (state != ETHARP_STATE_STATIC)
;;;217    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;218          ) {
;;;219          arp_table[i].ctime++;
000018  eb040084          ADD      r0,r4,r4,LSL #2
00001c  eb010080          ADD      r0,r1,r0,LSL #2
000020  7cc0              LDRB     r0,[r0,#0x13]
000022  1c40              ADDS     r0,r0,#1
000024  eb040184          ADD      r1,r4,r4,LSL #2
000028  4a19              LDR      r2,|L12.144|
00002a  eb020181          ADD      r1,r2,r1,LSL #2
00002e  74c8              STRB     r0,[r1,#0x13]
;;;220          if ((arp_table[i].ctime >= ARP_MAXAGE) ||
000030  eb040084          ADD      r0,r4,r4,LSL #2
000034  4611              MOV      r1,r2
000036  eb010080          ADD      r0,r1,r0,LSL #2
00003a  7cc0              LDRB     r0,[r0,#0x13]
00003c  28f0              CMP      r0,#0xf0
00003e  da0d              BGE      |L12.92|
;;;221              ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
000040  eb040084          ADD      r0,r4,r4,LSL #2
000044  eb010080          ADD      r0,r1,r0,LSL #2
000048  7c80              LDRB     r0,[r0,#0x12]
00004a  2801              CMP      r0,#1
00004c  d10c              BNE      |L12.104|
;;;222               (arp_table[i].ctime >= ARP_MAXPENDING))) {
00004e  eb040084          ADD      r0,r4,r4,LSL #2
000052  eb010080          ADD      r0,r1,r0,LSL #2
000056  7cc0              LDRB     r0,[r0,#0x13]
000058  2802              CMP      r0,#2
00005a  db05              BLT      |L12.104|
                  |L12.92|
;;;223            /* pending or stable entry has become old! */
;;;224            LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
00005c  bf00              NOP      
00005e  bf00              NOP      
;;;225                 arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
;;;226            /* clean up entries that have just been expired */
;;;227            etharp_free_entry(i);
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       etharp_free_entry
                  |L12.102|
000066  e00e              B        |L12.134|
                  |L12.104|
;;;228          }
;;;229          else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
000068  eb040084          ADD      r0,r4,r4,LSL #2
00006c  4908              LDR      r1,|L12.144|
00006e  eb010080          ADD      r0,r1,r0,LSL #2
000072  7c80              LDRB     r0,[r0,#0x12]
000074  2803              CMP      r0,#3
000076  d106              BNE      |L12.134|
;;;230            /* Reset state to stable, so that the next transmitted packet will
;;;231               re-send an ARP request. */
;;;232            arp_table[i].state = ETHARP_STATE_STABLE;
000078  2002              MOVS     r0,#2
00007a  eb040184          ADD      r1,r4,r4,LSL #2
00007e  4a04              LDR      r2,|L12.144|
000080  eb020181          ADD      r1,r2,r1,LSL #2
000084  7488              STRB     r0,[r1,#0x12]
                  |L12.134|
000086  1c60              ADDS     r0,r4,#1              ;212
000088  b2c4              UXTB     r4,r0                 ;212
                  |L12.138|
00008a  2c0a              CMP      r4,#0xa               ;212
00008c  dbbd              BLT      |L12.10|
;;;233          }
;;;234    #if ARP_QUEUEING
;;;235          /* still pending entry? (not expired) */
;;;236          if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;237            /* resend an ARP query here? */
;;;238          }
;;;239    #endif /* ARP_QUEUEING */
;;;240        }
;;;241      }
;;;242    }
00008e  bd70              POP      {r4-r6,pc}
;;;243    
                          ENDP

                  |L12.144|
                          DCD      arp_table

                          AREA ||i.etharp_update_arp_entry||, CODE, READONLY, ALIGN=2

                  etharp_update_arp_entry PROC
;;;447    static err_t
;;;448    etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;449    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;450      s8_t i;
;;;451      LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
00000c  bf00              NOP      
00000e  f8960022          LDRB     r0,[r6,#0x22]
000012  2806              CMP      r0,#6
000014  d004              BEQ      |L13.32|
000016  a02e              ADR      r0,|L13.208|
000018  f7fffffe          BL       __2printf
00001c  bf00              NOP      
                  |L13.30|
00001e  e7fe              B        |L13.30|
                  |L13.32|
000020  bf00              NOP      
;;;452      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
000022  bf00              NOP      
000024  bf00              NOP      
;;;453        ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
;;;454        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
;;;455        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
;;;456      /* non-unicast address? */
;;;457      if (ip_addr_isany(ipaddr) ||
000026  b15d              CBZ      r5,|L13.64|
000028  6828              LDR      r0,[r5,#0]
00002a  b148              CBZ      r0,|L13.64|
;;;458          ip_addr_isbroadcast(ipaddr, netif) ||
00002c  4631              MOV      r1,r6
00002e  6828              LDR      r0,[r5,#0]
000030  f7fffffe          BL       ip4_addr_isbroadcast
000034  b920              CBNZ     r0,|L13.64|
;;;459          ip_addr_ismulticast(ipaddr)) {
000036  7828              LDRB     r0,[r5,#0]
000038  f00000f0          AND      r0,r0,#0xf0
00003c  28e0              CMP      r0,#0xe0
00003e  d105              BNE      |L13.76|
                  |L13.64|
;;;460        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
000040  bf00              NOP      
000042  bf00              NOP      
;;;461        return ERR_ARG;
000044  f06f000d          MVN      r0,#0xd
                  |L13.72|
;;;462      }
;;;463      /* find or create ARP entry */
;;;464      i = etharp_find_entry(ipaddr, flags);
;;;465      /* bail out if no entry could be found */
;;;466      if (i < 0) {
;;;467        return (err_t)i;
;;;468      }
;;;469    
;;;470    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;471      if (flags & ETHARP_FLAG_STATIC_ENTRY) {
;;;472        /* record static type */
;;;473        arp_table[i].state = ETHARP_STATE_STATIC;
;;;474      } else
;;;475    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;476      {
;;;477        /* mark it stable */
;;;478        arp_table[i].state = ETHARP_STATE_STABLE;
;;;479      }
;;;480    
;;;481      /* record network interface */
;;;482      arp_table[i].netif = netif;
;;;483      /* insert in SNMP ARP index tree */
;;;484      snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);
;;;485    
;;;486      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
;;;487      /* update address */
;;;488      ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
;;;489      /* reset time stamp */
;;;490      arp_table[i].ctime = 0;
;;;491      /* this is where we will send out queued packets! */
;;;492    #if ARP_QUEUEING
;;;493      while (arp_table[i].q != NULL) {
;;;494        struct pbuf *p;
;;;495        /* remember remainder of queue */
;;;496        struct etharp_q_entry *q = arp_table[i].q;
;;;497        /* pop first item off the queue */
;;;498        arp_table[i].q = q->next;
;;;499        /* get the packet pointer */
;;;500        p = q->p;
;;;501        /* now queue entry can be freed */
;;;502        memp_free(MEMP_ARP_QUEUE, q);
;;;503    #else /* ARP_QUEUEING */
;;;504      if (arp_table[i].q != NULL) {
;;;505        struct pbuf *p = arp_table[i].q;
;;;506        arp_table[i].q = NULL;
;;;507    #endif /* ARP_QUEUEING */
;;;508        /* send the queued IP packet */
;;;509        etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
;;;510        /* free the queued IP packet */
;;;511        pbuf_free(p);
;;;512      }
;;;513      return ERR_OK;
;;;514    }
000048  e8bd87f0          POP      {r4-r10,pc}
                  |L13.76|
00004c  4641              MOV      r1,r8                 ;464
00004e  4628              MOV      r0,r5                 ;464
000050  f7fffffe          BL       etharp_find_entry
000054  4604              MOV      r4,r0                 ;464
000056  2c00              CMP      r4,#0                 ;466
000058  da01              BGE      |L13.94|
00005a  4620              MOV      r0,r4                 ;467
00005c  e7f4              B        |L13.72|
                  |L13.94|
00005e  2002              MOVS     r0,#2                 ;478
000060  eb040184          ADD      r1,r4,r4,LSL #2       ;478
000064  4a24              LDR      r2,|L13.248|
000066  eb020181          ADD      r1,r2,r1,LSL #2       ;478
00006a  7488              STRB     r0,[r1,#0x12]         ;478
00006c  eb040084          ADD      r0,r4,r4,LSL #2       ;482
000070  4611              MOV      r1,r2                 ;482
000072  eb010080          ADD      r0,r1,r0,LSL #2       ;482
000076  6086              STR      r6,[r0,#8]            ;482
000078  bf00              NOP                            ;486
00007a  bf00              NOP                            ;486
00007c  eb040084          ADD      r0,r4,r4,LSL #2       ;488
000080  eb010080          ADD      r0,r1,r0,LSL #2       ;488
000084  6839              LDR      r1,[r7,#0]            ;488
000086  60c1              STR      r1,[r0,#0xc]          ;488
000088  88b9              LDRH     r1,[r7,#4]            ;488
00008a  8201              STRH     r1,[r0,#0x10]         ;488
00008c  2000              MOVS     r0,#0                 ;490
00008e  eb040184          ADD      r1,r4,r4,LSL #2       ;490
000092  eb020181          ADD      r1,r2,r1,LSL #2       ;490
000096  74c8              STRB     r0,[r1,#0x13]         ;490
000098  eb040084          ADD      r0,r4,r4,LSL #2       ;504
00009c  4611              MOV      r1,r2                 ;504
00009e  f8510020          LDR      r0,[r1,r0,LSL #2]     ;504
0000a2  b198              CBZ      r0,|L13.204|
0000a4  eb040084          ADD      r0,r4,r4,LSL #2       ;505
0000a8  f8519020          LDR      r9,[r1,r0,LSL #2]     ;505
0000ac  2000              MOVS     r0,#0                 ;506
0000ae  eb040184          ADD      r1,r4,r4,LSL #2       ;506
0000b2  f8420021          STR      r0,[r2,r1,LSL #2]     ;506
0000b6  463b              MOV      r3,r7                 ;509
0000b8  f1060223          ADD      r2,r6,#0x23           ;509
0000bc  4649              MOV      r1,r9                 ;509
0000be  4630              MOV      r0,r6                 ;509
0000c0  f7fffffe          BL       etharp_send_ip
0000c4  4648              MOV      r0,r9                 ;511
0000c6  f7fffffe          BL       pbuf_free
0000ca  bf00              NOP                            ;512
                  |L13.204|
0000cc  2000              MOVS     r0,#0                 ;513
0000ce  e7bb              B        |L13.72|
;;;515    
                          ENDP

                  |L13.208|
0000d0  6e657469          DCB      "netif->hwaddr_len == ETHARP_HWADDR_LEN",0
0000d4  662d3e68
0000d8  77616464
0000dc  725f6c65
0000e0  6e203d3d
0000e4  20455448
0000e8  4152505f
0000ec  48574144
0000f0  44525f4c
0000f4  454e00  
0000f7  00                DCB      0
                  |L13.248|
                          DCD      arp_table

                          AREA ||i.ethernet_input||, CODE, READONLY, ALIGN=2

                  ethernet_input PROC
;;;1276   err_t
;;;1277   ethernet_input(struct pbuf *p, struct netif *netif)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1278   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1279     struct eth_hdr* ethhdr;
;;;1280     u16_t type;
;;;1281   #if LWIP_ARP || ETHARP_SUPPORT_VLAN
;;;1282     s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
000008  f04f080e          MOV      r8,#0xe
;;;1283   #endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */
;;;1284   
;;;1285     if (p->len <= SIZEOF_ETH_HDR) {
00000c  8960              LDRH     r0,[r4,#0xa]
00000e  280e              CMP      r0,#0xe
000010  dc0b              BGT      |L14.42|
;;;1286       /* a packet with only an ethernet header (or less) is not valid for us */
;;;1287       ETHARP_STATS_INC(etharp.proterr);
000012  4835              LDR      r0,|L14.232|
000014  8d00              LDRH     r0,[r0,#0x28]
000016  1c40              ADDS     r0,r0,#1
000018  b281              UXTH     r1,r0
00001a  4833              LDR      r0,|L14.232|
00001c  8501              STRH     r1,[r0,#0x28]
;;;1288       ETHARP_STATS_INC(etharp.drop);
00001e  8bc0              LDRH     r0,[r0,#0x1e]
000020  1c40              ADDS     r0,r0,#1
000022  b281              UXTH     r1,r0
000024  4830              LDR      r0,|L14.232|
000026  83c1              STRH     r1,[r0,#0x1e]
;;;1289       goto free_and_return;
000028  e059              B        |L14.222|
                  |L14.42|
;;;1290     }
;;;1291   
;;;1292     /* points to packet payload, which starts with an Ethernet header */
;;;1293     ethhdr = (struct eth_hdr *)p->payload;
00002a  6865              LDR      r5,[r4,#4]
;;;1294     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;1295       ("ethernet_input: dest:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", src:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", type:%"X16_F"\n",
;;;1296        (unsigned)ethhdr->dest.addr[0], (unsigned)ethhdr->dest.addr[1], (unsigned)ethhdr->dest.addr[2],
;;;1297        (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
;;;1298        (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
;;;1299        (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
;;;1300        (unsigned)htons(ethhdr->type)));
;;;1301   
;;;1302     type = ethhdr->type;
000030  89af              LDRH     r7,[r5,#0xc]
;;;1303   #if ETHARP_SUPPORT_VLAN
;;;1304     if (type == PP_HTONS(ETHTYPE_VLAN)) {
;;;1305       struct eth_vlan_hdr *vlan = (struct eth_vlan_hdr*)(((char*)ethhdr) + SIZEOF_ETH_HDR);
;;;1306       if (p->len <= SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR) {
;;;1307         /* a packet with only an ethernet/vlan header (or less) is not valid for us */
;;;1308         ETHARP_STATS_INC(etharp.proterr);
;;;1309         ETHARP_STATS_INC(etharp.drop);
;;;1310         goto free_and_return;
;;;1311       }
;;;1312   #if defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) /* if not, allow all VLANs */
;;;1313   #ifdef ETHARP_VLAN_CHECK_FN
;;;1314       if (!ETHARP_VLAN_CHECK_FN(ethhdr, vlan)) {
;;;1315   #elif defined(ETHARP_VLAN_CHECK)
;;;1316       if (VLAN_ID(vlan) != ETHARP_VLAN_CHECK) {
;;;1317   #endif
;;;1318         /* silently ignore this packet: not for our VLAN */
;;;1319         pbuf_free(p);
;;;1320         return ERR_OK;
;;;1321       }
;;;1322   #endif /* defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) */
;;;1323       type = vlan->tpid;
;;;1324       ip_hdr_offset = SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR;
;;;1325     }
;;;1326   #endif /* ETHARP_SUPPORT_VLAN */
;;;1327   
;;;1328   #if LWIP_ARP_FILTER_NETIF
;;;1329     netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
;;;1330   #endif /* LWIP_ARP_FILTER_NETIF*/
;;;1331   
;;;1332     if (ethhdr->dest.addr[0] & 1) {
000032  7828              LDRB     r0,[r5,#0]
000034  f0000001          AND      r0,r0,#1
000038  b1b0              CBZ      r0,|L14.104|
;;;1333       /* this might be a multicast or broadcast packet */
;;;1334       if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
00003a  7828              LDRB     r0,[r5,#0]
00003c  2801              CMP      r0,#1
00003e  d109              BNE      |L14.84|
;;;1335         if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
000040  7868              LDRB     r0,[r5,#1]
000042  b988              CBNZ     r0,|L14.104|
;;;1336             (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
000044  78a8              LDRB     r0,[r5,#2]
000046  285e              CMP      r0,#0x5e
000048  d10e              BNE      |L14.104|
;;;1337           /* mark the pbuf as link-layer multicast */
;;;1338           p->flags |= PBUF_FLAG_LLMCAST;
00004a  7b60              LDRB     r0,[r4,#0xd]
00004c  f0400010          ORR      r0,r0,#0x10
000050  7360              STRB     r0,[r4,#0xd]
000052  e009              B        |L14.104|
                  |L14.84|
;;;1339         }
;;;1340       } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
000054  2206              MOVS     r2,#6
000056  4925              LDR      r1,|L14.236|
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       memcmp
00005e  b918              CBNZ     r0,|L14.104|
;;;1341         /* mark the pbuf as link-layer broadcast */
;;;1342         p->flags |= PBUF_FLAG_LLBCAST;
000060  7b60              LDRB     r0,[r4,#0xd]
000062  f0400008          ORR      r0,r0,#8
000066  7360              STRB     r0,[r4,#0xd]
                  |L14.104|
;;;1343       }
;;;1344     }
;;;1345   
;;;1346     switch (type) {
000068  2f08              CMP      r7,#8
00006a  d003              BEQ      |L14.116|
00006c  f5b76fc1          CMP      r7,#0x608
000070  d125              BNE      |L14.190|
000072  e017              B        |L14.164|
                  |L14.116|
;;;1347   #if LWIP_ARP
;;;1348       /* IP packet? */
;;;1349       case PP_HTONS(ETHTYPE_IP):
;;;1350         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
000074  f8960029          LDRB     r0,[r6,#0x29]
000078  f0000020          AND      r0,r0,#0x20
00007c  b900              CBNZ     r0,|L14.128|
;;;1351           goto free_and_return;
00007e  e02e              B        |L14.222|
                  |L14.128|
;;;1352         }
;;;1353   #if ETHARP_TRUST_IP_MAC
;;;1354         /* update ARP table */
;;;1355         etharp_ip_input(netif, p);
;;;1356   #endif /* ETHARP_TRUST_IP_MAC */
;;;1357         /* skip Ethernet header */
;;;1358         if(pbuf_header(p, -ip_hdr_offset)) {
000080  f1c80000          RSB      r0,r8,#0
000084  b201              SXTH     r1,r0
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       pbuf_header
00008c  b128              CBZ      r0,|L14.154|
;;;1359           LWIP_ASSERT("Can't move over header in packet", 0);
00008e  bf00              NOP      
000090  a017              ADR      r0,|L14.240|
000092  f7fffffe          BL       __2printf
000096  bf00              NOP      
                  |L14.152|
000098  e7fe              B        |L14.152|
                  |L14.154|
;;;1360           goto free_and_return;
;;;1361         } else {
;;;1362           /* pass to IP layer */
;;;1363           ip_input(p, netif);
00009a  4631              MOV      r1,r6
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       ip_input
;;;1364         }
;;;1365         break;
0000a2  e018              B        |L14.214|
                  |L14.164|
;;;1366         
;;;1367       case PP_HTONS(ETHTYPE_ARP):
;;;1368         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
0000a4  f8960029          LDRB     r0,[r6,#0x29]
0000a8  f0000020          AND      r0,r0,#0x20
0000ac  b900              CBNZ     r0,|L14.176|
;;;1369           goto free_and_return;
0000ae  e016              B        |L14.222|
                  |L14.176|
;;;1370         }
;;;1371         /* pass p to ARP module */
;;;1372         etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
0000b0  4622              MOV      r2,r4
0000b2  f1060123          ADD      r1,r6,#0x23
0000b6  4630              MOV      r0,r6
0000b8  f7fffffe          BL       etharp_arp_input
;;;1373         break;
0000bc  e00b              B        |L14.214|
                  |L14.190|
;;;1374   #endif /* LWIP_ARP */
;;;1375   #if PPPOE_SUPPORT
;;;1376       case PP_HTONS(ETHTYPE_PPPOEDISC): /* PPP Over Ethernet Discovery Stage */
;;;1377         pppoe_disc_input(netif, p);
;;;1378         break;
;;;1379   
;;;1380       case PP_HTONS(ETHTYPE_PPPOE): /* PPP Over Ethernet Session Stage */
;;;1381         pppoe_data_input(netif, p);
;;;1382         break;
;;;1383   #endif /* PPPOE_SUPPORT */
;;;1384   
;;;1385       default:
;;;1386         ETHARP_STATS_INC(etharp.proterr);
0000be  480a              LDR      r0,|L14.232|
0000c0  8d00              LDRH     r0,[r0,#0x28]
0000c2  1c40              ADDS     r0,r0,#1
0000c4  b281              UXTH     r1,r0
0000c6  4808              LDR      r0,|L14.232|
0000c8  8501              STRH     r1,[r0,#0x28]
;;;1387         ETHARP_STATS_INC(etharp.drop);
0000ca  8bc0              LDRH     r0,[r0,#0x1e]
0000cc  1c40              ADDS     r0,r0,#1
0000ce  b281              UXTH     r1,r0
0000d0  4805              LDR      r0,|L14.232|
0000d2  83c1              STRH     r1,[r0,#0x1e]
;;;1388         goto free_and_return;
0000d4  e003              B        |L14.222|
                  |L14.214|
0000d6  bf00              NOP                            ;1365
;;;1389     }
;;;1390   
;;;1391     /* This means the pbuf is freed or consumed,
;;;1392        so the caller doesn't have to free it again */
;;;1393     return ERR_OK;
0000d8  2000              MOVS     r0,#0
                  |L14.218|
;;;1394   
;;;1395   free_and_return:
;;;1396     pbuf_free(p);
;;;1397     return ERR_OK;
;;;1398   }
0000da  e8bd81f0          POP      {r4-r8,pc}
                  |L14.222|
0000de  4620              MOV      r0,r4                 ;1396
0000e0  f7fffffe          BL       pbuf_free
0000e4  2000              MOVS     r0,#0                 ;1397
0000e6  e7f8              B        |L14.218|
;;;1399   #endif /* LWIP_ARP || LWIP_ETHERNET */
                          ENDP

                  |L14.232|
                          DCD      lwip_stats
                  |L14.236|
                          DCD      ethbroadcast
                  |L14.240|
0000f0  43616e27          DCB      "Can't move over header in packet",0
0000f4  74206d6f
0000f8  7665206f
0000fc  76657220
000100  68656164
000104  65722069
000108  6e207061
00010c  636b6574
000110  00      
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  arp_table
                          %        200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ethbroadcast
000000  ffffffff          DCB      0xff,0xff,0xff,0xff
000004  ffff              DCB      0xff,0xff
                  ethzero
000006  0000              DCB      0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  6e657469          DCB      "netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN"
000004  662d3e68
000008  77616464
00000c  725f6c65
000010  6e206d75
000014  73742062
000018  65207468
00001c  65207361
000020  6d652061
000024  73204554
000028  48415250
00002c  5f485741
000030  4444525f
000034  4c454e  
000037  20666f72          DCB      " for etharp!",0
00003b  20657468
00003f  61727021
000043  00      

                          AREA ||.data||, DATA, ALIGN=0

                  etharp_cached_entry
000000  00                DCB      0x00
