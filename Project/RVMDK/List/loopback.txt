; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\loopback.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\loopback.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IC:\Users\Administrator\Desktop\lwip.practise\example6-1\Project\RVMDK\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\loopback.crf ..\..\Source\src\loopback.c]
                          THUMB

                          AREA ||i.loopclient_connect||, CODE, READONLY, ALIGN=2

                  loopclient_connect PROC
;;;155    
;;;156    err_t loopclient_connect(void *arg, struct tcp_pcb *tpcb, err_t err)
000000  b570              PUSH     {r4-r6,lr}
;;;157    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;158      tcp_recv(tpcb, loopclient_recv);
000008  4905              LDR      r1,|L1.32|
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       tcp_recv
;;;159      tcp_poll(tpcb, loopclient_poll, 10);
000010  220a              MOVS     r2,#0xa
000012  4904              LDR      r1,|L1.36|
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       tcp_poll
;;;160      return ERR_OK;
00001a  2000              MOVS     r0,#0
;;;161    }
00001c  bd70              POP      {r4-r6,pc}
;;;162    
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      loopclient_recv
                  |L1.36|
                          DCD      loopclient_poll

                          AREA ||i.loopclient_init||, CODE, READONLY, ALIGN=2

                  loopclient_init PROC
;;;162    
;;;163    void loopclient_init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;164    {
;;;165      struct tcp_pcb *pcb = NULL;
000002  2400              MOVS     r4,#0
;;;166      struct ip_addr ipaddr;
;;;167      //IP4_ADDR(&ipaddr, 192, 168, 1, 37); 
;;;168      IP4_ADDR(&ipaddr, 127, 0, 0, 1);
000004  4806              LDR      r0,|L2.32|
000006  9000              STR      r0,[sp,#0]
;;;169      /* Create a new TCP control block  */
;;;170      pcb = tcp_new();	                		 	
000008  f7fffffe          BL       tcp_new
00000c  4604              MOV      r4,r0
;;;171    
;;;172      /* Assign to the new pcb a local IP address and a port number */
;;;173      /* Using IP_ADDR_ANY allow the pcb to be used by any local interface */
;;;174      //tcp_bind(pcb, IP_ADDR_ANY, 7);       
;;;175    
;;;176      tcp_connect(pcb,&ipaddr,6060,loopclient_connect);
00000e  4b05              LDR      r3,|L2.36|
000010  f24172ac          MOV      r2,#0x17ac
000014  4669              MOV      r1,sp
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       tcp_connect
;;;177    }
00001c  bd38              POP      {r3-r5,pc}
;;;178    
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      0x0100007f
                  |L2.36|
                          DCD      loopclient_connect

                          AREA ||i.loopclient_poll||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_return_value
                          REQUIRE _printf_u
                          REQUIRE _printf_int_dec
                  loopclient_poll PROC
;;;120    //unsigned char loopdata[]="Loop Interface Test!!\n";
;;;121    err_t loopclient_poll(void *arg, struct tcp_pcb *tpcb)
000000  b570              PUSH     {r4-r6,lr}
;;;122    {
000002  b09a              SUB      sp,sp,#0x68
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;123        char loopdata[100] = {0,};
000008  2164              MOVS     r1,#0x64
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       __aeabi_memclr4
;;;124    	static unsigned int count = 0;
;;;125        int len = 0;
000010  2500              MOVS     r5,#0
;;;126    
;;;127    	len = sprintf(loopdata, "Loop Interface Test, loop count = %u", count++);
000012  480a              LDR      r0,|L3.60|
000014  6802              LDR      r2,[r0,#0]  ; count
000016  6800              LDR      r0,[r0,#0]  ; count
000018  1c40              ADDS     r0,r0,#1
00001a  4b08              LDR      r3,|L3.60|
00001c  a108              ADR      r1,|L3.64|
00001e  6018              STR      r0,[r3,#0]  ; count
000020  a801              ADD      r0,sp,#4
000022  f7fffffe          BL       __2sprintf
000026  4605              MOV      r5,r0
;;;128    	
;;;129        tcp_write(tpcb, loopdata, len, TCP_WRITE_FLAG_COPY);
000028  b2aa              UXTH     r2,r5
00002a  2301              MOVS     r3,#1
00002c  a901              ADD      r1,sp,#4
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       tcp_write
;;;130    	return ERR_OK;
000034  2000              MOVS     r0,#0
;;;131    }
000036  b01a              ADD      sp,sp,#0x68
000038  bd70              POP      {r4-r6,pc}
;;;132    
                          ENDP

00003a  0000              DCW      0x0000
                  |L3.60|
                          DCD      count
                  |L3.64|
000040  4c6f6f70          DCB      "Loop Interface Test, loop count = %u",0
000044  20496e74
000048  65726661
00004c  63652054
000050  6573742c
000054  206c6f6f
000058  7020636f
00005c  756e7420
000060  3d202575
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.loopclient_recv||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  loopclient_recv PROC
;;;132    
;;;133    err_t loopclient_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;134    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
;;;135    
;;;136    //  char *rq;
;;;137    
;;;138      /* We perform here any necessary processing on the pbuf */
;;;139      if (p != NULL) 
00000c  b15c              CBZ      r4,|L4.38|
;;;140      {        
;;;141    	/* We call this function to tell the LwIp that we have processed the data */
;;;142    	/* This lets the stack advertise a larger window, so more data can be received*/
;;;143    	tcp_recved(pcb, p->tot_len);
00000e  8921              LDRH     r1,[r4,#8]
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       tcp_recved
;;;144    	printf("[Client]recive data, len = %d\r\n", p->tot_len);
000016  8921              LDRH     r1,[r4,#8]
000018  a007              ADR      r0,|L4.56|
00001a  f7fffffe          BL       __2printf
;;;145        pbuf_free(p);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       pbuf_free
000024  e005              B        |L4.50|
                  |L4.38|
;;;146      } 
;;;147      else if (err == ERR_OK) 
000026  b926              CBNZ     r6,|L4.50|
;;;148      {
;;;149        return tcp_close(pcb);
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       tcp_close
                  |L4.46|
;;;150      }
;;;151      
;;;152      return ERR_OK;
;;;153    }
00002e  e8bd81f0          POP      {r4-r8,pc}
                  |L4.50|
000032  2000              MOVS     r0,#0                 ;152
000034  e7fb              B        |L4.46|
;;;154    
                          ENDP

000036  0000              DCW      0x0000
                  |L4.56|
000038  5b436c69          DCB      "[Client]recive data, len = %d\r\n",0
00003c  656e745d
000040  72656369
000044  76652064
000048  6174612c
00004c  206c656e
000050  203d2025
000054  640d0a00

                          AREA ||i.server_accept||, CODE, READONLY, ALIGN=2

                  server_accept PROC
;;;77       */
;;;78     err_t server_accept(void *arg, struct tcp_pcb *pcb, err_t err)
000000  b570              PUSH     {r4-r6,lr}
;;;79     {     
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;80       
;;;81       /* Tell LwIP to associate this structure with this connection. */
;;;82      // tcp_arg(pcb, mem_calloc(sizeof(struct name), 1));	
;;;83       
;;;84       /* Configure LwIP to use our call back functions. */
;;;85      // tcp_err(pcb, HelloWorld_conn_err);
;;;86      // tcp_setprio(pcb, TCP_PRIO_MIN);
;;;87       tcp_recv(pcb, server_recv);
000008  4902              LDR      r1,|L5.20|
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       tcp_recv
;;;88      // tcp_poll(pcb, http_poll, 10);
;;;89      //  tcp_sent(pcb, http_sent);
;;;90      
;;;91       return ERR_OK;
000010  2000              MOVS     r0,#0
;;;92     }
000012  bd70              POP      {r4-r6,pc}
;;;93     
                          ENDP

                  |L5.20|
                          DCD      server_recv

                          AREA ||i.server_recv||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_u
                          REQUIRE _printf_int_dec
                  server_recv PROC
;;;26     
;;;27     err_t server_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;28     {
000004  4682              MOV      r10,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  4698              MOV      r8,r3
;;;29     
;;;30       char *data_recv = NULL;
00000c  2600              MOVS     r6,#0
;;;31       int index = 0;
00000e  46b1              MOV      r9,r6
;;;32       struct pbuf *q = NULL;
000010  2500              MOVS     r5,#0
;;;33     
;;;34       /* We perform here any necessary processing on the pbuf */
;;;35       if (p != NULL) 
000012  2c00              CMP      r4,#0
000014  d029              BEQ      |L6.106|
;;;36       {        
;;;37     	/* We call this function to tell the LwIp that we have processed the data */
;;;38     	/* This lets the stack advertise a larger window, so more data can be received*/
;;;39         data_recv = (char *)mem_calloc(p->tot_len + 1, 1);
000016  8921              LDRH     r1,[r4,#8]
000018  1c49              ADDS     r1,r1,#1
00001a  b288              UXTH     r0,r1
00001c  2101              MOVS     r1,#1
00001e  f7fffffe          BL       mem_calloc
000022  4606              MOV      r6,r0
;;;40     	if(NULL != data_recv)
000024  b1ae              CBZ      r6,|L6.82|
;;;41     	{
;;;42             q = p;
000026  4625              MOV      r5,r4
;;;43     		while(q != NULL)
000028  e008              B        |L6.60|
                  |L6.42|
;;;44     		{
;;;45     		    memcpy(&data_recv[index],q->payload,q->len);
00002a  896a              LDRH     r2,[r5,#0xa]
00002c  eb060009          ADD      r0,r6,r9
000030  6869              LDR      r1,[r5,#4]
000032  f7fffffe          BL       __aeabi_memcpy
;;;46     		    index += q->len;
000036  8968              LDRH     r0,[r5,#0xa]
000038  4481              ADD      r9,r9,r0
;;;47     		    q = q->next;
00003a  682d              LDR      r5,[r5,#0]
                  |L6.60|
00003c  2d00              CMP      r5,#0                 ;43
00003e  d1f4              BNE      |L6.42|
;;;48     		}
;;;49     
;;;50     		printf("[Server]Get MSG: %s", data_recv);
000040  4631              MOV      r1,r6
000042  a00f              ADR      r0,|L6.128|
000044  f7fffffe          BL       __2printf
;;;51             mem_free(data_recv);
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       mem_free
;;;52     		data_recv = NULL;
00004e  2600              MOVS     r6,#0
000050  e003              B        |L6.90|
                  |L6.82|
;;;53     	}
;;;54     	else
;;;55     	{
;;;56             printf("[Server]mem_calloc error, len = %u\r\n", p->tot_len);
000052  8921              LDRH     r1,[r4,#8]
000054  a00f              ADR      r0,|L6.148|
000056  f7fffffe          BL       __2printf
                  |L6.90|
;;;57     	}
;;;58     	
;;;59     	tcp_recved(pcb, p->tot_len);
00005a  8921              LDRH     r1,[r4,#8]
00005c  4638              MOV      r0,r7
00005e  f7fffffe          BL       tcp_recved
;;;60         pbuf_free(p);
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       pbuf_free
000068  e007              B        |L6.122|
                  |L6.106|
;;;61       } 
;;;62       else if (err == ERR_OK) 
00006a  f1b80f00          CMP      r8,#0
00006e  d104              BNE      |L6.122|
;;;63       {
;;;64         /* When the pbuf is NULL and the err is ERR_OK, the remote end is closing the connection. */
;;;65         /* We free the allocated memory and we close the connection */
;;;66         return tcp_close(pcb);
000070  4638              MOV      r0,r7
000072  f7fffffe          BL       tcp_close
                  |L6.118|
;;;67       }
;;;68       return ERR_OK;
;;;69     }
000076  e8bd87f0          POP      {r4-r10,pc}
                  |L6.122|
00007a  2000              MOVS     r0,#0                 ;68
00007c  e7fb              B        |L6.118|
;;;70     
                          ENDP

00007e  0000              DCW      0x0000
                  |L6.128|
000080  5b536572          DCB      "[Server]Get MSG: %s",0
000084  7665725d
000088  47657420
00008c  4d53473a
000090  20257300
                  |L6.148|
000094  5b536572          DCB      "[Server]mem_calloc error, len = %u\r\n",0
000098  7665725d
00009c  6d656d5f
0000a0  63616c6c
0000a4  6f632065
0000a8  72726f72
0000ac  2c206c65
0000b0  6e203d20
0000b4  25750d0a
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0

                          AREA ||i.tcpserver_init||, CODE, READONLY, ALIGN=2

                  tcpserver_init PROC
;;;99      
;;;100    void tcpserver_init(void)
000000  b510              PUSH     {r4,lr}
;;;101    {
;;;102      struct tcp_pcb *pcb;	            		
;;;103      
;;;104      /* Create a new TCP control block  */
;;;105      pcb = tcp_new();	                		 	
000002  f7fffffe          BL       tcp_new
000006  4604              MOV      r4,r0
;;;106    
;;;107      /* Assign to the new pcb a local IP address and a port number */
;;;108      /* Using IP_ADDR_ANY allow the pcb to be used by any local interface */
;;;109      tcp_bind(pcb, IP_ADDR_ANY, 6060);       
000008  f24172ac          MOV      r2,#0x17ac
00000c  4906              LDR      r1,|L7.40|
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       tcp_bind
;;;110    
;;;111    
;;;112      /* Set the connection to the LISTEN state */
;;;113      pcb = tcp_listen(pcb);				
000014  21ff              MOVS     r1,#0xff
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       tcp_listen_with_backlog
00001c  4604              MOV      r4,r0
;;;114    
;;;115      /* Specify the function to be called when a connection is established */	
;;;116      tcp_accept(pcb, server_accept);   
00001e  4903              LDR      r1,|L7.44|
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       tcp_accept
;;;117    										
;;;118    }
000026  bd10              POP      {r4,pc}
;;;119    
                          ENDP

                  |L7.40|
                          DCD      ip_addr_any
                  |L7.44|
                          DCD      server_accept

                          AREA ||.data||, DATA, ALIGN=2

                  count
                          DCD      0x00000000
