; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\tcp_in.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\tcp_in.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IC:\Users\Administrator\Desktop\lwip.practise\example6-1\Project\RVMDK\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\tcp_in.crf ..\..\lwip\src\core\tcp_in.c]
                          THUMB

                          AREA ||i.tcp_input||, CODE, READONLY, ALIGN=2

                  tcp_input PROC
;;;91     void
;;;92     tcp_input(struct pbuf *p, struct netif *inp)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;93     {
000004  4606              MOV      r6,r0
000006  468a              MOV      r10,r1
;;;94       struct tcp_pcb *pcb, *prev;
;;;95       struct tcp_pcb_listen *lpcb;
;;;96     #if SO_REUSE
;;;97       struct tcp_pcb *lpcb_prev = NULL;
;;;98       struct tcp_pcb_listen *lpcb_any = NULL;
;;;99     #endif /* SO_REUSE */
;;;100      u8_t hdrlen;
;;;101      err_t err;
;;;102    
;;;103      PERF_START;
;;;104    
;;;105      TCP_STATS_INC(tcp.recv);
000008  48f7              LDR      r0,|L1.1000|
00000a  f8b00092          LDRH     r0,[r0,#0x92]
00000e  1c40              ADDS     r0,r0,#1
000010  b281              UXTH     r1,r0
000012  48f5              LDR      r0,|L1.1000|
000014  f8a01092          STRH     r1,[r0,#0x92]
;;;106      snmp_inc_tcpinsegs();
;;;107    
;;;108      iphdr = (struct ip_hdr *)p->payload;
000018  49f4              LDR      r1,|L1.1004|
00001a  6870              LDR      r0,[r6,#4]
00001c  6008              STR      r0,[r1,#0]  ; iphdr
;;;109      tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
00001e  48f3              LDR      r0,|L1.1004|
000020  6871              LDR      r1,[r6,#4]
000022  6800              LDR      r0,[r0,#0]  ; iphdr
000024  7800              LDRB     r0,[r0,#0]
000026  f000000f          AND      r0,r0,#0xf
00002a  eb010080          ADD      r0,r1,r0,LSL #2
00002e  49f0              LDR      r1,|L1.1008|
000030  6008              STR      r0,[r1,#0]  ; tcphdr
;;;110    
;;;111    #if TCP_INPUT_DEBUG
;;;112      tcp_debug_print(tcphdr);
;;;113    #endif
;;;114    
;;;115      /* remove header from payload */
;;;116      if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
000032  48ee              LDR      r0,|L1.1004|
000034  6800              LDR      r0,[r0,#0]  ; iphdr
000036  7800              LDRB     r0,[r0,#0]
000038  0700              LSLS     r0,r0,#28
00003a  0e80              LSRS     r0,r0,#26
00003c  4241              RSBS     r1,r0,#0
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       pbuf_header
000044  b910              CBNZ     r0,|L1.76|
000046  8930              LDRH     r0,[r6,#8]
000048  2814              CMP      r0,#0x14
00004a  d20a              BCS      |L1.98|
                  |L1.76|
;;;117        /* drop short packets */
;;;118        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
00004c  bf00              NOP      
00004e  bf00              NOP      
;;;119        TCP_STATS_INC(tcp.lenerr);
000050  48e5              LDR      r0,|L1.1000|
000052  f8b0009a          LDRH     r0,[r0,#0x9a]
000056  1c40              ADDS     r0,r0,#1
000058  b281              UXTH     r1,r0
00005a  48e3              LDR      r0,|L1.1000|
00005c  f8a0109a          STRH     r1,[r0,#0x9a]
;;;120        goto dropped;
000060  e312              B        |L1.1672|
                  |L1.98|
;;;121      }
;;;122    
;;;123      /* Don't even process incoming broadcasts/multicasts. */
;;;124      if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
000062  49e4              LDR      r1,|L1.1012|
000064  6808              LDR      r0,[r1,#0]  ; current_iphdr_dest
000066  4651              MOV      r1,r10
000068  f7fffffe          BL       ip4_addr_isbroadcast
00006c  b928              CBNZ     r0,|L1.122|
;;;125          ip_addr_ismulticast(&current_iphdr_dest)) {
00006e  48e1              LDR      r0,|L1.1012|
000070  7800              LDRB     r0,[r0,#0]  ; current_iphdr_dest
000072  f00000f0          AND      r0,r0,#0xf0
000076  28e0              CMP      r0,#0xe0
000078  d108              BNE      |L1.140|
                  |L1.122|
;;;126        TCP_STATS_INC(tcp.proterr);
00007a  48db              LDR      r0,|L1.1000|
00007c  f8b000a0          LDRH     r0,[r0,#0xa0]
000080  1c40              ADDS     r0,r0,#1
000082  b281              UXTH     r1,r0
000084  48d8              LDR      r0,|L1.1000|
000086  f8a010a0          STRH     r1,[r0,#0xa0]
;;;127        goto dropped;
00008a  e2fd              B        |L1.1672|
                  |L1.140|
;;;128      }
;;;129    
;;;130    #if CHECKSUM_CHECK_TCP
;;;131      /* Verify TCP checksum. */
;;;132      if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
00008c  8930              LDRH     r0,[r6,#8]
00008e  2306              MOVS     r3,#6
000090  4ad8              LDR      r2,|L1.1012|
000092  49d9              LDR      r1,|L1.1016|
000094  9000              STR      r0,[sp,#0]
000096  4630              MOV      r0,r6
000098  f7fffffe          BL       inet_chksum_pseudo
00009c  b150              CBZ      r0,|L1.180|
;;;133          IP_PROTO_TCP, p->tot_len) != 0) {
;;;134          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
00009e  bf00              NOP      
0000a0  bf00              NOP      
;;;135            inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
;;;136          IP_PROTO_TCP, p->tot_len)));
;;;137    #if TCP_DEBUG
;;;138        tcp_debug_print(tcphdr);
;;;139    #endif /* TCP_DEBUG */
;;;140        TCP_STATS_INC(tcp.chkerr);
0000a2  48d1              LDR      r0,|L1.1000|
0000a4  f8b00098          LDRH     r0,[r0,#0x98]
0000a8  1c40              ADDS     r0,r0,#1
0000aa  b281              UXTH     r1,r0
0000ac  48ce              LDR      r0,|L1.1000|
0000ae  f8a01098          STRH     r1,[r0,#0x98]
;;;141        goto dropped;
0000b2  e2e9              B        |L1.1672|
                  |L1.180|
;;;142      }
;;;143    #endif
;;;144    
;;;145      /* Move the payload pointer in the pbuf so that it points to the
;;;146         TCP data instead of the TCP header. */
;;;147      hdrlen = TCPH_HDRLEN(tcphdr);
0000b4  49ce              LDR      r1,|L1.1008|
0000b6  6809              LDR      r1,[r1,#0]  ; tcphdr
0000b8  8988              LDRH     r0,[r1,#0xc]
0000ba  f7fffffe          BL       lwip_ntohs
0000be  ea4f3920          ASR      r9,r0,#12
;;;148      if(pbuf_header(p, -(hdrlen * 4))){
0000c2  ea4f0089          LSL      r0,r9,#2
0000c6  4241              RSBS     r1,r0,#0
0000c8  4630              MOV      r0,r6
0000ca  f7fffffe          BL       pbuf_header
0000ce  b150              CBZ      r0,|L1.230|
;;;149        /* drop short packets */
;;;150        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
0000d0  bf00              NOP      
0000d2  bf00              NOP      
;;;151        TCP_STATS_INC(tcp.lenerr);
0000d4  48c4              LDR      r0,|L1.1000|
0000d6  f8b0009a          LDRH     r0,[r0,#0x9a]
0000da  1c40              ADDS     r0,r0,#1
0000dc  b281              UXTH     r1,r0
0000de  48c2              LDR      r0,|L1.1000|
0000e0  f8a0109a          STRH     r1,[r0,#0x9a]
;;;152        goto dropped;
0000e4  e2d0              B        |L1.1672|
                  |L1.230|
;;;153      }
;;;154    
;;;155      /* Convert fields in TCP header to host byte order. */
;;;156      tcphdr->src = ntohs(tcphdr->src);
0000e6  49c2              LDR      r1,|L1.1008|
0000e8  6809              LDR      r1,[r1,#0]  ; tcphdr
0000ea  8808              LDRH     r0,[r1,#0]
0000ec  f7fffffe          BL       lwip_ntohs
0000f0  49bf              LDR      r1,|L1.1008|
0000f2  6809              LDR      r1,[r1,#0]  ; tcphdr
0000f4  8008              STRH     r0,[r1,#0]
;;;157      tcphdr->dest = ntohs(tcphdr->dest);
0000f6  49be              LDR      r1,|L1.1008|
0000f8  6809              LDR      r1,[r1,#0]  ; tcphdr
0000fa  8848              LDRH     r0,[r1,#2]
0000fc  f7fffffe          BL       lwip_ntohs
000100  49bb              LDR      r1,|L1.1008|
000102  6809              LDR      r1,[r1,#0]  ; tcphdr
000104  8048              STRH     r0,[r1,#2]
;;;158      seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
000106  49ba              LDR      r1,|L1.1008|
000108  6809              LDR      r1,[r1,#0]  ; tcphdr
00010a  6848              LDR      r0,[r1,#4]
00010c  f7fffffe          BL       lwip_ntohl
000110  49b7              LDR      r1,|L1.1008|
000112  6809              LDR      r1,[r1,#0]  ; tcphdr
000114  6048              STR      r0,[r1,#4]
000116  49b9              LDR      r1,|L1.1020|
000118  6008              STR      r0,[r1,#0]  ; seqno
;;;159      ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
00011a  49b5              LDR      r1,|L1.1008|
00011c  6809              LDR      r1,[r1,#0]  ; tcphdr
00011e  6888              LDR      r0,[r1,#8]
000120  f7fffffe          BL       lwip_ntohl
000124  49b2              LDR      r1,|L1.1008|
000126  6809              LDR      r1,[r1,#0]  ; tcphdr
000128  6088              STR      r0,[r1,#8]
00012a  49b5              LDR      r1,|L1.1024|
00012c  6008              STR      r0,[r1,#0]  ; ackno
;;;160      tcphdr->wnd = ntohs(tcphdr->wnd);
00012e  49b0              LDR      r1,|L1.1008|
000130  6809              LDR      r1,[r1,#0]  ; tcphdr
000132  89c8              LDRH     r0,[r1,#0xe]
000134  f7fffffe          BL       lwip_ntohs
000138  49ad              LDR      r1,|L1.1008|
00013a  6809              LDR      r1,[r1,#0]  ; tcphdr
00013c  81c8              STRH     r0,[r1,#0xe]
;;;161    
;;;162      flags = TCPH_FLAGS(tcphdr);
00013e  49ac              LDR      r1,|L1.1008|
000140  6809              LDR      r1,[r1,#0]  ; tcphdr
000142  8988              LDRH     r0,[r1,#0xc]
000144  f7fffffe          BL       lwip_ntohs
000148  f000003f          AND      r0,r0,#0x3f
00014c  49ad              LDR      r1,|L1.1028|
00014e  7008              STRB     r0,[r1,#0]
;;;163      tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
000150  8930              LDRH     r0,[r6,#8]
000152  7809              LDRB     r1,[r1,#0]  ; flags
000154  f0010103          AND      r1,r1,#3
000158  b109              CBZ      r1,|L1.350|
00015a  2101              MOVS     r1,#1
00015c  e000              B        |L1.352|
                  |L1.350|
00015e  2100              MOVS     r1,#0
                  |L1.352|
000160  4408              ADD      r0,r0,r1
000162  49a9              LDR      r1,|L1.1032|
000164  8008              STRH     r0,[r1,#0]
;;;164    
;;;165      /* Demultiplex an incoming segment. First, we check if it is destined
;;;166         for an active connection. */
;;;167      prev = NULL;
000166  2700              MOVS     r7,#0
;;;168    
;;;169      
;;;170      for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
000168  48a8              LDR      r0,|L1.1036|
00016a  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
00016c  e051              B        |L1.530|
                  |L1.366|
;;;171        LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
00016e  bf00              NOP      
000170  7e20              LDRB     r0,[r4,#0x18]
000172  b920              CBNZ     r0,|L1.382|
000174  a0a6              ADR      r0,|L1.1040|
000176  f7fffffe          BL       __2printf
00017a  bf00              NOP      
                  |L1.380|
00017c  e7fe              B        |L1.380|
                  |L1.382|
00017e  bf00              NOP      
;;;172        LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
000180  bf00              NOP      
000182  7e20              LDRB     r0,[r4,#0x18]
000184  280a              CMP      r0,#0xa
000186  d104              BNE      |L1.402|
000188  a0ab              ADR      r0,|L1.1080|
00018a  f7fffffe          BL       __2printf
00018e  bf00              NOP      
                  |L1.400|
000190  e7fe              B        |L1.400|
                  |L1.402|
000192  bf00              NOP      
;;;173        LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
000194  bf00              NOP      
000196  7e20              LDRB     r0,[r4,#0x18]
000198  2801              CMP      r0,#1
00019a  d104              BNE      |L1.422|
00019c  a0b1              ADR      r0,|L1.1124|
00019e  f7fffffe          BL       __2printf
0001a2  bf00              NOP      
                  |L1.420|
0001a4  e7fe              B        |L1.420|
                  |L1.422|
0001a6  bf00              NOP      
;;;174        if (pcb->remote_port == tcphdr->src &&
0001a8  8ba0              LDRH     r0,[r4,#0x1c]
0001aa  4991              LDR      r1,|L1.1008|
0001ac  6809              LDR      r1,[r1,#0]  ; tcphdr
0001ae  8809              LDRH     r1,[r1,#0]
0001b0  4288              CMP      r0,r1
0001b2  d12c              BNE      |L1.526|
;;;175           pcb->local_port == tcphdr->dest &&
0001b4  8b60              LDRH     r0,[r4,#0x1a]
0001b6  498e              LDR      r1,|L1.1008|
0001b8  6809              LDR      r1,[r1,#0]  ; tcphdr
0001ba  8849              LDRH     r1,[r1,#2]
0001bc  4288              CMP      r0,r1
0001be  d126              BNE      |L1.526|
;;;176           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
0001c0  498d              LDR      r1,|L1.1016|
0001c2  6860              LDR      r0,[r4,#4]
0001c4  6809              LDR      r1,[r1,#0]  ; current_iphdr_src
0001c6  4288              CMP      r0,r1
0001c8  d121              BNE      |L1.526|
;;;177           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
0001ca  498a              LDR      r1,|L1.1012|
0001cc  6820              LDR      r0,[r4,#0]
0001ce  6809              LDR      r1,[r1,#0]  ; current_iphdr_dest
0001d0  4288              CMP      r0,r1
0001d2  d11c              BNE      |L1.526|
;;;178    
;;;179          /* Move this PCB to the front of the list so that subsequent
;;;180             lookups will be faster (we exploit locality in TCP segment
;;;181             arrivals). */
;;;182          LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
0001d4  bf00              NOP      
0001d6  68e0              LDR      r0,[r4,#0xc]
0001d8  42a0              CMP      r0,r4
0001da  d104              BNE      |L1.486|
0001dc  a0ab              ADR      r0,|L1.1164|
0001de  f7fffffe          BL       __2printf
0001e2  bf00              NOP      
                  |L1.484|
0001e4  e7fe              B        |L1.484|
                  |L1.486|
0001e6  bf00              NOP      
;;;183          if (prev != NULL) {
0001e8  b137              CBZ      r7,|L1.504|
;;;184            prev->next = pcb->next;
0001ea  68e0              LDR      r0,[r4,#0xc]
0001ec  60f8              STR      r0,[r7,#0xc]
;;;185            pcb->next = tcp_active_pcbs;
0001ee  4887              LDR      r0,|L1.1036|
0001f0  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
0001f2  60e0              STR      r0,[r4,#0xc]
;;;186            tcp_active_pcbs = pcb;
0001f4  4885              LDR      r0,|L1.1036|
0001f6  6004              STR      r4,[r0,#0]  ; tcp_active_pcbs
                  |L1.504|
;;;187          }
;;;188          LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
0001f8  bf00              NOP      
0001fa  68e0              LDR      r0,[r4,#0xc]
0001fc  42a0              CMP      r0,r4
0001fe  d104              BNE      |L1.522|
000200  a0ad              ADR      r0,|L1.1208|
000202  f7fffffe          BL       __2printf
000206  bf00              NOP      
                  |L1.520|
000208  e7fe              B        |L1.520|
                  |L1.522|
00020a  bf00              NOP      
;;;189          break;
00020c  e003              B        |L1.534|
                  |L1.526|
;;;190        }
;;;191        prev = pcb;
00020e  4627              MOV      r7,r4
000210  68e4              LDR      r4,[r4,#0xc]          ;170
                  |L1.530|
000212  2c00              CMP      r4,#0                 ;170
000214  d1ab              BNE      |L1.366|
                  |L1.534|
000216  bf00              NOP                            ;189
;;;192      }
;;;193    
;;;194      if (pcb == NULL) {
000218  2c00              CMP      r4,#0
00021a  d159              BNE      |L1.720|
;;;195        /* If it did not go to an active connection, we check the connections
;;;196           in the TIME-WAIT state. */
;;;197        for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
00021c  48b1              LDR      r0,|L1.1252|
00021e  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
000220  e02a              B        |L1.632|
                  |L1.546|
;;;198          LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
000222  bf00              NOP      
000224  7e20              LDRB     r0,[r4,#0x18]
000226  280a              CMP      r0,#0xa
000228  d004              BEQ      |L1.564|
00022a  a0af              ADR      r0,|L1.1256|
00022c  f7fffffe          BL       __2printf
000230  bf00              NOP      
                  |L1.562|
000232  e7fe              B        |L1.562|
                  |L1.564|
000234  bf00              NOP      
;;;199          if (pcb->remote_port == tcphdr->src &&
000236  8ba0              LDRH     r0,[r4,#0x1c]
000238  496d              LDR      r1,|L1.1008|
00023a  6809              LDR      r1,[r1,#0]  ; tcphdr
00023c  8809              LDRH     r1,[r1,#0]
00023e  4288              CMP      r0,r1
000240  d119              BNE      |L1.630|
;;;200             pcb->local_port == tcphdr->dest &&
000242  8b60              LDRH     r0,[r4,#0x1a]
000244  496a              LDR      r1,|L1.1008|
000246  6809              LDR      r1,[r1,#0]  ; tcphdr
000248  8849              LDRH     r1,[r1,#2]
00024a  4288              CMP      r0,r1
00024c  d113              BNE      |L1.630|
;;;201             ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
00024e  496a              LDR      r1,|L1.1016|
000250  6860              LDR      r0,[r4,#4]
000252  6809              LDR      r1,[r1,#0]  ; current_iphdr_src
000254  4288              CMP      r0,r1
000256  d10e              BNE      |L1.630|
;;;202             ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
000258  4966              LDR      r1,|L1.1012|
00025a  6820              LDR      r0,[r4,#0]
00025c  6809              LDR      r1,[r1,#0]  ; current_iphdr_dest
00025e  4288              CMP      r0,r1
000260  d109              BNE      |L1.630|
;;;203            /* We don't really care enough to move this PCB to the front
;;;204               of the list since we are not very likely to receive that
;;;205               many segments for connections in TIME-WAIT. */
;;;206            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
000262  bf00              NOP      
000264  bf00              NOP      
;;;207            tcp_timewait_input(pcb);
000266  4620              MOV      r0,r4
000268  f7fffffe          BL       tcp_timewait_input
;;;208            pbuf_free(p);
00026c  4630              MOV      r0,r6
00026e  f7fffffe          BL       pbuf_free
                  |L1.626|
;;;209            return;
;;;210          }
;;;211        }
;;;212    
;;;213        /* Finally, if we still did not get a match, we check all PCBs that
;;;214           are LISTENing for incoming connections. */
;;;215        prev = NULL;
;;;216        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;217          if (lpcb->local_port == tcphdr->dest) {
;;;218    #if SO_REUSE
;;;219            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest)) {
;;;220              /* found an exact match */
;;;221              break;
;;;222            } else if(ip_addr_isany(&(lpcb->local_ip))) {
;;;223              /* found an ANY-match */
;;;224              lpcb_any = lpcb;
;;;225              lpcb_prev = prev;
;;;226            }
;;;227    #else /* SO_REUSE */
;;;228            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
;;;229                ip_addr_isany(&(lpcb->local_ip))) {
;;;230              /* found a match */
;;;231              break;
;;;232            }
;;;233    #endif /* SO_REUSE */
;;;234          }
;;;235          prev = (struct tcp_pcb *)lpcb;
;;;236        }
;;;237    #if SO_REUSE
;;;238        /* first try specific local IP */
;;;239        if (lpcb == NULL) {
;;;240          /* only pass to ANY if no specific local IP has been found */
;;;241          lpcb = lpcb_any;
;;;242          prev = lpcb_prev;
;;;243        }
;;;244    #endif /* SO_REUSE */
;;;245        if (lpcb != NULL) {
;;;246          /* Move this PCB to the front of the list so that subsequent
;;;247             lookups will be faster (we exploit locality in TCP segment
;;;248             arrivals). */
;;;249          if (prev != NULL) {
;;;250            ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
;;;251                  /* our successor is the remainder of the listening list */
;;;252            lpcb->next = tcp_listen_pcbs.listen_pcbs;
;;;253                  /* put this listening pcb at the head of the listening list */
;;;254            tcp_listen_pcbs.listen_pcbs = lpcb;
;;;255          }
;;;256        
;;;257          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
;;;258          tcp_listen_input(lpcb);
;;;259          pbuf_free(p);
;;;260          return;
;;;261        }
;;;262      }
;;;263    
;;;264    #if TCP_INPUT_DEBUG
;;;265      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
;;;266      tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
;;;267      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
;;;268    #endif /* TCP_INPUT_DEBUG */
;;;269    
;;;270    
;;;271      if (pcb != NULL) {
;;;272        /* The incoming segment belongs to a connection. */
;;;273    #if TCP_INPUT_DEBUG
;;;274    #if TCP_DEBUG
;;;275        tcp_debug_print_state(pcb->state);
;;;276    #endif /* TCP_DEBUG */
;;;277    #endif /* TCP_INPUT_DEBUG */
;;;278    
;;;279        /* Set up a tcp_seg structure. */
;;;280        inseg.next = NULL;
;;;281        inseg.len = p->tot_len;
;;;282        inseg.p = p;
;;;283        inseg.tcphdr = tcphdr;
;;;284    
;;;285        recv_data = NULL;
;;;286        recv_flags = 0;
;;;287    
;;;288        if (flags & TCP_PSH) {
;;;289          p->flags |= PBUF_FLAG_PUSH;
;;;290        }
;;;291    
;;;292        /* If there is data which was previously "refused" by upper layer */
;;;293        if (pcb->refused_data != NULL) {
;;;294          if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
;;;295            ((pcb->refused_data != NULL) && (tcplen > 0))) {
;;;296            /* pcb has been aborted or refused data is still refused and the new
;;;297               segment contains data */
;;;298            TCP_STATS_INC(tcp.drop);
;;;299            snmp_inc_tcpinerrs();
;;;300            goto aborted;
;;;301          }
;;;302        }
;;;303        tcp_input_pcb = pcb;
;;;304        err = tcp_process(pcb);
;;;305        /* A return value of ERR_ABRT means that tcp_abort() was called
;;;306           and that the pcb has been freed. If so, we don't do anything. */
;;;307        if (err != ERR_ABRT) {
;;;308          if (recv_flags & TF_RESET) {
;;;309            /* TF_RESET means that the connection was reset by the other
;;;310               end. We then call the error callback to inform the
;;;311               application that the connection is dead before we
;;;312               deallocate the PCB. */
;;;313            TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
;;;314            tcp_pcb_remove(&tcp_active_pcbs, pcb);
;;;315            memp_free(MEMP_TCP_PCB, pcb);
;;;316          } else if (recv_flags & TF_CLOSED) {
;;;317            /* The connection has been closed and we will deallocate the
;;;318               PCB. */
;;;319            if (!(pcb->flags & TF_RXCLOSED)) {
;;;320              /* Connection closed although the application has only shut down the
;;;321                 tx side: call the PCB's err callback and indicate the closure to
;;;322                 ensure the application doesn't continue using the PCB. */
;;;323              TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
;;;324            }
;;;325            tcp_pcb_remove(&tcp_active_pcbs, pcb);
;;;326            memp_free(MEMP_TCP_PCB, pcb);
;;;327          } else {
;;;328            err = ERR_OK;
;;;329            /* If the application has registered a "sent" function to be
;;;330               called when new send buffer space is available, we call it
;;;331               now. */
;;;332            if (pcb->acked > 0) {
;;;333              TCP_EVENT_SENT(pcb, pcb->acked, err);
;;;334              if (err == ERR_ABRT) {
;;;335                goto aborted;
;;;336              }
;;;337            }
;;;338    
;;;339            if (recv_data != NULL) {
;;;340              LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
;;;341              if (pcb->flags & TF_RXCLOSED) {
;;;342                /* received data although already closed -> abort (send RST) to
;;;343                   notify the remote host that not all data has been processed */
;;;344                pbuf_free(recv_data);
;;;345                tcp_abort(pcb);
;;;346                goto aborted;
;;;347              }
;;;348    
;;;349              /* Notify application that data has been received. */
;;;350              TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
;;;351              if (err == ERR_ABRT) {
;;;352                goto aborted;
;;;353              }
;;;354    
;;;355              /* If the upper layer can't receive this data, store it */
;;;356              if (err != ERR_OK) {
;;;357                pcb->refused_data = recv_data;
;;;358                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"\n"));
;;;359              }
;;;360            }
;;;361    
;;;362            /* If a FIN segment was received, we call the callback
;;;363               function with a NULL buffer to indicate EOF. */
;;;364            if (recv_flags & TF_GOT_FIN) {
;;;365              if (pcb->refused_data != NULL) {
;;;366                /* Delay this if we have refused data. */
;;;367                pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
;;;368              } else {
;;;369                /* correct rcv_wnd as the application won't call tcp_recved()
;;;370                   for the FIN's seqno */
;;;371                if (pcb->rcv_wnd != TCP_WND) {
;;;372                  pcb->rcv_wnd++;
;;;373                }
;;;374                TCP_EVENT_CLOSED(pcb, err);
;;;375                if (err == ERR_ABRT) {
;;;376                  goto aborted;
;;;377                }
;;;378              }
;;;379            }
;;;380    
;;;381            tcp_input_pcb = NULL;
;;;382            /* Try to send something out. */
;;;383            tcp_output(pcb);
;;;384    #if TCP_INPUT_DEBUG
;;;385    #if TCP_DEBUG
;;;386            tcp_debug_print_state(pcb->state);
;;;387    #endif /* TCP_DEBUG */
;;;388    #endif /* TCP_INPUT_DEBUG */
;;;389          }
;;;390        }
;;;391        /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
;;;392           Below this line, 'pcb' may not be dereferenced! */
;;;393    aborted:
;;;394        tcp_input_pcb = NULL;
;;;395        recv_data = NULL;
;;;396    
;;;397        /* give up our reference to inseg.p */
;;;398        if (inseg.p != NULL)
;;;399        {
;;;400          pbuf_free(inseg.p);
;;;401          inseg.p = NULL;
;;;402        }
;;;403      } else {
;;;404    
;;;405        /* If no matching PCB was found, send a TCP RST (reset) to the
;;;406           sender. */
;;;407        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
;;;408        if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
;;;409          TCP_STATS_INC(tcp.proterr);
;;;410          TCP_STATS_INC(tcp.drop);
;;;411          tcp_rst(ackno, seqno + tcplen,
;;;412            ip_current_dest_addr(), ip_current_src_addr(),
;;;413            tcphdr->dest, tcphdr->src);
;;;414        }
;;;415        pbuf_free(p);
;;;416      }
;;;417    
;;;418      LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;419      PERF_STOP("tcp_input");
;;;420      return;
;;;421    dropped:
;;;422      TCP_STATS_INC(tcp.drop);
;;;423      snmp_inc_tcpinerrs();
;;;424      pbuf_free(p);
;;;425    }
000272  e8bd87fc          POP      {r2-r10,pc}
                  |L1.630|
000276  68e4              LDR      r4,[r4,#0xc]          ;197
                  |L1.632|
000278  2c00              CMP      r4,#0                 ;197
00027a  d1d2              BNE      |L1.546|
00027c  2700              MOVS     r7,#0                 ;215
00027e  48a6              LDR      r0,|L1.1304|
000280  6805              LDR      r5,[r0,#0]            ;216  ; tcp_listen_pcbs
000282  e010              B        |L1.678|
                  |L1.644|
000284  8b68              LDRH     r0,[r5,#0x1a]         ;217
000286  495a              LDR      r1,|L1.1008|
000288  6809              LDR      r1,[r1,#0]            ;217  ; tcphdr
00028a  8849              LDRH     r1,[r1,#2]            ;217
00028c  4288              CMP      r0,r1                 ;217
00028e  d108              BNE      |L1.674|
000290  4958              LDR      r1,|L1.1012|
000292  6828              LDR      r0,[r5,#0]            ;228
000294  6809              LDR      r1,[r1,#0]            ;228  ; current_iphdr_dest
000296  4288              CMP      r0,r1                 ;228
000298  d002              BEQ      |L1.672|
00029a  b10d              CBZ      r5,|L1.672|
00029c  6828              LDR      r0,[r5,#0]            ;229
00029e  b900              CBNZ     r0,|L1.674|
                  |L1.672|
0002a0  e003              B        |L1.682|
                  |L1.674|
0002a2  462f              MOV      r7,r5                 ;235
0002a4  68ed              LDR      r5,[r5,#0xc]          ;216
                  |L1.678|
0002a6  2d00              CMP      r5,#0                 ;216
0002a8  d1ec              BNE      |L1.644|
                  |L1.682|
0002aa  bf00              NOP                            ;231
0002ac  b185              CBZ      r5,|L1.720|
0002ae  b137              CBZ      r7,|L1.702|
0002b0  68e8              LDR      r0,[r5,#0xc]          ;250
0002b2  60f8              STR      r0,[r7,#0xc]          ;250
0002b4  4898              LDR      r0,|L1.1304|
0002b6  6800              LDR      r0,[r0,#0]            ;252  ; tcp_listen_pcbs
0002b8  60e8              STR      r0,[r5,#0xc]          ;252
0002ba  4897              LDR      r0,|L1.1304|
0002bc  6005              STR      r5,[r0,#0]            ;254  ; tcp_listen_pcbs
                  |L1.702|
0002be  bf00              NOP                            ;257
0002c0  bf00              NOP                            ;257
0002c2  4628              MOV      r0,r5                 ;258
0002c4  f7fffffe          BL       tcp_listen_input
0002c8  4630              MOV      r0,r6                 ;259
0002ca  f7fffffe          BL       pbuf_free
0002ce  e7d0              B        |L1.626|
                  |L1.720|
0002d0  2c00              CMP      r4,#0                 ;271
0002d2  d07d              BEQ      |L1.976|
0002d4  2000              MOVS     r0,#0                 ;280
0002d6  4991              LDR      r1,|L1.1308|
0002d8  6008              STR      r0,[r1,#0]            ;280  ; inseg
0002da  8930              LDRH     r0,[r6,#8]            ;281
0002dc  8108              STRH     r0,[r1,#8]            ;281
0002de  4608              MOV      r0,r1                 ;282
0002e0  6046              STR      r6,[r0,#4]            ;282  ; inseg
0002e2  4843              LDR      r0,|L1.1008|
0002e4  6800              LDR      r0,[r0,#0]            ;283  ; tcphdr
0002e6  6108              STR      r0,[r1,#0x10]         ;283  ; inseg
0002e8  2000              MOVS     r0,#0                 ;285
0002ea  498d              LDR      r1,|L1.1312|
0002ec  6008              STR      r0,[r1,#0]            ;285  ; recv_data
0002ee  498d              LDR      r1,|L1.1316|
0002f0  7008              STRB     r0,[r1,#0]            ;286
0002f2  4844              LDR      r0,|L1.1028|
0002f4  7800              LDRB     r0,[r0,#0]            ;288  ; flags
0002f6  f0000008          AND      r0,r0,#8              ;288
0002fa  b118              CBZ      r0,|L1.772|
0002fc  7b70              LDRB     r0,[r6,#0xd]          ;289
0002fe  f0400001          ORR      r0,r0,#1              ;289
000302  7370              STRB     r0,[r6,#0xd]          ;289
                  |L1.772|
000304  6fa0              LDR      r0,[r4,#0x78]         ;293
000306  b198              CBZ      r0,|L1.816|
000308  4620              MOV      r0,r4                 ;294
00030a  f7fffffe          BL       tcp_process_refused_data
00030e  300a              ADDS     r0,r0,#0xa            ;294
000310  b128              CBZ      r0,|L1.798|
000312  6fa0              LDR      r0,[r4,#0x78]         ;295
000314  b160              CBZ      r0,|L1.816|
000316  483c              LDR      r0,|L1.1032|
000318  8800              LDRH     r0,[r0,#0]            ;295  ; tcplen
00031a  2800              CMP      r0,#0                 ;295
00031c  dd08              BLE      |L1.816|
                  |L1.798|
00031e  4832              LDR      r0,|L1.1000|
000320  f8b00096          LDRH     r0,[r0,#0x96]         ;298
000324  1c40              ADDS     r0,r0,#1              ;298
000326  b281              UXTH     r1,r0                 ;298
000328  482f              LDR      r0,|L1.1000|
00032a  f8a01096          STRH     r1,[r0,#0x96]         ;298
00032e  e169              B        |L1.1540|
                  |L1.816|
000330  487d              LDR      r0,|L1.1320|
000332  6004              STR      r4,[r0,#0]            ;303  ; tcp_input_pcb
000334  4620              MOV      r0,r4                 ;304
000336  f7fffffe          BL       tcp_process
00033a  4680              MOV      r8,r0                 ;304
00033c  f108000a          ADD      r0,r8,#0xa            ;307
000340  2800              CMP      r0,#0                 ;307
000342  d017              BEQ      |L1.884|
000344  4877              LDR      r0,|L1.1316|
000346  7800              LDRB     r0,[r0,#0]            ;308  ; recv_flags
000348  f0000008          AND      r0,r0,#8              ;308
00034c  b198              CBZ      r0,|L1.886|
00034e  bf00              NOP                            ;313
000350  f8d4008c          LDR      r0,[r4,#0x8c]         ;313
000354  b128              CBZ      r0,|L1.866|
000356  f06f010a          MVN      r1,#0xa               ;313
00035a  f8d4208c          LDR      r2,[r4,#0x8c]         ;313
00035e  6920              LDR      r0,[r4,#0x10]         ;313
000360  4790              BLX      r2                    ;313
                  |L1.866|
000362  bf00              NOP                            ;313
000364  4621              MOV      r1,r4                 ;314
000366  4829              LDR      r0,|L1.1036|
000368  f7fffffe          BL       tcp_pcb_remove
00036c  4621              MOV      r1,r4                 ;315
00036e  2002              MOVS     r0,#2                 ;315
000370  f7fffffe          BL       memp_free
                  |L1.884|
000374  e145              B        |L1.1538|
                  |L1.886|
000376  486b              LDR      r0,|L1.1316|
000378  7800              LDRB     r0,[r0,#0]            ;316  ; recv_flags
00037a  f0000010          AND      r0,r0,#0x10           ;316
00037e  b1b8              CBZ      r0,|L1.944|
000380  7fa0              LDRB     r0,[r4,#0x1e]         ;319
000382  f0000010          AND      r0,r0,#0x10           ;319
000386  b950              CBNZ     r0,|L1.926|
000388  bf00              NOP                            ;323
00038a  f8d4008c          LDR      r0,[r4,#0x8c]         ;323
00038e  b128              CBZ      r0,|L1.924|
000390  f06f010b          MVN      r1,#0xb               ;323
000394  f8d4208c          LDR      r2,[r4,#0x8c]         ;323
000398  6920              LDR      r0,[r4,#0x10]         ;323
00039a  4790              BLX      r2                    ;323
                  |L1.924|
00039c  bf00              NOP                            ;323
                  |L1.926|
00039e  4621              MOV      r1,r4                 ;325
0003a0  481a              LDR      r0,|L1.1036|
0003a2  f7fffffe          BL       tcp_pcb_remove
0003a6  4621              MOV      r1,r4                 ;326
0003a8  2002              MOVS     r0,#2                 ;326
0003aa  f7fffffe          BL       memp_free
0003ae  e128              B        |L1.1538|
                  |L1.944|
0003b0  f04f0800          MOV      r8,#0                 ;328
0003b4  f8b40064          LDRH     r0,[r4,#0x64]         ;332
0003b8  2800              CMP      r0,#0                 ;332
0003ba  dd13              BLE      |L1.996|
0003bc  bf00              NOP                            ;333
0003be  6fe0              LDR      r0,[r4,#0x7c]         ;333
0003c0  b148              CBZ      r0,|L1.982|
0003c2  f8b42064          LDRH     r2,[r4,#0x64]         ;333
0003c6  4621              MOV      r1,r4                 ;333
0003c8  6fe3              LDR      r3,[r4,#0x7c]         ;333
0003ca  6920              LDR      r0,[r4,#0x10]         ;333
0003cc  4798              BLX      r3                    ;333
0003ce  e000              B        |L1.978|
                  |L1.976|
0003d0  e128              B        |L1.1572|
                  |L1.978|
0003d2  4680              MOV      r8,r0                 ;333
0003d4  e001              B        |L1.986|
                  |L1.982|
0003d6  f04f0800          MOV      r8,#0                 ;333
                  |L1.986|
0003da  bf00              NOP                            ;333
0003dc  f108000a          ADD      r0,r8,#0xa            ;334
0003e0  b900              CBNZ     r0,|L1.996|
0003e2  e10f              B        |L1.1540|
                  |L1.996|
0003e4  e0a2              B        |L1.1324|
0003e6  0000              DCW      0x0000
                  |L1.1000|
                          DCD      lwip_stats
                  |L1.1004|
                          DCD      iphdr
                  |L1.1008|
                          DCD      tcphdr
                  |L1.1012|
                          DCD      current_iphdr_dest
                  |L1.1016|
                          DCD      current_iphdr_src
                  |L1.1020|
                          DCD      seqno
                  |L1.1024|
                          DCD      ackno
                  |L1.1028|
                          DCD      flags
                  |L1.1032|
                          DCD      tcplen
                  |L1.1036|
                          DCD      tcp_active_pcbs
                  |L1.1040|
000410  7463705f          DCB      "tcp_input: active pcb->state != CLOSED",0
000414  696e7075
000418  743a2061
00041c  63746976
000420  65207063
000424  622d3e73
000428  74617465
00042c  20213d20
000430  434c4f53
000434  454400  
000437  00                DCB      0
                  |L1.1080|
000438  7463705f          DCB      "tcp_input: active pcb->state != TIME-WAIT",0
00043c  696e7075
000440  743a2061
000444  63746976
000448  65207063
00044c  622d3e73
000450  74617465
000454  20213d20
000458  54494d45
00045c  2d574149
000460  5400    
000462  00                DCB      0
000463  00                DCB      0
                  |L1.1124|
000464  7463705f          DCB      "tcp_input: active pcb->state != LISTEN",0
000468  696e7075
00046c  743a2061
000470  63746976
000474  65207063
000478  622d3e73
00047c  74617465
000480  20213d20
000484  4c495354
000488  454e00  
00048b  00                DCB      0
                  |L1.1164|
00048c  7463705f          DCB      "tcp_input: pcb->next != pcb (before cache)",0
000490  696e7075
000494  743a2070
000498  63622d3e
00049c  6e657874
0004a0  20213d20
0004a4  70636220
0004a8  28626566
0004ac  6f726520
0004b0  63616368
0004b4  652900  
0004b7  00                DCB      0
                  |L1.1208|
0004b8  7463705f          DCB      "tcp_input: pcb->next != pcb (after cache)",0
0004bc  696e7075
0004c0  743a2070
0004c4  63622d3e
0004c8  6e657874
0004cc  20213d20
0004d0  70636220
0004d4  28616674
0004d8  65722063
0004dc  61636865
0004e0  2900    
0004e2  00                DCB      0
0004e3  00                DCB      0
                  |L1.1252|
                          DCD      tcp_tw_pcbs
                  |L1.1256|
0004e8  7463705f          DCB      "tcp_input: TIME-WAIT pcb->state == TIME-WAIT",0
0004ec  696e7075
0004f0  743a2054
0004f4  494d452d
0004f8  57414954
0004fc  20706362
000500  2d3e7374
000504  61746520
000508  3d3d2054
00050c  494d452d
000510  57414954
000514  00      
000515  00                DCB      0
000516  00                DCB      0
000517  00                DCB      0
                  |L1.1304|
                          DCD      tcp_listen_pcbs
                  |L1.1308|
                          DCD      inseg
                  |L1.1312|
                          DCD      recv_data
                  |L1.1316|
                          DCD      recv_flags
                  |L1.1320|
                          DCD      tcp_input_pcb
                  |L1.1324|
00052c  485d              LDR      r0,|L1.1700|
00052e  6800              LDR      r0,[r0,#0]            ;339  ; recv_data
000530  b378              CBZ      r0,|L1.1426|
000532  bf00              NOP                            ;340
000534  6fa0              LDR      r0,[r4,#0x78]         ;340
000536  b120              CBZ      r0,|L1.1346|
000538  a05b              ADR      r0,|L1.1704|
00053a  f7fffffe          BL       __2printf
00053e  bf00              NOP                            ;340
                  |L1.1344|
000540  e7fe              B        |L1.1344|
                  |L1.1346|
000542  bf00              NOP                            ;340
000544  7fa0              LDRB     r0,[r4,#0x1e]         ;341
000546  f0000010          AND      r0,r0,#0x10           ;341
00054a  b138              CBZ      r0,|L1.1372|
00054c  4855              LDR      r0,|L1.1700|
00054e  6800              LDR      r0,[r0,#0]            ;344  ; recv_data
000550  f7fffffe          BL       pbuf_free
000554  4620              MOV      r0,r4                 ;345
000556  f7fffffe          BL       tcp_abort
00055a  e053              B        |L1.1540|
                  |L1.1372|
00055c  bf00              NOP                            ;350
00055e  f8d40080          LDR      r0,[r4,#0x80]         ;350
000562  b148              CBZ      r0,|L1.1400|
000564  2300              MOVS     r3,#0                 ;350
000566  494f              LDR      r1,|L1.1700|
000568  f8d4c080          LDR      r12,[r4,#0x80]        ;350
00056c  6920              LDR      r0,[r4,#0x10]         ;350
00056e  680a              LDR      r2,[r1,#0]            ;350  ; recv_data
000570  4621              MOV      r1,r4                 ;350
000572  47e0              BLX      r12                   ;350
000574  4680              MOV      r8,r0                 ;350
000576  e007              B        |L1.1416|
                  |L1.1400|
000578  2300              MOVS     r3,#0                 ;350
00057a  484a              LDR      r0,|L1.1700|
00057c  4621              MOV      r1,r4                 ;350
00057e  6802              LDR      r2,[r0,#0]            ;350  ; recv_data
000580  4618              MOV      r0,r3                 ;350
000582  f7fffffe          BL       tcp_recv_null
000586  4680              MOV      r8,r0                 ;350
                  |L1.1416|
000588  bf00              NOP                            ;350
00058a  f108000a          ADD      r0,r8,#0xa            ;351
00058e  b908              CBNZ     r0,|L1.1428|
000590  e038              B        |L1.1540|
                  |L1.1426|
000592  e007              B        |L1.1444|
                  |L1.1428|
000594  f1b80f00          CMP      r8,#0                 ;356
000598  d004              BEQ      |L1.1444|
00059a  4842              LDR      r0,|L1.1700|
00059c  6800              LDR      r0,[r0,#0]            ;357  ; recv_data
00059e  67a0              STR      r0,[r4,#0x78]         ;357
0005a0  bf00              NOP                            ;358
0005a2  bf00              NOP                            ;358
                  |L1.1444|
0005a4  4847              LDR      r0,|L1.1732|
0005a6  7800              LDRB     r0,[r0,#0]            ;364  ; recv_flags
0005a8  f0000020          AND      r0,r0,#0x20           ;364
0005ac  b318              CBZ      r0,|L1.1526|
0005ae  6fa0              LDR      r0,[r4,#0x78]         ;365
0005b0  b130              CBZ      r0,|L1.1472|
0005b2  6fa0              LDR      r0,[r4,#0x78]         ;367
0005b4  7b40              LDRB     r0,[r0,#0xd]          ;367
0005b6  f0400020          ORR      r0,r0,#0x20           ;367
0005ba  6fa1              LDR      r1,[r4,#0x78]         ;367
0005bc  7348              STRB     r0,[r1,#0xd]          ;367
0005be  e01a              B        |L1.1526|
                  |L1.1472|
0005c0  8da0              LDRH     r0,[r4,#0x2c]         ;371
0005c2  f5b06f7a          CMP      r0,#0xfa0             ;371
0005c6  d002              BEQ      |L1.1486|
0005c8  8da0              LDRH     r0,[r4,#0x2c]         ;372
0005ca  1c40              ADDS     r0,r0,#1              ;372
0005cc  85a0              STRH     r0,[r4,#0x2c]         ;372
                  |L1.1486|
0005ce  bf00              NOP                            ;374
0005d0  f8d40080          LDR      r0,[r4,#0x80]         ;374
0005d4  b140              CBZ      r0,|L1.1512|
0005d6  2300              MOVS     r3,#0                 ;374
0005d8  461a              MOV      r2,r3                 ;374
0005da  4621              MOV      r1,r4                 ;374
0005dc  f8d4c080          LDR      r12,[r4,#0x80]        ;374
0005e0  6920              LDR      r0,[r4,#0x10]         ;374
0005e2  47e0              BLX      r12                   ;374
0005e4  4680              MOV      r8,r0                 ;374
0005e6  e001              B        |L1.1516|
                  |L1.1512|
0005e8  f04f0800          MOV      r8,#0                 ;374
                  |L1.1516|
0005ec  bf00              NOP                            ;374
0005ee  f108000a          ADD      r0,r8,#0xa            ;375
0005f2  b900              CBNZ     r0,|L1.1526|
0005f4  e006              B        |L1.1540|
                  |L1.1526|
0005f6  2000              MOVS     r0,#0                 ;381
0005f8  4933              LDR      r1,|L1.1736|
0005fa  6008              STR      r0,[r1,#0]            ;381  ; tcp_input_pcb
0005fc  4620              MOV      r0,r4                 ;383
0005fe  f7fffffe          BL       tcp_output
                  |L1.1538|
000602  bf00              NOP                            ;393
                  |L1.1540|
000604  2000              MOVS     r0,#0                 ;394
000606  4930              LDR      r1,|L1.1736|
000608  6008              STR      r0,[r1,#0]            ;394  ; tcp_input_pcb
00060a  4926              LDR      r1,|L1.1700|
00060c  6008              STR      r0,[r1,#0]            ;395  ; recv_data
00060e  482f              LDR      r0,|L1.1740|
000610  6840              LDR      r0,[r0,#4]            ;398  ; inseg
000612  b3b0              CBZ      r0,|L1.1666|
000614  492d              LDR      r1,|L1.1740|
000616  6848              LDR      r0,[r1,#4]            ;400  ; inseg
000618  f7fffffe          BL       pbuf_free
00061c  2000              MOVS     r0,#0                 ;401
00061e  492b              LDR      r1,|L1.1740|
000620  6048              STR      r0,[r1,#4]            ;401  ; inseg
000622  e02e              B        |L1.1666|
                  |L1.1572|
000624  bf00              NOP                            ;407
000626  bf00              NOP                            ;407
000628  4929              LDR      r1,|L1.1744|
00062a  6809              LDR      r1,[r1,#0]            ;408  ; tcphdr
00062c  8988              LDRH     r0,[r1,#0xc]          ;408
00062e  f7fffffe          BL       lwip_ntohs
000632  f0000004          AND      r0,r0,#4              ;408
000636  bb08              CBNZ     r0,|L1.1660|
000638  4826              LDR      r0,|L1.1748|
00063a  f8b000a0          LDRH     r0,[r0,#0xa0]         ;409
00063e  1c40              ADDS     r0,r0,#1              ;409
000640  b281              UXTH     r1,r0                 ;409
000642  4824              LDR      r0,|L1.1748|
000644  f8a010a0          STRH     r1,[r0,#0xa0]         ;409
000648  f8b00096          LDRH     r0,[r0,#0x96]         ;410
00064c  1c40              ADDS     r0,r0,#1              ;410
00064e  b281              UXTH     r1,r0                 ;410
000650  4820              LDR      r0,|L1.1748|
000652  f8a01096          STRH     r1,[r0,#0x96]         ;410
000656  481e              LDR      r0,|L1.1744|
000658  6800              LDR      r0,[r0,#0]            ;411  ; tcphdr
00065a  8800              LDRH     r0,[r0,#0]            ;411
00065c  491c              LDR      r1,|L1.1744|
00065e  6809              LDR      r1,[r1,#0]            ;411  ; tcphdr
000660  8849              LDRH     r1,[r1,#2]            ;411
000662  e9cd1000          STRD     r1,r0,[sp,#0]         ;411
000666  481c              LDR      r0,|L1.1752|
000668  6800              LDR      r0,[r0,#0]            ;411  ; seqno
00066a  4a1c              LDR      r2,|L1.1756|
00066c  8812              LDRH     r2,[r2,#0]            ;411  ; tcplen
00066e  1881              ADDS     r1,r0,r2              ;411
000670  4b1b              LDR      r3,|L1.1760|
000672  4a1c              LDR      r2,|L1.1764|
000674  481c              LDR      r0,|L1.1768|
000676  6800              LDR      r0,[r0,#0]            ;411  ; ackno
000678  f7fffffe          BL       tcp_rst
                  |L1.1660|
00067c  4630              MOV      r0,r6                 ;415
00067e  f7fffffe          BL       pbuf_free
                  |L1.1666|
000682  bf00              NOP                            ;418
000684  bf00              NOP                            ;418
000686  e5f4              B        |L1.626|
                  |L1.1672|
000688  4812              LDR      r0,|L1.1748|
00068a  f8b00096          LDRH     r0,[r0,#0x96]         ;422
00068e  1c40              ADDS     r0,r0,#1              ;422
000690  b281              UXTH     r1,r0                 ;422
000692  4810              LDR      r0,|L1.1748|
000694  f8a01096          STRH     r1,[r0,#0x96]         ;422
000698  4630              MOV      r0,r6                 ;424
00069a  f7fffffe          BL       pbuf_free
00069e  bf00              NOP      
0006a0  e5e7              B        |L1.626|
;;;426    
                          ENDP

0006a2  0000              DCW      0x0000
                  |L1.1700|
                          DCD      recv_data
                  |L1.1704|
0006a8  7063622d          DCB      "pcb->refused_data == NULL",0
0006ac  3e726566
0006b0  75736564
0006b4  5f646174
0006b8  61203d3d
0006bc  204e554c
0006c0  4c00    
0006c2  00                DCB      0
0006c3  00                DCB      0
                  |L1.1732|
                          DCD      recv_flags
                  |L1.1736|
                          DCD      tcp_input_pcb
                  |L1.1740|
                          DCD      inseg
                  |L1.1744|
                          DCD      tcphdr
                  |L1.1748|
                          DCD      lwip_stats
                  |L1.1752|
                          DCD      seqno
                  |L1.1756|
                          DCD      tcplen
                  |L1.1760|
                          DCD      current_iphdr_src
                  |L1.1764|
                          DCD      current_iphdr_dest
                  |L1.1768|
                          DCD      ackno

                          AREA ||i.tcp_listen_input||, CODE, READONLY, ALIGN=2

                  tcp_listen_input PROC
;;;439    static err_t
;;;440    tcp_listen_input(struct tcp_pcb_listen *pcb)
000000  b57c              PUSH     {r2-r6,lr}
;;;441    {
000002  4605              MOV      r5,r0
;;;442      struct tcp_pcb *npcb;
;;;443      err_t rc;
;;;444    
;;;445      if (flags & TCP_RST) {
000004  4848              LDR      r0,|L2.296|
000006  7800              LDRB     r0,[r0,#0]  ; flags
000008  f0000004          AND      r0,r0,#4
00000c  b108              CBZ      r0,|L2.18|
;;;446        /* An incoming RST should be ignored. Return. */
;;;447        return ERR_OK;
00000e  2000              MOVS     r0,#0
                  |L2.16|
;;;448      }
;;;449    
;;;450      /* In the LISTEN state, we check for incoming SYN segments,
;;;451         creates a new PCB, and responds with a SYN|ACK. */
;;;452      if (flags & TCP_ACK) {
;;;453        /* For incoming segments with the ACK flag set, respond with a
;;;454           RST. */
;;;455        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
;;;456        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
;;;457          ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;458      } else if (flags & TCP_SYN) {
;;;459        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
;;;460    #if TCP_LISTEN_BACKLOG
;;;461        if (pcb->accepts_pending >= pcb->backlog) {
;;;462          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
;;;463          return ERR_ABRT;
;;;464        }
;;;465    #endif /* TCP_LISTEN_BACKLOG */
;;;466        npcb = tcp_alloc(pcb->prio);
;;;467        /* If a new PCB could not be created (probably due to lack of memory),
;;;468           we don't do anything, but rely on the sender will retransmit the
;;;469           SYN at a time when we have more memory available. */
;;;470        if (npcb == NULL) {
;;;471          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
;;;472          TCP_STATS_INC(tcp.memerr);
;;;473          return ERR_MEM;
;;;474        }
;;;475    #if TCP_LISTEN_BACKLOG
;;;476        pcb->accepts_pending++;
;;;477    #endif /* TCP_LISTEN_BACKLOG */
;;;478        /* Set up the new PCB. */
;;;479        ip_addr_copy(npcb->local_ip, current_iphdr_dest);
;;;480        npcb->local_port = pcb->local_port;
;;;481        ip_addr_copy(npcb->remote_ip, current_iphdr_src);
;;;482        npcb->remote_port = tcphdr->src;
;;;483        npcb->state = SYN_RCVD;
;;;484        npcb->rcv_nxt = seqno + 1;
;;;485        npcb->rcv_ann_right_edge = npcb->rcv_nxt;
;;;486        npcb->snd_wnd = tcphdr->wnd;
;;;487        npcb->snd_wnd_max = tcphdr->wnd;
;;;488        npcb->ssthresh = npcb->snd_wnd;
;;;489        npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
;;;490        npcb->callback_arg = pcb->callback_arg;
;;;491    #if LWIP_CALLBACK_API
;;;492        npcb->accept = pcb->accept;
;;;493    #endif /* LWIP_CALLBACK_API */
;;;494        /* inherit socket options */
;;;495        npcb->so_options = pcb->so_options & SOF_INHERITED;
;;;496        /* Register the new PCB so that we can begin receiving segments
;;;497           for it. */
;;;498        TCP_REG_ACTIVE(npcb);
;;;499    
;;;500        /* Parse any options in the SYN. */
;;;501        tcp_parseopt(npcb);
;;;502    #if TCP_CALCULATE_EFF_SEND_MSS
;;;503        npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
;;;504    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;505    
;;;506        snmp_inc_tcppassiveopens();
;;;507    
;;;508        /* Send a SYN|ACK together with the MSS option. */
;;;509        rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
;;;510        if (rc != ERR_OK) {
;;;511          tcp_abandon(npcb, 0);
;;;512          return rc;
;;;513        }
;;;514        return tcp_output(npcb);
;;;515      }
;;;516      return ERR_OK;
;;;517    }
000010  bd7c              POP      {r2-r6,pc}
                  |L2.18|
000012  4845              LDR      r0,|L2.296|
000014  7800              LDRB     r0,[r0,#0]            ;452  ; flags
000016  f0000010          AND      r0,r0,#0x10           ;452
00001a  b1a8              CBZ      r0,|L2.72|
00001c  bf00              NOP                            ;455
00001e  bf00              NOP                            ;455
000020  4842              LDR      r0,|L2.300|
000022  6800              LDR      r0,[r0,#0]            ;456  ; tcphdr
000024  8800              LDRH     r0,[r0,#0]            ;456
000026  4941              LDR      r1,|L2.300|
000028  6809              LDR      r1,[r1,#0]            ;456  ; tcphdr
00002a  8849              LDRH     r1,[r1,#2]            ;456
00002c  e9cd1000          STRD     r1,r0,[sp,#0]         ;456
000030  483f              LDR      r0,|L2.304|
000032  6800              LDR      r0,[r0,#0]            ;456  ; seqno
000034  4a3f              LDR      r2,|L2.308|
000036  8812              LDRH     r2,[r2,#0]            ;456  ; tcplen
000038  1881              ADDS     r1,r0,r2              ;456
00003a  4b3f              LDR      r3,|L2.312|
00003c  4a3f              LDR      r2,|L2.316|
00003e  4840              LDR      r0,|L2.320|
000040  6800              LDR      r0,[r0,#0]            ;456  ; ackno
000042  f7fffffe          BL       tcp_rst
000046  e06d              B        |L2.292|
                  |L2.72|
000048  4837              LDR      r0,|L2.296|
00004a  7800              LDRB     r0,[r0,#0]            ;458  ; flags
00004c  f0000002          AND      r0,r0,#2              ;458
000050  2800              CMP      r0,#0                 ;458
000052  d067              BEQ      |L2.292|
000054  bf00              NOP                            ;459
000056  bf00              NOP                            ;459
000058  7e68              LDRB     r0,[r5,#0x19]         ;466
00005a  f7fffffe          BL       tcp_alloc
00005e  4604              MOV      r4,r0                 ;466
000060  b964              CBNZ     r4,|L2.124|
000062  bf00              NOP                            ;471
000064  bf00              NOP                            ;471
000066  4837              LDR      r0,|L2.324|
000068  f8b0009c          LDRH     r0,[r0,#0x9c]         ;472
00006c  1c40              ADDS     r0,r0,#1              ;472
00006e  b281              UXTH     r1,r0                 ;472
000070  4834              LDR      r0,|L2.324|
000072  f8a0109c          STRH     r1,[r0,#0x9c]         ;472
000076  f04f30ff          MOV      r0,#0xffffffff        ;473
00007a  e7c9              B        |L2.16|
                  |L2.124|
00007c  482f              LDR      r0,|L2.316|
00007e  6800              LDR      r0,[r0,#0]            ;479  ; current_iphdr_dest
000080  6020              STR      r0,[r4,#0]            ;479
000082  8b68              LDRH     r0,[r5,#0x1a]         ;480
000084  8360              STRH     r0,[r4,#0x1a]         ;480
000086  482c              LDR      r0,|L2.312|
000088  6800              LDR      r0,[r0,#0]            ;481  ; current_iphdr_src
00008a  6060              STR      r0,[r4,#4]            ;481
00008c  4827              LDR      r0,|L2.300|
00008e  6800              LDR      r0,[r0,#0]            ;482  ; tcphdr
000090  8800              LDRH     r0,[r0,#0]            ;482
000092  83a0              STRH     r0,[r4,#0x1c]         ;482
000094  2003              MOVS     r0,#3                 ;483
000096  7620              STRB     r0,[r4,#0x18]         ;483
000098  4825              LDR      r0,|L2.304|
00009a  6800              LDR      r0,[r0,#0]            ;484  ; seqno
00009c  1c40              ADDS     r0,r0,#1              ;484
00009e  62a0              STR      r0,[r4,#0x28]         ;484
0000a0  6aa0              LDR      r0,[r4,#0x28]         ;485
0000a2  6320              STR      r0,[r4,#0x30]         ;485
0000a4  4821              LDR      r0,|L2.300|
0000a6  6800              LDR      r0,[r0,#0]            ;486  ; tcphdr
0000a8  89c0              LDRH     r0,[r0,#0xe]          ;486
0000aa  f8a40060          STRH     r0,[r4,#0x60]         ;486
0000ae  481f              LDR      r0,|L2.300|
0000b0  6800              LDR      r0,[r0,#0]            ;487  ; tcphdr
0000b2  89c0              LDRH     r0,[r0,#0xe]          ;487
0000b4  f8a40062          STRH     r0,[r4,#0x62]         ;487
0000b8  f8b40060          LDRH     r0,[r4,#0x60]         ;488
0000bc  f8a4004e          STRH     r0,[r4,#0x4e]         ;488
0000c0  481b              LDR      r0,|L2.304|
0000c2  6800              LDR      r0,[r0,#0]            ;489  ; seqno
0000c4  1e40              SUBS     r0,r0,#1              ;489
0000c6  6560              STR      r0,[r4,#0x54]         ;489
0000c8  6928              LDR      r0,[r5,#0x10]         ;490
0000ca  6120              STR      r0,[r4,#0x10]         ;490
0000cc  6968              LDR      r0,[r5,#0x14]         ;492
0000ce  6160              STR      r0,[r4,#0x14]         ;492
0000d0  7a28              LDRB     r0,[r5,#8]            ;495
0000d2  f000008c          AND      r0,r0,#0x8c           ;495
0000d6  7220              STRB     r0,[r4,#8]            ;495
0000d8  bf00              NOP                            ;498
0000da  bf00              NOP                            ;498
0000dc  481a              LDR      r0,|L2.328|
0000de  6800              LDR      r0,[r0,#0]            ;498  ; tcp_active_pcbs
0000e0  60e0              STR      r0,[r4,#0xc]          ;498
0000e2  4819              LDR      r0,|L2.328|
0000e4  6004              STR      r4,[r0,#0]            ;498  ; tcp_active_pcbs
0000e6  f7fffffe          BL       tcp_timer_needed
0000ea  bf00              NOP                            ;498
0000ec  2001              MOVS     r0,#1                 ;498
0000ee  4917              LDR      r1,|L2.332|
0000f0  7008              STRB     r0,[r1,#0]            ;498
0000f2  bf00              NOP                            ;498
0000f4  4620              MOV      r0,r4                 ;501
0000f6  f7fffffe          BL       tcp_parseopt
0000fa  8ee0              LDRH     r0,[r4,#0x36]         ;503
0000fc  1d21              ADDS     r1,r4,#4              ;503
0000fe  f7fffffe          BL       tcp_eff_send_mss
000102  86e0              STRH     r0,[r4,#0x36]         ;503
000104  2112              MOVS     r1,#0x12              ;509
000106  4620              MOV      r0,r4                 ;509
000108  f7fffffe          BL       tcp_enqueue_flags
00010c  4606              MOV      r6,r0                 ;509
00010e  b12e              CBZ      r6,|L2.284|
000110  2100              MOVS     r1,#0                 ;511
000112  4620              MOV      r0,r4                 ;511
000114  f7fffffe          BL       tcp_abandon
000118  4630              MOV      r0,r6                 ;512
00011a  e779              B        |L2.16|
                  |L2.284|
00011c  4620              MOV      r0,r4                 ;514
00011e  f7fffffe          BL       tcp_output
000122  e775              B        |L2.16|
                  |L2.292|
000124  2000              MOVS     r0,#0                 ;516
000126  e773              B        |L2.16|
;;;518    
                          ENDP

                  |L2.296|
                          DCD      flags
                  |L2.300|
                          DCD      tcphdr
                  |L2.304|
                          DCD      seqno
                  |L2.308|
                          DCD      tcplen
                  |L2.312|
                          DCD      current_iphdr_src
                  |L2.316|
                          DCD      current_iphdr_dest
                  |L2.320|
                          DCD      ackno
                  |L2.324|
                          DCD      lwip_stats
                  |L2.328|
                          DCD      tcp_active_pcbs
                  |L2.332|
                          DCD      tcp_active_pcbs_changed

                          AREA ||i.tcp_oos_insert_segment||, CODE, READONLY, ALIGN=2

                  tcp_oos_insert_segment PROC
;;;799    static void
;;;800    tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
000000  b570              PUSH     {r4-r6,lr}
;;;801    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;802      struct tcp_seg *old_seg;
;;;803    
;;;804      if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
000006  6929              LDR      r1,[r5,#0x10]
000008  8988              LDRH     r0,[r1,#0xc]
00000a  f7fffffe          BL       lwip_ntohs
00000e  f0000001          AND      r0,r0,#1
000012  b120              CBZ      r0,|L3.30|
;;;805        /* received segment overlaps all following segments */
;;;806        tcp_segs_free(next);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       tcp_segs_free
;;;807        next = NULL;
00001a  2400              MOVS     r4,#0
00001c  e033              B        |L3.134|
                  |L3.30|
;;;808      }
;;;809      else {
;;;810        /* delete some following segments
;;;811           oos queue may have segments with FIN flag */
;;;812        while (next &&
00001e  e013              B        |L3.72|
                  |L3.32|
;;;813               TCP_SEQ_GEQ((seqno + cseg->len),
;;;814                          (next->tcphdr->seqno + next->len))) {
;;;815          /* cseg with FIN already processed */
;;;816          if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
000020  6921              LDR      r1,[r4,#0x10]
000022  8988              LDRH     r0,[r1,#0xc]
000024  f7fffffe          BL       lwip_ntohs
000028  f0000001          AND      r0,r0,#1
00002c  b138              CBZ      r0,|L3.62|
;;;817            TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       lwip_htons
000034  6929              LDR      r1,[r5,#0x10]
000036  8989              LDRH     r1,[r1,#0xc]
000038  4308              ORRS     r0,r0,r1
00003a  6929              LDR      r1,[r5,#0x10]
00003c  8188              STRH     r0,[r1,#0xc]
                  |L3.62|
;;;818          }
;;;819          old_seg = next;
00003e  4626              MOV      r6,r4
;;;820          next = next->next;
000040  6824              LDR      r4,[r4,#0]
;;;821          tcp_seg_free(old_seg);
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       tcp_seg_free
                  |L3.72|
000048  b14c              CBZ      r4,|L3.94|
00004a  6920              LDR      r0,[r4,#0x10]         ;813
00004c  6840              LDR      r0,[r0,#4]            ;813
00004e  8921              LDRH     r1,[r4,#8]            ;813
000050  4408              ADD      r0,r0,r1              ;813
000052  8929              LDRH     r1,[r5,#8]            ;813
000054  4a0d              LDR      r2,|L3.140|
000056  6812              LDR      r2,[r2,#0]            ;813  ; seqno
000058  4411              ADD      r1,r1,r2              ;813
00005a  1a08              SUBS     r0,r1,r0              ;813
00005c  d5e0              BPL      |L3.32|
                  |L3.94|
;;;822        }
;;;823        if (next &&
00005e  b194              CBZ      r4,|L3.134|
;;;824            TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
000060  8928              LDRH     r0,[r5,#8]
000062  490a              LDR      r1,|L3.140|
000064  6809              LDR      r1,[r1,#0]  ; seqno
000066  4408              ADD      r0,r0,r1
000068  6921              LDR      r1,[r4,#0x10]
00006a  6849              LDR      r1,[r1,#4]
00006c  1a40              SUBS     r0,r0,r1
00006e  2800              CMP      r0,#0
000070  dd09              BLE      |L3.134|
;;;825          /* We need to trim the incoming segment. */
;;;826          cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
000072  6920              LDR      r0,[r4,#0x10]
000074  8880              LDRH     r0,[r0,#4]
000076  4905              LDR      r1,|L3.140|
000078  8809              LDRH     r1,[r1,#0]  ; seqno
00007a  1a40              SUBS     r0,r0,r1
00007c  8128              STRH     r0,[r5,#8]
;;;827          pbuf_realloc(cseg->p, cseg->len);
00007e  8929              LDRH     r1,[r5,#8]
000080  6868              LDR      r0,[r5,#4]
000082  f7fffffe          BL       pbuf_realloc
                  |L3.134|
;;;828        }
;;;829      }
;;;830      cseg->next = next;
000086  602c              STR      r4,[r5,#0]
;;;831    }
000088  bd70              POP      {r4-r6,pc}
;;;832    #endif /* TCP_QUEUE_OOSEQ */
                          ENDP

00008a  0000              DCW      0x0000
                  |L3.140|
                          DCD      seqno

                          AREA ||i.tcp_parseopt||, CODE, READONLY, ALIGN=2

                  tcp_parseopt PROC
;;;1541   static void
;;;1542   tcp_parseopt(struct tcp_pcb *pcb)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1543   {
000004  4680              MOV      r8,r0
;;;1544     u16_t c, max_c;
;;;1545     u16_t mss;
;;;1546     u8_t *opts, opt;
;;;1547   #if LWIP_TCP_TIMESTAMPS
;;;1548     u32_t tsval;
;;;1549   #endif
;;;1550   
;;;1551     opts = (u8_t *)tcphdr + TCP_HLEN;
000006  4830              LDR      r0,|L4.200|
000008  6800              LDR      r0,[r0,#0]  ; tcphdr
00000a  f1000514          ADD      r5,r0,#0x14
;;;1552   
;;;1553     /* Parse the TCP MSS option, if present. */
;;;1554     if(TCPH_HDRLEN(tcphdr) > 0x5) {
00000e  492e              LDR      r1,|L4.200|
000010  6809              LDR      r1,[r1,#0]  ; tcphdr
000012  8988              LDRH     r0,[r1,#0xc]
000014  f7fffffe          BL       lwip_ntohs
000018  2105              MOVS     r1,#5
00001a  ebb13f20          CMP      r1,r0,ASR #12
00001e  da51              BGE      |L4.196|
;;;1555       max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
000020  4929              LDR      r1,|L4.200|
000022  6809              LDR      r1,[r1,#0]  ; tcphdr
000024  8988              LDRH     r0,[r1,#0xc]
000026  f7fffffe          BL       lwip_ntohs
00002a  2105              MOVS     r1,#5
00002c  ebc13020          RSB      r0,r1,r0,ASR #12
000030  f64f71ff          MOV      r1,#0xffff
000034  ea010680          AND      r6,r1,r0,LSL #2
;;;1556       for (c = 0; c < max_c; ) {
000038  2400              MOVS     r4,#0
00003a  e041              B        |L4.192|
                  |L4.60|
;;;1557         opt = opts[c];
00003c  f8159004          LDRB     r9,[r5,r4]
;;;1558         switch (opt) {
000040  f1b90f00          CMP      r9,#0
000044  d006              BEQ      |L4.84|
000046  f1b90f01          CMP      r9,#1
00004a  d007              BEQ      |L4.92|
00004c  f1b90f02          CMP      r9,#2
000050  d128              BNE      |L4.164|
000052  e008              B        |L4.102|
                  |L4.84|
;;;1559         case 0x00:
;;;1560           /* End of options. */
;;;1561           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
000054  bf00              NOP      
000056  bf00              NOP      
                  |L4.88|
;;;1562           return;
;;;1563         case 0x01:
;;;1564           /* NOP option. */
;;;1565           ++c;
;;;1566           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
;;;1567           break;
;;;1568         case 0x02:
;;;1569           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
;;;1570           if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
;;;1571             /* Bad length */
;;;1572             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1573             return;
;;;1574           }
;;;1575           /* An MSS option with the right option length. */
;;;1576           mss = (opts[c + 2] << 8) | opts[c + 3];
;;;1577           /* Limit the mss to the configured TCP_MSS and prevent division by zero */
;;;1578           pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
;;;1579           /* Advance to next option */
;;;1580           c += 0x04;
;;;1581           break;
;;;1582   #if LWIP_TCP_TIMESTAMPS
;;;1583         case 0x08:
;;;1584           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: TS\n"));
;;;1585           if (opts[c + 1] != 0x0A || c + 0x0A > max_c) {
;;;1586             /* Bad length */
;;;1587             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1588             return;
;;;1589           }
;;;1590           /* TCP timestamp option with valid length */
;;;1591           tsval = (opts[c+2]) | (opts[c+3] << 8) | 
;;;1592             (opts[c+4] << 16) | (opts[c+5] << 24);
;;;1593           if (flags & TCP_SYN) {
;;;1594             pcb->ts_recent = ntohl(tsval);
;;;1595             pcb->flags |= TF_TIMESTAMP;
;;;1596           } else if (TCP_SEQ_BETWEEN(pcb->ts_lastacksent, seqno, seqno+tcplen)) {
;;;1597             pcb->ts_recent = ntohl(tsval);
;;;1598           }
;;;1599           /* Advance to next option */
;;;1600           c += 0x0A;
;;;1601           break;
;;;1602   #endif
;;;1603         default:
;;;1604           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
;;;1605           if (opts[c + 1] == 0) {
;;;1606             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1607             /* If the length field is zero, the options are malformed
;;;1608                and we don't process them further. */
;;;1609             return;
;;;1610           }
;;;1611           /* All other options have a length field, so that we easily
;;;1612              can skip past them. */
;;;1613           c += opts[c + 1];
;;;1614         }
;;;1615       }
;;;1616     }
;;;1617   }
000058  e8bd87f0          POP      {r4-r10,pc}
                  |L4.92|
00005c  1c60              ADDS     r0,r4,#1              ;1565
00005e  b284              UXTH     r4,r0                 ;1565
000060  bf00              NOP                            ;1566
000062  bf00              NOP                            ;1566
000064  e02b              B        |L4.190|
                  |L4.102|
000066  bf00              NOP                            ;1569
000068  bf00              NOP                            ;1569
00006a  1c60              ADDS     r0,r4,#1              ;1570
00006c  5c28              LDRB     r0,[r5,r0]            ;1570
00006e  2804              CMP      r0,#4                 ;1570
000070  d102              BNE      |L4.120|
000072  1d20              ADDS     r0,r4,#4              ;1570
000074  42b0              CMP      r0,r6                 ;1570
000076  dd02              BLE      |L4.126|
                  |L4.120|
000078  bf00              NOP                            ;1572
00007a  bf00              NOP                            ;1572
00007c  e7ec              B        |L4.88|
                  |L4.126|
00007e  1ce0              ADDS     r0,r4,#3              ;1576
000080  5c29              LDRB     r1,[r5,r0]            ;1576
000082  1ca0              ADDS     r0,r4,#2              ;1576
000084  5c28              LDRB     r0,[r5,r0]            ;1576
000086  ea412700          ORR      r7,r1,r0,LSL #8       ;1576
00008a  f5b77f7a          CMP      r7,#0x3e8             ;1578
00008e  dc00              BGT      |L4.146|
000090  b917              CBNZ     r7,|L4.152|
                  |L4.146|
000092  f44f707a          MOV      r0,#0x3e8             ;1578
000096  e000              B        |L4.154|
                  |L4.152|
000098  4638              MOV      r0,r7                 ;1578
                  |L4.154|
00009a  f8a80036          STRH     r0,[r8,#0x36]         ;1578
00009e  1d20              ADDS     r0,r4,#4              ;1580
0000a0  b284              UXTH     r4,r0                 ;1580
0000a2  e00c              B        |L4.190|
                  |L4.164|
0000a4  bf00              NOP                            ;1604
0000a6  bf00              NOP                            ;1604
0000a8  1c60              ADDS     r0,r4,#1              ;1605
0000aa  5c28              LDRB     r0,[r5,r0]            ;1605
0000ac  b910              CBNZ     r0,|L4.180|
0000ae  bf00              NOP                            ;1606
0000b0  bf00              NOP                            ;1606
0000b2  e7d1              B        |L4.88|
                  |L4.180|
0000b4  1c60              ADDS     r0,r4,#1              ;1613
0000b6  5c28              LDRB     r0,[r5,r0]            ;1613
0000b8  4420              ADD      r0,r0,r4              ;1613
0000ba  b284              UXTH     r4,r0                 ;1613
0000bc  bf00              NOP                            ;1558
                  |L4.190|
0000be  bf00              NOP                            ;1567
                  |L4.192|
0000c0  42b4              CMP      r4,r6                 ;1556
0000c2  dbbb              BLT      |L4.60|
                  |L4.196|
0000c4  bf00              NOP      
0000c6  e7c7              B        |L4.88|
;;;1618   
                          ENDP

                  |L4.200|
                          DCD      tcphdr

                          AREA ||i.tcp_process||, CODE, READONLY, ALIGN=2

                  tcp_process PROC
;;;574    static err_t
;;;575    tcp_process(struct tcp_pcb *pcb)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;576    {
000004  4604              MOV      r4,r0
;;;577      struct tcp_seg *rseg;
;;;578      u8_t acceptable = 0;
000006  f04f0800          MOV      r8,#0
;;;579      err_t err;
;;;580    
;;;581      err = ERR_OK;
00000a  2600              MOVS     r6,#0
;;;582    
;;;583      /* Process incoming RST segments. */
;;;584      if (flags & TCP_RST) {
00000c  48fc              LDR      r0,|L5.1024|
00000e  7800              LDRB     r0,[r0,#0]  ; flags
000010  f0000004          AND      r0,r0,#4
000014  2800              CMP      r0,#0
000016  d03b              BEQ      |L5.144|
;;;585        /* First, determine if the reset is acceptable. */
;;;586        if (pcb->state == SYN_SENT) {
000018  7e20              LDRB     r0,[r4,#0x18]
00001a  2802              CMP      r0,#2
00001c  d107              BNE      |L5.46|
;;;587          if (ackno == pcb->snd_nxt) {
00001e  49f9              LDR      r1,|L5.1028|
000020  6d20              LDR      r0,[r4,#0x50]
000022  6809              LDR      r1,[r1,#0]  ; ackno
000024  4288              CMP      r0,r1
000026  d111              BNE      |L5.76|
;;;588            acceptable = 1;
000028  f04f0801          MOV      r8,#1
00002c  e00e              B        |L5.76|
                  |L5.46|
;;;589          }
;;;590        } else {
;;;591          if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
00002e  49f6              LDR      r1,|L5.1032|
000030  6aa0              LDR      r0,[r4,#0x28]
000032  6809              LDR      r1,[r1,#0]  ; seqno
000034  1a08              SUBS     r0,r1,r0
000036  d409              BMI      |L5.76|
000038  8da1              LDRH     r1,[r4,#0x2c]
00003a  6aa0              LDR      r0,[r4,#0x28]
00003c  4408              ADD      r0,r0,r1
00003e  49f2              LDR      r1,|L5.1032|
000040  6809              LDR      r1,[r1,#0]  ; seqno
000042  1a08              SUBS     r0,r1,r0
000044  2800              CMP      r0,#0
000046  dc01              BGT      |L5.76|
;;;592                              pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;593            acceptable = 1;
000048  f04f0801          MOV      r8,#1
                  |L5.76|
;;;594          }
;;;595        }
;;;596    
;;;597        if (acceptable) {
00004c  f1b80f00          CMP      r8,#0
000050  d018              BEQ      |L5.132|
;;;598          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
000052  bf00              NOP      
000054  bf00              NOP      
;;;599          LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
000056  bf00              NOP      
000058  7e20              LDRB     r0,[r4,#0x18]
00005a  b920              CBNZ     r0,|L5.102|
00005c  a0eb              ADR      r0,|L5.1036|
00005e  f7fffffe          BL       __2printf
000062  bf00              NOP      
                  |L5.100|
000064  e7fe              B        |L5.100|
                  |L5.102|
000066  bf00              NOP      
;;;600          recv_flags |= TF_RESET;
000068  48f0              LDR      r0,|L5.1068|
00006a  7800              LDRB     r0,[r0,#0]  ; recv_flags
00006c  f0400008          ORR      r0,r0,#8
000070  49ee              LDR      r1,|L5.1068|
000072  7008              STRB     r0,[r1,#0]
;;;601          pcb->flags &= ~TF_ACK_DELAY;
000074  7fa0              LDRB     r0,[r4,#0x1e]
000076  f0200001          BIC      r0,r0,#1
00007a  77a0              STRB     r0,[r4,#0x1e]
;;;602          return ERR_RST;
00007c  f06f000a          MVN      r0,#0xa
                  |L5.128|
;;;603        } else {
;;;604          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;605           seqno, pcb->rcv_nxt));
;;;606          LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;607           seqno, pcb->rcv_nxt));
;;;608          return ERR_OK;
;;;609        }
;;;610      }
;;;611    
;;;612      if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
;;;613        /* Cope with new connection attempt after remote end crashed */
;;;614        tcp_ack_now(pcb);
;;;615        return ERR_OK;
;;;616      }
;;;617      
;;;618      if ((pcb->flags & TF_RXCLOSED) == 0) {
;;;619        /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
;;;620        pcb->tmr = tcp_ticks;
;;;621      }
;;;622      pcb->keep_cnt_sent = 0;
;;;623    
;;;624      tcp_parseopt(pcb);
;;;625    
;;;626      /* Do different things depending on the TCP state. */
;;;627      switch (pcb->state) {
;;;628      case SYN_SENT:
;;;629        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
;;;630         pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
;;;631        /* received SYN ACK with expected sequence number? */
;;;632        if ((flags & TCP_ACK) && (flags & TCP_SYN)
;;;633            && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
;;;634          pcb->snd_buf++;
;;;635          pcb->rcv_nxt = seqno + 1;
;;;636          pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;637          pcb->lastack = ackno;
;;;638          pcb->snd_wnd = tcphdr->wnd;
;;;639          pcb->snd_wnd_max = tcphdr->wnd;
;;;640          pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
;;;641          pcb->state = ESTABLISHED;
;;;642    
;;;643    #if TCP_CALCULATE_EFF_SEND_MSS
;;;644          pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
;;;645    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;646    
;;;647          /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
;;;648           * but for the default value of pcb->mss) */
;;;649          pcb->ssthresh = pcb->mss * 10;
;;;650    
;;;651          pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;652          LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
;;;653          --pcb->snd_queuelen;
;;;654          LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;655          rseg = pcb->unacked;
;;;656          pcb->unacked = rseg->next;
;;;657          tcp_seg_free(rseg);
;;;658    
;;;659          /* If there's nothing left to acknowledge, stop the retransmit
;;;660             timer, otherwise reset it to start again */
;;;661          if(pcb->unacked == NULL)
;;;662            pcb->rtime = -1;
;;;663          else {
;;;664            pcb->rtime = 0;
;;;665            pcb->nrtx = 0;
;;;666          }
;;;667    
;;;668          /* Call the user specified function to call when sucessfully
;;;669           * connected. */
;;;670          TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
;;;671          if (err == ERR_ABRT) {
;;;672            return ERR_ABRT;
;;;673          }
;;;674          tcp_ack_now(pcb);
;;;675        }
;;;676        /* received ACK? possibly a half-open connection */
;;;677        else if (flags & TCP_ACK) {
;;;678          /* send a RST to bring the other side in a non-synchronized state. */
;;;679          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;680            tcphdr->dest, tcphdr->src);
;;;681        }
;;;682        break;
;;;683      case SYN_RCVD:
;;;684        if (flags & TCP_ACK) {
;;;685          /* expected ACK number? */
;;;686          if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
;;;687            u16_t old_cwnd;
;;;688            pcb->state = ESTABLISHED;
;;;689            LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;690    #if LWIP_CALLBACK_API
;;;691            LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
;;;692    #endif
;;;693            /* Call the accept function. */
;;;694            TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
;;;695            if (err != ERR_OK) {
;;;696              /* If the accept function returns with an error, we abort
;;;697               * the connection. */
;;;698              /* Already aborted? */
;;;699              if (err != ERR_ABRT) {
;;;700                tcp_abort(pcb);
;;;701              }
;;;702              return ERR_ABRT;
;;;703            }
;;;704            old_cwnd = pcb->cwnd;
;;;705            /* If there was any data contained within this ACK,
;;;706             * we'd better pass it on to the application as well. */
;;;707            tcp_receive(pcb);
;;;708    
;;;709            /* Prevent ACK for SYN to generate a sent event */
;;;710            if (pcb->acked != 0) {
;;;711              pcb->acked--;
;;;712            }
;;;713    
;;;714            pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;715    
;;;716            if (recv_flags & TF_GOT_FIN) {
;;;717              tcp_ack_now(pcb);
;;;718              pcb->state = CLOSE_WAIT;
;;;719            }
;;;720          } else {
;;;721            /* incorrect ACK number, send RST */
;;;722            tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;723                    tcphdr->dest, tcphdr->src);
;;;724          }
;;;725        } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
;;;726          /* Looks like another copy of the SYN - retransmit our SYN-ACK */
;;;727          tcp_rexmit(pcb);
;;;728        }
;;;729        break;
;;;730      case CLOSE_WAIT:
;;;731        /* FALLTHROUGH */
;;;732      case ESTABLISHED:
;;;733        tcp_receive(pcb);
;;;734        if (recv_flags & TF_GOT_FIN) { /* passive close */
;;;735          tcp_ack_now(pcb);
;;;736          pcb->state = CLOSE_WAIT;
;;;737        }
;;;738        break;
;;;739      case FIN_WAIT_1:
;;;740        tcp_receive(pcb);
;;;741        if (recv_flags & TF_GOT_FIN) {
;;;742          if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;743            LWIP_DEBUGF(TCP_DEBUG,
;;;744              ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;745            tcp_ack_now(pcb);
;;;746            tcp_pcb_purge(pcb);
;;;747            TCP_RMV_ACTIVE(pcb);
;;;748            pcb->state = TIME_WAIT;
;;;749            TCP_REG(&tcp_tw_pcbs, pcb);
;;;750          } else {
;;;751            tcp_ack_now(pcb);
;;;752            pcb->state = CLOSING;
;;;753          }
;;;754        } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;755          pcb->state = FIN_WAIT_2;
;;;756        }
;;;757        break;
;;;758      case FIN_WAIT_2:
;;;759        tcp_receive(pcb);
;;;760        if (recv_flags & TF_GOT_FIN) {
;;;761          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;762          tcp_ack_now(pcb);
;;;763          tcp_pcb_purge(pcb);
;;;764          TCP_RMV_ACTIVE(pcb);
;;;765          pcb->state = TIME_WAIT;
;;;766          TCP_REG(&tcp_tw_pcbs, pcb);
;;;767        }
;;;768        break;
;;;769      case CLOSING:
;;;770        tcp_receive(pcb);
;;;771        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;772          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;773          tcp_pcb_purge(pcb);
;;;774          TCP_RMV_ACTIVE(pcb);
;;;775          pcb->state = TIME_WAIT;
;;;776          TCP_REG(&tcp_tw_pcbs, pcb);
;;;777        }
;;;778        break;
;;;779      case LAST_ACK:
;;;780        tcp_receive(pcb);
;;;781        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;782          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;783          /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
;;;784          recv_flags |= TF_CLOSED;
;;;785        }
;;;786        break;
;;;787      default:
;;;788        break;
;;;789      }
;;;790      return ERR_OK;
;;;791    }
000080  e8bd81fc          POP      {r2-r8,pc}
                  |L5.132|
000084  bf00              NOP                            ;604
000086  bf00              NOP                            ;604
000088  bf00              NOP                            ;606
00008a  bf00              NOP                            ;606
00008c  2000              MOVS     r0,#0                 ;608
00008e  e7f7              B        |L5.128|
                  |L5.144|
000090  48db              LDR      r0,|L5.1024|
000092  7800              LDRB     r0,[r0,#0]            ;612  ; flags
000094  f0000002          AND      r0,r0,#2              ;612
000098  b168              CBZ      r0,|L5.182|
00009a  7e20              LDRB     r0,[r4,#0x18]         ;612
00009c  2802              CMP      r0,#2                 ;612
00009e  d00a              BEQ      |L5.182|
0000a0  7e20              LDRB     r0,[r4,#0x18]         ;612
0000a2  2803              CMP      r0,#3                 ;612
0000a4  d007              BEQ      |L5.182|
0000a6  bf00              NOP                            ;614
0000a8  7fa0              LDRB     r0,[r4,#0x1e]         ;614
0000aa  f0400002          ORR      r0,r0,#2              ;614
0000ae  77a0              STRB     r0,[r4,#0x1e]         ;614
0000b0  bf00              NOP                            ;614
0000b2  2000              MOVS     r0,#0                 ;615
0000b4  e7e4              B        |L5.128|
                  |L5.182|
0000b6  7fa0              LDRB     r0,[r4,#0x1e]         ;618
0000b8  f0000010          AND      r0,r0,#0x10           ;618
0000bc  b910              CBNZ     r0,|L5.196|
0000be  48dc              LDR      r0,|L5.1072|
0000c0  6800              LDR      r0,[r0,#0]            ;620  ; tcp_ticks
0000c2  6260              STR      r0,[r4,#0x24]         ;620
                  |L5.196|
0000c4  2000              MOVS     r0,#0                 ;622
0000c6  f8840096          STRB     r0,[r4,#0x96]         ;622
0000ca  4620              MOV      r0,r4                 ;624
0000cc  f7fffffe          BL       tcp_parseopt
0000d0  7e20              LDRB     r0,[r4,#0x18]         ;627
0000d2  1e80              SUBS     r0,r0,#2              ;627
0000d4  2808              CMP      r0,#8                 ;627
0000d6  d270              BCS      |L5.442|
0000d8  e8dff000          TBB      [pc,r0]               ;627
0000dc  04a8f5f4          DCB      0x04,0xa8,0xf5,0xf4
0000e0  f3f2f1f0          DCB      0xf3,0xf2,0xf1,0xf0
0000e4  bf00              NOP                            ;629
0000e6  bf00              NOP                            ;629
0000e8  48c5              LDR      r0,|L5.1024|
0000ea  7800              LDRB     r0,[r0,#0]            ;632  ; flags
0000ec  f0000010          AND      r0,r0,#0x10           ;632
0000f0  2800              CMP      r0,#0                 ;632
0000f2  d073              BEQ      |L5.476|
0000f4  48c2              LDR      r0,|L5.1024|
0000f6  7800              LDRB     r0,[r0,#0]            ;632  ; flags
0000f8  f0000002          AND      r0,r0,#2              ;632
0000fc  2800              CMP      r0,#0                 ;632
0000fe  d07c              BEQ      |L5.506|
000100  6f21              LDR      r1,[r4,#0x70]         ;633
000102  6909              LDR      r1,[r1,#0x10]         ;633
000104  6848              LDR      r0,[r1,#4]            ;633
000106  f7fffffe          BL       lwip_ntohl
00010a  1c40              ADDS     r0,r0,#1              ;633
00010c  49bd              LDR      r1,|L5.1028|
00010e  6809              LDR      r1,[r1,#0]            ;633  ; ackno
000110  4288              CMP      r0,r1                 ;633
000112  d172              BNE      |L5.506|
000114  3428              ADDS     r4,r4,#0x28           ;634
000116  8fe0              LDRH     r0,[r4,#0x3e]         ;634
000118  1c40              ADDS     r0,r0,#1              ;634
00011a  87e0              STRH     r0,[r4,#0x3e]         ;634
00011c  48ba              LDR      r0,|L5.1032|
00011e  6800              LDR      r0,[r0,#0]            ;635  ; seqno
000120  1c40              ADDS     r0,r0,#1              ;635
000122  6020              STR      r0,[r4,#0]            ;635
000124  6820              LDR      r0,[r4,#0]            ;636
000126  60a0              STR      r0,[r4,#8]            ;636
000128  48b6              LDR      r0,|L5.1028|
00012a  6800              LDR      r0,[r0,#0]            ;637  ; ackno
00012c  6220              STR      r0,[r4,#0x20]         ;637
00012e  48c1              LDR      r0,|L5.1076|
000130  6800              LDR      r0,[r0,#0]            ;638  ; tcphdr
000132  89c0              LDRH     r0,[r0,#0xe]          ;638
000134  8720              STRH     r0,[r4,#0x38]         ;638
000136  48bf              LDR      r0,|L5.1076|
000138  6800              LDR      r0,[r0,#0]            ;639  ; tcphdr
00013a  89c0              LDRH     r0,[r0,#0xe]          ;639
00013c  8760              STRH     r0,[r4,#0x3a]         ;639
00013e  48b2              LDR      r0,|L5.1032|
000140  6800              LDR      r0,[r0,#0]            ;640  ; seqno
000142  1e40              SUBS     r0,r0,#1              ;640
000144  62e0              STR      r0,[r4,#0x2c]         ;640
000146  2004              MOVS     r0,#4                 ;641
000148  f8040c10          STRB     r0,[r4,#-0x10]        ;641
00014c  89e0              LDRH     r0,[r4,#0xe]          ;644
00014e  3c28              SUBS     r4,r4,#0x28           ;644
000150  1d21              ADDS     r1,r4,#4              ;644
000152  f7fffffe          BL       tcp_eff_send_mss
000156  86e0              STRH     r0,[r4,#0x36]         ;644
000158  8ee0              LDRH     r0,[r4,#0x36]         ;649
00015a  eb000080          ADD      r0,r0,r0,LSL #2       ;649
00015e  f64f71ff          MOV      r1,#0xffff            ;649
000162  ea010040          AND      r0,r1,r0,LSL #1       ;649
000166  f8a4004e          STRH     r0,[r4,#0x4e]         ;649
00016a  f8b4004c          LDRH     r0,[r4,#0x4c]         ;651
00016e  2801              CMP      r0,#1                 ;651
000170  d102              BNE      |L5.376|
000172  8ee0              LDRH     r0,[r4,#0x36]         ;651
000174  0040              LSLS     r0,r0,#1              ;651
000176  e000              B        |L5.378|
                  |L5.376|
000178  8ee0              LDRH     r0,[r4,#0x36]         ;651
                  |L5.378|
00017a  f8a4004c          STRH     r0,[r4,#0x4c]         ;651
00017e  bf00              NOP                            ;652
000180  f8b40068          LDRH     r0,[r4,#0x68]         ;652
000184  2800              CMP      r0,#0                 ;652
000186  dc04              BGT      |L5.402|
000188  a0ab              ADR      r0,|L5.1080|
00018a  f7fffffe          BL       __2printf
00018e  bf00              NOP                            ;652
                  |L5.400|
000190  e7fe              B        |L5.400|
                  |L5.402|
000192  bf00              NOP                            ;652
000194  f8b40068          LDRH     r0,[r4,#0x68]         ;653
000198  1e40              SUBS     r0,r0,#1              ;653
00019a  f8a40068          STRH     r0,[r4,#0x68]         ;653
00019e  bf00              NOP                            ;654
0001a0  bf00              NOP                            ;654
0001a2  6f25              LDR      r5,[r4,#0x70]         ;655
0001a4  6828              LDR      r0,[r5,#0]            ;656
0001a6  6720              STR      r0,[r4,#0x70]         ;656
0001a8  4628              MOV      r0,r5                 ;657
0001aa  f7fffffe          BL       tcp_seg_free
0001ae  6f20              LDR      r0,[r4,#0x70]         ;661
0001b0  b920              CBNZ     r0,|L5.444|
0001b2  f04f30ff          MOV      r0,#0xffffffff        ;662
0001b6  86a0              STRH     r0,[r4,#0x34]         ;662
0001b8  e004              B        |L5.452|
                  |L5.442|
0001ba  e226              B        |L5.1546|
                  |L5.444|
0001bc  2000              MOVS     r0,#0                 ;664
0001be  86a0              STRH     r0,[r4,#0x34]         ;664
0001c0  f8840046          STRB     r0,[r4,#0x46]         ;665
                  |L5.452|
0001c4  bf00              NOP                            ;670
0001c6  f8d40084          LDR      r0,[r4,#0x84]         ;670
0001ca  b140              CBZ      r0,|L5.478|
0001cc  2200              MOVS     r2,#0                 ;670
0001ce  4621              MOV      r1,r4                 ;670
0001d0  f8d43084          LDR      r3,[r4,#0x84]         ;670
0001d4  6920              LDR      r0,[r4,#0x10]         ;670
0001d6  4798              BLX      r3                    ;670
0001d8  4606              MOV      r6,r0                 ;670
0001da  e001              B        |L5.480|
                  |L5.476|
0001dc  e00d              B        |L5.506|
                  |L5.478|
0001de  2600              MOVS     r6,#0                 ;670
                  |L5.480|
0001e0  bf00              NOP                            ;670
0001e2  f106000a          ADD      r0,r6,#0xa            ;671
0001e6  b910              CBNZ     r0,|L5.494|
0001e8  f06f0009          MVN      r0,#9                 ;672
0001ec  e748              B        |L5.128|
                  |L5.494|
0001ee  bf00              NOP                            ;674
0001f0  7fa0              LDRB     r0,[r4,#0x1e]         ;674
0001f2  f0400002          ORR      r0,r0,#2              ;674
0001f6  77a0              STRB     r0,[r4,#0x1e]         ;674
0001f8  e017              B        |L5.554|
                  |L5.506|
0001fa  4881              LDR      r0,|L5.1024|
0001fc  7800              LDRB     r0,[r0,#0]            ;677  ; flags
0001fe  f0000010          AND      r0,r0,#0x10           ;677
000202  b190              CBZ      r0,|L5.554|
000204  488b              LDR      r0,|L5.1076|
000206  6800              LDR      r0,[r0,#0]            ;679  ; tcphdr
000208  8800              LDRH     r0,[r0,#0]            ;679
00020a  498a              LDR      r1,|L5.1076|
00020c  6809              LDR      r1,[r1,#0]            ;679  ; tcphdr
00020e  8849              LDRH     r1,[r1,#2]            ;679
000210  e9cd1000          STRD     r1,r0,[sp,#0]         ;679
000214  487c              LDR      r0,|L5.1032|
000216  6800              LDR      r0,[r0,#0]            ;679  ; seqno
000218  4a8d              LDR      r2,|L5.1104|
00021a  8812              LDRH     r2,[r2,#0]            ;679  ; tcplen
00021c  1881              ADDS     r1,r0,r2              ;679
00021e  4b8d              LDR      r3,|L5.1108|
000220  4a8d              LDR      r2,|L5.1112|
000222  4878              LDR      r0,|L5.1028|
000224  6800              LDR      r0,[r0,#0]            ;679  ; ackno
000226  f7fffffe          BL       tcp_rst
                  |L5.554|
00022a  e1ef              B        |L5.1548|
00022c  4874              LDR      r0,|L5.1024|
00022e  7800              LDRB     r0,[r0,#0]            ;684  ; flags
000230  f0000010          AND      r0,r0,#0x10           ;684
000234  2800              CMP      r0,#0                 ;684
000236  d06c              BEQ      |L5.786|
000238  6ca0              LDR      r0,[r4,#0x48]         ;686
00023a  1c40              ADDS     r0,r0,#1              ;686
00023c  4971              LDR      r1,|L5.1028|
00023e  6809              LDR      r1,[r1,#0]            ;686  ; ackno
000240  1a08              SUBS     r0,r1,r0              ;686
000242  d452              BMI      |L5.746|
000244  496f              LDR      r1,|L5.1028|
000246  6d20              LDR      r0,[r4,#0x50]         ;686
000248  6809              LDR      r1,[r1,#0]            ;686  ; ackno
00024a  1a08              SUBS     r0,r1,r0              ;686
00024c  2800              CMP      r0,#0                 ;686
00024e  dc4c              BGT      |L5.746|
000250  2004              MOVS     r0,#4                 ;688
000252  7620              STRB     r0,[r4,#0x18]         ;688
000254  bf00              NOP                            ;689
000256  bf00              NOP                            ;689
000258  bf00              NOP                            ;691
00025a  6960              LDR      r0,[r4,#0x14]         ;691
00025c  b920              CBNZ     r0,|L5.616|
00025e  a07f              ADR      r0,|L5.1116|
000260  f7fffffe          BL       __2printf
000264  bf00              NOP                            ;691
                  |L5.614|
000266  e7fe              B        |L5.614|
                  |L5.616|
000268  bf00              NOP                            ;691
00026a  bf00              NOP                            ;694
00026c  6960              LDR      r0,[r4,#0x14]         ;694
00026e  b130              CBZ      r0,|L5.638|
000270  2200              MOVS     r2,#0                 ;694
000272  4621              MOV      r1,r4                 ;694
000274  e9d40304          LDRD     r0,r3,[r4,#0x10]      ;694
000278  4798              BLX      r3                    ;694
00027a  4606              MOV      r6,r0                 ;694
00027c  e001              B        |L5.642|
                  |L5.638|
00027e  f06f060d          MVN      r6,#0xd               ;694
                  |L5.642|
000282  bf00              NOP                            ;694
000284  b146              CBZ      r6,|L5.664|
000286  f106000a          ADD      r0,r6,#0xa            ;699
00028a  b110              CBZ      r0,|L5.658|
00028c  4620              MOV      r0,r4                 ;700
00028e  f7fffffe          BL       tcp_abort
                  |L5.658|
000292  f06f0009          MVN      r0,#9                 ;702
000296  e6f3              B        |L5.128|
                  |L5.664|
000298  f8b4704c          LDRH     r7,[r4,#0x4c]         ;704
00029c  4620              MOV      r0,r4                 ;707
00029e  f7fffffe          BL       tcp_receive
0002a2  f8b40064          LDRH     r0,[r4,#0x64]         ;710
0002a6  b120              CBZ      r0,|L5.690|
0002a8  f8b40064          LDRH     r0,[r4,#0x64]         ;711
0002ac  1e40              SUBS     r0,r0,#1              ;711
0002ae  f8a40064          STRH     r0,[r4,#0x64]         ;711
                  |L5.690|
0002b2  2f01              CMP      r7,#1                 ;714
0002b4  d108              BNE      |L5.712|
0002b6  8ee0              LDRH     r0,[r4,#0x36]         ;714
0002b8  0040              LSLS     r0,r0,#1              ;714
0002ba  e006              B        |L5.714|
0002bc  e18f              B        |L5.1502|
0002be  e142              B        |L5.1350|
0002c0  e036              B        |L5.816|
0002c2  e0f3              B        |L5.1196|
0002c4  e046              B        |L5.852|
0002c6  e034              B        |L5.818|
                  |L5.712|
0002c8  8ee0              LDRH     r0,[r4,#0x36]         ;714
                  |L5.714|
0002ca  f8a4004c          STRH     r0,[r4,#0x4c]         ;714
0002ce  4857              LDR      r0,|L5.1068|
0002d0  7800              LDRB     r0,[r0,#0]            ;716  ; recv_flags
0002d2  f0000020          AND      r0,r0,#0x20           ;716
0002d6  b138              CBZ      r0,|L5.744|
0002d8  bf00              NOP                            ;717
0002da  7fa0              LDRB     r0,[r4,#0x1e]         ;717
0002dc  f0400002          ORR      r0,r0,#2              ;717
0002e0  77a0              STRB     r0,[r4,#0x1e]         ;717
0002e2  bf00              NOP                            ;717
0002e4  2007              MOVS     r0,#7                 ;718
0002e6  7620              STRB     r0,[r4,#0x18]         ;718
                  |L5.744|
0002e8  e021              B        |L5.814|
                  |L5.746|
0002ea  4852              LDR      r0,|L5.1076|
0002ec  6800              LDR      r0,[r0,#0]            ;722  ; tcphdr
0002ee  8800              LDRH     r0,[r0,#0]            ;722
0002f0  4950              LDR      r1,|L5.1076|
0002f2  6809              LDR      r1,[r1,#0]            ;722  ; tcphdr
0002f4  8849              LDRH     r1,[r1,#2]            ;722
0002f6  e9cd1000          STRD     r1,r0,[sp,#0]         ;722
0002fa  4843              LDR      r0,|L5.1032|
0002fc  6800              LDR      r0,[r0,#0]            ;722  ; seqno
0002fe  4a54              LDR      r2,|L5.1104|
000300  8812              LDRH     r2,[r2,#0]            ;722  ; tcplen
000302  1881              ADDS     r1,r0,r2              ;722
000304  4b53              LDR      r3,|L5.1108|
000306  4a54              LDR      r2,|L5.1112|
000308  483e              LDR      r0,|L5.1028|
00030a  6800              LDR      r0,[r0,#0]            ;722  ; ackno
00030c  f7fffffe          BL       tcp_rst
000310  e00d              B        |L5.814|
                  |L5.786|
000312  483b              LDR      r0,|L5.1024|
000314  7800              LDRB     r0,[r0,#0]            ;725  ; flags
000316  f0000002          AND      r0,r0,#2              ;725
00031a  b140              CBZ      r0,|L5.814|
00031c  6aa0              LDR      r0,[r4,#0x28]         ;725
00031e  1e40              SUBS     r0,r0,#1              ;725
000320  4939              LDR      r1,|L5.1032|
000322  6809              LDR      r1,[r1,#0]            ;725  ; seqno
000324  4288              CMP      r0,r1                 ;725
000326  d102              BNE      |L5.814|
000328  4620              MOV      r0,r4                 ;727
00032a  f7fffffe          BL       tcp_rexmit
                  |L5.814|
00032e  e16d              B        |L5.1548|
                  |L5.816|
000330  bf00              NOP                            ;732
                  |L5.818|
000332  4620              MOV      r0,r4                 ;733
000334  f7fffffe          BL       tcp_receive
000338  483c              LDR      r0,|L5.1068|
00033a  7800              LDRB     r0,[r0,#0]            ;734  ; recv_flags
00033c  f0000020          AND      r0,r0,#0x20           ;734
000340  b138              CBZ      r0,|L5.850|
000342  bf00              NOP                            ;735
000344  7fa0              LDRB     r0,[r4,#0x1e]         ;735
000346  f0400002          ORR      r0,r0,#2              ;735
00034a  77a0              STRB     r0,[r4,#0x1e]         ;735
00034c  bf00              NOP                            ;735
00034e  2007              MOVS     r0,#7                 ;736
000350  7620              STRB     r0,[r4,#0x18]         ;736
                  |L5.850|
000352  e15b              B        |L5.1548|
                  |L5.852|
000354  4620              MOV      r0,r4                 ;740
000356  f7fffffe          BL       tcp_receive
00035a  4834              LDR      r0,|L5.1068|
00035c  7800              LDRB     r0,[r0,#0]            ;741  ; recv_flags
00035e  f0000020          AND      r0,r0,#0x20           ;741
000362  b378              CBZ      r0,|L5.964|
000364  4826              LDR      r0,|L5.1024|
000366  7800              LDRB     r0,[r0,#0]            ;742  ; flags
000368  f0000010          AND      r0,r0,#0x10           ;742
00036c  b358              CBZ      r0,|L5.966|
00036e  4925              LDR      r1,|L5.1028|
000370  6d20              LDR      r0,[r4,#0x50]         ;742
000372  6809              LDR      r1,[r1,#0]            ;742  ; ackno
000374  4288              CMP      r0,r1                 ;742
000376  d126              BNE      |L5.966|
000378  bf00              NOP                            ;743
00037a  bf00              NOP                            ;743
00037c  bf00              NOP                            ;745
00037e  7fa0              LDRB     r0,[r4,#0x1e]         ;745
000380  f0400002          ORR      r0,r0,#2              ;745
000384  77a0              STRB     r0,[r4,#0x1e]         ;745
000386  bf00              NOP                            ;745
000388  4620              MOV      r0,r4                 ;746
00038a  f7fffffe          BL       tcp_pcb_purge
00038e  bf00              NOP                            ;747
000390  bf00              NOP                            ;747
000392  4837              LDR      r0,|L5.1136|
000394  6800              LDR      r0,[r0,#0]            ;747  ; tcp_active_pcbs
000396  42a0              CMP      r0,r4                 ;747
000398  d105              BNE      |L5.934|
00039a  4835              LDR      r0,|L5.1136|
00039c  6800              LDR      r0,[r0,#0]            ;747  ; tcp_active_pcbs
00039e  68c0              LDR      r0,[r0,#0xc]          ;747
0003a0  4933              LDR      r1,|L5.1136|
0003a2  6008              STR      r0,[r1,#0]            ;747  ; tcp_active_pcbs
0003a4  e01a              B        |L5.988|
                  |L5.934|
0003a6  4832              LDR      r0,|L5.1136|
0003a8  6800              LDR      r0,[r0,#0]            ;747  ; tcp_active_pcbs
0003aa  4932              LDR      r1,|L5.1140|
0003ac  6008              STR      r0,[r1,#0]            ;747  ; tcp_tmp_pcb
0003ae  e010              B        |L5.978|
                  |L5.944|
0003b0  4830              LDR      r0,|L5.1140|
0003b2  6800              LDR      r0,[r0,#0]            ;747  ; tcp_tmp_pcb
0003b4  68c0              LDR      r0,[r0,#0xc]          ;747
0003b6  42a0              CMP      r0,r4                 ;747
0003b8  d106              BNE      |L5.968|
0003ba  492e              LDR      r1,|L5.1140|
0003bc  68e0              LDR      r0,[r4,#0xc]          ;747
0003be  6809              LDR      r1,[r1,#0]            ;747  ; tcp_tmp_pcb
0003c0  60c8              STR      r0,[r1,#0xc]          ;747
0003c2  e00a              B        |L5.986|
                  |L5.964|
0003c4  e065              B        |L5.1170|
                  |L5.966|
0003c6  e05b              B        |L5.1152|
                  |L5.968|
0003c8  482a              LDR      r0,|L5.1140|
0003ca  6800              LDR      r0,[r0,#0]            ;747  ; tcp_tmp_pcb
0003cc  68c0              LDR      r0,[r0,#0xc]          ;747
0003ce  4929              LDR      r1,|L5.1140|
0003d0  6008              STR      r0,[r1,#0]            ;747  ; tcp_tmp_pcb
                  |L5.978|
0003d2  4828              LDR      r0,|L5.1140|
0003d4  6800              LDR      r0,[r0,#0]            ;747  ; tcp_tmp_pcb
0003d6  2800              CMP      r0,#0                 ;747
0003d8  d1ea              BNE      |L5.944|
                  |L5.986|
0003da  bf00              NOP                            ;747
                  |L5.988|
0003dc  2000              MOVS     r0,#0                 ;747
0003de  60e0              STR      r0,[r4,#0xc]          ;747
0003e0  bf00              NOP                            ;747
0003e2  2001              MOVS     r0,#1                 ;747
0003e4  4924              LDR      r1,|L5.1144|
0003e6  7008              STRB     r0,[r1,#0]            ;747
0003e8  bf00              NOP                            ;747
0003ea  200a              MOVS     r0,#0xa               ;748
0003ec  7620              STRB     r0,[r4,#0x18]         ;748
0003ee  bf00              NOP                            ;749
0003f0  4822              LDR      r0,|L5.1148|
0003f2  6800              LDR      r0,[r0,#0]            ;749  ; tcp_tw_pcbs
0003f4  60e0              STR      r0,[r4,#0xc]          ;749
0003f6  4821              LDR      r0,|L5.1148|
0003f8  6004              STR      r4,[r0,#0]            ;749  ; tcp_tw_pcbs
0003fa  f7fffffe          BL       tcp_timer_needed
0003fe  e054              B        |L5.1194|
                  |L5.1024|
                          DCD      flags
                  |L5.1028|
                          DCD      ackno
                  |L5.1032|
                          DCD      seqno
                  |L5.1036|
00040c  7463705f          DCB      "tcp_input: pcb->state != CLOSED",0
000410  696e7075
000414  743a2070
000418  63622d3e
00041c  73746174
000420  6520213d
000424  20434c4f
000428  53454400
                  |L5.1068|
                          DCD      recv_flags
                  |L5.1072|
                          DCD      tcp_ticks
                  |L5.1076|
                          DCD      tcphdr
                  |L5.1080|
000438  7063622d          DCB      "pcb->snd_queuelen > 0",0
00043c  3e736e64
000440  5f717565
000444  75656c65
000448  6e203e20
00044c  3000    
00044e  00                DCB      0
00044f  00                DCB      0
                  |L5.1104|
                          DCD      tcplen
                  |L5.1108|
                          DCD      current_iphdr_src
                  |L5.1112|
                          DCD      current_iphdr_dest
                  |L5.1116|
00045c  7063622d          DCB      "pcb->accept != NULL",0
000460  3e616363
000464  65707420
000468  213d204e
00046c  554c4c00
                  |L5.1136|
                          DCD      tcp_active_pcbs
                  |L5.1140|
                          DCD      tcp_tmp_pcb
                  |L5.1144|
                          DCD      tcp_active_pcbs_changed
                  |L5.1148|
                          DCD      tcp_tw_pcbs
                  |L5.1152|
000480  bf00              NOP                            ;751
000482  7fa0              LDRB     r0,[r4,#0x1e]         ;751
000484  f0400002          ORR      r0,r0,#2              ;751
000488  77a0              STRB     r0,[r4,#0x1e]         ;751
00048a  bf00              NOP                            ;751
00048c  2008              MOVS     r0,#8                 ;752
00048e  7620              STRB     r0,[r4,#0x18]         ;752
000490  e00b              B        |L5.1194|
                  |L5.1170|
000492  4860              LDR      r0,|L5.1556|
000494  7800              LDRB     r0,[r0,#0]            ;754  ; flags
000496  f0000010          AND      r0,r0,#0x10           ;754
00049a  b130              CBZ      r0,|L5.1194|
00049c  495e              LDR      r1,|L5.1560|
00049e  6d20              LDR      r0,[r4,#0x50]         ;754
0004a0  6809              LDR      r1,[r1,#0]            ;754  ; ackno
0004a2  4288              CMP      r0,r1                 ;754
0004a4  d101              BNE      |L5.1194|
0004a6  2006              MOVS     r0,#6                 ;755
0004a8  7620              STRB     r0,[r4,#0x18]         ;755
                  |L5.1194|
0004aa  e0af              B        |L5.1548|
                  |L5.1196|
0004ac  4620              MOV      r0,r4                 ;759
0004ae  f7fffffe          BL       tcp_receive
0004b2  485a              LDR      r0,|L5.1564|
0004b4  7800              LDRB     r0,[r0,#0]            ;760  ; recv_flags
0004b6  f0000020          AND      r0,r0,#0x20           ;760
0004ba  b3e8              CBZ      r0,|L5.1336|
0004bc  bf00              NOP                            ;761
0004be  bf00              NOP                            ;761
0004c0  bf00              NOP                            ;762
0004c2  7fa0              LDRB     r0,[r4,#0x1e]         ;762
0004c4  f0400002          ORR      r0,r0,#2              ;762
0004c8  77a0              STRB     r0,[r4,#0x1e]         ;762
0004ca  bf00              NOP                            ;762
0004cc  4620              MOV      r0,r4                 ;763
0004ce  f7fffffe          BL       tcp_pcb_purge
0004d2  bf00              NOP                            ;764
0004d4  bf00              NOP                            ;764
0004d6  4852              LDR      r0,|L5.1568|
0004d8  6800              LDR      r0,[r0,#0]            ;764  ; tcp_active_pcbs
0004da  42a0              CMP      r0,r4                 ;764
0004dc  d105              BNE      |L5.1258|
0004de  4850              LDR      r0,|L5.1568|
0004e0  6800              LDR      r0,[r0,#0]            ;764  ; tcp_active_pcbs
0004e2  68c0              LDR      r0,[r0,#0xc]          ;764
0004e4  494e              LDR      r1,|L5.1568|
0004e6  6008              STR      r0,[r1,#0]            ;764  ; tcp_active_pcbs
0004e8  e018              B        |L5.1308|
                  |L5.1258|
0004ea  484d              LDR      r0,|L5.1568|
0004ec  6800              LDR      r0,[r0,#0]            ;764  ; tcp_active_pcbs
0004ee  494d              LDR      r1,|L5.1572|
0004f0  6008              STR      r0,[r1,#0]            ;764  ; tcp_tmp_pcb
0004f2  e00e              B        |L5.1298|
                  |L5.1268|
0004f4  484b              LDR      r0,|L5.1572|
0004f6  6800              LDR      r0,[r0,#0]            ;764  ; tcp_tmp_pcb
0004f8  68c0              LDR      r0,[r0,#0xc]          ;764
0004fa  42a0              CMP      r0,r4                 ;764
0004fc  d104              BNE      |L5.1288|
0004fe  4949              LDR      r1,|L5.1572|
000500  68e0              LDR      r0,[r4,#0xc]          ;764
000502  6809              LDR      r1,[r1,#0]            ;764  ; tcp_tmp_pcb
000504  60c8              STR      r0,[r1,#0xc]          ;764
000506  e008              B        |L5.1306|
                  |L5.1288|
000508  4846              LDR      r0,|L5.1572|
00050a  6800              LDR      r0,[r0,#0]            ;764  ; tcp_tmp_pcb
00050c  68c0              LDR      r0,[r0,#0xc]          ;764
00050e  4945              LDR      r1,|L5.1572|
000510  6008              STR      r0,[r1,#0]            ;764  ; tcp_tmp_pcb
                  |L5.1298|
000512  4844              LDR      r0,|L5.1572|
000514  6800              LDR      r0,[r0,#0]            ;764  ; tcp_tmp_pcb
000516  2800              CMP      r0,#0                 ;764
000518  d1ec              BNE      |L5.1268|
                  |L5.1306|
00051a  bf00              NOP                            ;764
                  |L5.1308|
00051c  2000              MOVS     r0,#0                 ;764
00051e  60e0              STR      r0,[r4,#0xc]          ;764
000520  bf00              NOP                            ;764
000522  2001              MOVS     r0,#1                 ;764
000524  4940              LDR      r1,|L5.1576|
000526  7008              STRB     r0,[r1,#0]            ;764
000528  bf00              NOP                            ;764
00052a  200a              MOVS     r0,#0xa               ;765
00052c  7620              STRB     r0,[r4,#0x18]         ;765
00052e  bf00              NOP                            ;766
000530  483e              LDR      r0,|L5.1580|
000532  6800              LDR      r0,[r0,#0]            ;766  ; tcp_tw_pcbs
000534  60e0              STR      r0,[r4,#0xc]          ;766
000536  e000              B        |L5.1338|
                  |L5.1336|
000538  e004              B        |L5.1348|
                  |L5.1338|
00053a  483c              LDR      r0,|L5.1580|
00053c  6004              STR      r4,[r0,#0]            ;766  ; tcp_tw_pcbs
00053e  f7fffffe          BL       tcp_timer_needed
000542  bf00              NOP                            ;766
                  |L5.1348|
000544  e062              B        |L5.1548|
                  |L5.1350|
000546  4620              MOV      r0,r4                 ;770
000548  f7fffffe          BL       tcp_receive
00054c  4831              LDR      r0,|L5.1556|
00054e  7800              LDRB     r0,[r0,#0]            ;771  ; flags
000550  f0000010          AND      r0,r0,#0x10           ;771
000554  b3f0              CBZ      r0,|L5.1492|
000556  4930              LDR      r1,|L5.1560|
000558  6d20              LDR      r0,[r4,#0x50]         ;771
00055a  6809              LDR      r1,[r1,#0]            ;771  ; ackno
00055c  4288              CMP      r0,r1                 ;771
00055e  d13d              BNE      |L5.1500|
000560  bf00              NOP                            ;772
000562  bf00              NOP                            ;772
000564  4620              MOV      r0,r4                 ;773
000566  f7fffffe          BL       tcp_pcb_purge
00056a  bf00              NOP                            ;774
00056c  bf00              NOP                            ;774
00056e  482c              LDR      r0,|L5.1568|
000570  6800              LDR      r0,[r0,#0]            ;774  ; tcp_active_pcbs
000572  42a0              CMP      r0,r4                 ;774
000574  d105              BNE      |L5.1410|
000576  482a              LDR      r0,|L5.1568|
000578  6800              LDR      r0,[r0,#0]            ;774  ; tcp_active_pcbs
00057a  68c0              LDR      r0,[r0,#0xc]          ;774
00057c  4928              LDR      r1,|L5.1568|
00057e  6008              STR      r0,[r1,#0]            ;774  ; tcp_active_pcbs
000580  e018              B        |L5.1460|
                  |L5.1410|
000582  4827              LDR      r0,|L5.1568|
000584  6800              LDR      r0,[r0,#0]            ;774  ; tcp_active_pcbs
000586  4927              LDR      r1,|L5.1572|
000588  6008              STR      r0,[r1,#0]            ;774  ; tcp_tmp_pcb
00058a  e00e              B        |L5.1450|
                  |L5.1420|
00058c  4825              LDR      r0,|L5.1572|
00058e  6800              LDR      r0,[r0,#0]            ;774  ; tcp_tmp_pcb
000590  68c0              LDR      r0,[r0,#0xc]          ;774
000592  42a0              CMP      r0,r4                 ;774
000594  d104              BNE      |L5.1440|
000596  4923              LDR      r1,|L5.1572|
000598  68e0              LDR      r0,[r4,#0xc]          ;774
00059a  6809              LDR      r1,[r1,#0]            ;774  ; tcp_tmp_pcb
00059c  60c8              STR      r0,[r1,#0xc]          ;774
00059e  e008              B        |L5.1458|
                  |L5.1440|
0005a0  4820              LDR      r0,|L5.1572|
0005a2  6800              LDR      r0,[r0,#0]            ;774  ; tcp_tmp_pcb
0005a4  68c0              LDR      r0,[r0,#0xc]          ;774
0005a6  491f              LDR      r1,|L5.1572|
0005a8  6008              STR      r0,[r1,#0]            ;774  ; tcp_tmp_pcb
                  |L5.1450|
0005aa  481e              LDR      r0,|L5.1572|
0005ac  6800              LDR      r0,[r0,#0]            ;774  ; tcp_tmp_pcb
0005ae  2800              CMP      r0,#0                 ;774
0005b0  d1ec              BNE      |L5.1420|
                  |L5.1458|
0005b2  bf00              NOP                            ;774
                  |L5.1460|
0005b4  2000              MOVS     r0,#0                 ;774
0005b6  60e0              STR      r0,[r4,#0xc]          ;774
0005b8  bf00              NOP                            ;774
0005ba  2001              MOVS     r0,#1                 ;774
0005bc  491a              LDR      r1,|L5.1576|
0005be  7008              STRB     r0,[r1,#0]            ;774
0005c0  bf00              NOP                            ;774
0005c2  200a              MOVS     r0,#0xa               ;775
0005c4  7620              STRB     r0,[r4,#0x18]         ;775
0005c6  bf00              NOP                            ;776
0005c8  4818              LDR      r0,|L5.1580|
0005ca  6800              LDR      r0,[r0,#0]            ;776  ; tcp_tw_pcbs
0005cc  60e0              STR      r0,[r4,#0xc]          ;776
0005ce  4817              LDR      r0,|L5.1580|
0005d0  6004              STR      r4,[r0,#0]            ;776  ; tcp_tw_pcbs
0005d2  e000              B        |L5.1494|
                  |L5.1492|
0005d4  e002              B        |L5.1500|
                  |L5.1494|
0005d6  f7fffffe          BL       tcp_timer_needed
0005da  bf00              NOP                            ;776
                  |L5.1500|
0005dc  e016              B        |L5.1548|
                  |L5.1502|
0005de  4620              MOV      r0,r4                 ;780
0005e0  f7fffffe          BL       tcp_receive
0005e4  480b              LDR      r0,|L5.1556|
0005e6  7800              LDRB     r0,[r0,#0]            ;781  ; flags
0005e8  f0000010          AND      r0,r0,#0x10           ;781
0005ec  b160              CBZ      r0,|L5.1544|
0005ee  490a              LDR      r1,|L5.1560|
0005f0  6d20              LDR      r0,[r4,#0x50]         ;781
0005f2  6809              LDR      r1,[r1,#0]            ;781  ; ackno
0005f4  4288              CMP      r0,r1                 ;781
0005f6  d107              BNE      |L5.1544|
0005f8  bf00              NOP                            ;782
0005fa  bf00              NOP                            ;782
0005fc  4807              LDR      r0,|L5.1564|
0005fe  7800              LDRB     r0,[r0,#0]            ;784  ; recv_flags
000600  f0400010          ORR      r0,r0,#0x10           ;784
000604  4905              LDR      r1,|L5.1564|
000606  7008              STRB     r0,[r1,#0]            ;784
                  |L5.1544|
000608  e000              B        |L5.1548|
                  |L5.1546|
00060a  bf00              NOP                            ;788
                  |L5.1548|
00060c  bf00              NOP                            ;682
00060e  2000              MOVS     r0,#0                 ;790
000610  e536              B        |L5.128|
;;;792    
                          ENDP

000612  0000              DCW      0x0000
                  |L5.1556|
                          DCD      flags
                  |L5.1560|
                          DCD      ackno
                  |L5.1564|
                          DCD      recv_flags
                  |L5.1568|
                          DCD      tcp_active_pcbs
                  |L5.1572|
                          DCD      tcp_tmp_pcb
                  |L5.1576|
                          DCD      tcp_active_pcbs_changed
                  |L5.1580|
                          DCD      tcp_tw_pcbs

                          AREA ||i.tcp_receive||, CODE, READONLY, ALIGN=2

                  tcp_receive PROC
;;;846    static void
;;;847    tcp_receive(struct tcp_pcb *pcb)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;848    {
000004  4604              MOV      r4,r0
;;;849      struct tcp_seg *next;
;;;850    #if TCP_QUEUE_OOSEQ
;;;851      struct tcp_seg *prev, *cseg;
;;;852    #endif /* TCP_QUEUE_OOSEQ */
;;;853      struct pbuf *p;
;;;854      s32_t off;
;;;855      s16_t m;
;;;856      u32_t right_wnd_edge;
;;;857      u16_t new_tot_len;
;;;858      int found_dupack = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;859    #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;860      u32_t ooseq_blen;
;;;861      u16_t ooseq_qlen;
;;;862    #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;863    
;;;864      LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
00000a  bf00              NOP      
00000c  7e20              LDRB     r0,[r4,#0x18]
00000e  2804              CMP      r0,#4
000010  da04              BGE      |L6.28|
000012  a0fa              ADR      r0,|L6.1020|
000014  f7fffffe          BL       __2printf
000018  bf00              NOP      
                  |L6.26|
00001a  e7fe              B        |L6.26|
                  |L6.28|
00001c  bf00              NOP      
;;;865    
;;;866      if (flags & TCP_ACK) {
00001e  48fe              LDR      r0,|L6.1048|
000020  7800              LDRB     r0,[r0,#0]  ; flags
000022  f0000010          AND      r0,r0,#0x10
000026  2800              CMP      r0,#0
000028  d07e              BEQ      |L6.296|
;;;867        right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
00002a  f8b40060          LDRH     r0,[r4,#0x60]
00002e  6da1              LDR      r1,[r4,#0x58]
000030  4408              ADD      r0,r0,r1
000032  9002              STR      r0,[sp,#8]
;;;868    
;;;869        /* Update window. */
;;;870        if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
000034  49f9              LDR      r1,|L6.1052|
000036  6d60              LDR      r0,[r4,#0x54]
000038  6809              LDR      r1,[r1,#0]  ; seqno
00003a  1a40              SUBS     r0,r0,r1
00003c  d415              BMI      |L6.106|
;;;871           (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
00003e  49f7              LDR      r1,|L6.1052|
000040  6d60              LDR      r0,[r4,#0x54]
000042  6809              LDR      r1,[r1,#0]  ; seqno
000044  4288              CMP      r0,r1
000046  d104              BNE      |L6.82|
000048  49f5              LDR      r1,|L6.1056|
00004a  6da0              LDR      r0,[r4,#0x58]
00004c  6809              LDR      r1,[r1,#0]  ; ackno
00004e  1a40              SUBS     r0,r0,r1
000050  d40b              BMI      |L6.106|
                  |L6.82|
;;;872           (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
000052  49f3              LDR      r1,|L6.1056|
000054  6da0              LDR      r0,[r4,#0x58]
000056  6809              LDR      r1,[r1,#0]  ; ackno
000058  4288              CMP      r0,r1
00005a  d133              BNE      |L6.196|
00005c  48f1              LDR      r0,|L6.1060|
00005e  6800              LDR      r0,[r0,#0]  ; tcphdr
000060  89c0              LDRH     r0,[r0,#0xe]
000062  f8b41060          LDRH     r1,[r4,#0x60]
000066  4288              CMP      r0,r1
000068  dd2c              BLE      |L6.196|
                  |L6.106|
;;;873          pcb->snd_wnd = tcphdr->wnd;
00006a  48ee              LDR      r0,|L6.1060|
00006c  6800              LDR      r0,[r0,#0]  ; tcphdr
00006e  89c0              LDRH     r0,[r0,#0xe]
000070  f8a40060          STRH     r0,[r4,#0x60]
;;;874          /* keep track of the biggest window announced by the remote host to calculate
;;;875             the maximum segment size */
;;;876          if (pcb->snd_wnd_max < tcphdr->wnd) {
000074  f8b40062          LDRH     r0,[r4,#0x62]
000078  49ea              LDR      r1,|L6.1060|
00007a  6809              LDR      r1,[r1,#0]  ; tcphdr
00007c  89c9              LDRH     r1,[r1,#0xe]
00007e  4288              CMP      r0,r1
000080  da04              BGE      |L6.140|
;;;877            pcb->snd_wnd_max = tcphdr->wnd;
000082  48e8              LDR      r0,|L6.1060|
000084  6800              LDR      r0,[r0,#0]  ; tcphdr
000086  89c0              LDRH     r0,[r0,#0xe]
000088  f8a40062          STRH     r0,[r4,#0x62]
                  |L6.140|
;;;878          }
;;;879          pcb->snd_wl1 = seqno;
00008c  48e3              LDR      r0,|L6.1052|
00008e  6800              LDR      r0,[r0,#0]  ; seqno
000090  6560              STR      r0,[r4,#0x54]
;;;880          pcb->snd_wl2 = ackno;
000092  48e3              LDR      r0,|L6.1056|
000094  6800              LDR      r0,[r0,#0]  ; ackno
000096  65a0              STR      r0,[r4,#0x58]
;;;881          if (pcb->snd_wnd == 0) {
000098  f8b40060          LDRH     r0,[r4,#0x60]
00009c  b948              CBNZ     r0,|L6.178|
;;;882            if (pcb->persist_backoff == 0) {
00009e  f8940095          LDRB     r0,[r4,#0x95]
0000a2  b968              CBNZ     r0,|L6.192|
;;;883              /* start persist timer */
;;;884              pcb->persist_cnt = 0;
0000a4  2000              MOVS     r0,#0
0000a6  f8840094          STRB     r0,[r4,#0x94]
;;;885              pcb->persist_backoff = 1;
0000aa  2001              MOVS     r0,#1
0000ac  f8840095          STRB     r0,[r4,#0x95]
0000b0  e006              B        |L6.192|
                  |L6.178|
;;;886            }
;;;887          } else if (pcb->persist_backoff > 0) {
0000b2  f8940095          LDRB     r0,[r4,#0x95]
0000b6  2800              CMP      r0,#0
0000b8  dd02              BLE      |L6.192|
;;;888            /* stop persist timer */
;;;889              pcb->persist_backoff = 0;
0000ba  2000              MOVS     r0,#0
0000bc  f8840095          STRB     r0,[r4,#0x95]
                  |L6.192|
;;;890          }
;;;891          LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"U16_F"\n", pcb->snd_wnd));
0000c0  bf00              NOP      
0000c2  bf00              NOP      
                  |L6.196|
;;;892    #if TCP_WND_DEBUG
;;;893        } else {
;;;894          if (pcb->snd_wnd != tcphdr->wnd) {
;;;895            LWIP_DEBUGF(TCP_WND_DEBUG, 
;;;896                        ("tcp_receive: no window update lastack %"U32_F" ackno %"
;;;897                         U32_F" wl1 %"U32_F" seqno %"U32_F" wl2 %"U32_F"\n",
;;;898                         pcb->lastack, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
;;;899          }
;;;900    #endif /* TCP_WND_DEBUG */
;;;901        }
;;;902    
;;;903        /* (From Stevens TCP/IP Illustrated Vol II, p970.) Its only a
;;;904         * duplicate ack if:
;;;905         * 1) It doesn't ACK new data 
;;;906         * 2) length of received packet is zero (i.e. no payload) 
;;;907         * 3) the advertised window hasn't changed 
;;;908         * 4) There is outstanding unacknowledged data (retransmission timer running)
;;;909         * 5) The ACK is == biggest ACK sequence number so far seen (snd_una)
;;;910         * 
;;;911         * If it passes all five, should process as a dupack: 
;;;912         * a) dupacks < 3: do nothing 
;;;913         * b) dupacks == 3: fast retransmit 
;;;914         * c) dupacks > 3: increase cwnd 
;;;915         * 
;;;916         * If it only passes 1-3, should reset dupack counter (and add to
;;;917         * stats, which we don't do in lwIP)
;;;918         *
;;;919         * If it only passes 1, should reset dupack counter
;;;920         *
;;;921         */
;;;922    
;;;923        /* Clause 1 */
;;;924        if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
0000c4  49d6              LDR      r1,|L6.1056|
0000c6  6ca0              LDR      r0,[r4,#0x48]
0000c8  6809              LDR      r1,[r1,#0]  ; ackno
0000ca  1a08              SUBS     r0,r1,r0
0000cc  2800              CMP      r0,#0
0000ce  dc48              BGT      |L6.354|
;;;925          pcb->acked = 0;
0000d0  2000              MOVS     r0,#0
0000d2  f8a40064          STRH     r0,[r4,#0x64]
;;;926          /* Clause 2 */
;;;927          if (tcplen == 0) {
0000d6  48d4              LDR      r0,|L6.1064|
0000d8  8800              LDRH     r0,[r0,#0]  ; tcplen
0000da  bb30              CBNZ     r0,|L6.298|
;;;928            /* Clause 3 */
;;;929            if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
0000dc  f8b41060          LDRH     r1,[r4,#0x60]
0000e0  6da0              LDR      r0,[r4,#0x58]
0000e2  4401              ADD      r1,r1,r0
0000e4  9802              LDR      r0,[sp,#8]
0000e6  4281              CMP      r1,r0
0000e8  d135              BNE      |L6.342|
;;;930              /* Clause 4 */
;;;931              if (pcb->rtime >= 0) {
0000ea  f9b40034          LDRSH    r0,[r4,#0x34]
0000ee  2800              CMP      r0,#0
0000f0  db31              BLT      |L6.342|
;;;932                /* Clause 5 */
;;;933                if (pcb->lastack == ackno) {
0000f2  49cb              LDR      r1,|L6.1056|
0000f4  6ca0              LDR      r0,[r4,#0x48]
0000f6  6809              LDR      r1,[r1,#0]  ; ackno
0000f8  4288              CMP      r0,r1
0000fa  d12c              BNE      |L6.342|
;;;934                  found_dupack = 1;
0000fc  2001              MOVS     r0,#1
0000fe  9000              STR      r0,[sp,#0]
;;;935                  if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
000100  f8940047          LDRB     r0,[r4,#0x47]
000104  1c40              ADDS     r0,r0,#1
000106  b2c0              UXTB     r0,r0
000108  f8941047          LDRB     r1,[r4,#0x47]
00010c  4288              CMP      r0,r1
00010e  dd04              BLE      |L6.282|
;;;936                    ++pcb->dupacks;
000110  f8940047          LDRB     r0,[r4,#0x47]
000114  1c40              ADDS     r0,r0,#1
000116  f8840047          STRB     r0,[r4,#0x47]
                  |L6.282|
;;;937                  }
;;;938                  if (pcb->dupacks > 3) {
00011a  f8940047          LDRB     r0,[r4,#0x47]
00011e  2803              CMP      r0,#3
000120  dd12              BLE      |L6.328|
;;;939                    /* Inflate the congestion window, but not if it means that
;;;940                       the value overflows. */
;;;941                    if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
000122  f8b4004c          LDRH     r0,[r4,#0x4c]
000126  e001              B        |L6.300|
                  |L6.296|
000128  e166              B        |L6.1016|
                  |L6.298|
00012a  e00c              B        |L6.326|
                  |L6.300|
00012c  8ee1              LDRH     r1,[r4,#0x36]
00012e  4408              ADD      r0,r0,r1
000130  b280              UXTH     r0,r0
000132  f8b4104c          LDRH     r1,[r4,#0x4c]
000136  4288              CMP      r0,r1
000138  dd0d              BLE      |L6.342|
;;;942                      pcb->cwnd += pcb->mss;
00013a  f8b4004c          LDRH     r0,[r4,#0x4c]
00013e  8ee1              LDRH     r1,[r4,#0x36]
000140  4408              ADD      r0,r0,r1
000142  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L6.326|
000146  e006              B        |L6.342|
                  |L6.328|
;;;943                    }
;;;944                  } else if (pcb->dupacks == 3) {
000148  f8940047          LDRB     r0,[r4,#0x47]
00014c  2803              CMP      r0,#3
00014e  d102              BNE      |L6.342|
;;;945                    /* Do fast retransmit */
;;;946                    tcp_rexmit_fast(pcb);
000150  4620              MOV      r0,r4
000152  f7fffffe          BL       tcp_rexmit_fast
                  |L6.342|
;;;947                  }
;;;948                }
;;;949              }
;;;950            }
;;;951          }
;;;952          /* If Clause (1) or more is true, but not a duplicate ack, reset
;;;953           * count of consecutive duplicate acks */
;;;954          if (!found_dupack) {
000156  9800              LDR      r0,[sp,#0]
000158  2800              CMP      r0,#0
00015a  d101              BNE      |L6.352|
;;;955            pcb->dupacks = 0;
00015c  f8840047          STRB     r0,[r4,#0x47]
                  |L6.352|
000160  e0cb              B        |L6.762|
                  |L6.354|
;;;956          }
;;;957        } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
000162  6ca0              LDR      r0,[r4,#0x48]
000164  1c40              ADDS     r0,r0,#1
000166  49ae              LDR      r1,|L6.1056|
000168  6809              LDR      r1,[r1,#0]  ; ackno
00016a  1a08              SUBS     r0,r1,r0
00016c  d47d              BMI      |L6.618|
00016e  49ac              LDR      r1,|L6.1056|
000170  6d20              LDR      r0,[r4,#0x50]
000172  6809              LDR      r1,[r1,#0]  ; ackno
000174  1a08              SUBS     r0,r1,r0
000176  2800              CMP      r0,#0
000178  dc77              BGT      |L6.618|
;;;958          /* We come here when the ACK acknowledges new data. */
;;;959    
;;;960          /* Reset the "IN Fast Retransmit" flag, since we are no longer
;;;961             in fast retransmit. Also reset the congestion window to the
;;;962             slow start threshold. */
;;;963          if (pcb->flags & TF_INFR) {
00017a  7fa0              LDRB     r0,[r4,#0x1e]
00017c  f0000004          AND      r0,r0,#4
000180  b138              CBZ      r0,|L6.402|
;;;964            pcb->flags &= ~TF_INFR;
000182  7fa0              LDRB     r0,[r4,#0x1e]
000184  f0200004          BIC      r0,r0,#4
000188  77a0              STRB     r0,[r4,#0x1e]
;;;965            pcb->cwnd = pcb->ssthresh;
00018a  f8b4004e          LDRH     r0,[r4,#0x4e]
00018e  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L6.402|
;;;966          }
;;;967    
;;;968          /* Reset the number of retransmissions. */
;;;969          pcb->nrtx = 0;
000192  2000              MOVS     r0,#0
000194  3428              ADDS     r4,r4,#0x28
000196  77a0              STRB     r0,[r4,#0x1e]
;;;970    
;;;971          /* Reset the retransmission time-out. */
;;;972          pcb->rto = (pcb->sa >> 3) + pcb->sv;
000198  8b60              LDRH     r0,[r4,#0x1a]
00019a  f9b41018          LDRSH    r1,[r4,#0x18]
00019e  eb0000e1          ADD      r0,r0,r1,ASR #3
0001a2  b200              SXTH     r0,r0
0001a4  83a0              STRH     r0,[r4,#0x1c]
;;;973    
;;;974          /* Update the send buffer space. Diff between the two can never exceed 64K? */
;;;975          pcb->acked = (u16_t)(ackno - pcb->lastack);
0001a6  8c20              LDRH     r0,[r4,#0x20]
0001a8  499d              LDR      r1,|L6.1056|
0001aa  8809              LDRH     r1,[r1,#0]  ; ackno
0001ac  1a08              SUBS     r0,r1,r0
0001ae  87a0              STRH     r0,[r4,#0x3c]
;;;976    
;;;977          pcb->snd_buf += pcb->acked;
0001b0  8fe0              LDRH     r0,[r4,#0x3e]
0001b2  8fa1              LDRH     r1,[r4,#0x3c]
0001b4  4408              ADD      r0,r0,r1
0001b6  87e0              STRH     r0,[r4,#0x3e]
;;;978    
;;;979          /* Reset the fast retransmit variables. */
;;;980          pcb->dupacks = 0;
0001b8  2000              MOVS     r0,#0
0001ba  77e0              STRB     r0,[r4,#0x1f]
;;;981          pcb->lastack = ackno;
0001bc  4898              LDR      r0,|L6.1056|
0001be  6800              LDR      r0,[r0,#0]  ; ackno
0001c0  6220              STR      r0,[r4,#0x20]
;;;982    
;;;983          /* Update the congestion control variables (cwnd and
;;;984             ssthresh). */
;;;985          if (pcb->state >= ESTABLISHED) {
0001c2  f8140c10          LDRB     r0,[r4,#-0x10]
0001c6  3c28              SUBS     r4,r4,#0x28
0001c8  2804              CMP      r0,#4
0001ca  db27              BLT      |L6.540|
;;;986            if (pcb->cwnd < pcb->ssthresh) {
0001cc  f8b4004c          LDRH     r0,[r4,#0x4c]
0001d0  f8b4104e          LDRH     r1,[r4,#0x4e]
0001d4  4288              CMP      r0,r1
0001d6  da10              BGE      |L6.506|
;;;987              if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
0001d8  f8b4004c          LDRH     r0,[r4,#0x4c]
0001dc  8ee1              LDRH     r1,[r4,#0x36]
0001de  4408              ADD      r0,r0,r1
0001e0  b280              UXTH     r0,r0
0001e2  f8b4104c          LDRH     r1,[r4,#0x4c]
0001e6  4288              CMP      r0,r1
0001e8  dd05              BLE      |L6.502|
;;;988                pcb->cwnd += pcb->mss;
0001ea  f8b4004c          LDRH     r0,[r4,#0x4c]
0001ee  8ee1              LDRH     r1,[r4,#0x36]
0001f0  4408              ADD      r0,r0,r1
0001f2  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L6.502|
;;;989              }
;;;990              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
0001f6  bf00              NOP      
0001f8  e010              B        |L6.540|
                  |L6.506|
;;;991            } else {
;;;992              u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
0001fa  f8341f36          LDRH     r1,[r4,#0x36]!
0001fe  4349              MULS     r1,r1,r1
000200  8ae2              LDRH     r2,[r4,#0x16]
000202  fb91f1f2          SDIV     r1,r1,r2
000206  4411              ADD      r1,r1,r2
000208  b288              UXTH     r0,r1
;;;993              if (new_cwnd > pcb->cwnd) {
00020a  8ae1              LDRH     r1,[r4,#0x16]
00020c  3c36              SUBS     r4,r4,#0x36
00020e  4281              CMP      r1,r0
000210  da01              BGE      |L6.534|
;;;994                pcb->cwnd = new_cwnd;
000212  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L6.534|
;;;995              }
;;;996              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: congestion avoidance cwnd %"U16_F"\n", pcb->cwnd));
000216  bf00              NOP      
000218  bf00              NOP      
;;;997            }
00021a  bf00              NOP      
                  |L6.540|
;;;998          }
;;;999          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: ACK for %"U32_F", unacked->seqno %"U32_F":%"U32_F"\n",
00021c  bf00              NOP      
00021e  bf00              NOP      
;;;1000                                       ackno,
;;;1001                                       pcb->unacked != NULL?
;;;1002                                       ntohl(pcb->unacked->tcphdr->seqno): 0,
;;;1003                                       pcb->unacked != NULL?
;;;1004                                       ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));
;;;1005   
;;;1006         /* Remove segment from the unacknowledged list if the incoming
;;;1007            ACK acknowlegdes them. */
;;;1008         while (pcb->unacked != NULL &&
000220  e041              B        |L6.678|
                  |L6.546|
;;;1009                TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
;;;1010                            TCP_TCPLEN(pcb->unacked), ackno)) {
;;;1011           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
000222  bf00              NOP      
000224  bf00              NOP      
;;;1012                                         ntohl(pcb->unacked->tcphdr->seqno),
;;;1013                                         ntohl(pcb->unacked->tcphdr->seqno) +
;;;1014                                         TCP_TCPLEN(pcb->unacked)));
;;;1015   
;;;1016           next = pcb->unacked;
000226  6f25              LDR      r5,[r4,#0x70]
;;;1017           pcb->unacked = pcb->unacked->next;
000228  6f20              LDR      r0,[r4,#0x70]
00022a  6800              LDR      r0,[r0,#0]
00022c  6720              STR      r0,[r4,#0x70]
;;;1018   
;;;1019           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
00022e  bf00              NOP      
000230  bf00              NOP      
;;;1020           LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
000232  bf00              NOP      
000234  6868              LDR      r0,[r5,#4]
000236  f7fffffe          BL       pbuf_clen
00023a  f8b41068          LDRH     r1,[r4,#0x68]
00023e  4288              CMP      r0,r1
000240  dd04              BLE      |L6.588|
000242  a07a              ADR      r0,|L6.1068|
000244  f7fffffe          BL       __2printf
000248  bf00              NOP      
                  |L6.586|
00024a  e7fe              B        |L6.586|
                  |L6.588|
00024c  bf00              NOP      
;;;1021           /* Prevent ACK for FIN to generate a sent event */
;;;1022           if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
00024e  f8b40064          LDRH     r0,[r4,#0x64]
000252  b168              CBZ      r0,|L6.624|
000254  6929              LDR      r1,[r5,#0x10]
000256  8988              LDRH     r0,[r1,#0xc]
000258  f7fffffe          BL       lwip_ntohs
00025c  f0000001          AND      r0,r0,#1
000260  b130              CBZ      r0,|L6.624|
;;;1023             pcb->acked--;
000262  f8b40064          LDRH     r0,[r4,#0x64]
000266  1e40              SUBS     r0,r0,#1
000268  e000              B        |L6.620|
                  |L6.618|
00026a  e043              B        |L6.756|
                  |L6.620|
00026c  f8a40064          STRH     r0,[r4,#0x64]
                  |L6.624|
;;;1024           }
;;;1025   
;;;1026           pcb->snd_queuelen -= pbuf_clen(next->p);
000270  6868              LDR      r0,[r5,#4]
000272  f7fffffe          BL       pbuf_clen
000276  f8b41068          LDRH     r1,[r4,#0x68]
00027a  1a08              SUBS     r0,r1,r0
00027c  f8a40068          STRH     r0,[r4,#0x68]
;;;1027           tcp_seg_free(next);
000280  4628              MOV      r0,r5
000282  f7fffffe          BL       tcp_seg_free
;;;1028   
;;;1029           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
000286  bf00              NOP      
000288  bf00              NOP      
;;;1030           if (pcb->snd_queuelen != 0) {
00028a  f8b40068          LDRH     r0,[r4,#0x68]
00028e  b150              CBZ      r0,|L6.678|
;;;1031             LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
000290  bf00              NOP      
000292  6f20              LDR      r0,[r4,#0x70]
000294  b930              CBNZ     r0,|L6.676|
000296  6ee0              LDR      r0,[r4,#0x6c]
000298  b920              CBNZ     r0,|L6.676|
00029a  a06e              ADR      r0,|L6.1108|
00029c  f7fffffe          BL       __2printf
0002a0  bf00              NOP      
                  |L6.674|
0002a2  e7fe              B        |L6.674|
                  |L6.676|
0002a4  bf00              NOP      
                  |L6.678|
0002a6  6f20              LDR      r0,[r4,#0x70]         ;1008
0002a8  b1c8              CBZ      r0,|L6.734|
0002aa  6f21              LDR      r1,[r4,#0x70]         ;1009
0002ac  6909              LDR      r1,[r1,#0x10]         ;1009
0002ae  6848              LDR      r0,[r1,#4]            ;1009
0002b0  f7fffffe          BL       lwip_ntohl
0002b4  4683              MOV      r11,r0                ;1009
0002b6  6f21              LDR      r1,[r4,#0x70]         ;1009
0002b8  6909              LDR      r1,[r1,#0x10]         ;1009
0002ba  8988              LDRH     r0,[r1,#0xc]          ;1009
0002bc  f7fffffe          BL       lwip_ntohs
0002c0  f0000003          AND      r0,r0,#3              ;1009
0002c4  b108              CBZ      r0,|L6.714|
0002c6  2001              MOVS     r0,#1                 ;1009
0002c8  e000              B        |L6.716|
                  |L6.714|
0002ca  2000              MOVS     r0,#0                 ;1009
                  |L6.716|
0002cc  6f21              LDR      r1,[r4,#0x70]         ;1009
0002ce  8909              LDRH     r1,[r1,#8]            ;1009
0002d0  4408              ADD      r0,r0,r1              ;1009
0002d2  4458              ADD      r0,r0,r11             ;1009
0002d4  4952              LDR      r1,|L6.1056|
0002d6  6809              LDR      r1,[r1,#0]            ;1009  ; ackno
0002d8  1a40              SUBS     r0,r0,r1              ;1009
0002da  2800              CMP      r0,#0                 ;1009
0002dc  dda1              BLE      |L6.546|
                  |L6.734|
;;;1032                         pcb->unsent != NULL);
;;;1033           }
;;;1034         }
;;;1035   
;;;1036         /* If there's nothing left to acknowledge, stop the retransmit
;;;1037            timer, otherwise reset it to start again */
;;;1038         if(pcb->unacked == NULL)
0002de  6f20              LDR      r0,[r4,#0x70]
0002e0  b918              CBNZ     r0,|L6.746|
;;;1039           pcb->rtime = -1;
0002e2  f04f30ff          MOV      r0,#0xffffffff
0002e6  86a0              STRH     r0,[r4,#0x34]
0002e8  e001              B        |L6.750|
                  |L6.746|
;;;1040         else
;;;1041           pcb->rtime = 0;
0002ea  2000              MOVS     r0,#0
0002ec  86a0              STRH     r0,[r4,#0x34]
                  |L6.750|
;;;1042   
;;;1043         pcb->polltmr = 0;
0002ee  2000              MOVS     r0,#0
0002f0  77e0              STRB     r0,[r4,#0x1f]
0002f2  e002              B        |L6.762|
                  |L6.756|
;;;1044       } else {
;;;1045         /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
;;;1046         pcb->acked = 0;
0002f4  2000              MOVS     r0,#0
0002f6  f8a40064          STRH     r0,[r4,#0x64]
                  |L6.762|
;;;1047       }
;;;1048   
;;;1049       /* We go through the ->unsent list to see if any of the segments
;;;1050          on the list are acknowledged by the ACK. This may seem
;;;1051          strange since an "unsent" segment shouldn't be acked. The
;;;1052          rationale is that lwIP puts all outstanding segments on the
;;;1053          ->unsent list after a retransmission, so these segments may
;;;1054          in fact have been sent once. */
;;;1055       while (pcb->unsent != NULL &&
0002fa  e044              B        |L6.902|
                  |L6.764|
;;;1056              TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
;;;1057                              TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
;;;1058         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
0002fc  bf00              NOP      
0002fe  bf00              NOP      
;;;1059                                       ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
;;;1060                                       TCP_TCPLEN(pcb->unsent)));
;;;1061   
;;;1062         next = pcb->unsent;
000300  6ee5              LDR      r5,[r4,#0x6c]
;;;1063         pcb->unsent = pcb->unsent->next;
000302  6ee0              LDR      r0,[r4,#0x6c]
000304  6800              LDR      r0,[r0,#0]
000306  66e0              STR      r0,[r4,#0x6c]
;;;1064   #if TCP_OVERSIZE
;;;1065         if (pcb->unsent == NULL) {
000308  6ee0              LDR      r0,[r4,#0x6c]
00030a  b910              CBNZ     r0,|L6.786|
;;;1066           pcb->unsent_oversize = 0;
00030c  2000              MOVS     r0,#0
00030e  f8a4006a          STRH     r0,[r4,#0x6a]
                  |L6.786|
;;;1067         }
;;;1068   #endif /* TCP_OVERSIZE */ 
;;;1069         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
000312  bf00              NOP      
000314  bf00              NOP      
;;;1070         LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
000316  bf00              NOP      
000318  6868              LDR      r0,[r5,#4]
00031a  f7fffffe          BL       pbuf_clen
00031e  f8b41068          LDRH     r1,[r4,#0x68]
000322  4288              CMP      r0,r1
000324  dd04              BLE      |L6.816|
000326  a041              ADR      r0,|L6.1068|
000328  f7fffffe          BL       __2printf
00032c  bf00              NOP      
                  |L6.814|
00032e  e7fe              B        |L6.814|
                  |L6.816|
000330  bf00              NOP      
;;;1071         /* Prevent ACK for FIN to generate a sent event */
;;;1072         if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
000332  f8b40064          LDRH     r0,[r4,#0x64]
000336  b158              CBZ      r0,|L6.848|
000338  6929              LDR      r1,[r5,#0x10]
00033a  8988              LDRH     r0,[r1,#0xc]
00033c  f7fffffe          BL       lwip_ntohs
000340  f0000001          AND      r0,r0,#1
000344  b120              CBZ      r0,|L6.848|
;;;1073           pcb->acked--;
000346  f8b40064          LDRH     r0,[r4,#0x64]
00034a  1e40              SUBS     r0,r0,#1
00034c  f8a40064          STRH     r0,[r4,#0x64]
                  |L6.848|
;;;1074         }
;;;1075         pcb->snd_queuelen -= pbuf_clen(next->p);
000350  6868              LDR      r0,[r5,#4]
000352  f7fffffe          BL       pbuf_clen
000356  f8b41068          LDRH     r1,[r4,#0x68]
00035a  1a08              SUBS     r0,r1,r0
00035c  f8a40068          STRH     r0,[r4,#0x68]
;;;1076         tcp_seg_free(next);
000360  4628              MOV      r0,r5
000362  f7fffffe          BL       tcp_seg_free
;;;1077         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
000366  bf00              NOP      
000368  bf00              NOP      
;;;1078         if (pcb->snd_queuelen != 0) {
00036a  f8b40068          LDRH     r0,[r4,#0x68]
00036e  b150              CBZ      r0,|L6.902|
;;;1079           LWIP_ASSERT("tcp_receive: valid queue length",
000370  bf00              NOP      
000372  6f20              LDR      r0,[r4,#0x70]
000374  b930              CBNZ     r0,|L6.900|
000376  6ee0              LDR      r0,[r4,#0x6c]
000378  b920              CBNZ     r0,|L6.900|
00037a  a036              ADR      r0,|L6.1108|
00037c  f7fffffe          BL       __2printf
000380  bf00              NOP      
                  |L6.898|
000382  e7fe              B        |L6.898|
                  |L6.900|
000384  bf00              NOP      
                  |L6.902|
000386  6ee0              LDR      r0,[r4,#0x6c]         ;1055
000388  b1f0              CBZ      r0,|L6.968|
00038a  6ee1              LDR      r1,[r4,#0x6c]         ;1056
00038c  6909              LDR      r1,[r1,#0x10]         ;1056
00038e  6848              LDR      r0,[r1,#4]            ;1056
000390  f7fffffe          BL       lwip_ntohl
000394  4683              MOV      r11,r0                ;1056
000396  6ee1              LDR      r1,[r4,#0x6c]         ;1056
000398  6909              LDR      r1,[r1,#0x10]         ;1056
00039a  8988              LDRH     r0,[r1,#0xc]          ;1056
00039c  f7fffffe          BL       lwip_ntohs
0003a0  f0000003          AND      r0,r0,#3              ;1056
0003a4  b108              CBZ      r0,|L6.938|
0003a6  2001              MOVS     r0,#1                 ;1056
0003a8  e000              B        |L6.940|
                  |L6.938|
0003aa  2000              MOVS     r0,#0                 ;1056
                  |L6.940|
0003ac  6ee1              LDR      r1,[r4,#0x6c]         ;1056
0003ae  8909              LDRH     r1,[r1,#8]            ;1056
0003b0  4408              ADD      r0,r0,r1              ;1056
0003b2  4458              ADD      r0,r0,r11             ;1056
0003b4  491a              LDR      r1,|L6.1056|
0003b6  6809              LDR      r1,[r1,#0]            ;1056  ; ackno
0003b8  1a08              SUBS     r0,r1,r0              ;1056
0003ba  d405              BMI      |L6.968|
0003bc  4918              LDR      r1,|L6.1056|
0003be  6d20              LDR      r0,[r4,#0x50]         ;1056
0003c0  6809              LDR      r1,[r1,#0]            ;1056  ; ackno
0003c2  1a08              SUBS     r0,r1,r0              ;1056
0003c4  2800              CMP      r0,#0                 ;1056
0003c6  dd99              BLE      |L6.764|
                  |L6.968|
;;;1080             pcb->unacked != NULL || pcb->unsent != NULL);
;;;1081         }
;;;1082       }
;;;1083       /* End of ACK for new data processing. */
;;;1084   
;;;1085       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: pcb->rttest %"U32_F" rtseq %"U32_F" ackno %"U32_F"\n",
0003c8  bf00              NOP      
0003ca  bf00              NOP      
;;;1086                                   pcb->rttest, pcb->rtseq, ackno));
;;;1087   
;;;1088       /* RTT estimation calculations. This is done by checking if the
;;;1089          incoming segment acknowledges the segment we use to take a
;;;1090          round-trip time measurement. */
;;;1091       if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
0003cc  6ba0              LDR      r0,[r4,#0x38]
0003ce  b198              CBZ      r0,|L6.1016|
0003d0  4913              LDR      r1,|L6.1056|
0003d2  6be0              LDR      r0,[r4,#0x3c]
0003d4  6809              LDR      r1,[r1,#0]  ; ackno
0003d6  1a40              SUBS     r0,r0,r1
0003d8  d571              BPL      |L6.1214|
;;;1092         /* diff between this shouldn't exceed 32K since this are tcp timer ticks
;;;1093            and a round-trip shouldn't be that long... */
;;;1094         m = (s16_t)(tcp_ticks - pcb->rttest);
0003da  8f20              LDRH     r0,[r4,#0x38]
0003dc  4925              LDR      r1,|L6.1140|
0003de  8809              LDRH     r1,[r1,#0]  ; tcp_ticks
0003e0  1a08              SUBS     r0,r1,r0
0003e2  fa0ffa80          SXTH     r10,r0
;;;1095   
;;;1096         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
0003e6  bf00              NOP      
0003e8  bf00              NOP      
;;;1097                                     m, m * TCP_SLOW_INTERVAL));
;;;1098   
;;;1099         /* This is taken directly from VJs original code in his paper */
;;;1100         m = m - (pcb->sa >> 3);
0003ea  f9340f40          LDRSH    r0,[r4,#0x40]!
0003ee  ebaa00e0          SUB      r0,r10,r0,ASR #3
0003f2  fa0ffa80          SXTH     r10,r0
;;;1101         pcb->sa += m;
0003f6  e03f              B        |L6.1144|
                  |L6.1016|
0003f8  e061              B        |L6.1214|
0003fa  0000              DCW      0x0000
                  |L6.1020|
0003fc  7463705f          DCB      "tcp_receive: wrong state",0
000400  72656365
000404  6976653a
000408  2077726f
00040c  6e672073
000410  74617465
000414  00      
000415  00                DCB      0
000416  00                DCB      0
000417  00                DCB      0
                  |L6.1048|
                          DCD      flags
                  |L6.1052|
                          DCD      seqno
                  |L6.1056|
                          DCD      ackno
                  |L6.1060|
                          DCD      tcphdr
                  |L6.1064|
                          DCD      tcplen
                  |L6.1068|
00042c  7063622d          DCB      "pcb->snd_queuelen >= pbuf_clen(next->p)",0
000430  3e736e64
000434  5f717565
000438  75656c65
00043c  6e203e3d
000440  20706275
000444  665f636c
000448  656e286e
00044c  6578742d
000450  3e702900
                  |L6.1108|
000454  7463705f          DCB      "tcp_receive: valid queue length",0
000458  72656365
00045c  6976653a
000460  2076616c
000464  69642071
000468  75657565
00046c  206c656e
000470  67746800
                  |L6.1140|
                          DCD      tcp_ticks
                  |L6.1144|
000478  8820              LDRH     r0,[r4,#0]
00047a  4450              ADD      r0,r0,r10
00047c  b200              SXTH     r0,r0
00047e  f8240940          STRH     r0,[r4],#-0x40
;;;1102         if (m < 0) {
000482  f1ba0f00          CMP      r10,#0
000486  da03              BGE      |L6.1168|
;;;1103           m = -m;
000488  f1ca0000          RSB      r0,r10,#0
00048c  fa0ffa80          SXTH     r10,r0
                  |L6.1168|
;;;1104         }
;;;1105         m = m - (pcb->sv >> 2);
000490  3440              ADDS     r4,r4,#0x40
000492  f9b40002          LDRSH    r0,[r4,#2]
000496  ebaa00a0          SUB      r0,r10,r0,ASR #2
00049a  fa0ffa80          SXTH     r10,r0
;;;1106         pcb->sv += m;
00049e  8860              LDRH     r0,[r4,#2]
0004a0  4450              ADD      r0,r0,r10
0004a2  b200              SXTH     r0,r0
0004a4  8060              STRH     r0,[r4,#2]
;;;1107         pcb->rto = (pcb->sa >> 3) + pcb->sv;
0004a6  8860              LDRH     r0,[r4,#2]
0004a8  f9b41000          LDRSH    r1,[r4,#0]
0004ac  eb0000e1          ADD      r0,r0,r1,ASR #3
0004b0  b200              SXTH     r0,r0
0004b2  80a0              STRH     r0,[r4,#4]
0004b4  3c40              SUBS     r4,r4,#0x40
;;;1108   
;;;1109         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
0004b6  bf00              NOP      
0004b8  bf00              NOP      
;;;1110                                     pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));
;;;1111   
;;;1112         pcb->rttest = 0;
0004ba  2000              MOVS     r0,#0
0004bc  63a0              STR      r0,[r4,#0x38]
                  |L6.1214|
;;;1113       }
;;;1114     }
;;;1115   
;;;1116     /* If the incoming segment contains data, we must process it
;;;1117        further unless the pcb already received a FIN.
;;;1118        (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
;;;1119        LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
;;;1120     if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
0004be  48fb              LDR      r0,|L6.2220|
0004c0  8800              LDRH     r0,[r0,#0]  ; tcplen
0004c2  2800              CMP      r0,#0
0004c4  dd72              BLE      |L6.1452|
0004c6  7e20              LDRB     r0,[r4,#0x18]
0004c8  2807              CMP      r0,#7
0004ca  da6f              BGE      |L6.1452|
;;;1121       /* This code basically does three things:
;;;1122   
;;;1123       +) If the incoming segment contains data that is the next
;;;1124       in-sequence data, this data is passed to the application. This
;;;1125       might involve trimming the first edge of the data. The rcv_nxt
;;;1126       variable and the advertised window are adjusted.
;;;1127   
;;;1128       +) If the incoming segment has data that is above the next
;;;1129       sequence number expected (->rcv_nxt), the segment is placed on
;;;1130       the ->ooseq queue. This is done by finding the appropriate
;;;1131       place in the ->ooseq queue (which is ordered by sequence
;;;1132       number) and trim the segment in both ends if needed. An
;;;1133       immediate ACK is sent to indicate that we received an
;;;1134       out-of-sequence segment.
;;;1135   
;;;1136       +) Finally, we check if the first segment on the ->ooseq queue
;;;1137       now is in sequence (i.e., if rcv_nxt >= ooseq->seqno). If
;;;1138       rcv_nxt > ooseq->seqno, we must trim the first edge of the
;;;1139       segment on ->ooseq before we adjust rcv_nxt. The data in the
;;;1140       segments that are now on sequence are chained onto the
;;;1141       incoming segment so that we only need to call the application
;;;1142       once.
;;;1143       */
;;;1144   
;;;1145       /* First, we check if we must trim the first edge. We have to do
;;;1146          this if the sequence number of the incoming segment is less
;;;1147          than rcv_nxt, and the sequence number plus the length of the
;;;1148          segment is larger than rcv_nxt. */
;;;1149       /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
;;;1150             if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
;;;1151       if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
0004cc  48f8              LDR      r0,|L6.2224|
0004ce  6aa1              LDR      r1,[r4,#0x28]
0004d0  6800              LDR      r0,[r0,#0]  ; seqno
0004d2  1c40              ADDS     r0,r0,#1
0004d4  1a08              SUBS     r0,r1,r0
0004d6  d47b              BMI      |L6.1488|
0004d8  48f5              LDR      r0,|L6.2224|
0004da  6aa1              LDR      r1,[r4,#0x28]
0004dc  6800              LDR      r0,[r0,#0]  ; seqno
0004de  4af3              LDR      r2,|L6.2220|
0004e0  8812              LDRH     r2,[r2,#0]  ; tcplen
0004e2  4410              ADD      r0,r0,r2
0004e4  1e40              SUBS     r0,r0,#1
0004e6  1a08              SUBS     r0,r1,r0
0004e8  2800              CMP      r0,#0
0004ea  dc71              BGT      |L6.1488|
;;;1152         /* Trimming the first edge is done by pushing the payload
;;;1153            pointer in the pbuf downwards. This is somewhat tricky since
;;;1154            we do not want to discard the full contents of the pbuf up to
;;;1155            the new starting point of the data since we have to keep the
;;;1156            TCP header which is present in the first pbuf in the chain.
;;;1157   
;;;1158            What is done is really quite a nasty hack: the first pbuf in
;;;1159            the pbuf chain is pointed to by inseg.p. Since we need to be
;;;1160            able to deallocate the whole pbuf, we cannot change this
;;;1161            inseg.p pointer to point to any of the later pbufs in the
;;;1162            chain. Instead, we point the ->payload pointer in the first
;;;1163            pbuf to data in one of the later pbufs. We also set the
;;;1164            inseg.data pointer to point to the right place. This way, the
;;;1165            ->p pointer will still point to the first pbuf, but the
;;;1166            ->p->payload pointer will point to data in another pbuf.
;;;1167   
;;;1168            After we are done with adjusting the pbuf pointers we must
;;;1169            adjust the ->data pointer in the seg and the segment
;;;1170            length.*/
;;;1171   
;;;1172         off = pcb->rcv_nxt - seqno;
0004ec  49f0              LDR      r1,|L6.2224|
0004ee  6aa0              LDR      r0,[r4,#0x28]
0004f0  6809              LDR      r1,[r1,#0]  ; seqno
0004f2  eba00801          SUB      r8,r0,r1
;;;1173         p = inseg.p;
0004f6  48ef              LDR      r0,|L6.2228|
0004f8  f8d09004          LDR      r9,[r0,#4]  ; inseg
;;;1174         LWIP_ASSERT("inseg.p != NULL", inseg.p);
0004fc  bf00              NOP      
0004fe  6840              LDR      r0,[r0,#4]  ; inseg
000500  b920              CBNZ     r0,|L6.1292|
000502  a0ed              ADR      r0,|L6.2232|
000504  f7fffffe          BL       __2printf
000508  bf00              NOP      
                  |L6.1290|
00050a  e7fe              B        |L6.1290|
                  |L6.1292|
00050c  bf00              NOP      
;;;1175         LWIP_ASSERT("insane offset!", (off < 0x7fff));
00050e  bf00              NOP      
000510  f64770ff          MOV      r0,#0x7fff
000514  4580              CMP      r8,r0
000516  db04              BLT      |L6.1314|
000518  a0eb              ADR      r0,|L6.2248|
00051a  f7fffffe          BL       __2printf
00051e  bf00              NOP      
                  |L6.1312|
000520  e7fe              B        |L6.1312|
                  |L6.1314|
000522  bf00              NOP      
;;;1176         if (inseg.p->len < off) {
000524  48e3              LDR      r0,|L6.2228|
000526  6840              LDR      r0,[r0,#4]  ; inseg
000528  8940              LDRH     r0,[r0,#0xa]
00052a  4540              CMP      r0,r8
00052c  da30              BGE      |L6.1424|
;;;1177           LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
00052e  bf00              NOP      
000530  48e0              LDR      r0,|L6.2228|
000532  6840              LDR      r0,[r0,#4]  ; inseg
000534  8900              LDRH     r0,[r0,#8]
000536  4540              CMP      r0,r8
000538  da04              BGE      |L6.1348|
00053a  a0e7              ADR      r0,|L6.2264|
00053c  f7fffffe          BL       __2printf
000540  bf00              NOP      
                  |L6.1346|
000542  e7fe              B        |L6.1346|
                  |L6.1348|
000544  bf00              NOP      
;;;1178           new_tot_len = (u16_t)(inseg.p->tot_len - off);
000546  48db              LDR      r0,|L6.2228|
000548  6840              LDR      r0,[r0,#4]  ; inseg
00054a  8900              LDRH     r0,[r0,#8]
00054c  eba00008          SUB      r0,r0,r8
000550  b280              UXTH     r0,r0
000552  9001              STR      r0,[sp,#4]
;;;1179           while (p->len < off) {
000554  e00b              B        |L6.1390|
                  |L6.1366|
;;;1180             off -= p->len;
000556  f8b9000a          LDRH     r0,[r9,#0xa]
00055a  eba80800          SUB      r8,r8,r0
;;;1181             /* KJM following line changed (with addition of new_tot_len var)
;;;1182                to fix bug #9076
;;;1183                inseg.p->tot_len -= p->len; */
;;;1184             p->tot_len = new_tot_len;
00055e  9801              LDR      r0,[sp,#4]
000560  f8a90008          STRH     r0,[r9,#8]
;;;1185             p->len = 0;
000564  2000              MOVS     r0,#0
000566  f8a9000a          STRH     r0,[r9,#0xa]
;;;1186             p = p->next;
00056a  f8d99000          LDR      r9,[r9,#0]
                  |L6.1390|
00056e  f8b9000a          LDRH     r0,[r9,#0xa]          ;1179
000572  4540              CMP      r0,r8                 ;1179
000574  dbef              BLT      |L6.1366|
;;;1187           }
;;;1188           if(pbuf_header(p, (s16_t)-off)) {
000576  f1c80000          RSB      r0,r8,#0
00057a  b201              SXTH     r1,r0
00057c  4648              MOV      r0,r9
00057e  f7fffffe          BL       pbuf_header
000582  b1a8              CBZ      r0,|L6.1456|
;;;1189             /* Do we need to cope with this failing?  Assert for now */
;;;1190             LWIP_ASSERT("pbuf_header failed", 0);
000584  bf00              NOP      
000586  a0d8              ADR      r0,|L6.2280|
000588  f7fffffe          BL       __2printf
00058c  bf00              NOP      
                  |L6.1422|
00058e  e7fe              B        |L6.1422|
                  |L6.1424|
;;;1191           }
;;;1192         } else {
;;;1193           if(pbuf_header(inseg.p, (s16_t)-off)) {
000590  49c8              LDR      r1,|L6.2228|
000592  6848              LDR      r0,[r1,#4]  ; inseg
000594  f1c80100          RSB      r1,r8,#0
000598  b209              SXTH     r1,r1
00059a  f7fffffe          BL       pbuf_header
00059e  b138              CBZ      r0,|L6.1456|
;;;1194             /* Do we need to cope with this failing?  Assert for now */
;;;1195             LWIP_ASSERT("pbuf_header failed", 0);
0005a0  bf00              NOP      
0005a2  a0d1              ADR      r0,|L6.2280|
0005a4  f7fffffe          BL       __2printf
0005a8  bf00              NOP      
                  |L6.1450|
0005aa  e7fe              B        |L6.1450|
                  |L6.1452|
0005ac  e35e              B        |L6.3180|
0005ae  e00f              B        |L6.1488|
                  |L6.1456|
;;;1196           }
;;;1197         }
;;;1198         inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
0005b0  48c0              LDR      r0,|L6.2228|
0005b2  8900              LDRH     r0,[r0,#8]  ; inseg
0005b4  8d21              LDRH     r1,[r4,#0x28]
0005b6  4abe              LDR      r2,|L6.2224|
0005b8  8812              LDRH     r2,[r2,#0]  ; seqno
0005ba  1a89              SUBS     r1,r1,r2
0005bc  1a40              SUBS     r0,r0,r1
0005be  49bd              LDR      r1,|L6.2228|
0005c0  8108              STRH     r0,[r1,#8]
;;;1199         inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
0005c2  49bb              LDR      r1,|L6.2224|
0005c4  6aa0              LDR      r0,[r4,#0x28]
0005c6  6008              STR      r0,[r1,#0]  ; seqno
0005c8  49ba              LDR      r1,|L6.2228|
0005ca  6909              LDR      r1,[r1,#0x10]  ; inseg
0005cc  6048              STR      r0,[r1,#4]
0005ce  e00c              B        |L6.1514|
                  |L6.1488|
;;;1200       }
;;;1201       else {
;;;1202         if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
0005d0  49b7              LDR      r1,|L6.2224|
0005d2  6aa0              LDR      r0,[r4,#0x28]
0005d4  6809              LDR      r1,[r1,#0]  ; seqno
0005d6  1a08              SUBS     r0,r1,r0
0005d8  d507              BPL      |L6.1514|
;;;1203           /* the whole segment is < rcv_nxt */
;;;1204           /* must be a duplicate of a packet that has already been correctly handled */
;;;1205   
;;;1206           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
0005da  bf00              NOP      
0005dc  bf00              NOP      
;;;1207           tcp_ack_now(pcb);
0005de  bf00              NOP      
0005e0  7fa0              LDRB     r0,[r4,#0x1e]
0005e2  f0400002          ORR      r0,r0,#2
0005e6  77a0              STRB     r0,[r4,#0x1e]
0005e8  bf00              NOP      
                  |L6.1514|
;;;1208         }
;;;1209       }
;;;1210   
;;;1211       /* The sequence number must be within the window (above rcv_nxt
;;;1212          and below rcv_nxt + rcv_wnd) in order to be further
;;;1213          processed. */
;;;1214       if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
0005ea  49b1              LDR      r1,|L6.2224|
0005ec  6aa0              LDR      r0,[r4,#0x28]
0005ee  6809              LDR      r1,[r1,#0]  ; seqno
0005f0  1a08              SUBS     r0,r1,r0
0005f2  d46f              BMI      |L6.1748|
0005f4  8da1              LDRH     r1,[r4,#0x2c]
0005f6  6aa0              LDR      r0,[r4,#0x28]
0005f8  4408              ADD      r0,r0,r1
0005fa  1e40              SUBS     r0,r0,#1
0005fc  49ac              LDR      r1,|L6.2224|
0005fe  6809              LDR      r1,[r1,#0]  ; seqno
000600  1a08              SUBS     r0,r1,r0
000602  2800              CMP      r0,#0
000604  dc66              BGT      |L6.1748|
;;;1215                           pcb->rcv_nxt + pcb->rcv_wnd - 1)){
;;;1216         if (pcb->rcv_nxt == seqno) {
000606  49aa              LDR      r1,|L6.2224|
000608  6aa0              LDR      r0,[r4,#0x28]
00060a  6809              LDR      r1,[r1,#0]  ; seqno
00060c  4288              CMP      r0,r1
00060e  d176              BNE      |L6.1790|
;;;1217           /* The incoming segment is the next in sequence. We check if
;;;1218              we have to trim the end of the segment and update rcv_nxt
;;;1219              and pass the data to the application. */
;;;1220           tcplen = TCP_TCPLEN(&inseg);
000610  49a8              LDR      r1,|L6.2228|
000612  6909              LDR      r1,[r1,#0x10]  ; inseg
000614  8988              LDRH     r0,[r1,#0xc]
000616  f7fffffe          BL       lwip_ntohs
00061a  f0000003          AND      r0,r0,#3
00061e  b108              CBZ      r0,|L6.1572|
000620  2001              MOVS     r0,#1
000622  e000              B        |L6.1574|
                  |L6.1572|
000624  2000              MOVS     r0,#0
                  |L6.1574|
000626  49a3              LDR      r1,|L6.2228|
000628  8909              LDRH     r1,[r1,#8]  ; inseg
00062a  4408              ADD      r0,r0,r1
00062c  499f              LDR      r1,|L6.2220|
00062e  8008              STRH     r0,[r1,#0]
;;;1221   
;;;1222           if (tcplen > pcb->rcv_wnd) {
000630  8da0              LDRH     r0,[r4,#0x2c]
000632  8809              LDRH     r1,[r1,#0]  ; tcplen
000634  4288              CMP      r0,r1
000636  da54              BGE      |L6.1762|
;;;1223             LWIP_DEBUGF(TCP_INPUT_DEBUG, 
000638  bf00              NOP      
00063a  bf00              NOP      
;;;1224                         ("tcp_receive: other end overran receive window"
;;;1225                          "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1226                          seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1227             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
00063c  499d              LDR      r1,|L6.2228|
00063e  6909              LDR      r1,[r1,#0x10]  ; inseg
000640  8988              LDRH     r0,[r1,#0xc]
000642  f7fffffe          BL       lwip_ntohs
000646  f0000001          AND      r0,r0,#1
00064a  b198              CBZ      r0,|L6.1652|
;;;1228               /* Must remove the FIN from the header as we're trimming 
;;;1229                * that byte of sequence-space from the packet */
;;;1230               TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
00064c  4999              LDR      r1,|L6.2228|
00064e  6909              LDR      r1,[r1,#0x10]  ; inseg
000650  8988              LDRH     r0,[r1,#0xc]
000652  f7fffffe          BL       lwip_ntohs
000656  f0000b3e          AND      r11,r0,#0x3e
00065a  4658              MOV      r0,r11
00065c  f7fffffe          BL       lwip_htons
000660  4994              LDR      r1,|L6.2228|
000662  6909              LDR      r1,[r1,#0x10]  ; inseg
000664  8989              LDRH     r1,[r1,#0xc]
000666  f24c02ff          MOV      r2,#0xc0ff
00066a  4011              ANDS     r1,r1,r2
00066c  4308              ORRS     r0,r0,r1
00066e  4991              LDR      r1,|L6.2228|
000670  6909              LDR      r1,[r1,#0x10]  ; inseg
000672  8188              STRH     r0,[r1,#0xc]
                  |L6.1652|
;;;1231             }
;;;1232             /* Adjust length of segment to fit in the window. */
;;;1233             inseg.len = pcb->rcv_wnd;
000674  8da0              LDRH     r0,[r4,#0x2c]
000676  498f              LDR      r1,|L6.2228|
000678  8108              STRH     r0,[r1,#8]
;;;1234             if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
00067a  6909              LDR      r1,[r1,#0x10]  ; inseg
00067c  8988              LDRH     r0,[r1,#0xc]
00067e  f7fffffe          BL       lwip_ntohs
000682  f0000002          AND      r0,r0,#2
000686  b120              CBZ      r0,|L6.1682|
;;;1235               inseg.len -= 1;
000688  488a              LDR      r0,|L6.2228|
00068a  8900              LDRH     r0,[r0,#8]  ; inseg
00068c  1e40              SUBS     r0,r0,#1
00068e  4989              LDR      r1,|L6.2228|
000690  8108              STRH     r0,[r1,#8]
                  |L6.1682|
;;;1236             }
;;;1237             pbuf_realloc(inseg.p, inseg.len);
000692  4a88              LDR      r2,|L6.2228|
000694  8911              LDRH     r1,[r2,#8]  ; inseg
000696  6850              LDR      r0,[r2,#4]  ; inseg
000698  f7fffffe          BL       pbuf_realloc
;;;1238             tcplen = TCP_TCPLEN(&inseg);
00069c  4985              LDR      r1,|L6.2228|
00069e  6909              LDR      r1,[r1,#0x10]  ; inseg
0006a0  8988              LDRH     r0,[r1,#0xc]
0006a2  f7fffffe          BL       lwip_ntohs
0006a6  f0000003          AND      r0,r0,#3
0006aa  b108              CBZ      r0,|L6.1712|
0006ac  2001              MOVS     r0,#1
0006ae  e000              B        |L6.1714|
                  |L6.1712|
0006b0  2000              MOVS     r0,#0
                  |L6.1714|
0006b2  4980              LDR      r1,|L6.2228|
0006b4  8909              LDRH     r1,[r1,#8]  ; inseg
0006b6  4408              ADD      r0,r0,r1
0006b8  497c              LDR      r1,|L6.2220|
0006ba  8008              STRH     r0,[r1,#0]
;;;1239             LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
0006bc  bf00              NOP      
0006be  8da1              LDRH     r1,[r4,#0x2c]
0006c0  6aa0              LDR      r0,[r4,#0x28]
0006c2  4408              ADD      r0,r0,r1
0006c4  497a              LDR      r1,|L6.2224|
0006c6  6809              LDR      r1,[r1,#0]  ; seqno
0006c8  4a78              LDR      r2,|L6.2220|
0006ca  8812              LDRH     r2,[r2,#0]  ; tcplen
0006cc  4411              ADD      r1,r1,r2
0006ce  4288              CMP      r0,r1
0006d0  d006              BEQ      |L6.1760|
0006d2  e000              B        |L6.1750|
                  |L6.1748|
0006d4  e2c6              B        |L6.3172|
                  |L6.1750|
0006d6  a089              ADR      r0,|L6.2300|
0006d8  f7fffffe          BL       __2printf
0006dc  bf00              NOP      
                  |L6.1758|
0006de  e7fe              B        |L6.1758|
                  |L6.1760|
0006e0  bf00              NOP      
                  |L6.1762|
;;;1240                         (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1241           }
;;;1242   #if TCP_QUEUE_OOSEQ
;;;1243           /* Received in-sequence data, adjust ooseq data if:
;;;1244              - FIN has been received or
;;;1245              - inseq overlaps with ooseq */
;;;1246           if (pcb->ooseq != NULL) {
0006e2  6f60              LDR      r0,[r4,#0x74]
0006e4  2800              CMP      r0,#0
0006e6  d017              BEQ      |L6.1816|
;;;1247             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
0006e8  4972              LDR      r1,|L6.2228|
0006ea  6909              LDR      r1,[r1,#0x10]  ; inseg
0006ec  8988              LDRH     r0,[r1,#0xc]
0006ee  f7fffffe          BL       lwip_ntohs
0006f2  f0000001          AND      r0,r0,#1
0006f6  b180              CBZ      r0,|L6.1818|
;;;1248               LWIP_DEBUGF(TCP_INPUT_DEBUG, 
0006f8  bf00              NOP      
0006fa  bf00              NOP      
;;;1249                           ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
;;;1250               /* Received in-order FIN means anything that was received
;;;1251                * out of order must now have been received in-order, so
;;;1252                * bin the ooseq queue */
;;;1253               while (pcb->ooseq != NULL) {
0006fc  e009              B        |L6.1810|
                  |L6.1790|
0006fe  e1c0              B        |L6.2690|
                  |L6.1792|
;;;1254                 struct tcp_seg *old_ooseq = pcb->ooseq;
000700  f8d4b074          LDR      r11,[r4,#0x74]
;;;1255                 pcb->ooseq = pcb->ooseq->next;
000704  6f60              LDR      r0,[r4,#0x74]
000706  6800              LDR      r0,[r0,#0]
000708  6760              STR      r0,[r4,#0x74]
;;;1256                 tcp_seg_free(old_ooseq);
00070a  4658              MOV      r0,r11
00070c  f7fffffe          BL       tcp_seg_free
;;;1257               }
000710  bf00              NOP      
                  |L6.1810|
000712  6f60              LDR      r0,[r4,#0x74]         ;1253
000714  2800              CMP      r0,#0                 ;1253
000716  d1f3              BNE      |L6.1792|
                  |L6.1816|
000718  e080              B        |L6.2076|
                  |L6.1818|
;;;1258             } else {
;;;1259               next = pcb->ooseq;
00071a  6f65              LDR      r5,[r4,#0x74]
;;;1260               /* Remove all segments on ooseq that are covered by inseg already.
;;;1261                * FIN is copied from ooseq to inseg if present. */
;;;1262               while (next &&
00071c  e02d              B        |L6.1914|
                  |L6.1822|
;;;1263                      TCP_SEQ_GEQ(seqno + tcplen,
;;;1264                                  next->tcphdr->seqno + next->len)) {
;;;1265                 /* inseg cannot have FIN here (already processed above) */
;;;1266                 if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
00071e  6929              LDR      r1,[r5,#0x10]
000720  8988              LDRH     r0,[r1,#0xc]
000722  f7fffffe          BL       lwip_ntohs
000726  f0000001          AND      r0,r0,#1
00072a  b308              CBZ      r0,|L6.1904|
;;;1267                     (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
00072c  4961              LDR      r1,|L6.2228|
00072e  6909              LDR      r1,[r1,#0x10]  ; inseg
000730  8988              LDRH     r0,[r1,#0xc]
000732  f7fffffe          BL       lwip_ntohs
000736  f0000002          AND      r0,r0,#2
00073a  b9c8              CBNZ     r0,|L6.1904|
;;;1268                   TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
00073c  2001              MOVS     r0,#1
00073e  f7fffffe          BL       lwip_htons
000742  495c              LDR      r1,|L6.2228|
000744  6909              LDR      r1,[r1,#0x10]  ; inseg
000746  8989              LDRH     r1,[r1,#0xc]
000748  4308              ORRS     r0,r0,r1
00074a  495a              LDR      r1,|L6.2228|
00074c  6909              LDR      r1,[r1,#0x10]  ; inseg
00074e  8188              STRH     r0,[r1,#0xc]
;;;1269                   tcplen = TCP_TCPLEN(&inseg);
000750  4958              LDR      r1,|L6.2228|
000752  6909              LDR      r1,[r1,#0x10]  ; inseg
000754  8988              LDRH     r0,[r1,#0xc]
000756  f7fffffe          BL       lwip_ntohs
00075a  f0000003          AND      r0,r0,#3
00075e  b108              CBZ      r0,|L6.1892|
000760  2001              MOVS     r0,#1
000762  e000              B        |L6.1894|
                  |L6.1892|
000764  2000              MOVS     r0,#0
                  |L6.1894|
000766  4953              LDR      r1,|L6.2228|
000768  8909              LDRH     r1,[r1,#8]  ; inseg
00076a  4408              ADD      r0,r0,r1
00076c  494f              LDR      r1,|L6.2220|
00076e  8008              STRH     r0,[r1,#0]
                  |L6.1904|
;;;1270                 }
;;;1271                 prev = next;
000770  462f              MOV      r7,r5
;;;1272                 next = next->next;
000772  682d              LDR      r5,[r5,#0]
;;;1273                 tcp_seg_free(prev);
000774  4638              MOV      r0,r7
000776  f7fffffe          BL       tcp_seg_free
                  |L6.1914|
00077a  b155              CBZ      r5,|L6.1938|
00077c  6928              LDR      r0,[r5,#0x10]         ;1263
00077e  6840              LDR      r0,[r0,#4]            ;1263
000780  8929              LDRH     r1,[r5,#8]            ;1263
000782  4408              ADD      r0,r0,r1              ;1263
000784  494a              LDR      r1,|L6.2224|
000786  6809              LDR      r1,[r1,#0]            ;1263  ; seqno
000788  4a48              LDR      r2,|L6.2220|
00078a  8812              LDRH     r2,[r2,#0]            ;1263  ; tcplen
00078c  4411              ADD      r1,r1,r2              ;1263
00078e  1a08              SUBS     r0,r1,r0              ;1263
000790  d5c5              BPL      |L6.1822|
                  |L6.1938|
;;;1274               }
;;;1275               /* Now trim right side of inseg if it overlaps with the first
;;;1276                * segment on ooseq */
;;;1277               if (next &&
000792  b3dd              CBZ      r5,|L6.2060|
;;;1278                   TCP_SEQ_GT(seqno + tcplen,
000794  4846              LDR      r0,|L6.2224|
000796  6800              LDR      r0,[r0,#0]  ; seqno
000798  4944              LDR      r1,|L6.2220|
00079a  8809              LDRH     r1,[r1,#0]  ; tcplen
00079c  4408              ADD      r0,r0,r1
00079e  6929              LDR      r1,[r5,#0x10]
0007a0  6849              LDR      r1,[r1,#4]
0007a2  1a40              SUBS     r0,r0,r1
0007a4  2800              CMP      r0,#0
0007a6  dd38              BLE      |L6.2074|
;;;1279                              next->tcphdr->seqno)) {
;;;1280                 /* inseg cannot have FIN here (already processed above) */
;;;1281                 inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
0007a8  6928              LDR      r0,[r5,#0x10]
0007aa  8880              LDRH     r0,[r0,#4]
0007ac  4940              LDR      r1,|L6.2224|
0007ae  8809              LDRH     r1,[r1,#0]  ; seqno
0007b0  1a40              SUBS     r0,r0,r1
0007b2  4940              LDR      r1,|L6.2228|
0007b4  8108              STRH     r0,[r1,#8]
;;;1282                 if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
0007b6  6909              LDR      r1,[r1,#0x10]  ; inseg
0007b8  8988              LDRH     r0,[r1,#0xc]
0007ba  f7fffffe          BL       lwip_ntohs
0007be  f0000002          AND      r0,r0,#2
0007c2  b120              CBZ      r0,|L6.1998|
;;;1283                   inseg.len -= 1;
0007c4  483b              LDR      r0,|L6.2228|
0007c6  8900              LDRH     r0,[r0,#8]  ; inseg
0007c8  1e40              SUBS     r0,r0,#1
0007ca  493a              LDR      r1,|L6.2228|
0007cc  8108              STRH     r0,[r1,#8]
                  |L6.1998|
;;;1284                 }
;;;1285                 pbuf_realloc(inseg.p, inseg.len);
0007ce  4a39              LDR      r2,|L6.2228|
0007d0  8911              LDRH     r1,[r2,#8]  ; inseg
0007d2  6850              LDR      r0,[r2,#4]  ; inseg
0007d4  f7fffffe          BL       pbuf_realloc
;;;1286                 tcplen = TCP_TCPLEN(&inseg);
0007d8  4936              LDR      r1,|L6.2228|
0007da  6909              LDR      r1,[r1,#0x10]  ; inseg
0007dc  8988              LDRH     r0,[r1,#0xc]
0007de  f7fffffe          BL       lwip_ntohs
0007e2  f0000003          AND      r0,r0,#3
0007e6  b108              CBZ      r0,|L6.2028|
0007e8  2001              MOVS     r0,#1
0007ea  e000              B        |L6.2030|
                  |L6.2028|
0007ec  2000              MOVS     r0,#0
                  |L6.2030|
0007ee  4931              LDR      r1,|L6.2228|
0007f0  8909              LDRH     r1,[r1,#8]  ; inseg
0007f2  4408              ADD      r0,r0,r1
0007f4  492d              LDR      r1,|L6.2220|
0007f6  8008              STRH     r0,[r1,#0]
;;;1287                 LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
0007f8  bf00              NOP      
0007fa  482d              LDR      r0,|L6.2224|
0007fc  6800              LDR      r0,[r0,#0]  ; seqno
0007fe  8809              LDRH     r1,[r1,#0]  ; tcplen
000800  4408              ADD      r0,r0,r1
000802  6929              LDR      r1,[r5,#0x10]
000804  6849              LDR      r1,[r1,#4]
000806  4288              CMP      r0,r1
000808  d006              BEQ      |L6.2072|
00080a  e000              B        |L6.2062|
                  |L6.2060|
00080c  e005              B        |L6.2074|
                  |L6.2062|
00080e  a049              ADR      r0,|L6.2356|
000810  f7fffffe          BL       __2printf
000814  bf00              NOP      
                  |L6.2070|
000816  e7fe              B        |L6.2070|
                  |L6.2072|
000818  bf00              NOP      
                  |L6.2074|
;;;1288                             (seqno + tcplen) == next->tcphdr->seqno);
;;;1289               }
;;;1290               pcb->ooseq = next;
00081a  6765              STR      r5,[r4,#0x74]
                  |L6.2076|
;;;1291             }
;;;1292           }
;;;1293   #endif /* TCP_QUEUE_OOSEQ */
;;;1294   
;;;1295           pcb->rcv_nxt = seqno + tcplen;
00081c  4824              LDR      r0,|L6.2224|
00081e  6800              LDR      r0,[r0,#0]  ; seqno
000820  4922              LDR      r1,|L6.2220|
000822  8809              LDRH     r1,[r1,#0]  ; tcplen
000824  4408              ADD      r0,r0,r1
000826  62a0              STR      r0,[r4,#0x28]
;;;1296   
;;;1297           /* Update the receiver's (our) window. */
;;;1298           LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
000828  bf00              NOP      
00082a  8da0              LDRH     r0,[r4,#0x2c]
00082c  491f              LDR      r1,|L6.2220|
00082e  8809              LDRH     r1,[r1,#0]  ; tcplen
000830  4288              CMP      r0,r1
000832  da04              BGE      |L6.2110|
000834  a04e              ADR      r0,|L6.2416|
000836  f7fffffe          BL       __2printf
00083a  bf00              NOP      
                  |L6.2108|
00083c  e7fe              B        |L6.2108|
                  |L6.2110|
00083e  bf00              NOP      
;;;1299           pcb->rcv_wnd -= tcplen;
000840  8da0              LDRH     r0,[r4,#0x2c]
000842  491a              LDR      r1,|L6.2220|
000844  8809              LDRH     r1,[r1,#0]  ; tcplen
000846  1a40              SUBS     r0,r0,r1
000848  85a0              STRH     r0,[r4,#0x2c]
;;;1300   
;;;1301           tcp_update_rcv_ann_wnd(pcb);
00084a  4620              MOV      r0,r4
00084c  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;1302   
;;;1303           /* If there is data in the segment, we make preparations to
;;;1304              pass this up to the application. The ->recv_data variable
;;;1305              is used for holding the pbuf that goes to the
;;;1306              application. The code for reassembling out-of-sequence data
;;;1307              chains its data on this pbuf as well.
;;;1308   
;;;1309              If the segment was a FIN, we set the TF_GOT_FIN flag that will
;;;1310              be used to indicate to the application that the remote side has
;;;1311              closed its end of the connection. */
;;;1312           if (inseg.p->tot_len > 0) {
000850  4818              LDR      r0,|L6.2228|
000852  6840              LDR      r0,[r0,#4]  ; inseg
000854  8900              LDRH     r0,[r0,#8]
000856  2800              CMP      r0,#0
000858  dd06              BLE      |L6.2152|
;;;1313             recv_data = inseg.p;
00085a  4816              LDR      r0,|L6.2228|
00085c  6840              LDR      r0,[r0,#4]  ; inseg
00085e  494c              LDR      r1,|L6.2448|
000860  6008              STR      r0,[r1,#0]  ; recv_data
;;;1314             /* Since this pbuf now is the responsibility of the
;;;1315                application, we delete our reference to it so that we won't
;;;1316                (mistakingly) deallocate it. */
;;;1317             inseg.p = NULL;
000862  2000              MOVS     r0,#0
000864  4913              LDR      r1,|L6.2228|
000866  6048              STR      r0,[r1,#4]  ; inseg
                  |L6.2152|
;;;1318           }
;;;1319           if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
000868  4912              LDR      r1,|L6.2228|
00086a  6909              LDR      r1,[r1,#0x10]  ; inseg
00086c  8988              LDRH     r0,[r1,#0xc]
00086e  f7fffffe          BL       lwip_ntohs
000872  f0000001          AND      r0,r0,#1
000876  b138              CBZ      r0,|L6.2184|
;;;1320             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
000878  bf00              NOP      
00087a  bf00              NOP      
;;;1321             recv_flags |= TF_GOT_FIN;
00087c  4845              LDR      r0,|L6.2452|
00087e  7800              LDRB     r0,[r0,#0]  ; recv_flags
000880  f0400020          ORR      r0,r0,#0x20
000884  4943              LDR      r1,|L6.2452|
000886  7008              STRB     r0,[r1,#0]
                  |L6.2184|
;;;1322           }
;;;1323   
;;;1324   #if TCP_QUEUE_OOSEQ
;;;1325           /* We now check if we have segments on the ->ooseq queue that
;;;1326              are now in sequence. */
;;;1327           while (pcb->ooseq != NULL &&
000888  e0df              B        |L6.2634|
                  |L6.2186|
;;;1328                  pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
;;;1329   
;;;1330             cseg = pcb->ooseq;
00088a  6f66              LDR      r6,[r4,#0x74]
;;;1331             seqno = pcb->ooseq->tcphdr->seqno;
00088c  6f60              LDR      r0,[r4,#0x74]
00088e  6900              LDR      r0,[r0,#0x10]
000890  6840              LDR      r0,[r0,#4]
000892  4907              LDR      r1,|L6.2224|
000894  6008              STR      r0,[r1,#0]  ; seqno
;;;1332   
;;;1333             pcb->rcv_nxt += TCP_TCPLEN(cseg);
000896  6931              LDR      r1,[r6,#0x10]
000898  8988              LDRH     r0,[r1,#0xc]
00089a  f7fffffe          BL       lwip_ntohs
00089e  f0000003          AND      r0,r0,#3
0008a2  b108              CBZ      r0,|L6.2216|
0008a4  2001              MOVS     r0,#1
0008a6  e078              B        |L6.2458|
                  |L6.2216|
0008a8  e076              B        |L6.2456|
0008aa  0000              DCW      0x0000
                  |L6.2220|
                          DCD      tcplen
                  |L6.2224|
                          DCD      seqno
                  |L6.2228|
                          DCD      inseg
                  |L6.2232|
0008b8  696e7365          DCB      "inseg.p != NULL",0
0008bc  672e7020
0008c0  213d204e
0008c4  554c4c00
                  |L6.2248|
0008c8  696e7361          DCB      "insane offset!",0
0008cc  6e65206f
0008d0  66667365
0008d4  742100  
0008d7  00                DCB      0
                  |L6.2264|
0008d8  70627566          DCB      "pbuf too short!",0
0008dc  20746f6f
0008e0  2073686f
0008e4  72742100
                  |L6.2280|
0008e8  70627566          DCB      "pbuf_header failed",0
0008ec  5f686561
0008f0  64657220
0008f4  6661696c
0008f8  656400  
0008fb  00                DCB      0
                  |L6.2300|
0008fc  7463705f          DCB      "tcp_receive: segment not trimmed correctly to rcv_wnd\n"
000900  72656365
000904  6976653a
000908  20736567
00090c  6d656e74
000910  206e6f74
000914  20747269
000918  6d6d6564
00091c  20636f72
000920  72656374
000924  6c792074
000928  6f207263
00092c  765f776e
000930  640a    
000932  00                DCB      0
000933  00                DCB      0
                  |L6.2356|
000934  7463705f          DCB      "tcp_receive: segment not trimmed correctly to ooseq que"
000938  72656365
00093c  6976653a
000940  20736567
000944  6d656e74
000948  206e6f74
00094c  20747269
000950  6d6d6564
000954  20636f72
000958  72656374
00095c  6c792074
000960  6f206f6f
000964  73657120
000968  717565  
00096b  75650a00          DCB      "ue\n",0
00096f  00                DCB      0
                  |L6.2416|
000970  7463705f          DCB      "tcp_receive: tcplen > rcv_wnd\n",0
000974  72656365
000978  6976653a
00097c  20746370
000980  6c656e20
000984  3e207263
000988  765f776e
00098c  640a00  
00098f  00                DCB      0
                  |L6.2448|
                          DCD      recv_data
                  |L6.2452|
                          DCD      recv_flags
                  |L6.2456|
000998  2000              MOVS     r0,#0
                  |L6.2458|
00099a  8931              LDRH     r1,[r6,#8]
00099c  4408              ADD      r0,r0,r1
00099e  6aa1              LDR      r1,[r4,#0x28]
0009a0  4408              ADD      r0,r0,r1
0009a2  62a0              STR      r0,[r4,#0x28]
;;;1334             LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
0009a4  bf00              NOP      
0009a6  6931              LDR      r1,[r6,#0x10]
0009a8  8988              LDRH     r0,[r1,#0xc]
0009aa  f7fffffe          BL       lwip_ntohs
0009ae  f0000003          AND      r0,r0,#3
0009b2  b108              CBZ      r0,|L6.2488|
0009b4  2001              MOVS     r0,#1
0009b6  e000              B        |L6.2490|
                  |L6.2488|
0009b8  2000              MOVS     r0,#0
                  |L6.2490|
0009ba  8931              LDRH     r1,[r6,#8]
0009bc  4408              ADD      r0,r0,r1
0009be  8da1              LDRH     r1,[r4,#0x2c]
0009c0  4288              CMP      r0,r1
0009c2  dd04              BLE      |L6.2510|
0009c4  a0b4              ADR      r0,|L6.3224|
0009c6  f7fffffe          BL       __2printf
0009ca  bf00              NOP      
                  |L6.2508|
0009cc  e7fe              B        |L6.2508|
                  |L6.2510|
0009ce  bf00              NOP      
;;;1335                         pcb->rcv_wnd >= TCP_TCPLEN(cseg));
;;;1336             pcb->rcv_wnd -= TCP_TCPLEN(cseg);
0009d0  6931              LDR      r1,[r6,#0x10]
0009d2  8988              LDRH     r0,[r1,#0xc]
0009d4  f7fffffe          BL       lwip_ntohs
0009d8  f0000003          AND      r0,r0,#3
0009dc  b108              CBZ      r0,|L6.2530|
0009de  2001              MOVS     r0,#1
0009e0  e000              B        |L6.2532|
                  |L6.2530|
0009e2  2000              MOVS     r0,#0
                  |L6.2532|
0009e4  8931              LDRH     r1,[r6,#8]
0009e6  4408              ADD      r0,r0,r1
0009e8  8da1              LDRH     r1,[r4,#0x2c]
0009ea  1a08              SUBS     r0,r1,r0
0009ec  85a0              STRH     r0,[r4,#0x2c]
;;;1337   
;;;1338             tcp_update_rcv_ann_wnd(pcb);
0009ee  4620              MOV      r0,r4
0009f0  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;1339   
;;;1340             if (cseg->p->tot_len > 0) {
0009f4  6870              LDR      r0,[r6,#4]
0009f6  8900              LDRH     r0,[r0,#8]
0009f8  2800              CMP      r0,#0
0009fa  dd0d              BLE      |L6.2584|
;;;1341               /* Chain this pbuf onto the pbuf that we will pass to
;;;1342                  the application. */
;;;1343               if (recv_data) {
0009fc  48b0              LDR      r0,|L6.3264|
0009fe  6800              LDR      r0,[r0,#0]  ; recv_data
000a00  b128              CBZ      r0,|L6.2574|
;;;1344                 pbuf_cat(recv_data, cseg->p);
000a02  48af              LDR      r0,|L6.3264|
000a04  6871              LDR      r1,[r6,#4]
000a06  6800              LDR      r0,[r0,#0]  ; recv_data
000a08  f7fffffe          BL       pbuf_cat
000a0c  e002              B        |L6.2580|
                  |L6.2574|
;;;1345               } else {
;;;1346                 recv_data = cseg->p;
000a0e  49ac              LDR      r1,|L6.3264|
000a10  6870              LDR      r0,[r6,#4]
000a12  6008              STR      r0,[r1,#0]  ; recv_data
                  |L6.2580|
;;;1347               }
;;;1348               cseg->p = NULL;
000a14  2000              MOVS     r0,#0
000a16  6070              STR      r0,[r6,#4]
                  |L6.2584|
;;;1349             }
;;;1350             if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
000a18  6931              LDR      r1,[r6,#0x10]
000a1a  8988              LDRH     r0,[r1,#0xc]
000a1c  f7fffffe          BL       lwip_ntohs
000a20  f0000001          AND      r0,r0,#1
000a24  b160              CBZ      r0,|L6.2624|
;;;1351               LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
000a26  bf00              NOP      
000a28  bf00              NOP      
;;;1352               recv_flags |= TF_GOT_FIN;
000a2a  48a6              LDR      r0,|L6.3268|
000a2c  7800              LDRB     r0,[r0,#0]  ; recv_flags
000a2e  f0400020          ORR      r0,r0,#0x20
000a32  49a4              LDR      r1,|L6.3268|
000a34  7008              STRB     r0,[r1,#0]
;;;1353               if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
000a36  7e20              LDRB     r0,[r4,#0x18]
000a38  2804              CMP      r0,#4
000a3a  d101              BNE      |L6.2624|
;;;1354                 pcb->state = CLOSE_WAIT;
000a3c  2007              MOVS     r0,#7
000a3e  7620              STRB     r0,[r4,#0x18]
                  |L6.2624|
;;;1355               } 
;;;1356             }
;;;1357   
;;;1358             pcb->ooseq = cseg->next;
000a40  6830              LDR      r0,[r6,#0]
000a42  6760              STR      r0,[r4,#0x74]
;;;1359             tcp_seg_free(cseg);
000a44  4630              MOV      r0,r6
000a46  f7fffffe          BL       tcp_seg_free
                  |L6.2634|
000a4a  6f60              LDR      r0,[r4,#0x74]         ;1327
000a4c  b130              CBZ      r0,|L6.2652|
000a4e  6f60              LDR      r0,[r4,#0x74]         ;1328
000a50  6900              LDR      r0,[r0,#0x10]         ;1328
000a52  6840              LDR      r0,[r0,#4]            ;1328
000a54  6aa1              LDR      r1,[r4,#0x28]         ;1328
000a56  4288              CMP      r0,r1                 ;1328
000a58  f43faf17          BEQ      |L6.2186|
                  |L6.2652|
;;;1360           }
;;;1361   #endif /* TCP_QUEUE_OOSEQ */
;;;1362   
;;;1363   
;;;1364           /* Acknowledge the segment(s). */
;;;1365           tcp_ack(pcb);
000a5c  bf00              NOP      
000a5e  7fa0              LDRB     r0,[r4,#0x1e]
000a60  f0000001          AND      r0,r0,#1
000a64  b140              CBZ      r0,|L6.2680|
000a66  7fa0              LDRB     r0,[r4,#0x1e]
000a68  f0200001          BIC      r0,r0,#1
000a6c  77a0              STRB     r0,[r4,#0x1e]
000a6e  7fa0              LDRB     r0,[r4,#0x1e]
000a70  f0400002          ORR      r0,r0,#2
000a74  77a0              STRB     r0,[r4,#0x1e]
000a76  e003              B        |L6.2688|
                  |L6.2680|
000a78  7fa0              LDRB     r0,[r4,#0x1e]
000a7a  f0400001          ORR      r0,r0,#1
000a7e  77a0              STRB     r0,[r4,#0x1e]
                  |L6.2688|
000a80  e108              B        |L6.3220|
                  |L6.2690|
;;;1366   
;;;1367         } else {
;;;1368           /* We get here if the incoming segment is out-of-sequence. */
;;;1369           tcp_send_empty_ack(pcb);
000a82  4620              MOV      r0,r4
000a84  f7fffffe          BL       tcp_send_empty_ack
;;;1370   #if TCP_QUEUE_OOSEQ
;;;1371           /* We queue the segment on the ->ooseq queue. */
;;;1372           if (pcb->ooseq == NULL) {
000a88  6f60              LDR      r0,[r4,#0x74]
000a8a  b920              CBNZ     r0,|L6.2710|
;;;1373             pcb->ooseq = tcp_seg_copy(&inseg);
000a8c  488e              LDR      r0,|L6.3272|
000a8e  f7fffffe          BL       tcp_seg_copy
000a92  6760              STR      r0,[r4,#0x74]
000a94  e0fe              B        |L6.3220|
                  |L6.2710|
;;;1374           } else {
;;;1375             /* If the queue is not empty, we walk through the queue and
;;;1376                try to find a place where the sequence number of the
;;;1377                incoming segment is between the sequence numbers of the
;;;1378                previous and the next segment on the ->ooseq queue. That is
;;;1379                the place where we put the incoming segment. If needed, we
;;;1380                trim the second edges of the previous and the incoming
;;;1381                segment so that it will fit into the sequence.
;;;1382   
;;;1383                If the incoming segment has the same sequence number as a
;;;1384                segment on the ->ooseq queue, we discard the segment that
;;;1385                contains less data. */
;;;1386   
;;;1387             prev = NULL;
000a96  2700              MOVS     r7,#0
;;;1388             for(next = pcb->ooseq; next != NULL; next = next->next) {
000a98  6f65              LDR      r5,[r4,#0x74]
000a9a  e0df              B        |L6.3164|
                  |L6.2716|
;;;1389               if (seqno == next->tcphdr->seqno) {
000a9c  6928              LDR      r0,[r5,#0x10]
000a9e  6840              LDR      r0,[r0,#4]
000aa0  498a              LDR      r1,|L6.3276|
000aa2  6809              LDR      r1,[r1,#0]  ; seqno
000aa4  4288              CMP      r0,r1
000aa6  d113              BNE      |L6.2768|
;;;1390                 /* The sequence number of the incoming segment is the
;;;1391                    same as the sequence number of the segment on
;;;1392                    ->ooseq. We check the lengths to see which one to
;;;1393                    discard. */
;;;1394                 if (inseg.len > next->len) {
000aa8  4887              LDR      r0,|L6.3272|
000aaa  8900              LDRH     r0,[r0,#8]  ; inseg
000aac  8929              LDRH     r1,[r5,#8]
000aae  4288              CMP      r0,r1
000ab0  dd0d              BLE      |L6.2766|
;;;1395                   /* The incoming segment is larger than the old
;;;1396                      segment. We replace some segments with the new
;;;1397                      one. */
;;;1398                   cseg = tcp_seg_copy(&inseg);
000ab2  4885              LDR      r0,|L6.3272|
000ab4  f7fffffe          BL       tcp_seg_copy
000ab8  4606              MOV      r6,r0
;;;1399                   if (cseg != NULL) {
000aba  b13e              CBZ      r6,|L6.2764|
;;;1400                     if (prev != NULL) {
000abc  b10f              CBZ      r7,|L6.2754|
;;;1401                       prev->next = cseg;
000abe  603e              STR      r6,[r7,#0]
000ac0  e000              B        |L6.2756|
                  |L6.2754|
;;;1402                     } else {
;;;1403                       pcb->ooseq = cseg;
000ac2  6766              STR      r6,[r4,#0x74]
                  |L6.2756|
;;;1404                     }
;;;1405                     tcp_oos_insert_segment(cseg, next);
000ac4  4629              MOV      r1,r5
000ac6  4630              MOV      r0,r6
000ac8  f7fffffe          BL       tcp_oos_insert_segment
                  |L6.2764|
;;;1406                   }
;;;1407                   break;
000acc  e0c9              B        |L6.3170|
                  |L6.2766|
;;;1408                 } else {
;;;1409                   /* Either the lenghts are the same or the incoming
;;;1410                      segment was smaller than the old one; in either
;;;1411                      case, we ditch the incoming segment. */
;;;1412                   break;
000ace  e0c8              B        |L6.3170|
                  |L6.2768|
;;;1413                 }
;;;1414               } else {
;;;1415                 if (prev == NULL) {
000ad0  b987              CBNZ     r7,|L6.2804|
;;;1416                   if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
000ad2  6928              LDR      r0,[r5,#0x10]
000ad4  6840              LDR      r0,[r0,#4]
000ad6  497d              LDR      r1,|L6.3276|
000ad8  6809              LDR      r1,[r1,#0]  ; seqno
000ada  1a08              SUBS     r0,r1,r0
000adc  d537              BPL      |L6.2894|
;;;1417                     /* The sequence number of the incoming segment is lower
;;;1418                        than the sequence number of the first segment on the
;;;1419                        queue. We put the incoming segment first on the
;;;1420                        queue. */
;;;1421                     cseg = tcp_seg_copy(&inseg);
000ade  487a              LDR      r0,|L6.3272|
000ae0  f7fffffe          BL       tcp_seg_copy
000ae4  4606              MOV      r6,r0
;;;1422                     if (cseg != NULL) {
000ae6  b126              CBZ      r6,|L6.2802|
;;;1423                       pcb->ooseq = cseg;
000ae8  6766              STR      r6,[r4,#0x74]
;;;1424                       tcp_oos_insert_segment(cseg, next);
000aea  4629              MOV      r1,r5
000aec  4630              MOV      r0,r6
000aee  f7fffffe          BL       tcp_oos_insert_segment
                  |L6.2802|
;;;1425                     }
;;;1426                     break;
000af2  e0b6              B        |L6.3170|
                  |L6.2804|
;;;1427                   }
;;;1428                 } else {
;;;1429                   /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
;;;1430                     TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
;;;1431                   if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
000af4  6938              LDR      r0,[r7,#0x10]
000af6  6840              LDR      r0,[r0,#4]
000af8  1c40              ADDS     r0,r0,#1
000afa  4974              LDR      r1,|L6.3276|
000afc  6809              LDR      r1,[r1,#0]  ; seqno
000afe  1a08              SUBS     r0,r1,r0
000b00  d425              BMI      |L6.2894|
000b02  6928              LDR      r0,[r5,#0x10]
000b04  6840              LDR      r0,[r0,#4]
000b06  1e40              SUBS     r0,r0,#1
000b08  4970              LDR      r1,|L6.3276|
000b0a  6809              LDR      r1,[r1,#0]  ; seqno
000b0c  1a08              SUBS     r0,r1,r0
000b0e  2800              CMP      r0,#0
000b10  dc1d              BGT      |L6.2894|
;;;1432                     /* The sequence number of the incoming segment is in
;;;1433                        between the sequence numbers of the previous and
;;;1434                        the next segment on ->ooseq. We trim trim the previous
;;;1435                        segment, delete next segments that included in received segment
;;;1436                        and trim received, if needed. */
;;;1437                     cseg = tcp_seg_copy(&inseg);
000b12  486d              LDR      r0,|L6.3272|
000b14  f7fffffe          BL       tcp_seg_copy
000b18  4606              MOV      r6,r0
;;;1438                     if (cseg != NULL) {
000b1a  b1be              CBZ      r6,|L6.2892|
;;;1439                       if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
000b1c  6938              LDR      r0,[r7,#0x10]
000b1e  6840              LDR      r0,[r0,#4]
000b20  8939              LDRH     r1,[r7,#8]
000b22  4408              ADD      r0,r0,r1
000b24  4969              LDR      r1,|L6.3276|
000b26  6809              LDR      r1,[r1,#0]  ; seqno
000b28  1a40              SUBS     r0,r0,r1
000b2a  2800              CMP      r0,#0
000b2c  dd09              BLE      |L6.2882|
;;;1440                         /* We need to trim the prev segment. */
;;;1441                         prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
000b2e  6938              LDR      r0,[r7,#0x10]
000b30  8880              LDRH     r0,[r0,#4]
000b32  4966              LDR      r1,|L6.3276|
000b34  8809              LDRH     r1,[r1,#0]  ; seqno
000b36  1a08              SUBS     r0,r1,r0
000b38  8138              STRH     r0,[r7,#8]
;;;1442                         pbuf_realloc(prev->p, prev->len);
000b3a  8939              LDRH     r1,[r7,#8]
000b3c  6878              LDR      r0,[r7,#4]
000b3e  f7fffffe          BL       pbuf_realloc
                  |L6.2882|
;;;1443                       }
;;;1444                       prev->next = cseg;
000b42  603e              STR      r6,[r7,#0]
;;;1445                       tcp_oos_insert_segment(cseg, next);
000b44  4629              MOV      r1,r5
000b46  4630              MOV      r0,r6
000b48  f7fffffe          BL       tcp_oos_insert_segment
                  |L6.2892|
;;;1446                     }
;;;1447                     break;
000b4c  e089              B        |L6.3170|
                  |L6.2894|
;;;1448                   }
;;;1449                 }
;;;1450                 /* If the "next" segment is the last segment on the
;;;1451                    ooseq queue, we add the incoming segment to the end
;;;1452                    of the list. */
;;;1453                 if (next->next == NULL &&
000b4e  6828              LDR      r0,[r5,#0]
000b50  bbf0              CBNZ     r0,|L6.3024|
;;;1454                     TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
000b52  6928              LDR      r0,[r5,#0x10]
000b54  6840              LDR      r0,[r0,#4]
000b56  495d              LDR      r1,|L6.3276|
000b58  6809              LDR      r1,[r1,#0]  ; seqno
000b5a  1a08              SUBS     r0,r1,r0
000b5c  2800              CMP      r0,#0
000b5e  dd7b              BLE      |L6.3160|
;;;1455                   if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
000b60  6929              LDR      r1,[r5,#0x10]
000b62  8988              LDRH     r0,[r1,#0xc]
000b64  f7fffffe          BL       lwip_ntohs
000b68  f0000001          AND      r0,r0,#1
000b6c  b100              CBZ      r0,|L6.2928|
;;;1456                     /* segment "next" already contains all data */
;;;1457                     break;
000b6e  e078              B        |L6.3170|
                  |L6.2928|
;;;1458                   }
;;;1459                   next->next = tcp_seg_copy(&inseg);
000b70  4855              LDR      r0,|L6.3272|
000b72  f7fffffe          BL       tcp_seg_copy
000b76  6028              STR      r0,[r5,#0]
;;;1460                   if (next->next != NULL) {
000b78  6828              LDR      r0,[r5,#0]
000b7a  b350              CBZ      r0,|L6.3026|
;;;1461                     if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
000b7c  6928              LDR      r0,[r5,#0x10]
000b7e  6840              LDR      r0,[r0,#4]
000b80  8929              LDRH     r1,[r5,#8]
000b82  4408              ADD      r0,r0,r1
000b84  4951              LDR      r1,|L6.3276|
000b86  6809              LDR      r1,[r1,#0]  ; seqno
000b88  1a40              SUBS     r0,r0,r1
000b8a  2800              CMP      r0,#0
000b8c  dd09              BLE      |L6.2978|
;;;1462                       /* We need to trim the last segment. */
;;;1463                       next->len = (u16_t)(seqno - next->tcphdr->seqno);
000b8e  6928              LDR      r0,[r5,#0x10]
000b90  8880              LDRH     r0,[r0,#4]
000b92  494e              LDR      r1,|L6.3276|
000b94  8809              LDRH     r1,[r1,#0]  ; seqno
000b96  1a08              SUBS     r0,r1,r0
000b98  8128              STRH     r0,[r5,#8]
;;;1464                       pbuf_realloc(next->p, next->len);
000b9a  8929              LDRH     r1,[r5,#8]
000b9c  6868              LDR      r0,[r5,#4]
000b9e  f7fffffe          BL       pbuf_realloc
                  |L6.2978|
;;;1465                     }
;;;1466                     /* check if the remote side overruns our receive window */
;;;1467                     if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
000ba2  8da1              LDRH     r1,[r4,#0x2c]
000ba4  6aa0              LDR      r0,[r4,#0x28]
000ba6  4401              ADD      r1,r1,r0
000ba8  4849              LDR      r0,|L6.3280|
000baa  8800              LDRH     r0,[r0,#0]  ; tcplen
000bac  4a47              LDR      r2,|L6.3276|
000bae  6812              LDR      r2,[r2,#0]  ; seqno
000bb0  4410              ADD      r0,r0,r2
000bb2  4281              CMP      r1,r0
000bb4  d24f              BCS      |L6.3158|
;;;1468                       LWIP_DEBUGF(TCP_INPUT_DEBUG, 
000bb6  bf00              NOP      
000bb8  bf00              NOP      
;;;1469                                   ("tcp_receive: other end overran receive window"
;;;1470                                    "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1471                                    seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1472                       if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
000bba  6829              LDR      r1,[r5,#0]
000bbc  6909              LDR      r1,[r1,#0x10]
000bbe  8988              LDRH     r0,[r1,#0xc]
000bc0  f7fffffe          BL       lwip_ntohs
000bc4  f0000001          AND      r0,r0,#1
000bc8  b1b0              CBZ      r0,|L6.3064|
;;;1473                         /* Must remove the FIN from the header as we're trimming 
;;;1474                          * that byte of sequence-space from the packet */
;;;1475                         TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
000bca  6829              LDR      r1,[r5,#0]
000bcc  6909              LDR      r1,[r1,#0x10]
000bce  e001              B        |L6.3028|
                  |L6.3024|
000bd0  e042              B        |L6.3160|
                  |L6.3026|
000bd2  e040              B        |L6.3158|
                  |L6.3028|
000bd4  8988              LDRH     r0,[r1,#0xc]
000bd6  f7fffffe          BL       lwip_ntohs
000bda  f0000b3e          AND      r11,r0,#0x3e
000bde  4658              MOV      r0,r11
000be0  f7fffffe          BL       lwip_htons
000be4  6829              LDR      r1,[r5,#0]
000be6  6909              LDR      r1,[r1,#0x10]
000be8  8989              LDRH     r1,[r1,#0xc]
000bea  f24c02ff          MOV      r2,#0xc0ff
000bee  4011              ANDS     r1,r1,r2
000bf0  4308              ORRS     r0,r0,r1
000bf2  6829              LDR      r1,[r5,#0]
000bf4  6909              LDR      r1,[r1,#0x10]
000bf6  8188              STRH     r0,[r1,#0xc]
                  |L6.3064|
;;;1476                       }
;;;1477                       /* Adjust length of segment to fit in the window. */
;;;1478                       next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
000bf8  8d20              LDRH     r0,[r4,#0x28]
000bfa  8da1              LDRH     r1,[r4,#0x2c]
000bfc  4408              ADD      r0,r0,r1
000bfe  4933              LDR      r1,|L6.3276|
000c00  8809              LDRH     r1,[r1,#0]  ; seqno
000c02  1a40              SUBS     r0,r0,r1
000c04  6829              LDR      r1,[r5,#0]
000c06  8108              STRH     r0,[r1,#8]
;;;1479                       pbuf_realloc(next->next->p, next->next->len);
000c08  682a              LDR      r2,[r5,#0]
000c0a  8911              LDRH     r1,[r2,#8]
000c0c  6850              LDR      r0,[r2,#4]
000c0e  f7fffffe          BL       pbuf_realloc
;;;1480                       tcplen = TCP_TCPLEN(next->next);
000c12  6829              LDR      r1,[r5,#0]
000c14  6909              LDR      r1,[r1,#0x10]
000c16  8988              LDRH     r0,[r1,#0xc]
000c18  f7fffffe          BL       lwip_ntohs
000c1c  f0000003          AND      r0,r0,#3
000c20  b108              CBZ      r0,|L6.3110|
000c22  2001              MOVS     r0,#1
000c24  e000              B        |L6.3112|
                  |L6.3110|
000c26  2000              MOVS     r0,#0
                  |L6.3112|
000c28  6829              LDR      r1,[r5,#0]
000c2a  8909              LDRH     r1,[r1,#8]
000c2c  4408              ADD      r0,r0,r1
000c2e  4928              LDR      r1,|L6.3280|
000c30  8008              STRH     r0,[r1,#0]
;;;1481                       LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
000c32  bf00              NOP      
000c34  8da1              LDRH     r1,[r4,#0x2c]
000c36  6aa0              LDR      r0,[r4,#0x28]
000c38  4408              ADD      r0,r0,r1
000c3a  4924              LDR      r1,|L6.3276|
000c3c  6809              LDR      r1,[r1,#0]  ; seqno
000c3e  4a24              LDR      r2,|L6.3280|
000c40  8812              LDRH     r2,[r2,#0]  ; tcplen
000c42  4411              ADD      r1,r1,r2
000c44  4288              CMP      r0,r1
000c46  d005              BEQ      |L6.3156|
000c48  f2af3050          ADR      r0,|L6.2300|
000c4c  f7fffffe          BL       __2printf
000c50  bf00              NOP      
                  |L6.3154|
000c52  e7fe              B        |L6.3154|
                  |L6.3156|
000c54  bf00              NOP      
                  |L6.3158|
;;;1482                                   (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1483                     }
;;;1484                   }
;;;1485                   break;
000c56  e004              B        |L6.3170|
                  |L6.3160|
;;;1486                 }
;;;1487               }
;;;1488               prev = next;
000c58  462f              MOV      r7,r5
000c5a  682d              LDR      r5,[r5,#0]            ;1388
                  |L6.3164|
000c5c  2d00              CMP      r5,#0                 ;1388
000c5e  f47faf1d          BNE      |L6.2716|
                  |L6.3170|
000c62  e017              B        |L6.3220|
                  |L6.3172|
;;;1489             }
;;;1490           }
;;;1491   #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;1492           /* Check that the data on ooseq doesn't exceed one of the limits
;;;1493              and throw away everything above that limit. */
;;;1494           ooseq_blen = 0;
;;;1495           ooseq_qlen = 0;
;;;1496           prev = NULL;
;;;1497           for(next = pcb->ooseq; next != NULL; prev = next, next = next->next) {
;;;1498             struct pbuf *p = next->p;
;;;1499             ooseq_blen += p->tot_len;
;;;1500             ooseq_qlen += pbuf_clen(p);
;;;1501             if ((ooseq_blen > TCP_OOSEQ_MAX_BYTES) ||
;;;1502                 (ooseq_qlen > TCP_OOSEQ_MAX_PBUFS)) {
;;;1503                /* too much ooseq data, dump this and everything after it */
;;;1504                tcp_segs_free(next);
;;;1505                if (prev == NULL) {
;;;1506                  /* first ooseq segment is too much, dump the whole queue */
;;;1507                  pcb->ooseq = NULL;
;;;1508                } else {
;;;1509                  /* just dump 'next' and everything after it */
;;;1510                  prev->next = NULL;
;;;1511                }
;;;1512                break;
;;;1513             }
;;;1514           }
;;;1515   #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;1516   #endif /* TCP_QUEUE_OOSEQ */
;;;1517         }
;;;1518       } else {
;;;1519         /* The incoming segment is not withing the window. */
;;;1520         tcp_send_empty_ack(pcb);
000c64  4620              MOV      r0,r4
000c66  f7fffffe          BL       tcp_send_empty_ack
000c6a  e013              B        |L6.3220|
                  |L6.3180|
;;;1521       }
;;;1522     } else {
;;;1523       /* Segments with length 0 is taken care of here. Segments that
;;;1524          fall out of the window are ACKed. */
;;;1525       /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
;;;1526         TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
;;;1527       if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
000c6c  4917              LDR      r1,|L6.3276|
000c6e  6aa0              LDR      r0,[r4,#0x28]
000c70  6809              LDR      r1,[r1,#0]  ; seqno
000c72  1a08              SUBS     r0,r1,r0
000c74  d408              BMI      |L6.3208|
000c76  8da1              LDRH     r1,[r4,#0x2c]
000c78  6aa0              LDR      r0,[r4,#0x28]
000c7a  4408              ADD      r0,r0,r1
000c7c  1e40              SUBS     r0,r0,#1
000c7e  4913              LDR      r1,|L6.3276|
000c80  6809              LDR      r1,[r1,#0]  ; seqno
000c82  1a08              SUBS     r0,r1,r0
000c84  2800              CMP      r0,#0
000c86  dd05              BLE      |L6.3220|
                  |L6.3208|
;;;1528         tcp_ack_now(pcb);
000c88  bf00              NOP      
000c8a  7fa0              LDRB     r0,[r4,#0x1e]
000c8c  f0400002          ORR      r0,r0,#2
000c90  77a0              STRB     r0,[r4,#0x1e]
000c92  bf00              NOP      
                  |L6.3220|
;;;1529       }
;;;1530     }
;;;1531   }
000c94  e8bd8ffe          POP      {r1-r11,pc}
;;;1532   
                          ENDP

                  |L6.3224|
000c98  7463705f          DCB      "tcp_receive: ooseq tcplen > rcv_wnd\n",0
000c9c  72656365
000ca0  6976653a
000ca4  206f6f73
000ca8  65712074
000cac  63706c65
000cb0  6e203e20
000cb4  7263765f
000cb8  776e640a
000cbc  00      
000cbd  00                DCB      0
000cbe  00                DCB      0
000cbf  00                DCB      0
                  |L6.3264|
                          DCD      recv_data
                  |L6.3268|
                          DCD      recv_flags
                  |L6.3272|
                          DCD      inseg
                  |L6.3276|
                          DCD      seqno
                  |L6.3280|
                          DCD      tcplen

                          AREA ||i.tcp_timewait_input||, CODE, READONLY, ALIGN=2

                  tcp_timewait_input PROC
;;;528    static err_t
;;;529    tcp_timewait_input(struct tcp_pcb *pcb)
000000  b51c              PUSH     {r2-r4,lr}
;;;530    {
000002  4604              MOV      r4,r0
;;;531      /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
;;;532      /* RFC 793 3.9 Event Processing - Segment Arrives:
;;;533       * - first check sequence number - we skip that one in TIME_WAIT (always
;;;534       *   acceptable since we only send ACKs)
;;;535       * - second check the RST bit (... return) */
;;;536      if (flags & TCP_RST)  {
000004  4821              LDR      r0,|L7.140|
000006  7800              LDRB     r0,[r0,#0]  ; flags
000008  f0000004          AND      r0,r0,#4
00000c  b108              CBZ      r0,|L7.18|
;;;537        return ERR_OK;
00000e  2000              MOVS     r0,#0
                  |L7.16|
;;;538      }
;;;539      /* - fourth, check the SYN bit, */
;;;540      if (flags & TCP_SYN) {
;;;541        /* If an incoming segment is not acceptable, an acknowledgment
;;;542           should be sent in reply */
;;;543        if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;544          /* If the SYN is in the window it is an error, send a reset */
;;;545          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;546            tcphdr->dest, tcphdr->src);
;;;547          return ERR_OK;
;;;548        }
;;;549      } else if (flags & TCP_FIN) {
;;;550        /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
;;;551             Restart the 2 MSL time-wait timeout.*/
;;;552        pcb->tmr = tcp_ticks;
;;;553      }
;;;554    
;;;555      if ((tcplen > 0))  {
;;;556        /* Acknowledge data, FIN or out-of-window SYN */
;;;557        pcb->flags |= TF_ACK_NOW;
;;;558        return tcp_output(pcb);
;;;559      }
;;;560      return ERR_OK;
;;;561    }
000010  bd1c              POP      {r2-r4,pc}
                  |L7.18|
000012  481e              LDR      r0,|L7.140|
000014  7800              LDRB     r0,[r0,#0]            ;540  ; flags
000016  f0000002          AND      r0,r0,#2              ;540
00001a  b308              CBZ      r0,|L7.96|
00001c  491c              LDR      r1,|L7.144|
00001e  6aa0              LDR      r0,[r4,#0x28]         ;543
000020  6809              LDR      r1,[r1,#0]            ;543  ; seqno
000022  1a08              SUBS     r0,r1,r0              ;543
000024  d424              BMI      |L7.112|
000026  8da1              LDRH     r1,[r4,#0x2c]         ;543
000028  6aa0              LDR      r0,[r4,#0x28]         ;543
00002a  4408              ADD      r0,r0,r1              ;543
00002c  4918              LDR      r1,|L7.144|
00002e  6809              LDR      r1,[r1,#0]            ;543  ; seqno
000030  1a08              SUBS     r0,r1,r0              ;543
000032  2800              CMP      r0,#0                 ;543
000034  dc1c              BGT      |L7.112|
000036  4817              LDR      r0,|L7.148|
000038  6800              LDR      r0,[r0,#0]            ;545  ; tcphdr
00003a  8800              LDRH     r0,[r0,#0]            ;545
00003c  4915              LDR      r1,|L7.148|
00003e  6809              LDR      r1,[r1,#0]            ;545  ; tcphdr
000040  8849              LDRH     r1,[r1,#2]            ;545
000042  e9cd1000          STRD     r1,r0,[sp,#0]         ;545
000046  4812              LDR      r0,|L7.144|
000048  6800              LDR      r0,[r0,#0]            ;545  ; seqno
00004a  4a13              LDR      r2,|L7.152|
00004c  8812              LDRH     r2,[r2,#0]            ;545  ; tcplen
00004e  1881              ADDS     r1,r0,r2              ;545
000050  4b12              LDR      r3,|L7.156|
000052  4a13              LDR      r2,|L7.160|
000054  4813              LDR      r0,|L7.164|
000056  6800              LDR      r0,[r0,#0]            ;545  ; ackno
000058  f7fffffe          BL       tcp_rst
00005c  2000              MOVS     r0,#0                 ;547
00005e  e7d7              B        |L7.16|
                  |L7.96|
000060  480a              LDR      r0,|L7.140|
000062  7800              LDRB     r0,[r0,#0]            ;549  ; flags
000064  f0000001          AND      r0,r0,#1              ;549
000068  b110              CBZ      r0,|L7.112|
00006a  480f              LDR      r0,|L7.168|
00006c  6800              LDR      r0,[r0,#0]            ;552  ; tcp_ticks
00006e  6260              STR      r0,[r4,#0x24]         ;552
                  |L7.112|
000070  4809              LDR      r0,|L7.152|
000072  8800              LDRH     r0,[r0,#0]            ;555  ; tcplen
000074  2800              CMP      r0,#0                 ;555
000076  dd07              BLE      |L7.136|
000078  7fa0              LDRB     r0,[r4,#0x1e]         ;557
00007a  f0400002          ORR      r0,r0,#2              ;557
00007e  77a0              STRB     r0,[r4,#0x1e]         ;557
000080  4620              MOV      r0,r4                 ;558
000082  f7fffffe          BL       tcp_output
000086  e7c3              B        |L7.16|
                  |L7.136|
000088  2000              MOVS     r0,#0                 ;560
00008a  e7c1              B        |L7.16|
;;;562    
                          ENDP

                  |L7.140|
                          DCD      flags
                  |L7.144|
                          DCD      seqno
                  |L7.148|
                          DCD      tcphdr
                  |L7.152|
                          DCD      tcplen
                  |L7.156|
                          DCD      current_iphdr_src
                  |L7.160|
                          DCD      current_iphdr_dest
                  |L7.164|
                          DCD      ackno
                  |L7.168|
                          DCD      tcp_ticks

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  inseg
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  tcphdr
                          DCD      0x00000000
                  iphdr
                          DCD      0x00000000
                  seqno
                          DCD      0x00000000
                  ackno
                          DCD      0x00000000
                  flags
000010  0000              DCB      0x00,0x00
                  tcplen
000012  0000              DCB      0x00,0x00
                  recv_flags
000014  00000000          DCB      0x00,0x00,0x00,0x00
                  recv_data
                          DCD      0x00000000
                  tcp_input_pcb
                          DCD      0x00000000
