; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\spi.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\spi.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IE:\git_projects\enc28j60-for-uip\Project\RVMDK\RTE -I"D:\Program Files\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\spi.crf ..\..\lwip\src\arch\SPI.C]
                          THUMB

                          AREA ||i.SPI1_Init||, CODE, READONLY, ALIGN=2

                  SPI1_Init PROC
;;;30     ****************************************************************************/ 
;;;31     void SPI1_Init(void)
000000  b500              PUSH     {lr}
;;;32     {
000002  b087              SUB      sp,sp,#0x1c
;;;33     	SPI_InitTypeDef  SPI_InitStructure;
;;;34     	GPIO_InitTypeDef GPIO_InitStructure;
;;;35     	
;;;36     	/* 使能SPI1时钟 */
;;;37     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
000004  2101              MOVS     r1,#1
000006  0308              LSLS     r0,r1,#12
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;38     	
;;;39     	/* 配置SPI1的SCK,MISO MOSI */
;;;40     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
00000c  20e0              MOVS     r0,#0xe0
00000e  f8ad0004          STRH     r0,[sp,#4]
;;;41     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
000012  2001              MOVS     r0,#1
000014  f88d0006          STRB     r0,[sp,#6]
;;;42     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;			  //复用功能
000018  2018              MOVS     r0,#0x18
00001a  f88d0007          STRB     r0,[sp,#7]
;;;43     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00001e  a901              ADD      r1,sp,#4
000020  481c              LDR      r0,|L1.148|
000022  f7fffffe          BL       GPIO_Init
;;;44     	
;;;45     	/* 配置SPI1的ENC28J60片选 */
;;;46         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
000026  2010              MOVS     r0,#0x10
000028  f8ad0004          STRH     r0,[sp,#4]
;;;47         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
00002c  2001              MOVS     r0,#1
00002e  f88d0006          STRB     r0,[sp,#6]
;;;48         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000032  2010              MOVS     r0,#0x10
000034  f88d0007          STRB     r0,[sp,#7]
;;;49     	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;			  //复用功能
;;;50         GPIO_Init(GPIOA, &GPIO_InitStructure);
000038  a901              ADD      r1,sp,#4
00003a  4816              LDR      r0,|L1.148|
00003c  f7fffffe          BL       GPIO_Init
;;;51     
;;;52     	GPIO_SetBits(GPIOA, GPIO_Pin_4);   
000040  2110              MOVS     r1,#0x10
000042  4814              LDR      r0,|L1.148|
000044  f7fffffe          BL       GPIO_SetBits
;;;53     
;;;54     	/* SPI1配置 */ 
;;;55     	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
000048  2000              MOVS     r0,#0
00004a  f8ad0008          STRH     r0,[sp,#8]
;;;56     	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
00004e  f44f7082          MOV      r0,#0x104
000052  f8ad000a          STRH     r0,[sp,#0xa]
;;;57     	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
000056  2000              MOVS     r0,#0
000058  f8ad000c          STRH     r0,[sp,#0xc]
;;;58     	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
00005c  f8ad000e          STRH     r0,[sp,#0xe]
;;;59     	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
000060  f8ad0010          STRH     r0,[sp,#0x10]
;;;60     	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
000064  f44f7000          MOV      r0,#0x200
000068  f8ad0012          STRH     r0,[sp,#0x12]
;;;61     	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
00006c  2010              MOVS     r0,#0x10
00006e  f8ad0014          STRH     r0,[sp,#0x14]
;;;62     	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
000072  2000              MOVS     r0,#0
000074  f8ad0016          STRH     r0,[sp,#0x16]
;;;63     	SPI_InitStructure.SPI_CRCPolynomial = 7;
000078  2007              MOVS     r0,#7
00007a  f8ad0018          STRH     r0,[sp,#0x18]
;;;64     	SPI_Init(SPI1, &SPI_InitStructure);
00007e  a902              ADD      r1,sp,#8
000080  4805              LDR      r0,|L1.152|
000082  f7fffffe          BL       SPI_Init
;;;65     	
;;;66     	/* 使能SPI1  */
;;;67     	SPI_Cmd(SPI1, ENABLE); 
000086  2101              MOVS     r1,#1
000088  4803              LDR      r0,|L1.152|
00008a  f7fffffe          BL       SPI_Cmd
;;;68     }
00008e  b007              ADD      sp,sp,#0x1c
000090  bd00              POP      {pc}
;;;69     
                          ENDP

000092  0000              DCW      0x0000
                  |L1.148|
                          DCD      0x40010800
                  |L1.152|
                          DCD      0x40013000

                          AREA ||i.SPI1_ReadWrite||, CODE, READONLY, ALIGN=2

                  SPI1_ReadWrite PROC
;;;77     ****************************************************************************/ 
;;;78     unsigned char	SPI1_ReadWrite(unsigned char writedat)
000000  b510              PUSH     {r4,lr}
;;;79     	{
000002  4604              MOV      r4,r0
;;;80     	/* Loop while DR register in not emplty */
;;;81     	while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L2.6|
000006  2102              MOVS     r1,#2
000008  480a              LDR      r0,|L2.52|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L2.6|
;;;82     	
;;;83     	/* Send byte through the SPI1 peripheral */
;;;84     	SPI_I2S_SendData(SPI1, writedat);
000012  4621              MOV      r1,r4
000014  4807              LDR      r0,|L2.52|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;85     	
;;;86     	/* Wait to receive a byte */
;;;87     	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L2.28|
00001c  2101              MOVS     r1,#1
00001e  4805              LDR      r0,|L2.52|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L2.28|
;;;88     	
;;;89     	/* Return the byte read from the SPI bus */
;;;90     	return SPI_I2S_ReceiveData(SPI1);
000028  4802              LDR      r0,|L2.52|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  b2c0              UXTB     r0,r0
;;;91     	}
000030  bd10              POP      {r4,pc}
;;;92     
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
                          DCD      0x40013000
