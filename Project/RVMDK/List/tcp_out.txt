; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\tcp_out.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\tcp_out.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IE:\git_projects\enc28j60-for-uip\Project\RVMDK\RTE -I"D:\Program Files\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\tcp_out.crf ..\..\lwip\src\core\tcp_out.c]
                          THUMB

                          AREA ||i.tcp_create_segment||, CODE, READONLY, ALIGN=2

                  tcp_create_segment PROC
;;;158    static struct tcp_seg *
;;;159    tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;160    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;161      struct tcp_seg *seg;
;;;162      u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
000010  f0080001          AND      r0,r8,#1
000014  b108              CBZ      r0,|L1.26|
000016  2004              MOVS     r0,#4
000018  e000              B        |L1.28|
                  |L1.26|
00001a  2000              MOVS     r0,#0
                  |L1.28|
00001c  f0080102          AND      r1,r8,#2
000020  b109              CBZ      r1,|L1.38|
000022  210c              MOVS     r1,#0xc
000024  e000              B        |L1.40|
                  |L1.38|
000026  2100              MOVS     r1,#0
                  |L1.40|
000028  1845              ADDS     r5,r0,r1
;;;163    
;;;164      if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
00002a  2004              MOVS     r0,#4
00002c  f7fffffe          BL       memp_malloc
000030  1e04              SUBS     r4,r0,#0
000032  d107              BNE      |L1.68|
;;;165        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
000034  bf00              NOP      
000036  bf00              NOP      
;;;166        pbuf_free(p);
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       pbuf_free
;;;167        return NULL;
00003e  2000              MOVS     r0,#0
                  |L1.64|
;;;168      }
;;;169      seg->flags = optflags;
;;;170      seg->next = NULL;
;;;171      seg->p = p;
;;;172      seg->len = p->tot_len - optlen;
;;;173    #if TCP_OVERSIZE_DBGCHECK
;;;174      seg->oversize_left = 0;
;;;175    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;176    #if TCP_CHECKSUM_ON_COPY
;;;177      seg->chksum = 0;
;;;178      seg->chksum_swapped = 0;
;;;179      /* check optflags */
;;;180      LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
;;;181                  (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
;;;182    #endif /* TCP_CHECKSUM_ON_COPY */
;;;183    
;;;184      /* build TCP header */
;;;185      if (pbuf_header(p, TCP_HLEN)) {
;;;186        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
;;;187        TCP_STATS_INC(tcp.err);
;;;188        tcp_seg_free(seg);
;;;189        return NULL;
;;;190      }
;;;191      seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
;;;192      seg->tcphdr->src = htons(pcb->local_port);
;;;193      seg->tcphdr->dest = htons(pcb->remote_port);
;;;194      seg->tcphdr->seqno = htonl(seqno);
;;;195      /* ackno is set in tcp_output */
;;;196      TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
;;;197      /* wnd and chksum are set in tcp_output */
;;;198      seg->tcphdr->urgp = 0;
;;;199      return seg;
;;;200    } 
000040  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.68|
000044  f884800c          STRB     r8,[r4,#0xc]          ;169
000048  2000              MOVS     r0,#0                 ;170
00004a  6020              STR      r0,[r4,#0]            ;170
00004c  6066              STR      r6,[r4,#4]            ;171
00004e  8930              LDRH     r0,[r6,#8]            ;172
000050  1b40              SUBS     r0,r0,r5              ;172
000052  8120              STRH     r0,[r4,#8]            ;172
000054  2000              MOVS     r0,#0                 ;174
000056  8160              STRH     r0,[r4,#0xa]          ;174
000058  2114              MOVS     r1,#0x14              ;185
00005a  4630              MOV      r0,r6                 ;185
00005c  f7fffffe          BL       pbuf_header
000060  b170              CBZ      r0,|L1.128|
000062  bf00              NOP                            ;186
000064  bf00              NOP                            ;186
000066  4818              LDR      r0,|L1.200|
000068  f8b000a4          LDRH     r0,[r0,#0xa4]         ;187
00006c  1c40              ADDS     r0,r0,#1              ;187
00006e  b281              UXTH     r1,r0                 ;187
000070  4815              LDR      r0,|L1.200|
000072  f8a010a4          STRH     r1,[r0,#0xa4]         ;187
000076  4620              MOV      r0,r4                 ;188
000078  f7fffffe          BL       tcp_seg_free
00007c  2000              MOVS     r0,#0                 ;189
00007e  e7df              B        |L1.64|
                  |L1.128|
000080  6860              LDR      r0,[r4,#4]            ;191
000082  6840              LDR      r0,[r0,#4]            ;191
000084  6120              STR      r0,[r4,#0x10]         ;191
000086  8b78              LDRH     r0,[r7,#0x1a]         ;192
000088  f7fffffe          BL       lwip_htons
00008c  6921              LDR      r1,[r4,#0x10]         ;192
00008e  8008              STRH     r0,[r1,#0]            ;192
000090  8bb8              LDRH     r0,[r7,#0x1c]         ;193
000092  f7fffffe          BL       lwip_htons
000096  6921              LDR      r1,[r4,#0x10]         ;193
000098  8048              STRH     r0,[r1,#2]            ;193
00009a  4650              MOV      r0,r10                ;194
00009c  f7fffffe          BL       lwip_htonl
0000a0  6921              LDR      r1,[r4,#0x10]         ;194
0000a2  6048              STR      r0,[r1,#4]            ;194
0000a4  46ab              MOV      r11,r5                ;196
0000a6  17e9              ASRS     r1,r5,#31             ;196
0000a8  eb057191          ADD      r1,r5,r1,LSR #30      ;196
0000ac  1089              ASRS     r1,r1,#2              ;196
0000ae  1d49              ADDS     r1,r1,#5              ;196
0000b0  ea493101          ORR      r1,r9,r1,LSL #12      ;196
0000b4  b288              UXTH     r0,r1                 ;196
0000b6  f7fffffe          BL       lwip_htons
0000ba  6921              LDR      r1,[r4,#0x10]         ;196
0000bc  8188              STRH     r0,[r1,#0xc]          ;196
0000be  2000              MOVS     r0,#0                 ;198
0000c0  6921              LDR      r1,[r4,#0x10]         ;198
0000c2  8248              STRH     r0,[r1,#0x12]         ;198
0000c4  4620              MOV      r0,r4                 ;199
0000c6  e7bb              B        |L1.64|
;;;201    
                          ENDP

                  |L1.200|
                          DCD      lwip_stats

                          AREA ||i.tcp_enqueue_flags||, CODE, READONLY, ALIGN=2

                  tcp_enqueue_flags PROC
;;;721    err_t
;;;722    tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;723    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;724      struct pbuf *p;
;;;725      struct tcp_seg *seg;
;;;726      u8_t optflags = 0;
000008  f04f0800          MOV      r8,#0
;;;727      u8_t optlen = 0;
00000c  46c1              MOV      r9,r8
;;;728    
;;;729      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
00000e  bf00              NOP      
000010  bf00              NOP      
;;;730    
;;;731      LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
000012  bf00              NOP      
000014  f0050003          AND      r0,r5,#3
000018  b920              CBNZ     r0,|L2.36|
00001a  4868              LDR      r0,|L2.444|
00001c  f7fffffe          BL       __2printf
000020  bf00              NOP      
                  |L2.34|
000022  e7fe              B        |L2.34|
                  |L2.36|
000024  bf00              NOP      
;;;732                  (flags & (TCP_SYN | TCP_FIN)) != 0);
;;;733    
;;;734      /* check for configured max queuelen and possible overflow */
;;;735      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
000026  f8b40068          LDRH     r0,[r4,#0x68]
00002a  2810              CMP      r0,#0x10
00002c  da05              BGE      |L2.58|
00002e  f8b40068          LDRH     r0,[r4,#0x68]
000032  f64f71fc          MOV      r1,#0xfffc
000036  4288              CMP      r0,r1
000038  d911              BLS      |L2.94|
                  |L2.58|
;;;736        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
00003a  bf00              NOP      
00003c  bf00              NOP      
;;;737                                           pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;738        TCP_STATS_INC(tcp.memerr);
00003e  4860              LDR      r0,|L2.448|
000040  f8b0009c          LDRH     r0,[r0,#0x9c]
000044  1c40              ADDS     r0,r0,#1
000046  b281              UXTH     r1,r0
000048  485d              LDR      r0,|L2.448|
00004a  f8a0109c          STRH     r1,[r0,#0x9c]
;;;739        pcb->flags |= TF_NAGLEMEMERR;
00004e  7fa0              LDRB     r0,[r4,#0x1e]
000050  f0400080          ORR      r0,r0,#0x80
000054  77a0              STRB     r0,[r4,#0x1e]
;;;740        return ERR_MEM;
000056  f04f30ff          MOV      r0,#0xffffffff
                  |L2.90|
;;;741      }
;;;742    
;;;743      if (flags & TCP_SYN) {
;;;744        optflags = TF_SEG_OPTS_MSS;
;;;745      }
;;;746    #if LWIP_TCP_TIMESTAMPS
;;;747      if ((pcb->flags & TF_TIMESTAMP)) {
;;;748        optflags |= TF_SEG_OPTS_TS;
;;;749      }
;;;750    #endif /* LWIP_TCP_TIMESTAMPS */
;;;751      optlen = LWIP_TCP_OPT_LENGTH(optflags);
;;;752    
;;;753      /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
;;;754       * We need one available snd_buf byte to do that.
;;;755       * This means we can't send FIN while snd_buf==0. A better fix would be to
;;;756       * not include SYN and FIN sequence numbers in the snd_buf count. */
;;;757      if (pcb->snd_buf == 0) {
;;;758        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
;;;759        TCP_STATS_INC(tcp.memerr);
;;;760        return ERR_MEM;
;;;761      }
;;;762    
;;;763      /* Allocate pbuf with room for TCP header + options */
;;;764      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;765        pcb->flags |= TF_NAGLEMEMERR;
;;;766        TCP_STATS_INC(tcp.memerr);
;;;767        return ERR_MEM;
;;;768      }
;;;769      LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
;;;770                  (p->len >= optlen));
;;;771    
;;;772      /* Allocate memory for tcp_seg, and fill in fields. */
;;;773      if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
;;;774        pcb->flags |= TF_NAGLEMEMERR;
;;;775        TCP_STATS_INC(tcp.memerr);
;;;776        return ERR_MEM;
;;;777      }
;;;778      LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
;;;779      LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
;;;780    
;;;781      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE,
;;;782                  ("tcp_enqueue_flags: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
;;;783                   ntohl(seg->tcphdr->seqno),
;;;784                   ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
;;;785                   (u16_t)flags));
;;;786    
;;;787      /* Now append seg to pcb->unsent queue */
;;;788      if (pcb->unsent == NULL) {
;;;789        pcb->unsent = seg;
;;;790      } else {
;;;791        struct tcp_seg *useg;
;;;792        for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
;;;793        useg->next = seg;
;;;794      }
;;;795    #if TCP_OVERSIZE
;;;796      /* The new unsent tail has no space */
;;;797      pcb->unsent_oversize = 0;
;;;798    #endif /* TCP_OVERSIZE */
;;;799    
;;;800      /* SYN and FIN bump the sequence number */
;;;801      if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
;;;802        pcb->snd_lbb++;
;;;803        /* optlen does not influence snd_buf */
;;;804        pcb->snd_buf--;
;;;805      }
;;;806      if (flags & TCP_FIN) {
;;;807        pcb->flags |= TF_FIN;
;;;808      }
;;;809    
;;;810      /* update number of segments on the queues */
;;;811      pcb->snd_queuelen += pbuf_clen(seg->p);
;;;812      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
;;;813      if (pcb->snd_queuelen != 0) {
;;;814        LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
;;;815          pcb->unacked != NULL || pcb->unsent != NULL);
;;;816      }
;;;817    
;;;818      return ERR_OK;
;;;819    }
00005a  e8bd83f8          POP      {r3-r9,pc}
                  |L2.94|
00005e  f0050002          AND      r0,r5,#2              ;743
000062  b108              CBZ      r0,|L2.104|
000064  f04f0801          MOV      r8,#1                 ;744
                  |L2.104|
000068  f0080001          AND      r0,r8,#1              ;751
00006c  b108              CBZ      r0,|L2.114|
00006e  2004              MOVS     r0,#4                 ;751
000070  e000              B        |L2.116|
                  |L2.114|
000072  2000              MOVS     r0,#0                 ;751
                  |L2.116|
000074  f0080102          AND      r1,r8,#2              ;751
000078  b109              CBZ      r1,|L2.126|
00007a  210c              MOVS     r1,#0xc               ;751
00007c  e000              B        |L2.128|
                  |L2.126|
00007e  2100              MOVS     r1,#0                 ;751
                  |L2.128|
000080  eb000901          ADD      r9,r0,r1              ;751
000084  f8b40066          LDRH     r0,[r4,#0x66]         ;757
000088  b960              CBNZ     r0,|L2.164|
00008a  bf00              NOP                            ;758
00008c  bf00              NOP                            ;758
00008e  484c              LDR      r0,|L2.448|
000090  f8b0009c          LDRH     r0,[r0,#0x9c]         ;759
000094  1c40              ADDS     r0,r0,#1              ;759
000096  b281              UXTH     r1,r0                 ;759
000098  4849              LDR      r0,|L2.448|
00009a  f8a0109c          STRH     r1,[r0,#0x9c]         ;759
00009e  f04f30ff          MOV      r0,#0xffffffff        ;760
0000a2  e7da              B        |L2.90|
                  |L2.164|
0000a4  2200              MOVS     r2,#0                 ;764
0000a6  4649              MOV      r1,r9                 ;764
0000a8  4610              MOV      r0,r2                 ;764
0000aa  f7fffffe          BL       pbuf_alloc
0000ae  1e07              SUBS     r7,r0,#0              ;764
0000b0  d10d              BNE      |L2.206|
0000b2  7fa0              LDRB     r0,[r4,#0x1e]         ;765
0000b4  f0400080          ORR      r0,r0,#0x80           ;765
0000b8  77a0              STRB     r0,[r4,#0x1e]         ;765
0000ba  4841              LDR      r0,|L2.448|
0000bc  f8b0009c          LDRH     r0,[r0,#0x9c]         ;766
0000c0  1c40              ADDS     r0,r0,#1              ;766
0000c2  b281              UXTH     r1,r0                 ;766
0000c4  483e              LDR      r0,|L2.448|
0000c6  f8a0109c          STRH     r1,[r0,#0x9c]         ;766
0000ca  1e78              SUBS     r0,r7,#1              ;767
0000cc  e7c5              B        |L2.90|
                  |L2.206|
0000ce  bf00              NOP                            ;769
0000d0  8978              LDRH     r0,[r7,#0xa]          ;769
0000d2  4548              CMP      r0,r9                 ;769
0000d4  da04              BGE      |L2.224|
0000d6  a03b              ADR      r0,|L2.452|
0000d8  f7fffffe          BL       __2printf
0000dc  bf00              NOP                            ;769
                  |L2.222|
0000de  e7fe              B        |L2.222|
                  |L2.224|
0000e0  bf00              NOP                            ;769
0000e2  f8cd8000          STR      r8,[sp,#0]            ;773
0000e6  462a              MOV      r2,r5                 ;773
0000e8  4639              MOV      r1,r7                 ;773
0000ea  4620              MOV      r0,r4                 ;773
0000ec  6de3              LDR      r3,[r4,#0x5c]         ;773
0000ee  f7fffffe          BL       tcp_create_segment
0000f2  1e06              SUBS     r6,r0,#0              ;773
0000f4  d10d              BNE      |L2.274|
0000f6  7fa0              LDRB     r0,[r4,#0x1e]         ;774
0000f8  f0400080          ORR      r0,r0,#0x80           ;774
0000fc  77a0              STRB     r0,[r4,#0x1e]         ;774
0000fe  4830              LDR      r0,|L2.448|
000100  f8b0009c          LDRH     r0,[r0,#0x9c]         ;775
000104  1c40              ADDS     r0,r0,#1              ;775
000106  b281              UXTH     r1,r0                 ;775
000108  482d              LDR      r0,|L2.448|
00010a  f8a0109c          STRH     r1,[r0,#0x9c]         ;775
00010e  1e70              SUBS     r0,r6,#1              ;776
000110  e7a3              B        |L2.90|
                  |L2.274|
000112  bf00              NOP                            ;778
000114  7c30              LDRB     r0,[r6,#0x10]         ;778
000116  f0000003          AND      r0,r0,#3              ;778
00011a  b120              CBZ      r0,|L2.294|
00011c  a038              ADR      r0,|L2.512|
00011e  f7fffffe          BL       __2printf
000122  bf00              NOP                            ;778
                  |L2.292|
000124  e7fe              B        |L2.292|
                  |L2.294|
000126  bf00              NOP                            ;778
000128  bf00              NOP                            ;779
00012a  8930              LDRH     r0,[r6,#8]            ;779
00012c  b120              CBZ      r0,|L2.312|
00012e  a03a              ADR      r0,|L2.536|
000130  f7fffffe          BL       __2printf
000134  bf00              NOP                            ;779
                  |L2.310|
000136  e7fe              B        |L2.310|
                  |L2.312|
000138  bf00              NOP                            ;779
00013a  bf00              NOP                            ;781
00013c  bf00              NOP                            ;781
00013e  6ee0              LDR      r0,[r4,#0x6c]         ;788
000140  b908              CBNZ     r0,|L2.326|
000142  66e6              STR      r6,[r4,#0x6c]         ;789
000144  e007              B        |L2.342|
                  |L2.326|
000146  6ee0              LDR      r0,[r4,#0x6c]         ;792
000148  e000              B        |L2.332|
                  |L2.330|
00014a  6800              LDR      r0,[r0,#0]            ;792
                  |L2.332|
00014c  6801              LDR      r1,[r0,#0]            ;792
00014e  2900              CMP      r1,#0                 ;792
000150  d1fb              BNE      |L2.330|
000152  6006              STR      r6,[r0,#0]            ;793
000154  bf00              NOP                            ;794
                  |L2.342|
000156  2000              MOVS     r0,#0                 ;797
000158  f8a4006a          STRH     r0,[r4,#0x6a]         ;797
00015c  f0050002          AND      r0,r5,#2              ;801
000160  b910              CBNZ     r0,|L2.360|
000162  f0050001          AND      r0,r5,#1              ;801
000166  b138              CBZ      r0,|L2.376|
                  |L2.360|
000168  6de0              LDR      r0,[r4,#0x5c]         ;802
00016a  1c40              ADDS     r0,r0,#1              ;802
00016c  65e0              STR      r0,[r4,#0x5c]         ;802
00016e  f8b40066          LDRH     r0,[r4,#0x66]         ;804
000172  1e40              SUBS     r0,r0,#1              ;804
000174  f8a40066          STRH     r0,[r4,#0x66]         ;804
                  |L2.376|
000178  f0050001          AND      r0,r5,#1              ;806
00017c  b118              CBZ      r0,|L2.390|
00017e  7fa0              LDRB     r0,[r4,#0x1e]         ;807
000180  f0400020          ORR      r0,r0,#0x20           ;807
000184  77a0              STRB     r0,[r4,#0x1e]         ;807
                  |L2.390|
000186  6870              LDR      r0,[r6,#4]            ;811
000188  f7fffffe          BL       pbuf_clen
00018c  f8b41068          LDRH     r1,[r4,#0x68]         ;811
000190  4408              ADD      r0,r0,r1              ;811
000192  f8a40068          STRH     r0,[r4,#0x68]         ;811
000196  bf00              NOP                            ;812
000198  bf00              NOP                            ;812
00019a  f8b40068          LDRH     r0,[r4,#0x68]         ;813
00019e  b150              CBZ      r0,|L2.438|
0001a0  bf00              NOP                            ;814
0001a2  6f20              LDR      r0,[r4,#0x70]         ;814
0001a4  b930              CBNZ     r0,|L2.436|
0001a6  6ee0              LDR      r0,[r4,#0x6c]         ;814
0001a8  b920              CBNZ     r0,|L2.436|
0001aa  a026              ADR      r0,|L2.580|
0001ac  f7fffffe          BL       __2printf
0001b0  bf00              NOP                            ;814
                  |L2.434|
0001b2  e7fe              B        |L2.434|
                  |L2.436|
0001b4  bf00              NOP                            ;814
                  |L2.438|
0001b6  2000              MOVS     r0,#0                 ;818
0001b8  e74f              B        |L2.90|
;;;820    
                          ENDP

0001ba  0000              DCW      0x0000
                  |L2.444|
                          DCD      ||.conststring||
                  |L2.448|
                          DCD      lwip_stats
                  |L2.452|
0001c4  7463705f          DCB      "tcp_enqueue_flags: check that first pbuf can hold optle"
0001c8  656e7175
0001cc  6575655f
0001d0  666c6167
0001d4  733a2063
0001d8  6865636b
0001dc  20746861
0001e0  74206669
0001e4  72737420
0001e8  70627566
0001ec  2063616e
0001f0  20686f6c
0001f4  64206f70
0001f8  746c65  
0001fb  6e00              DCB      "n",0
0001fd  00                DCB      0
0001fe  00                DCB      0
0001ff  00                DCB      0
                  |L2.512|
000200  7365672d          DCB      "seg->tcphdr not aligned",0
000204  3e746370
000208  68647220
00020c  6e6f7420
000210  616c6967
000214  6e656400
                  |L2.536|
000218  7463705f          DCB      "tcp_enqueue_flags: invalid segment length",0
00021c  656e7175
000220  6575655f
000224  666c6167
000228  733a2069
00022c  6e76616c
000230  69642073
000234  65676d65
000238  6e74206c
00023c  656e6774
000240  6800    
000242  00                DCB      0
000243  00                DCB      0
                  |L2.580|
000244  7463705f          DCB      "tcp_enqueue_flags: invalid queue length",0
000248  656e7175
00024c  6575655f
000250  666c6167
000254  733a2069
000258  6e76616c
00025c  69642071
000260  75657565
000264  206c656e
000268  67746800

                          AREA ||i.tcp_keepalive||, CODE, READONLY, ALIGN=2

                  tcp_keepalive PROC
;;;1363   void
;;;1364   tcp_keepalive(struct tcp_pcb *pcb)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;1365   {
000004  4604              MOV      r4,r0
;;;1366     struct pbuf *p;
;;;1367     struct tcp_hdr *tcphdr;
;;;1368   
;;;1369     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
000006  bf00              NOP      
000008  bf00              NOP      
;;;1370                             ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1371                             ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1372   
;;;1373     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;1374                             tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1375      
;;;1376     p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
00000e  6d21              LDR      r1,[r4,#0x50]
000010  1e48              SUBS     r0,r1,#1
000012  f7fffffe          BL       lwip_htonl
000016  4607              MOV      r7,r0
000018  463b              MOV      r3,r7
00001a  2200              MOVS     r2,#0
00001c  4611              MOV      r1,r2
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       tcp_output_alloc_header
000024  4605              MOV      r5,r0
;;;1377     if(p == NULL) {
000026  b91d              CBNZ     r5,|L3.48|
;;;1378       LWIP_DEBUGF(TCP_DEBUG, 
000028  bf00              NOP      
00002a  bf00              NOP      
                  |L3.44|
;;;1379                   ("tcp_keepalive: could not allocate memory for pbuf\n"));
;;;1380       return;
;;;1381     }
;;;1382     tcphdr = (struct tcp_hdr *)p->payload;
;;;1383   
;;;1384   #if CHECKSUM_GEN_TCP
;;;1385     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
;;;1386                                         IP_PROTO_TCP, p->tot_len);
;;;1387   #endif
;;;1388     TCP_STATS_INC(tcp.xmit);
;;;1389   
;;;1390     /* Send output to IP */
;;;1391   #if LWIP_NETIF_HWADDRHINT
;;;1392     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1393       &(pcb->addr_hint));
;;;1394   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1395     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
;;;1396   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1397   
;;;1398     pbuf_free(p);
;;;1399   
;;;1400     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
;;;1401                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1402   }
00002c  e8bd81fc          POP      {r2-r8,pc}
                  |L3.48|
000030  686e              LDR      r6,[r5,#4]            ;1382
000032  8928              LDRH     r0,[r5,#8]            ;1385
000034  2306              MOVS     r3,#6                 ;1385
000036  1d22              ADDS     r2,r4,#4              ;1385
000038  4621              MOV      r1,r4                 ;1385
00003a  9000              STR      r0,[sp,#0]            ;1385
00003c  4628              MOV      r0,r5                 ;1385
00003e  f7fffffe          BL       inet_chksum_pseudo
000042  8230              STRH     r0,[r6,#0x10]         ;1385
000044  480b              LDR      r0,|L3.116|
000046  f8b00090          LDRH     r0,[r0,#0x90]         ;1388  ; lwip_stats
00004a  1c40              ADDS     r0,r0,#1              ;1388
00004c  4909              LDR      r1,|L3.116|
00004e  f8a10090          STRH     r0,[r1,#0x90]         ;1388
000052  2006              MOVS     r0,#6                 ;1395
000054  2100              MOVS     r1,#0                 ;1395
000056  e9cd1000          STRD     r1,r0,[sp,#0]         ;1395
00005a  7aa3              LDRB     r3,[r4,#0xa]          ;1395
00005c  1d22              ADDS     r2,r4,#4              ;1395
00005e  4621              MOV      r1,r4                 ;1395
000060  4628              MOV      r0,r5                 ;1395
000062  f7fffffe          BL       ip_output
000066  4628              MOV      r0,r5                 ;1398
000068  f7fffffe          BL       pbuf_free
00006c  bf00              NOP                            ;1400
00006e  bf00              NOP                            ;1400
000070  bf00              NOP      
000072  e7db              B        |L3.44|
;;;1403   
                          ENDP

                  |L3.116|
                          DCD      lwip_stats

                          AREA ||i.tcp_output||, CODE, READONLY, ALIGN=2

                  tcp_output PROC
;;;897    err_t
;;;898    tcp_output(struct tcp_pcb *pcb)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;899    {
000004  4604              MOV      r4,r0
;;;900      struct tcp_seg *seg, *useg;
;;;901      u32_t wnd, snd_nxt;
;;;902    #if TCP_CWND_DEBUG
;;;903      s16_t i = 0;
;;;904    #endif /* TCP_CWND_DEBUG */
;;;905    
;;;906      /* pcb->state LISTEN not allowed here */
;;;907      LWIP_ASSERT("don't call tcp_output for listen-pcbs",
000006  bf00              NOP      
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  2801              CMP      r0,#1
00000c  d104              BNE      |L4.24|
00000e  a073              ADR      r0,|L4.476|
000010  f7fffffe          BL       __2printf
000014  bf00              NOP      
                  |L4.22|
000016  e7fe              B        |L4.22|
                  |L4.24|
000018  bf00              NOP      
;;;908        pcb->state != LISTEN);
;;;909    
;;;910      /* First, check if we are invoked by the TCP input processing
;;;911         code. If so, we do not output anything. Instead, we rely on the
;;;912         input processing code to call us when input processing is done
;;;913         with. */
;;;914      if (tcp_input_pcb == pcb) {
00001a  487a              LDR      r0,|L4.516|
00001c  6800              LDR      r0,[r0,#0]  ; tcp_input_pcb
00001e  42a0              CMP      r0,r4
000020  d102              BNE      |L4.40|
;;;915        return ERR_OK;
000022  2000              MOVS     r0,#0
                  |L4.36|
;;;916      }
;;;917    
;;;918      wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
;;;919    
;;;920      seg = pcb->unsent;
;;;921    
;;;922      /* If the TF_ACK_NOW flag is set and no data will be sent (either
;;;923       * because the ->unsent queue is empty or because the window does
;;;924       * not allow it), construct an empty ACK segment and send it.
;;;925       *
;;;926       * If data is to be sent, we will just piggyback the ACK (see below).
;;;927       */
;;;928      if (pcb->flags & TF_ACK_NOW &&
;;;929         (seg == NULL ||
;;;930          ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
;;;931         return tcp_send_empty_ack(pcb);
;;;932      }
;;;933    
;;;934      /* useg should point to last segment on unacked queue */
;;;935      useg = pcb->unacked;
;;;936      if (useg != NULL) {
;;;937        for (; useg->next != NULL; useg = useg->next);
;;;938      }
;;;939    
;;;940    #if TCP_OUTPUT_DEBUG
;;;941      if (seg == NULL) {
;;;942        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n",
;;;943                                       (void*)pcb->unsent));
;;;944      }
;;;945    #endif /* TCP_OUTPUT_DEBUG */
;;;946    #if TCP_CWND_DEBUG
;;;947      if (seg == NULL) {
;;;948        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F
;;;949                                     ", cwnd %"U16_F", wnd %"U32_F
;;;950                                     ", seg == NULL, ack %"U32_F"\n",
;;;951                                     pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));
;;;952      } else {
;;;953        LWIP_DEBUGF(TCP_CWND_DEBUG, 
;;;954                    ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F
;;;955                     ", effwnd %"U32_F", seq %"U32_F", ack %"U32_F"\n",
;;;956                     pcb->snd_wnd, pcb->cwnd, wnd,
;;;957                     ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
;;;958                     ntohl(seg->tcphdr->seqno), pcb->lastack));
;;;959      }
;;;960    #endif /* TCP_CWND_DEBUG */
;;;961      /* data available and window allows it to be sent? */
;;;962      while (seg != NULL &&
;;;963             ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
;;;964        LWIP_ASSERT("RST not expected here!", 
;;;965                    (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);
;;;966        /* Stop sending if the nagle algorithm would prevent it
;;;967         * Don't stop:
;;;968         * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
;;;969         * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
;;;970         *   either seg->next != NULL or pcb->unacked == NULL;
;;;971         *   RST is no sent using tcp_write/tcp_output.
;;;972         */
;;;973        if((tcp_do_output_nagle(pcb) == 0) &&
;;;974          ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
;;;975          break;
;;;976        }
;;;977    #if TCP_CWND_DEBUG
;;;978        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F", effwnd %"U32_F", seq %"U32_F", ack %"U32_F", i %"S16_F"\n",
;;;979                                pcb->snd_wnd, pcb->cwnd, wnd,
;;;980                                ntohl(seg->tcphdr->seqno) + seg->len -
;;;981                                pcb->lastack,
;;;982                                ntohl(seg->tcphdr->seqno), pcb->lastack, i));
;;;983        ++i;
;;;984    #endif /* TCP_CWND_DEBUG */
;;;985    
;;;986        pcb->unsent = seg->next;
;;;987    
;;;988        if (pcb->state != SYN_SENT) {
;;;989          TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
;;;990          pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
;;;991        }
;;;992    
;;;993        tcp_output_segment(seg, pcb);
;;;994        snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
;;;995        if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
;;;996          pcb->snd_nxt = snd_nxt;
;;;997        }
;;;998        /* put segment on unacknowledged list if length > 0 */
;;;999        if (TCP_TCPLEN(seg) > 0) {
;;;1000         seg->next = NULL;
;;;1001         /* unacked list is empty? */
;;;1002         if (pcb->unacked == NULL) {
;;;1003           pcb->unacked = seg;
;;;1004           useg = seg;
;;;1005         /* unacked list is not empty? */
;;;1006         } else {
;;;1007           /* In the case of fast retransmit, the packet should not go to the tail
;;;1008            * of the unacked queue, but rather somewhere before it. We need to check for
;;;1009            * this case. -STJ Jul 27, 2004 */
;;;1010           if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
;;;1011             /* add segment to before tail of unacked list, keeping the list sorted */
;;;1012             struct tcp_seg **cur_seg = &(pcb->unacked);
;;;1013             while (*cur_seg &&
;;;1014               TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1015                 cur_seg = &((*cur_seg)->next );
;;;1016             }
;;;1017             seg->next = (*cur_seg);
;;;1018             (*cur_seg) = seg;
;;;1019           } else {
;;;1020             /* add segment to tail of unacked list */
;;;1021             useg->next = seg;
;;;1022             useg = useg->next;
;;;1023           }
;;;1024         }
;;;1025       /* do not queue empty segments on the unacked list */
;;;1026       } else {
;;;1027         tcp_seg_free(seg);
;;;1028       }
;;;1029       seg = pcb->unsent;
;;;1030     }
;;;1031   #if TCP_OVERSIZE
;;;1032     if (pcb->unsent == NULL) {
;;;1033       /* last unsent has been removed, reset unsent_oversize */
;;;1034       pcb->unsent_oversize = 0;
;;;1035     }
;;;1036   #endif /* TCP_OVERSIZE */
;;;1037   
;;;1038     pcb->flags &= ~TF_NAGLEMEMERR;
;;;1039     return ERR_OK;
;;;1040   }
000024  e8bd87f0          POP      {r4-r10,pc}
                  |L4.40|
000028  f8b40060          LDRH     r0,[r4,#0x60]         ;918
00002c  f8b4104c          LDRH     r1,[r4,#0x4c]         ;918
000030  4288              CMP      r0,r1                 ;918
000032  da02              BGE      |L4.58|
000034  f8b40060          LDRH     r0,[r4,#0x60]         ;918
000038  e001              B        |L4.62|
                  |L4.58|
00003a  f8b4004c          LDRH     r0,[r4,#0x4c]         ;918
                  |L4.62|
00003e  4681              MOV      r9,r0                 ;918
000040  6ee5              LDR      r5,[r4,#0x6c]         ;920
000042  7fa0              LDRB     r0,[r4,#0x1e]         ;928
000044  f0000002          AND      r0,r0,#2              ;928
000048  b170              CBZ      r0,|L4.104|
00004a  b14d              CBZ      r5,|L4.96|
00004c  6929              LDR      r1,[r5,#0x10]         ;930
00004e  6848              LDR      r0,[r1,#4]            ;930
000050  f7fffffe          BL       lwip_ntohl
000054  6ca1              LDR      r1,[r4,#0x48]         ;930
000056  1a40              SUBS     r0,r0,r1              ;930
000058  8929              LDRH     r1,[r5,#8]            ;930
00005a  4408              ADD      r0,r0,r1              ;930
00005c  4548              CMP      r0,r9                 ;930
00005e  d903              BLS      |L4.104|
                  |L4.96|
000060  4620              MOV      r0,r4                 ;931
000062  f7fffffe          BL       tcp_send_empty_ack
000066  e7dd              B        |L4.36|
                  |L4.104|
000068  6f26              LDR      r6,[r4,#0x70]         ;935
00006a  b126              CBZ      r6,|L4.118|
00006c  e000              B        |L4.112|
                  |L4.110|
00006e  6836              LDR      r6,[r6,#0]            ;937
                  |L4.112|
000070  6830              LDR      r0,[r6,#0]            ;937
000072  2800              CMP      r0,#0                 ;937
000074  d1fb              BNE      |L4.110|
                  |L4.118|
000076  e099              B        |L4.428|
                  |L4.120|
000078  bf00              NOP                            ;964
00007a  6929              LDR      r1,[r5,#0x10]         ;964
00007c  8988              LDRH     r0,[r1,#0xc]          ;964
00007e  f7fffffe          BL       lwip_ntohs
000082  f0000004          AND      r0,r0,#4              ;964
000086  b120              CBZ      r0,|L4.146|
000088  a05f              ADR      r0,|L4.520|
00008a  f7fffffe          BL       __2printf
00008e  bf00              NOP                            ;964
                  |L4.144|
000090  e7fe              B        |L4.144|
                  |L4.146|
000092  bf00              NOP                            ;964
000094  6f20              LDR      r0,[r4,#0x70]         ;973
000096  b1a0              CBZ      r0,|L4.194|
000098  7fa0              LDRB     r0,[r4,#0x1e]         ;973
00009a  f0000044          AND      r0,r0,#0x44           ;973
00009e  b980              CBNZ     r0,|L4.194|
0000a0  6ee0              LDR      r0,[r4,#0x6c]         ;973
0000a2  b138              CBZ      r0,|L4.180|
0000a4  6ee0              LDR      r0,[r4,#0x6c]         ;973
0000a6  6800              LDR      r0,[r0,#0]            ;973
0000a8  b958              CBNZ     r0,|L4.194|
0000aa  6ee0              LDR      r0,[r4,#0x6c]         ;973
0000ac  8900              LDRH     r0,[r0,#8]            ;973
0000ae  8ee1              LDRH     r1,[r4,#0x36]         ;973
0000b0  4288              CMP      r0,r1                 ;973
0000b2  da06              BGE      |L4.194|
                  |L4.180|
0000b4  f8b40066          LDRH     r0,[r4,#0x66]         ;973
0000b8  b118              CBZ      r0,|L4.194|
0000ba  f8b40068          LDRH     r0,[r4,#0x68]         ;973
0000be  2810              CMP      r0,#0x10              ;973
0000c0  db01              BLT      |L4.198|
                  |L4.194|
0000c2  2001              MOVS     r0,#1                 ;973
0000c4  e000              B        |L4.200|
                  |L4.198|
0000c6  2000              MOVS     r0,#0                 ;973
                  |L4.200|
0000c8  b920              CBNZ     r0,|L4.212|
0000ca  7fa0              LDRB     r0,[r4,#0x1e]         ;974
0000cc  f00000a0          AND      r0,r0,#0xa0           ;974
0000d0  b900              CBNZ     r0,|L4.212|
0000d2  e077              B        |L4.452|
                  |L4.212|
0000d4  6828              LDR      r0,[r5,#0]            ;986
0000d6  66e0              STR      r0,[r4,#0x6c]         ;986
0000d8  7e20              LDRB     r0,[r4,#0x18]         ;988
0000da  2802              CMP      r0,#2                 ;988
0000dc  d00b              BEQ      |L4.246|
0000de  2010              MOVS     r0,#0x10              ;989
0000e0  f7fffffe          BL       lwip_htons
0000e4  6929              LDR      r1,[r5,#0x10]         ;989
0000e6  8989              LDRH     r1,[r1,#0xc]          ;989
0000e8  4308              ORRS     r0,r0,r1              ;989
0000ea  6929              LDR      r1,[r5,#0x10]         ;989
0000ec  8188              STRH     r0,[r1,#0xc]          ;989
0000ee  7fa0              LDRB     r0,[r4,#0x1e]         ;990
0000f0  f0200003          BIC      r0,r0,#3              ;990
0000f4  77a0              STRB     r0,[r4,#0x1e]         ;990
                  |L4.246|
0000f6  4621              MOV      r1,r4                 ;993
0000f8  4628              MOV      r0,r5                 ;993
0000fa  f7fffffe          BL       tcp_output_segment
0000fe  6929              LDR      r1,[r5,#0x10]         ;994
000100  6848              LDR      r0,[r1,#4]            ;994
000102  f7fffffe          BL       lwip_ntohl
000106  4607              MOV      r7,r0                 ;994
000108  6929              LDR      r1,[r5,#0x10]         ;994
00010a  8988              LDRH     r0,[r1,#0xc]          ;994
00010c  f7fffffe          BL       lwip_ntohs
000110  f0000003          AND      r0,r0,#3              ;994
000114  b108              CBZ      r0,|L4.282|
000116  2001              MOVS     r0,#1                 ;994
000118  e000              B        |L4.284|
                  |L4.282|
00011a  2000              MOVS     r0,#0                 ;994
                  |L4.284|
00011c  8929              LDRH     r1,[r5,#8]            ;994
00011e  4408              ADD      r0,r0,r1              ;994
000120  eb070800          ADD      r8,r7,r0              ;994
000124  6d20              LDR      r0,[r4,#0x50]         ;995
000126  ebb00008          SUBS     r0,r0,r8              ;995
00012a  d501              BPL      |L4.304|
00012c  f8c48050          STR      r8,[r4,#0x50]         ;996
                  |L4.304|
000130  6929              LDR      r1,[r5,#0x10]         ;999
000132  8988              LDRH     r0,[r1,#0xc]          ;999
000134  f7fffffe          BL       lwip_ntohs
000138  f0000003          AND      r0,r0,#3              ;999
00013c  b108              CBZ      r0,|L4.322|
00013e  2001              MOVS     r0,#1                 ;999
000140  e000              B        |L4.324|
                  |L4.322|
000142  2000              MOVS     r0,#0                 ;999
                  |L4.324|
000144  8929              LDRH     r1,[r5,#8]            ;999
000146  4408              ADD      r0,r0,r1              ;999
000148  2800              CMP      r0,#0                 ;999
00014a  dd2b              BLE      |L4.420|
00014c  2000              MOVS     r0,#0                 ;1000
00014e  6028              STR      r0,[r5,#0]            ;1000
000150  6f20              LDR      r0,[r4,#0x70]         ;1002
000152  b910              CBNZ     r0,|L4.346|
000154  6725              STR      r5,[r4,#0x70]         ;1003
000156  462e              MOV      r6,r5                 ;1004
000158  e027              B        |L4.426|
                  |L4.346|
00015a  6929              LDR      r1,[r5,#0x10]         ;1010
00015c  6848              LDR      r0,[r1,#4]            ;1010
00015e  f7fffffe          BL       lwip_ntohl
000162  4607              MOV      r7,r0                 ;1010
000164  6931              LDR      r1,[r6,#0x10]         ;1010
000166  6848              LDR      r0,[r1,#4]            ;1010
000168  f7fffffe          BL       lwip_ntohl
00016c  1a38              SUBS     r0,r7,r0              ;1010
00016e  d516              BPL      |L4.414|
000170  f1040770          ADD      r7,r4,#0x70           ;1012
000174  e000              B        |L4.376|
                  |L4.374|
000176  683f              LDR      r7,[r7,#0]            ;1015
                  |L4.376|
000178  6838              LDR      r0,[r7,#0]            ;1013
00017a  b160              CBZ      r0,|L4.406|
00017c  6839              LDR      r1,[r7,#0]            ;1014
00017e  6909              LDR      r1,[r1,#0x10]         ;1014
000180  6848              LDR      r0,[r1,#4]            ;1014
000182  f7fffffe          BL       lwip_ntohl
000186  4682              MOV      r10,r0                ;1014
000188  6929              LDR      r1,[r5,#0x10]         ;1014
00018a  6848              LDR      r0,[r1,#4]            ;1014
00018c  f7fffffe          BL       lwip_ntohl
000190  ebba0000          SUBS     r0,r10,r0             ;1014
000194  d4ef              BMI      |L4.374|
                  |L4.406|
000196  6838              LDR      r0,[r7,#0]            ;1017
000198  6028              STR      r0,[r5,#0]            ;1017
00019a  603d              STR      r5,[r7,#0]            ;1018
00019c  e005              B        |L4.426|
                  |L4.414|
00019e  6035              STR      r5,[r6,#0]            ;1021
0001a0  6836              LDR      r6,[r6,#0]            ;1022
0001a2  e002              B        |L4.426|
                  |L4.420|
0001a4  4628              MOV      r0,r5                 ;1027
0001a6  f7fffffe          BL       tcp_seg_free
                  |L4.426|
0001aa  6ee5              LDR      r5,[r4,#0x6c]         ;1029
                  |L4.428|
0001ac  b155              CBZ      r5,|L4.452|
0001ae  6929              LDR      r1,[r5,#0x10]         ;963
0001b0  6848              LDR      r0,[r1,#4]            ;963
0001b2  f7fffffe          BL       lwip_ntohl
0001b6  6ca1              LDR      r1,[r4,#0x48]         ;963
0001b8  1a40              SUBS     r0,r0,r1              ;963
0001ba  8929              LDRH     r1,[r5,#8]            ;963
0001bc  4408              ADD      r0,r0,r1              ;963
0001be  4548              CMP      r0,r9                 ;963
0001c0  f67faf5a          BLS      |L4.120|
                  |L4.452|
0001c4  bf00              NOP                            ;975
0001c6  6ee0              LDR      r0,[r4,#0x6c]         ;1032
0001c8  b910              CBNZ     r0,|L4.464|
0001ca  2000              MOVS     r0,#0                 ;1034
0001cc  f8a4006a          STRH     r0,[r4,#0x6a]         ;1034
                  |L4.464|
0001d0  7fa0              LDRB     r0,[r4,#0x1e]         ;1038
0001d2  f0200080          BIC      r0,r0,#0x80           ;1038
0001d6  77a0              STRB     r0,[r4,#0x1e]         ;1038
0001d8  2000              MOVS     r0,#0                 ;1039
0001da  e723              B        |L4.36|
;;;1041   
                          ENDP

                  |L4.476|
0001dc  646f6e27          DCB      "don't call tcp_output for listen-pcbs",0
0001e0  74206361
0001e4  6c6c2074
0001e8  63705f6f
0001ec  75747075
0001f0  7420666f
0001f4  72206c69
0001f8  7374656e
0001fc  2d706362
000200  7300    
000202  00                DCB      0
000203  00                DCB      0
                  |L4.516|
                          DCD      tcp_input_pcb
                  |L4.520|
000208  52535420          DCB      "RST not expected here!",0
00020c  6e6f7420
000210  65787065
000214  63746564
000218  20686572
00021c  652100  
00021f  00                DCB      0

                          AREA ||i.tcp_output_alloc_header||, CODE, READONLY, ALIGN=2

                  tcp_output_alloc_header PROC
;;;93     static struct pbuf *
;;;94     tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;95                           u32_t seqno_be /* already in network byte order */)
;;;96     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;97       struct tcp_hdr *tcphdr;
;;;98       struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
00000c  f1060014          ADD      r0,r6,#0x14
000010  4440              ADD      r0,r0,r8
000012  b281              UXTH     r1,r0
000014  2200              MOVS     r2,#0
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       pbuf_alloc
00001c  4607              MOV      r7,r0
;;;99       if (p != NULL) {
00001e  2f00              CMP      r7,#0
000020  d032              BEQ      |L5.136|
;;;100        LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
000022  bf00              NOP      
000024  8979              LDRH     r1,[r7,#0xa]
000026  f1060014          ADD      r0,r6,#0x14
00002a  4281              CMP      r1,r0
00002c  da04              BGE      |L5.56|
00002e  a018              ADR      r0,|L5.144|
000030  f7fffffe          BL       __2printf
000034  bf00              NOP      
                  |L5.54|
000036  e7fe              B        |L5.54|
                  |L5.56|
000038  bf00              NOP      
;;;101                     (p->len >= TCP_HLEN + optlen));
;;;102        tcphdr = (struct tcp_hdr *)p->payload;
00003a  687c              LDR      r4,[r7,#4]
;;;103        tcphdr->src = htons(pcb->local_port);
00003c  8b68              LDRH     r0,[r5,#0x1a]
00003e  f7fffffe          BL       lwip_htons
000042  8020              STRH     r0,[r4,#0]
;;;104        tcphdr->dest = htons(pcb->remote_port);
000044  8ba8              LDRH     r0,[r5,#0x1c]
000046  f7fffffe          BL       lwip_htons
00004a  8060              STRH     r0,[r4,#2]
;;;105        tcphdr->seqno = seqno_be;
00004c  f8c49004          STR      r9,[r4,#4]
;;;106        tcphdr->ackno = htonl(pcb->rcv_nxt);
000050  6aa8              LDR      r0,[r5,#0x28]
000052  f7fffffe          BL       lwip_htonl
000056  60a0              STR      r0,[r4,#8]
;;;107        TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
000058  46b2              MOV      r10,r6
00005a  17f1              ASRS     r1,r6,#31
00005c  eb067191          ADD      r1,r6,r1,LSR #30
000060  1089              ASRS     r1,r1,#2
000062  1d49              ADDS     r1,r1,#5
000064  2210              MOVS     r2,#0x10
000066  ea423101          ORR      r1,r2,r1,LSL #12
00006a  b288              UXTH     r0,r1
00006c  f7fffffe          BL       lwip_htons
000070  81a0              STRH     r0,[r4,#0xc]
;;;108        tcphdr->wnd = htons(pcb->rcv_ann_wnd);
000072  8de8              LDRH     r0,[r5,#0x2e]
000074  f7fffffe          BL       lwip_htons
000078  81e0              STRH     r0,[r4,#0xe]
;;;109        tcphdr->chksum = 0;
00007a  2000              MOVS     r0,#0
00007c  8220              STRH     r0,[r4,#0x10]
;;;110        tcphdr->urgp = 0;
00007e  8260              STRH     r0,[r4,#0x12]
;;;111    
;;;112        /* If we're sending a packet, update the announced right window edge */
;;;113        pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
000080  8de9              LDRH     r1,[r5,#0x2e]
000082  6aa8              LDR      r0,[r5,#0x28]
000084  4408              ADD      r0,r0,r1
000086  6328              STR      r0,[r5,#0x30]
                  |L5.136|
;;;114      }
;;;115      return p;
000088  4638              MOV      r0,r7
;;;116    }
00008a  e8bd87f0          POP      {r4-r10,pc}
;;;117    
                          ENDP

00008e  0000              DCW      0x0000
                  |L5.144|
000090  63686563          DCB      "check that first pbuf can hold struct tcp_hdr",0
000094  6b207468
000098  61742066
00009c  69727374
0000a0  20706275
0000a4  66206361
0000a8  6e20686f
0000ac  6c642073
0000b0  74727563
0000b4  74207463
0000b8  705f6864
0000bc  7200    
0000be  00                DCB      0
0000bf  00                DCB      0

                          AREA ||i.tcp_output_segment||, CODE, READONLY, ALIGN=2

                  tcp_output_segment PROC
;;;1048   static void
;;;1049   tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1050   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1051     u16_t len;
;;;1052     struct netif *netif;
;;;1053     u32_t *opts;
;;;1054   
;;;1055     /** @bug Exclude retransmitted segments from this count. */
;;;1056     snmp_inc_tcpoutsegs();
;;;1057   
;;;1058     /* The TCP header has already been constructed, but the ackno and
;;;1059      wnd fields remain. */
;;;1060     seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
000008  6aa0              LDR      r0,[r4,#0x28]
00000a  f7fffffe          BL       lwip_htonl
00000e  6929              LDR      r1,[r5,#0x10]
000010  6088              STR      r0,[r1,#8]
;;;1061   
;;;1062     /* advertise our receive window size in this TCP segment */
;;;1063     seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
000012  8de0              LDRH     r0,[r4,#0x2e]
000014  f7fffffe          BL       lwip_htons
000018  6929              LDR      r1,[r5,#0x10]
00001a  81c8              STRH     r0,[r1,#0xe]
;;;1064   
;;;1065     pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
00001c  8de1              LDRH     r1,[r4,#0x2e]
00001e  6aa0              LDR      r0,[r4,#0x28]
000020  4408              ADD      r0,r0,r1
000022  6320              STR      r0,[r4,#0x30]
;;;1066   
;;;1067     /* Add any requested options.  NB MSS option is only set on SYN
;;;1068        packets, so ignore it here */
;;;1069     opts = (u32_t *)(void *)(seg->tcphdr + 1);
000024  6928              LDR      r0,[r5,#0x10]
000026  f1000814          ADD      r8,r0,#0x14
;;;1070     if (seg->flags & TF_SEG_OPTS_MSS) {
00002a  7b28              LDRB     r0,[r5,#0xc]
00002c  f0000001          AND      r0,r0,#1
000030  b170              CBZ      r0,|L6.80|
;;;1071       u16_t mss;
;;;1072   #if TCP_CALCULATE_EFF_SEND_MSS
;;;1073       mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
000032  1d21              ADDS     r1,r4,#4
000034  f44f707a          MOV      r0,#0x3e8
000038  f7fffffe          BL       tcp_eff_send_mss
00003c  4681              MOV      r9,r0
;;;1074   #else /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1075       mss = TCP_MSS;
;;;1076   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1077       *opts = TCP_BUILD_MSS_OPTION(mss);
00003e  f0497001          ORR      r0,r9,#0x2040000
000042  f7fffffe          BL       lwip_htonl
000046  f8c80000          STR      r0,[r8,#0]
;;;1078       opts += 1;
00004a  f1080804          ADD      r8,r8,#4
;;;1079     }
00004e  bf00              NOP      
                  |L6.80|
;;;1080   #if LWIP_TCP_TIMESTAMPS
;;;1081     pcb->ts_lastacksent = pcb->rcv_nxt;
;;;1082   
;;;1083     if (seg->flags & TF_SEG_OPTS_TS) {
;;;1084       tcp_build_timestamp_option(pcb, opts);
;;;1085       opts += 3;
;;;1086     }
;;;1087   #endif
;;;1088   
;;;1089     /* Set retransmission timer running if it is not currently enabled 
;;;1090        This must be set before checking the route. */
;;;1091     if (pcb->rtime == -1) {
000050  f9b40034          LDRSH    r0,[r4,#0x34]
000054  1c40              ADDS     r0,r0,#1
000056  b908              CBNZ     r0,|L6.92|
;;;1092       pcb->rtime = 0;
000058  2000              MOVS     r0,#0
00005a  86a0              STRH     r0,[r4,#0x34]
                  |L6.92|
;;;1093     }
;;;1094   
;;;1095     /* If we don't have a local IP address, we get one by
;;;1096        calling ip_route(). */
;;;1097     if (ip_addr_isany(&(pcb->local_ip))) {
00005c  b10c              CBZ      r4,|L6.98|
00005e  6820              LDR      r0,[r4,#0]
000060  b940              CBNZ     r0,|L6.116|
                  |L6.98|
;;;1098       netif = ip_route(&(pcb->remote_ip));
000062  1d20              ADDS     r0,r4,#4
000064  f7fffffe          BL       ip_route
000068  4606              MOV      r6,r0
;;;1099       if (netif == NULL) {
00006a  b90e              CBNZ     r6,|L6.112|
                  |L6.108|
;;;1100         return;
;;;1101       }
;;;1102       ip_addr_copy(pcb->local_ip, netif->ip_addr);
;;;1103     }
;;;1104   
;;;1105     if (pcb->rttest == 0) {
;;;1106       pcb->rttest = tcp_ticks;
;;;1107       pcb->rtseq = ntohl(seg->tcphdr->seqno);
;;;1108   
;;;1109       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
;;;1110     }
;;;1111     LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
;;;1112             htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
;;;1113             seg->len));
;;;1114   
;;;1115     len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
;;;1116   
;;;1117     seg->p->len -= len;
;;;1118     seg->p->tot_len -= len;
;;;1119   
;;;1120     seg->p->payload = seg->tcphdr;
;;;1121   
;;;1122     seg->tcphdr->chksum = 0;
;;;1123   #if CHECKSUM_GEN_TCP
;;;1124   #if TCP_CHECKSUM_ON_COPY
;;;1125     {
;;;1126       u32_t acc;
;;;1127   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1128       u16_t chksum_slow = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
;;;1129              &(pcb->remote_ip),
;;;1130              IP_PROTO_TCP, seg->p->tot_len);
;;;1131   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1132       if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
;;;1133         LWIP_ASSERT("data included but not checksummed",
;;;1134           seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
;;;1135       }
;;;1136   
;;;1137       /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
;;;1138       acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
;;;1139                &(pcb->remote_ip),
;;;1140                IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
;;;1141       /* add payload checksum */
;;;1142       if (seg->chksum_swapped) {
;;;1143         seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
;;;1144         seg->chksum_swapped = 0;
;;;1145       }
;;;1146       acc += (u16_t)~(seg->chksum);
;;;1147       seg->tcphdr->chksum = FOLD_U32T(acc);
;;;1148   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1149       if (chksum_slow != seg->tcphdr->chksum) {
;;;1150         LWIP_DEBUGF(TCP_DEBUG | LWIP_DBG_LEVEL_WARNING,
;;;1151                     ("tcp_output_segment: calculated checksum is %"X16_F" instead of %"X16_F"\n",
;;;1152                     seg->tcphdr->chksum, chksum_slow));
;;;1153         seg->tcphdr->chksum = chksum_slow;
;;;1154       }
;;;1155   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1156     }
;;;1157   #else /* TCP_CHECKSUM_ON_COPY */
;;;1158     seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
;;;1159            &(pcb->remote_ip),
;;;1160            IP_PROTO_TCP, seg->p->tot_len);
;;;1161   #endif /* TCP_CHECKSUM_ON_COPY */
;;;1162   #endif /* CHECKSUM_GEN_TCP */
;;;1163     TCP_STATS_INC(tcp.xmit);
;;;1164   
;;;1165   #if LWIP_NETIF_HWADDRHINT
;;;1166     ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;1167         IP_PROTO_TCP, &(pcb->addr_hint));
;;;1168   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1169     ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;1170         IP_PROTO_TCP);
;;;1171   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1172   }
00006c  e8bd87fc          POP      {r2-r10,pc}
                  |L6.112|
000070  6870              LDR      r0,[r6,#4]            ;1102
000072  6020              STR      r0,[r4,#0]            ;1102
                  |L6.116|
000074  6ba0              LDR      r0,[r4,#0x38]         ;1105
000076  b948              CBNZ     r0,|L6.140|
000078  481f              LDR      r0,|L6.248|
00007a  6800              LDR      r0,[r0,#0]            ;1106  ; tcp_ticks
00007c  63a0              STR      r0,[r4,#0x38]         ;1106
00007e  6929              LDR      r1,[r5,#0x10]         ;1107
000080  6848              LDR      r0,[r1,#4]            ;1107
000082  f7fffffe          BL       lwip_ntohl
000086  63e0              STR      r0,[r4,#0x3c]         ;1107
000088  bf00              NOP                            ;1109
00008a  bf00              NOP                            ;1109
                  |L6.140|
00008c  bf00              NOP                            ;1111
00008e  bf00              NOP                            ;1111
000090  8a28              LDRH     r0,[r5,#0x10]         ;1115
000092  6869              LDR      r1,[r5,#4]            ;1115
000094  8889              LDRH     r1,[r1,#4]            ;1115
000096  1a40              SUBS     r0,r0,r1              ;1115
000098  b287              UXTH     r7,r0                 ;1115
00009a  6868              LDR      r0,[r5,#4]            ;1117
00009c  8940              LDRH     r0,[r0,#0xa]          ;1117
00009e  1bc0              SUBS     r0,r0,r7              ;1117
0000a0  6869              LDR      r1,[r5,#4]            ;1117
0000a2  8148              STRH     r0,[r1,#0xa]          ;1117
0000a4  6868              LDR      r0,[r5,#4]            ;1118
0000a6  8900              LDRH     r0,[r0,#8]            ;1118
0000a8  1bc0              SUBS     r0,r0,r7              ;1118
0000aa  6869              LDR      r1,[r5,#4]            ;1118
0000ac  8108              STRH     r0,[r1,#8]            ;1118
0000ae  6869              LDR      r1,[r5,#4]            ;1120
0000b0  6928              LDR      r0,[r5,#0x10]         ;1120
0000b2  6048              STR      r0,[r1,#4]            ;1120
0000b4  2000              MOVS     r0,#0                 ;1122
0000b6  6929              LDR      r1,[r5,#0x10]         ;1122
0000b8  8208              STRH     r0,[r1,#0x10]         ;1122
0000ba  6868              LDR      r0,[r5,#4]            ;1158
0000bc  8900              LDRH     r0,[r0,#8]            ;1158
0000be  9000              STR      r0,[sp,#0]            ;1158
0000c0  2306              MOVS     r3,#6                 ;1158
0000c2  1d22              ADDS     r2,r4,#4              ;1158
0000c4  4621              MOV      r1,r4                 ;1158
0000c6  6868              LDR      r0,[r5,#4]            ;1158
0000c8  f7fffffe          BL       inet_chksum_pseudo
0000cc  6929              LDR      r1,[r5,#0x10]         ;1158
0000ce  8208              STRH     r0,[r1,#0x10]         ;1158
0000d0  480a              LDR      r0,|L6.252|
0000d2  f8b00090          LDRH     r0,[r0,#0x90]         ;1163  ; lwip_stats
0000d6  1c40              ADDS     r0,r0,#1              ;1163
0000d8  4908              LDR      r1,|L6.252|
0000da  f8a10090          STRH     r0,[r1,#0x90]         ;1163
0000de  2106              MOVS     r1,#6                 ;1169
0000e0  7a60              LDRB     r0,[r4,#9]            ;1169
0000e2  e9cd0100          STRD     r0,r1,[sp,#0]         ;1169
0000e6  7aa3              LDRB     r3,[r4,#0xa]          ;1169
0000e8  1d22              ADDS     r2,r4,#4              ;1169
0000ea  4621              MOV      r1,r4                 ;1169
0000ec  6868              LDR      r0,[r5,#4]            ;1169
0000ee  f7fffffe          BL       ip_output
0000f2  bf00              NOP      
0000f4  e7ba              B        |L6.108|
;;;1173   
                          ENDP

0000f6  0000              DCW      0x0000
                  |L6.248|
                          DCD      tcp_ticks
                  |L6.252|
                          DCD      lwip_stats

                          AREA ||i.tcp_pbuf_prealloc||, CODE, READONLY, ALIGN=2

                  tcp_pbuf_prealloc PROC
;;;218    static struct pbuf *
;;;219    tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;220                      u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
;;;221                      u8_t first_seg)
;;;222    {
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
000008  4698              MOV      r8,r3
00000a  e9ddab0f          LDRD     r10,r11,[sp,#0x3c]
00000e  9f0e              LDR      r7,[sp,#0x38]
;;;223      struct pbuf *p;
;;;224      u16_t alloc = length;
000010  46a1              MOV      r9,r4
;;;225    
;;;226    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;227      LWIP_UNUSED_ARG(max_length);
;;;228      LWIP_UNUSED_ARG(pcb);
;;;229      LWIP_UNUSED_ARG(apiflags);
;;;230      LWIP_UNUSED_ARG(first_seg);
;;;231      /* always create MSS-sized pbufs */
;;;232      alloc = max_length;
;;;233    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;234      if (length < max_length) {
000012  42b4              CMP      r4,r6
000014  da1b              BGE      |L7.78|
;;;235        /* Should we allocate an oversized pbuf, or just the minimum
;;;236         * length required? If tcp_write is going to be called again
;;;237         * before this segment is transmitted, we want the oversized
;;;238         * buffer. If the segment will be transmitted immediately, we can
;;;239         * save memory by allocating only length. We use a simple
;;;240         * heuristic based on the following information:
;;;241         *
;;;242         * Did the user set TCP_WRITE_FLAG_MORE?
;;;243         *
;;;244         * Will the Nagle algorithm defer transmission of this segment?
;;;245         */
;;;246        if ((apiflags & TCP_WRITE_FLAG_MORE) ||
000016  f00a0002          AND      r0,r10,#2
00001a  b950              CBNZ     r0,|L7.50|
;;;247            (!(pcb->flags & TF_NODELAY) &&
00001c  7fb8              LDRB     r0,[r7,#0x1e]
00001e  f0000040          AND      r0,r0,#0x40
000022  b9a0              CBNZ     r0,|L7.78|
;;;248             (!first_seg ||
000024  f1bb0f00          CMP      r11,#0
000028  d003              BEQ      |L7.50|
;;;249              pcb->unsent != NULL ||
00002a  6ef8              LDR      r0,[r7,#0x6c]
00002c  b908              CBNZ     r0,|L7.50|
;;;250              pcb->unacked != NULL))) {
00002e  6f38              LDR      r0,[r7,#0x70]
000030  b168              CBZ      r0,|L7.78|
                  |L7.50|
;;;251          alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
000032  f20430eb          ADD      r0,r4,#0x3eb
000036  f0200003          BIC      r0,r0,#3
00003a  42b0              CMP      r0,r6
00003c  dd01              BLE      |L7.66|
00003e  4630              MOV      r0,r6
000040  e003              B        |L7.74|
                  |L7.66|
000042  f20430eb          ADD      r0,r4,#0x3eb
000046  f0200003          BIC      r0,r0,#3
                  |L7.74|
00004a  fa1ff980          UXTH     r9,r0
                  |L7.78|
;;;252        }
;;;253      }
;;;254    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;255      p = pbuf_alloc(layer, alloc, PBUF_RAM);
00004e  2200              MOVS     r2,#0
000050  4649              MOV      r1,r9
000052  9800              LDR      r0,[sp,#0]
000054  f7fffffe          BL       pbuf_alloc
000058  4605              MOV      r5,r0
;;;256      if (p == NULL) {
00005a  b91d              CBNZ     r5,|L7.100|
;;;257        return NULL;
00005c  2000              MOVS     r0,#0
                  |L7.94|
;;;258      }
;;;259      LWIP_ASSERT("need unchained pbuf", p->next == NULL);
;;;260      *oversize = p->len - length;
;;;261      /* trim p->len to the currently used size */
;;;262      p->len = p->tot_len = length;
;;;263      return p;
;;;264    }
00005e  b004              ADD      sp,sp,#0x10
000060  e8bd9ff0          POP      {r4-r12,pc}
                  |L7.100|
000064  bf00              NOP                            ;259
000066  6828              LDR      r0,[r5,#0]            ;259
000068  b120              CBZ      r0,|L7.116|
00006a  a007              ADR      r0,|L7.136|
00006c  f7fffffe          BL       __2printf
000070  bf00              NOP                            ;259
                  |L7.114|
000072  e7fe              B        |L7.114|
                  |L7.116|
000074  bf00              NOP                            ;259
000076  8968              LDRH     r0,[r5,#0xa]          ;260
000078  1b00              SUBS     r0,r0,r4              ;260
00007a  f8a80000          STRH     r0,[r8,#0]            ;260
00007e  812c              STRH     r4,[r5,#8]            ;262
000080  816c              STRH     r4,[r5,#0xa]          ;262
000082  4628              MOV      r0,r5                 ;263
000084  e7eb              B        |L7.94|
;;;265    #else /* TCP_OVERSIZE */
                          ENDP

000086  0000              DCW      0x0000
                  |L7.136|
000088  6e656564          DCB      "need unchained pbuf",0
00008c  20756e63
000090  6861696e
000094  65642070
000098  62756600

                          AREA ||i.tcp_rexmit||, CODE, READONLY, ALIGN=1

                  tcp_rexmit PROC
;;;1274   void
;;;1275   tcp_rexmit(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1276   {
000004  4604              MOV      r4,r0
;;;1277     struct tcp_seg *seg;
;;;1278     struct tcp_seg **cur_seg;
;;;1279   
;;;1280     if (pcb->unacked == NULL) {
000006  6f20              LDR      r0,[r4,#0x70]
000008  b908              CBNZ     r0,|L8.14|
                  |L8.10|
;;;1281       return;
;;;1282     }
;;;1283   
;;;1284     /* Move the first unacked segment to the unsent queue */
;;;1285     /* Keep the unsent queue sorted. */
;;;1286     seg = pcb->unacked;
;;;1287     pcb->unacked = seg->next;
;;;1288   
;;;1289     cur_seg = &(pcb->unsent);
;;;1290     while (*cur_seg &&
;;;1291       TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1292         cur_seg = &((*cur_seg)->next );
;;;1293     }
;;;1294     seg->next = *cur_seg;
;;;1295     *cur_seg = seg;
;;;1296   #if TCP_OVERSIZE
;;;1297     if (seg->next == NULL) {
;;;1298       /* the retransmitted segment is last in unsent, so reset unsent_oversize */
;;;1299       pcb->unsent_oversize = 0;
;;;1300     }
;;;1301   #endif /* TCP_OVERSIZE */
;;;1302   
;;;1303     ++pcb->nrtx;
;;;1304   
;;;1305     /* Don't take any rtt measurements after retransmitting. */
;;;1306     pcb->rttest = 0;
;;;1307   
;;;1308     /* Do the actual retransmission. */
;;;1309     snmp_inc_tcpretranssegs();
;;;1310     /* No need to call tcp_output: we are always called from tcp_input()
;;;1311        and thus tcp_output directly returns. */
;;;1312   }
00000a  e8bd81f0          POP      {r4-r8,pc}
                  |L8.14|
00000e  6f25              LDR      r5,[r4,#0x70]         ;1286
000010  6828              LDR      r0,[r5,#0]            ;1287
000012  6720              STR      r0,[r4,#0x70]         ;1287
000014  f104066c          ADD      r6,r4,#0x6c           ;1289
000018  e000              B        |L8.28|
                  |L8.26|
00001a  6836              LDR      r6,[r6,#0]            ;1292
                  |L8.28|
00001c  6830              LDR      r0,[r6,#0]            ;1290
00001e  b158              CBZ      r0,|L8.56|
000020  6831              LDR      r1,[r6,#0]            ;1291
000022  6909              LDR      r1,[r1,#0x10]         ;1291
000024  6848              LDR      r0,[r1,#4]            ;1291
000026  f7fffffe          BL       lwip_ntohl
00002a  4607              MOV      r7,r0                 ;1291
00002c  6929              LDR      r1,[r5,#0x10]         ;1291
00002e  6848              LDR      r0,[r1,#4]            ;1291
000030  f7fffffe          BL       lwip_ntohl
000034  1a38              SUBS     r0,r7,r0              ;1291
000036  d4f0              BMI      |L8.26|
                  |L8.56|
000038  6830              LDR      r0,[r6,#0]            ;1294
00003a  6028              STR      r0,[r5,#0]            ;1294
00003c  6035              STR      r5,[r6,#0]            ;1295
00003e  6828              LDR      r0,[r5,#0]            ;1297
000040  b910              CBNZ     r0,|L8.72|
000042  2000              MOVS     r0,#0                 ;1299
000044  f8a4006a          STRH     r0,[r4,#0x6a]         ;1299
                  |L8.72|
000048  f8940046          LDRB     r0,[r4,#0x46]         ;1303
00004c  1c40              ADDS     r0,r0,#1              ;1303
00004e  f8840046          STRB     r0,[r4,#0x46]         ;1303
000052  2000              MOVS     r0,#0                 ;1306
000054  63a0              STR      r0,[r4,#0x38]         ;1306
000056  bf00              NOP      
000058  e7d7              B        |L8.10|
;;;1313   
                          ENDP


                          AREA ||i.tcp_rexmit_fast||, CODE, READONLY, ALIGN=1

                  tcp_rexmit_fast PROC
;;;1320   void 
;;;1321   tcp_rexmit_fast(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;1322   {
000002  4604              MOV      r4,r0
;;;1323     if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
000004  6f20              LDR      r0,[r4,#0x70]
000006  b3b0              CBZ      r0,|L9.118|
000008  7fa0              LDRB     r0,[r4,#0x1e]
00000a  f0000004          AND      r0,r0,#4
00000e  bb90              CBNZ     r0,|L9.118|
;;;1324       /* This is fast retransmit. Retransmit the first unacked segment. */
;;;1325       LWIP_DEBUGF(TCP_FR_DEBUG, 
000010  bf00              NOP      
000012  bf00              NOP      
;;;1326                   ("tcp_receive: dupacks %"U16_F" (%"U32_F
;;;1327                    "), fast retransmit %"U32_F"\n",
;;;1328                    (u16_t)pcb->dupacks, pcb->lastack,
;;;1329                    ntohl(pcb->unacked->tcphdr->seqno)));
;;;1330       tcp_rexmit(pcb);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       tcp_rexmit
;;;1331   
;;;1332       /* Set ssthresh to half of the minimum of the current
;;;1333        * cwnd and the advertised window */
;;;1334       if (pcb->cwnd > pcb->snd_wnd) {
00001a  f8b4004c          LDRH     r0,[r4,#0x4c]
00001e  f8b41060          LDRH     r1,[r4,#0x60]
000022  4288              CMP      r0,r1
000024  dd07              BLE      |L9.54|
;;;1335         pcb->ssthresh = pcb->snd_wnd / 2;
000026  f8b40060          LDRH     r0,[r4,#0x60]
00002a  eb0071d0          ADD      r1,r0,r0,LSR #31
00002e  1049              ASRS     r1,r1,#1
000030  f8a4104e          STRH     r1,[r4,#0x4e]
000034  e006              B        |L9.68|
                  |L9.54|
;;;1336       } else {
;;;1337         pcb->ssthresh = pcb->cwnd / 2;
000036  f8b4004c          LDRH     r0,[r4,#0x4c]
00003a  eb0071d0          ADD      r1,r0,r0,LSR #31
00003e  1049              ASRS     r1,r1,#1
000040  f8a4104e          STRH     r1,[r4,#0x4e]
                  |L9.68|
;;;1338       }
;;;1339       
;;;1340       /* The minimum value for ssthresh should be 2 MSS */
;;;1341       if (pcb->ssthresh < 2*pcb->mss) {
000044  f8b4004e          LDRH     r0,[r4,#0x4e]
000048  8ee1              LDRH     r1,[r4,#0x36]
00004a  0049              LSLS     r1,r1,#1
00004c  4288              CMP      r0,r1
00004e  da06              BGE      |L9.94|
;;;1342         LWIP_DEBUGF(TCP_FR_DEBUG, 
000050  bf00              NOP      
000052  bf00              NOP      
;;;1343                     ("tcp_receive: The minimum value for ssthresh %"U16_F
;;;1344                      " should be min 2 mss %"U16_F"...\n",
;;;1345                      pcb->ssthresh, 2*pcb->mss));
;;;1346         pcb->ssthresh = 2*pcb->mss;
000054  8ee0              LDRH     r0,[r4,#0x36]
000056  0440              LSLS     r0,r0,#17
000058  0c00              LSRS     r0,r0,#16
00005a  f8a4004e          STRH     r0,[r4,#0x4e]
                  |L9.94|
;;;1347       }
;;;1348       
;;;1349       pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
00005e  f8b4004e          LDRH     r0,[r4,#0x4e]
000062  8ee1              LDRH     r1,[r4,#0x36]
000064  2203              MOVS     r2,#3
000066  fb020001          MLA      r0,r2,r1,r0
00006a  f8a4004c          STRH     r0,[r4,#0x4c]
;;;1350       pcb->flags |= TF_INFR;
00006e  7fa0              LDRB     r0,[r4,#0x1e]
000070  f0400004          ORR      r0,r0,#4
000074  77a0              STRB     r0,[r4,#0x1e]
                  |L9.118|
;;;1351     } 
;;;1352   }
000076  bd10              POP      {r4,pc}
;;;1353   
                          ENDP


                          AREA ||i.tcp_rexmit_rto||, CODE, READONLY, ALIGN=1

                  tcp_rexmit_rto PROC
;;;1238   void
;;;1239   tcp_rexmit_rto(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1240   {
000002  4604              MOV      r4,r0
;;;1241     struct tcp_seg *seg;
;;;1242   
;;;1243     if (pcb->unacked == NULL) {
000004  6f20              LDR      r0,[r4,#0x70]
000006  b900              CBNZ     r0,|L10.10|
                  |L10.8|
;;;1244       return;
;;;1245     }
;;;1246   
;;;1247     /* Move all unacked segments to the head of the unsent queue */
;;;1248     for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
;;;1249     /* concatenate unsent queue after unacked queue */
;;;1250     seg->next = pcb->unsent;
;;;1251     /* unsent queue is the concatenated queue (of unacked, unsent) */
;;;1252     pcb->unsent = pcb->unacked;
;;;1253     /* unacked queue is now empty */
;;;1254     pcb->unacked = NULL;
;;;1255     /* last unsent hasn't changed, no need to reset unsent_oversize */
;;;1256   
;;;1257     /* increment number of retransmissions */
;;;1258     ++pcb->nrtx;
;;;1259   
;;;1260     /* Don't take any RTT measurements after retransmitting. */
;;;1261     pcb->rttest = 0;
;;;1262   
;;;1263     /* Do the actual retransmission */
;;;1264     tcp_output(pcb);
;;;1265   }
000008  bd70              POP      {r4-r6,pc}
                  |L10.10|
00000a  6f25              LDR      r5,[r4,#0x70]         ;1248
00000c  e000              B        |L10.16|
                  |L10.14|
00000e  682d              LDR      r5,[r5,#0]            ;1248
                  |L10.16|
000010  6828              LDR      r0,[r5,#0]            ;1248
000012  2800              CMP      r0,#0                 ;1248
000014  d1fb              BNE      |L10.14|
000016  6ee0              LDR      r0,[r4,#0x6c]         ;1250
000018  6028              STR      r0,[r5,#0]            ;1250
00001a  6f20              LDR      r0,[r4,#0x70]         ;1252
00001c  66e0              STR      r0,[r4,#0x6c]         ;1252
00001e  2000              MOVS     r0,#0                 ;1254
000020  6720              STR      r0,[r4,#0x70]         ;1254
000022  f8940046          LDRB     r0,[r4,#0x46]         ;1258
000026  1c40              ADDS     r0,r0,#1              ;1258
000028  f8840046          STRB     r0,[r4,#0x46]         ;1258
00002c  2000              MOVS     r0,#0                 ;1261
00002e  63a0              STR      r0,[r4,#0x38]         ;1261
000030  4620              MOV      r0,r4                 ;1264
000032  f7fffffe          BL       tcp_output
000036  bf00              NOP      
000038  e7e6              B        |L10.8|
;;;1266   
                          ENDP


                          AREA ||i.tcp_rst||, CODE, READONLY, ALIGN=2

                  tcp_rst PROC
;;;1194   void
;;;1195   tcp_rst(u32_t seqno, u32_t ackno,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1196     ip_addr_t *local_ip, ip_addr_t *remote_ip,
;;;1197     u16_t local_port, u16_t remote_port)
;;;1198   {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9ddab0c          LDRD     r10,r11,[sp,#0x30]
;;;1199     struct pbuf *p;
;;;1200     struct tcp_hdr *tcphdr;
;;;1201     p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
000010  2200              MOVS     r2,#0
000012  2114              MOVS     r1,#0x14
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       pbuf_alloc
00001a  4605              MOV      r5,r0
;;;1202     if (p == NULL) {
00001c  b91d              CBNZ     r5,|L11.38|
;;;1203         LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
00001e  bf00              NOP      
000020  bf00              NOP      
                  |L11.34|
;;;1204         return;
;;;1205     }
;;;1206     LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
;;;1207                 (p->len >= sizeof(struct tcp_hdr)));
;;;1208   
;;;1209     tcphdr = (struct tcp_hdr *)p->payload;
;;;1210     tcphdr->src = htons(local_port);
;;;1211     tcphdr->dest = htons(remote_port);
;;;1212     tcphdr->seqno = htonl(seqno);
;;;1213     tcphdr->ackno = htonl(ackno);
;;;1214     TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
;;;1215     tcphdr->wnd = PP_HTONS(TCP_WND);
;;;1216     tcphdr->chksum = 0;
;;;1217     tcphdr->urgp = 0;
;;;1218   
;;;1219   #if CHECKSUM_GEN_TCP
;;;1220     tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
;;;1221                 IP_PROTO_TCP, p->tot_len);
;;;1222   #endif
;;;1223     TCP_STATS_INC(tcp.xmit);
;;;1224     snmp_inc_tcpoutrsts();
;;;1225      /* Send output with hardcoded TTL since we have no access to the pcb */
;;;1226     ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
;;;1227     pbuf_free(p);
;;;1228     LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
;;;1229   }
000022  e8bd9ffc          POP      {r2-r12,pc}
                  |L11.38|
000026  bf00              NOP                            ;1206
000028  8968              LDRH     r0,[r5,#0xa]          ;1206
00002a  2814              CMP      r0,#0x14              ;1206
00002c  d204              BCS      |L11.56|
00002e  a021              ADR      r0,|L11.180|
000030  f7fffffe          BL       __2printf
000034  bf00              NOP                            ;1206
                  |L11.54|
000036  e7fe              B        |L11.54|
                  |L11.56|
000038  bf00              NOP                            ;1206
00003a  686c              LDR      r4,[r5,#4]            ;1209
00003c  4650              MOV      r0,r10                ;1210
00003e  f7fffffe          BL       lwip_htons
000042  8020              STRH     r0,[r4,#0]            ;1210
000044  4658              MOV      r0,r11                ;1211
000046  f7fffffe          BL       lwip_htons
00004a  8060              STRH     r0,[r4,#2]            ;1211
00004c  4648              MOV      r0,r9                 ;1212
00004e  f7fffffe          BL       lwip_htonl
000052  6060              STR      r0,[r4,#4]            ;1212
000054  4630              MOV      r0,r6                 ;1213
000056  f7fffffe          BL       lwip_htonl
00005a  60a0              STR      r0,[r4,#8]            ;1213
00005c  f2450014          MOV      r0,#0x5014            ;1214
000060  f7fffffe          BL       lwip_htons
000064  81a0              STRH     r0,[r4,#0xc]          ;1214
000066  f24a000f          MOV      r0,#0xa00f            ;1215
00006a  81e0              STRH     r0,[r4,#0xe]          ;1215
00006c  2000              MOVS     r0,#0                 ;1216
00006e  8220              STRH     r0,[r4,#0x10]         ;1216
000070  8260              STRH     r0,[r4,#0x12]         ;1217
000072  8928              LDRH     r0,[r5,#8]            ;1220
000074  2306              MOVS     r3,#6                 ;1220
000076  4642              MOV      r2,r8                 ;1220
000078  4639              MOV      r1,r7                 ;1220
00007a  9000              STR      r0,[sp,#0]            ;1220
00007c  4628              MOV      r0,r5                 ;1220
00007e  f7fffffe          BL       inet_chksum_pseudo
000082  8220              STRH     r0,[r4,#0x10]         ;1220
000084  4817              LDR      r0,|L11.228|
000086  f8b00090          LDRH     r0,[r0,#0x90]         ;1223  ; lwip_stats
00008a  1c40              ADDS     r0,r0,#1              ;1223
00008c  4915              LDR      r1,|L11.228|
00008e  f8a10090          STRH     r0,[r1,#0x90]         ;1223
000092  2006              MOVS     r0,#6                 ;1226
000094  2100              MOVS     r1,#0                 ;1226
000096  23ff              MOVS     r3,#0xff              ;1226
000098  4642              MOV      r2,r8                 ;1226
00009a  e9cd1000          STRD     r1,r0,[sp,#0]         ;1226
00009e  4639              MOV      r1,r7                 ;1226
0000a0  4628              MOV      r0,r5                 ;1226
0000a2  f7fffffe          BL       ip_output
0000a6  4628              MOV      r0,r5                 ;1227
0000a8  f7fffffe          BL       pbuf_free
0000ac  bf00              NOP                            ;1228
0000ae  bf00              NOP                            ;1228
0000b0  bf00              NOP      
0000b2  e7b6              B        |L11.34|
;;;1230   
                          ENDP

                  |L11.180|
0000b4  63686563          DCB      "check that first pbuf can hold struct tcp_hdr",0
0000b8  6b207468
0000bc  61742066
0000c0  69727374
0000c4  20706275
0000c8  66206361
0000cc  6e20686f
0000d0  6c642073
0000d4  74727563
0000d8  74207463
0000dc  705f6864
0000e0  7200    
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L11.228|
                          DCD      lwip_stats

                          AREA ||i.tcp_send_empty_ack||, CODE, READONLY, ALIGN=1

                  tcp_send_empty_ack PROC
;;;841    err_t
;;;842    tcp_send_empty_ack(struct tcp_pcb *pcb)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;843    {
000004  4604              MOV      r4,r0
;;;844      struct pbuf *p;
;;;845      struct tcp_hdr *tcphdr;
;;;846      u8_t optlen = 0;
000006  2700              MOVS     r7,#0
;;;847    
;;;848    #if LWIP_TCP_TIMESTAMPS
;;;849      if (pcb->flags & TF_TIMESTAMP) {
;;;850        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;851      }
;;;852    #endif
;;;853    
;;;854      p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
000008  6d20              LDR      r0,[r4,#0x50]
00000a  f7fffffe          BL       lwip_htonl
00000e  4680              MOV      r8,r0
000010  4643              MOV      r3,r8
000012  2200              MOVS     r2,#0
000014  4639              MOV      r1,r7
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       tcp_output_alloc_header
00001c  4605              MOV      r5,r0
;;;855      if (p == NULL) {
00001e  b925              CBNZ     r5,|L12.42|
;;;856        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
000020  bf00              NOP      
000022  bf00              NOP      
;;;857        return ERR_BUF;
000024  1eb8              SUBS     r0,r7,#2
                  |L12.38|
;;;858      }
;;;859      tcphdr = (struct tcp_hdr *)p->payload;
;;;860      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
;;;861                  ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
;;;862      /* remove ACK flags from the PCB, as we send an empty ACK now */
;;;863      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
;;;864    
;;;865      /* NB. MSS option is only sent on SYNs, so ignore it here */
;;;866    #if LWIP_TCP_TIMESTAMPS
;;;867      pcb->ts_lastacksent = pcb->rcv_nxt;
;;;868    
;;;869      if (pcb->flags & TF_TIMESTAMP) {
;;;870        tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
;;;871      }
;;;872    #endif 
;;;873    
;;;874    #if CHECKSUM_GEN_TCP
;;;875      tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
;;;876            IP_PROTO_TCP, p->tot_len);
;;;877    #endif
;;;878    #if LWIP_NETIF_HWADDRHINT
;;;879      ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;880          IP_PROTO_TCP, &(pcb->addr_hint));
;;;881    #else /* LWIP_NETIF_HWADDRHINT*/
;;;882      ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;883          IP_PROTO_TCP);
;;;884    #endif /* LWIP_NETIF_HWADDRHINT*/
;;;885      pbuf_free(p);
;;;886    
;;;887      return ERR_OK;
;;;888    }
000026  e8bd81fc          POP      {r2-r8,pc}
                  |L12.42|
00002a  686e              LDR      r6,[r5,#4]            ;859
00002c  bf00              NOP                            ;860
00002e  bf00              NOP                            ;860
000030  7fa0              LDRB     r0,[r4,#0x1e]         ;863
000032  f0200003          BIC      r0,r0,#3              ;863
000036  77a0              STRB     r0,[r4,#0x1e]         ;863
000038  8928              LDRH     r0,[r5,#8]            ;875
00003a  2306              MOVS     r3,#6                 ;875
00003c  1d22              ADDS     r2,r4,#4              ;875
00003e  4621              MOV      r1,r4                 ;875
000040  9000              STR      r0,[sp,#0]            ;875
000042  4628              MOV      r0,r5                 ;875
000044  f7fffffe          BL       inet_chksum_pseudo
000048  8230              STRH     r0,[r6,#0x10]         ;875
00004a  2106              MOVS     r1,#6                 ;882
00004c  7a60              LDRB     r0,[r4,#9]            ;882
00004e  e9cd0100          STRD     r0,r1,[sp,#0]         ;882
000052  7aa3              LDRB     r3,[r4,#0xa]          ;882
000054  1d22              ADDS     r2,r4,#4              ;882
000056  4621              MOV      r1,r4                 ;882
000058  4628              MOV      r0,r5                 ;882
00005a  f7fffffe          BL       ip_output
00005e  4628              MOV      r0,r5                 ;885
000060  f7fffffe          BL       pbuf_free
000064  2000              MOVS     r0,#0                 ;887
000066  e7de              B        |L12.38|
;;;889    
                          ENDP


                          AREA ||i.tcp_send_fin||, CODE, READONLY, ALIGN=1

                  tcp_send_fin PROC
;;;124    err_t
;;;125    tcp_send_fin(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;126    {
000002  4604              MOV      r4,r0
;;;127      /* first, try to add the fin to the last unsent segment */
;;;128      if (pcb->unsent != NULL) {
000004  6ee0              LDR      r0,[r4,#0x6c]
000006  b1d8              CBZ      r0,|L13.64|
;;;129        struct tcp_seg *last_unsent;
;;;130        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
000008  6ee5              LDR      r5,[r4,#0x6c]
00000a  e000              B        |L13.14|
                  |L13.12|
;;;131             last_unsent = last_unsent->next);
00000c  682d              LDR      r5,[r5,#0]
                  |L13.14|
00000e  6828              LDR      r0,[r5,#0]            ;130
000010  2800              CMP      r0,#0                 ;130
000012  d1fb              BNE      |L13.12|
;;;132    
;;;133        if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
000014  6929              LDR      r1,[r5,#0x10]
000016  8988              LDRH     r0,[r1,#0xc]
000018  f7fffffe          BL       lwip_ntohs
00001c  f0000007          AND      r0,r0,#7
000020  b968              CBNZ     r0,|L13.62|
;;;134          /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
;;;135          TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       lwip_htons
000028  6929              LDR      r1,[r5,#0x10]
00002a  8989              LDRH     r1,[r1,#0xc]
00002c  4308              ORRS     r0,r0,r1
00002e  6929              LDR      r1,[r5,#0x10]
000030  8188              STRH     r0,[r1,#0xc]
;;;136          pcb->flags |= TF_FIN;
000032  7fa0              LDRB     r0,[r4,#0x1e]
000034  f0400020          ORR      r0,r0,#0x20
000038  77a0              STRB     r0,[r4,#0x1e]
;;;137          return ERR_OK;
00003a  2000              MOVS     r0,#0
                  |L13.60|
;;;138        }
;;;139      }
;;;140      /* no data, no length, flags, copy=1, no optdata */
;;;141      return tcp_enqueue_flags(pcb, TCP_FIN);
;;;142    }
00003c  bd70              POP      {r4-r6,pc}
                  |L13.62|
00003e  bf00              NOP                            ;139
                  |L13.64|
000040  2101              MOVS     r1,#1                 ;141
000042  4620              MOV      r0,r4                 ;141
000044  f7fffffe          BL       tcp_enqueue_flags
000048  e7f8              B        |L13.60|
;;;143    
                          ENDP


                          AREA ||i.tcp_write||, CODE, READONLY, ALIGN=2

                  tcp_write PROC
;;;353    err_t
;;;354    tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;355    {
000004  b08f              SUB      sp,sp,#0x3c
000006  4604              MOV      r4,r0
000008  4617              MOV      r7,r2
;;;356      struct pbuf *concat_p = NULL;
00000a  f04f0b00          MOV      r11,#0
;;;357      struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
00000e  2500              MOVS     r5,#0
000010  46aa              MOV      r10,r5
000012  2000              MOVS     r0,#0
000014  900e              STR      r0,[sp,#0x38]
000016  900d              STR      r0,[sp,#0x34]
;;;358      u16_t pos = 0; /* position in 'arg' data */
000018  2600              MOVS     r6,#0
;;;359      u16_t queuelen;
;;;360      u8_t optlen = 0;
00001a  900b              STR      r0,[sp,#0x2c]
;;;361      u8_t optflags = 0;
00001c  900a              STR      r0,[sp,#0x28]
;;;362    #if TCP_OVERSIZE
;;;363      u16_t oversize = 0;
00001e  9009              STR      r0,[sp,#0x24]
;;;364      u16_t oversize_used = 0;
000020  4680              MOV      r8,r0
;;;365    #endif /* TCP_OVERSIZE */
;;;366    #if TCP_CHECKSUM_ON_COPY
;;;367      u16_t concat_chksum = 0;
;;;368      u8_t concat_chksum_swapped = 0;
;;;369      u16_t concat_chksummed = 0;
;;;370    #endif /* TCP_CHECKSUM_ON_COPY */
;;;371      err_t err;
;;;372      /* don't allocate segments bigger than half the maximum window we ever received */
;;;373      u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
000022  f8b41062          LDRH     r1,[r4,#0x62]
000026  eb0172d1          ADD      r2,r1,r1,LSR #31
00002a  1052              ASRS     r2,r2,#1
00002c  8ee3              LDRH     r3,[r4,#0x36]
00002e  429a              CMP      r2,r3
000030  dd01              BLE      |L14.54|
000032  8ee2              LDRH     r2,[r4,#0x36]
000034  e004              B        |L14.64|
                  |L14.54|
000036  f8b40062          LDRH     r0,[r4,#0x62]
00003a  eb0072d0          ADD      r2,r0,r0,LSR #31
00003e  1052              ASRS     r2,r2,#1
                  |L14.64|
000040  b292              UXTH     r2,r2
000042  9207              STR      r2,[sp,#0x1c]
;;;374    
;;;375    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;376      /* Always copy to try to create single pbufs for TX */
;;;377      apiflags |= TCP_WRITE_FLAG_COPY;
;;;378    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;379    
;;;380      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
000044  bf00              NOP      
000046  bf00              NOP      
;;;381        (void *)pcb, arg, len, (u16_t)apiflags));
;;;382      LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
000048  bf00              NOP      
00004a  9810              LDR      r0,[sp,#0x40]
00004c  b938              CBNZ     r0,|L14.94|
00004e  a0fe              ADR      r0,|L14.1096|
000050  f7fffffe          BL       __2printf
000054  f06f000d          MVN      r0,#0xd
                  |L14.88|
;;;383                 arg != NULL, return ERR_ARG;);
;;;384    
;;;385      err = tcp_write_checks(pcb, len);
;;;386      if (err != ERR_OK) {
;;;387        return err;
;;;388      }
;;;389      queuelen = pcb->snd_queuelen;
;;;390    
;;;391    #if LWIP_TCP_TIMESTAMPS
;;;392      if ((pcb->flags & TF_TIMESTAMP)) {
;;;393        optflags = TF_SEG_OPTS_TS;
;;;394        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;395      }
;;;396    #endif /* LWIP_TCP_TIMESTAMPS */
;;;397    
;;;398    
;;;399      /*
;;;400       * TCP segmentation is done in three phases with increasing complexity:
;;;401       *
;;;402       * 1. Copy data directly into an oversized pbuf.
;;;403       * 2. Chain a new pbuf to the end of pcb->unsent.
;;;404       * 3. Create new segments.
;;;405       *
;;;406       * We may run out of memory at any point. In that case we must
;;;407       * return ERR_MEM and not change anything in pcb. Therefore, all
;;;408       * changes are recorded in local variables and committed at the end
;;;409       * of the function. Some pcb fields are maintained in local copies:
;;;410       *
;;;411       * queuelen = pcb->snd_queuelen
;;;412       * oversize = pcb->unsent_oversize
;;;413       *
;;;414       * These variables are set consistently by the phases:
;;;415       *
;;;416       * seg points to the last segment tampered with.
;;;417       *
;;;418       * pos records progress as data is segmented.
;;;419       */
;;;420    
;;;421      /* Find the tail of the unsent queue. */
;;;422      if (pcb->unsent != NULL) {
;;;423        u16_t space;
;;;424        u16_t unsent_optlen;
;;;425    
;;;426        /* @todo: this could be sped up by keeping last_unsent in the pcb */
;;;427        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
;;;428             last_unsent = last_unsent->next);
;;;429    
;;;430        /* Usable space at the end of the last unsent segment */
;;;431        unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
;;;432        space = mss_local - (last_unsent->len + unsent_optlen);
;;;433    
;;;434        /*
;;;435         * Phase 1: Copy data directly into an oversized pbuf.
;;;436         *
;;;437         * The number of bytes copied is recorded in the oversize_used
;;;438         * variable. The actual copying is done at the bottom of the
;;;439         * function.
;;;440         */
;;;441    #if TCP_OVERSIZE
;;;442    #if TCP_OVERSIZE_DBGCHECK
;;;443        /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
;;;444        LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
;;;445                    pcb->unsent_oversize == last_unsent->oversize_left);
;;;446    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;447        oversize = pcb->unsent_oversize;
;;;448        if (oversize > 0) {
;;;449          LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
;;;450          seg = last_unsent;
;;;451          oversize_used = oversize < len ? oversize : len;
;;;452          pos += oversize_used;
;;;453          oversize -= oversize_used;
;;;454          space -= oversize_used;
;;;455        }
;;;456        /* now we are either finished or oversize is zero */
;;;457        LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
;;;458    #endif /* TCP_OVERSIZE */
;;;459    
;;;460        /*
;;;461         * Phase 2: Chain a new pbuf to the end of pcb->unsent.
;;;462         *
;;;463         * We don't extend segments containing SYN/FIN flags or options
;;;464         * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
;;;465         * the end.
;;;466         */
;;;467        if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
;;;468          u16_t seglen = space < len - pos ? space : len - pos;
;;;469          seg = last_unsent;
;;;470    
;;;471          /* Create a pbuf with a copy or reference to seglen bytes. We
;;;472           * can use PBUF_RAW here since the data appears in the middle of
;;;473           * a segment. A header will never be prepended. */
;;;474          if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;475            /* Data is copied */
;;;476            if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
;;;477              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;478                          ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
;;;479                           seglen));
;;;480              goto memerr;
;;;481            }
;;;482    #if TCP_OVERSIZE_DBGCHECK
;;;483            last_unsent->oversize_left += oversize;
;;;484    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;485            TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
;;;486    #if TCP_CHECKSUM_ON_COPY
;;;487            concat_chksummed += seglen;
;;;488    #endif /* TCP_CHECKSUM_ON_COPY */
;;;489          } else {
;;;490            /* Data is not copied */
;;;491            if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
;;;492              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;493                          ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;494              goto memerr;
;;;495            }
;;;496    #if TCP_CHECKSUM_ON_COPY
;;;497            /* calculate the checksum of nocopy-data */
;;;498            tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
;;;499              &concat_chksum, &concat_chksum_swapped);
;;;500            concat_chksummed += seglen;
;;;501    #endif /* TCP_CHECKSUM_ON_COPY */
;;;502            /* reference the non-volatile payload data */
;;;503            concat_p->payload = (u8_t*)arg + pos;
;;;504          }
;;;505    
;;;506          pos += seglen;
;;;507          queuelen += pbuf_clen(concat_p);
;;;508        }
;;;509      } else {
;;;510    #if TCP_OVERSIZE
;;;511        LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
;;;512                    pcb->unsent_oversize == 0);
;;;513    #endif /* TCP_OVERSIZE */
;;;514      }
;;;515    
;;;516      /*
;;;517       * Phase 3: Create new segments.
;;;518       *
;;;519       * The new segments are chained together in the local 'queue'
;;;520       * variable, ready to be appended to pcb->unsent.
;;;521       */
;;;522      while (pos < len) {
;;;523        struct pbuf *p;
;;;524        u16_t left = len - pos;
;;;525        u16_t max_len = mss_local - optlen;
;;;526        u16_t seglen = left > max_len ? max_len : left;
;;;527    #if TCP_CHECKSUM_ON_COPY
;;;528        u16_t chksum = 0;
;;;529        u8_t chksum_swapped = 0;
;;;530    #endif /* TCP_CHECKSUM_ON_COPY */
;;;531    
;;;532        if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;533          /* If copy is set, memory should be allocated and data copied
;;;534           * into pbuf */
;;;535          if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
;;;536            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
;;;537            goto memerr;
;;;538          }
;;;539          LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
;;;540                      (p->len >= seglen));
;;;541          TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
;;;542        } else {
;;;543          /* Copy is not set: First allocate a pbuf for holding the data.
;;;544           * Since the referenced data is available at least until it is
;;;545           * sent out on the link (as it has to be ACKed by the remote
;;;546           * party) we can safely use PBUF_ROM instead of PBUF_REF here.
;;;547           */
;;;548          struct pbuf *p2;
;;;549    #if TCP_OVERSIZE
;;;550          LWIP_ASSERT("oversize == 0", oversize == 0);
;;;551    #endif /* TCP_OVERSIZE */
;;;552          if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
;;;553            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;554            goto memerr;
;;;555          }
;;;556    #if TCP_CHECKSUM_ON_COPY
;;;557          /* calculate the checksum of nocopy-data */
;;;558          chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
;;;559    #endif /* TCP_CHECKSUM_ON_COPY */
;;;560          /* reference the non-volatile payload data */
;;;561          p2->payload = (u8_t*)arg + pos;
;;;562    
;;;563          /* Second, allocate a pbuf for the headers. */
;;;564          if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;565            /* If allocation fails, we have to deallocate the data pbuf as
;;;566             * well. */
;;;567            pbuf_free(p2);
;;;568            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
;;;569            goto memerr;
;;;570          }
;;;571          /* Concatenate the headers and data pbufs together. */
;;;572          pbuf_cat(p/*header*/, p2/*data*/);
;;;573        }
;;;574    
;;;575        queuelen += pbuf_clen(p);
;;;576    
;;;577        /* Now that there are more segments queued, we check again if the
;;;578         * length of the queue exceeds the configured maximum or
;;;579         * overflows. */
;;;580        if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;581          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
;;;582          pbuf_free(p);
;;;583          goto memerr;
;;;584        }
;;;585    
;;;586        if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
;;;587          goto memerr;
;;;588        }
;;;589    #if TCP_OVERSIZE_DBGCHECK
;;;590        seg->oversize_left = oversize;
;;;591    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;592    #if TCP_CHECKSUM_ON_COPY
;;;593        seg->chksum = chksum;
;;;594        seg->chksum_swapped = chksum_swapped;
;;;595        seg->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;596    #endif /* TCP_CHECKSUM_ON_COPY */
;;;597    
;;;598        /* first segment of to-be-queued data? */
;;;599        if (queue == NULL) {
;;;600          queue = seg;
;;;601        } else {
;;;602          /* Attach the segment to the end of the queued segments */
;;;603          LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
;;;604          prev_seg->next = seg;
;;;605        }
;;;606        /* remember last segment of to-be-queued data for next iteration */
;;;607        prev_seg = seg;
;;;608    
;;;609        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
;;;610          ntohl(seg->tcphdr->seqno),
;;;611          ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));
;;;612    
;;;613        pos += seglen;
;;;614      }
;;;615    
;;;616      /*
;;;617       * All three segmentation phases were successful. We can commit the
;;;618       * transaction.
;;;619       */
;;;620    
;;;621      /*
;;;622       * Phase 1: If data has been added to the preallocated tail of
;;;623       * last_unsent, we update the length fields of the pbuf chain.
;;;624       */
;;;625    #if TCP_OVERSIZE
;;;626      if (oversize_used > 0) {
;;;627        struct pbuf *p;
;;;628        /* Bump tot_len of whole chain, len of tail */
;;;629        for (p = last_unsent->p; p; p = p->next) {
;;;630          p->tot_len += oversize_used;
;;;631          if (p->next == NULL) {
;;;632            TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
;;;633            p->len += oversize_used;
;;;634          }
;;;635        }
;;;636        last_unsent->len += oversize_used;
;;;637    #if TCP_OVERSIZE_DBGCHECK
;;;638        LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
;;;639                    last_unsent->oversize_left >= oversize_used);
;;;640        last_unsent->oversize_left -= oversize_used;
;;;641    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;642      }
;;;643      pcb->unsent_oversize = oversize;
;;;644    #endif /* TCP_OVERSIZE */
;;;645    
;;;646      /*
;;;647       * Phase 2: concat_p can be concatenated onto last_unsent->p
;;;648       */
;;;649      if (concat_p != NULL) {
;;;650        LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
;;;651          (last_unsent != NULL));
;;;652        pbuf_cat(last_unsent->p, concat_p);
;;;653        last_unsent->len += concat_p->tot_len;
;;;654    #if TCP_CHECKSUM_ON_COPY
;;;655        if (concat_chksummed) {
;;;656          tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
;;;657            &last_unsent->chksum_swapped);
;;;658          last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;659        }
;;;660    #endif /* TCP_CHECKSUM_ON_COPY */
;;;661      }
;;;662    
;;;663      /*
;;;664       * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
;;;665       * is harmless
;;;666       */
;;;667      if (last_unsent == NULL) {
;;;668        pcb->unsent = queue;
;;;669      } else {
;;;670        last_unsent->next = queue;
;;;671      }
;;;672    
;;;673      /*
;;;674       * Finally update the pcb state.
;;;675       */
;;;676      pcb->snd_lbb += len;
;;;677      pcb->snd_buf -= len;
;;;678      pcb->snd_queuelen = queuelen;
;;;679    
;;;680      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
;;;681        pcb->snd_queuelen));
;;;682      if (pcb->snd_queuelen != 0) {
;;;683        LWIP_ASSERT("tcp_write: valid queue length",
;;;684                    pcb->unacked != NULL || pcb->unsent != NULL);
;;;685      }
;;;686    
;;;687      /* Set the PSH flag in the last segment that we enqueued. */
;;;688      if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
;;;689        TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
;;;690      }
;;;691    
;;;692      return ERR_OK;
;;;693    memerr:
;;;694      pcb->flags |= TF_NAGLEMEMERR;
;;;695      TCP_STATS_INC(tcp.memerr);
;;;696    
;;;697      if (concat_p != NULL) {
;;;698        pbuf_free(concat_p);
;;;699      }
;;;700      if (queue != NULL) {
;;;701        tcp_segs_free(queue);
;;;702      }
;;;703      if (pcb->snd_queuelen != 0) {
;;;704        LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
;;;705          pcb->unsent != NULL);
;;;706      }
;;;707      LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
;;;708      return ERR_MEM;
;;;709    }
000058  b013              ADD      sp,sp,#0x4c
00005a  e8bd8ff0          POP      {r4-r11,pc}
                  |L14.94|
00005e  bf00              NOP                            ;382
000060  4639              MOV      r1,r7                 ;385
000062  4620              MOV      r0,r4                 ;385
000064  f7fffffe          BL       tcp_write_checks
000068  9008              STR      r0,[sp,#0x20]         ;385
00006a  9808              LDR      r0,[sp,#0x20]         ;386
00006c  b108              CBZ      r0,|L14.114|
00006e  9808              LDR      r0,[sp,#0x20]         ;387
000070  e7f2              B        |L14.88|
                  |L14.114|
000072  f8b40068          LDRH     r0,[r4,#0x68]         ;389
000076  900c              STR      r0,[sp,#0x30]         ;389
000078  6ee0              LDR      r0,[r4,#0x6c]         ;422
00007a  2800              CMP      r0,#0                 ;422
00007c  d07e              BEQ      |L14.380|
00007e  6ee5              LDR      r5,[r4,#0x6c]         ;427
000080  e000              B        |L14.132|
                  |L14.130|
000082  682d              LDR      r5,[r5,#0]            ;428
                  |L14.132|
000084  6828              LDR      r0,[r5,#0]            ;427
000086  2800              CMP      r0,#0                 ;427
000088  d1fb              BNE      |L14.130|
00008a  7b28              LDRB     r0,[r5,#0xc]          ;431
00008c  f0000001          AND      r0,r0,#1              ;431
000090  b108              CBZ      r0,|L14.150|
000092  2004              MOVS     r0,#4                 ;431
000094  e000              B        |L14.152|
                  |L14.150|
000096  2000              MOVS     r0,#0                 ;431
                  |L14.152|
000098  7b29              LDRB     r1,[r5,#0xc]          ;431
00009a  f0010102          AND      r1,r1,#2              ;431
00009e  b109              CBZ      r1,|L14.164|
0000a0  210c              MOVS     r1,#0xc               ;431
0000a2  e000              B        |L14.166|
                  |L14.164|
0000a4  2100              MOVS     r1,#0                 ;431
                  |L14.166|
0000a6  4408              ADD      r0,r0,r1              ;431
0000a8  9006              STR      r0,[sp,#0x18]         ;431
0000aa  8929              LDRH     r1,[r5,#8]            ;432
0000ac  9806              LDR      r0,[sp,#0x18]         ;432
0000ae  4401              ADD      r1,r1,r0              ;432
0000b0  9807              LDR      r0,[sp,#0x1c]         ;432
0000b2  1a40              SUBS     r0,r0,r1              ;432
0000b4  fa1ff980          UXTH     r9,r0                 ;432
0000b8  bf00              NOP                            ;444
0000ba  f8b4006a          LDRH     r0,[r4,#0x6a]         ;444
0000be  8969              LDRH     r1,[r5,#0xa]          ;444
0000c0  4288              CMP      r0,r1                 ;444
0000c2  d004              BEQ      |L14.206|
0000c4  a0ed              ADR      r0,|L14.1148|
0000c6  f7fffffe          BL       __2printf
0000ca  bf00              NOP                            ;444
                  |L14.204|
0000cc  e7fe              B        |L14.204|
                  |L14.206|
0000ce  bf00              NOP                            ;444
0000d0  f8b4006a          LDRH     r0,[r4,#0x6a]         ;447
0000d4  9009              STR      r0,[sp,#0x24]         ;447
0000d6  f8bd0024          LDRH     r0,[sp,#0x24]         ;448
0000da  2800              CMP      r0,#0                 ;448
0000dc  dd1f              BLE      |L14.286|
0000de  bf00              NOP                            ;449
0000e0  45c8              CMP      r8,r9                 ;449
0000e2  dd04              BLE      |L14.238|
0000e4  a0f1              ADR      r0,|L14.1196|
0000e6  f7fffffe          BL       __2printf
0000ea  bf00              NOP                            ;449
                  |L14.236|
0000ec  e7fe              B        |L14.236|
                  |L14.238|
0000ee  bf00              NOP                            ;449
0000f0  46aa              MOV      r10,r5                ;450
0000f2  f8bd0024          LDRH     r0,[sp,#0x24]         ;451
0000f6  42b8              CMP      r0,r7                 ;451
0000f8  da02              BGE      |L14.256|
0000fa  f8bd0024          LDRH     r0,[sp,#0x24]         ;451
0000fe  e000              B        |L14.258|
                  |L14.256|
000100  4638              MOV      r0,r7                 ;451
                  |L14.258|
000102  4680              MOV      r8,r0                 ;451
000104  eb060008          ADD      r0,r6,r8              ;452
000108  b286              UXTH     r6,r0                 ;452
00010a  f8bd0024          LDRH     r0,[sp,#0x24]         ;453
00010e  eba00008          SUB      r0,r0,r8              ;453
000112  b280              UXTH     r0,r0                 ;453
000114  9009              STR      r0,[sp,#0x24]         ;453
000116  eba90008          SUB      r0,r9,r8              ;454
00011a  fa1ff980          UXTH     r9,r0                 ;454
                  |L14.286|
00011e  bf00              NOP                            ;457
000120  f8bd0024          LDRH     r0,[sp,#0x24]         ;457
000124  b130              CBZ      r0,|L14.308|
000126  42be              CMP      r6,r7                 ;457
000128  d004              BEQ      |L14.308|
00012a  a0e8              ADR      r0,|L14.1228|
00012c  f7fffffe          BL       __2printf
000130  bf00              NOP                            ;457
                  |L14.306|
000132  e7fe              B        |L14.306|
                  |L14.308|
000134  bf00              NOP                            ;457
000136  42be              CMP      r6,r7                 ;467
000138  da4c              BGE      |L14.468|
00013a  f1b90f00          CMP      r9,#0                 ;467
00013e  dd49              BLE      |L14.468|
000140  8928              LDRH     r0,[r5,#8]            ;467
000142  2800              CMP      r0,#0                 ;467
000144  dd46              BLE      |L14.468|
000146  1bb8              SUBS     r0,r7,r6              ;468
000148  4548              CMP      r0,r9                 ;468
00014a  dd01              BLE      |L14.336|
00014c  4648              MOV      r0,r9                 ;468
00014e  e000              B        |L14.338|
                  |L14.336|
000150  1bb8              SUBS     r0,r7,r6              ;468
                  |L14.338|
000152  b280              UXTH     r0,r0                 ;468
000154  9005              STR      r0,[sp,#0x14]         ;468
000156  46aa              MOV      r10,r5                ;469
000158  9812              LDR      r0,[sp,#0x48]         ;474
00015a  f0000001          AND      r0,r0,#1              ;474
00015e  b1f8              CBZ      r0,|L14.416|
000160  2101              MOVS     r1,#1                 ;476
000162  9812              LDR      r0,[sp,#0x48]         ;476
000164  ab09              ADD      r3,sp,#0x24           ;476
000166  464a              MOV      r2,r9                 ;476
000168  e9cd4000          STRD     r4,r0,[sp,#0]         ;476
00016c  9102              STR      r1,[sp,#8]            ;476
00016e  2003              MOVS     r0,#3                 ;476
000170  9905              LDR      r1,[sp,#0x14]         ;476
000172  f7fffffe          BL       tcp_pbuf_prealloc
000176  f1b00b00          SUBS     r11,r0,#0             ;476
00017a  e000              B        |L14.382|
                  |L14.380|
00017c  e02b              B        |L14.470|
                  |L14.382|
00017e  d102              BNE      |L14.390|
000180  bf00              NOP                            ;477
000182  bf00              NOP                            ;477
000184  e243              B        |L14.1550|
                  |L14.390|
000186  8968              LDRH     r0,[r5,#0xa]          ;483
000188  f8bd1024          LDRH     r1,[sp,#0x24]         ;483
00018c  4408              ADD      r0,r0,r1              ;483
00018e  8168              STRH     r0,[r5,#0xa]          ;483
000190  9a10              LDR      r2,[sp,#0x40]         ;485
000192  1991              ADDS     r1,r2,r6              ;485
000194  f8db0004          LDR      r0,[r11,#4]           ;485
000198  9a05              LDR      r2,[sp,#0x14]         ;485
00019a  f7fffffe          BL       __aeabi_memcpy
00019e  e00e              B        |L14.446|
                  |L14.416|
0001a0  2201              MOVS     r2,#1                 ;491
0001a2  2003              MOVS     r0,#3                 ;491
0001a4  9905              LDR      r1,[sp,#0x14]         ;491
0001a6  f7fffffe          BL       pbuf_alloc
0001aa  f1b00b00          SUBS     r11,r0,#0             ;491
0001ae  d102              BNE      |L14.438|
0001b0  bf00              NOP                            ;492
0001b2  bf00              NOP                            ;492
0001b4  e22b              B        |L14.1550|
                  |L14.438|
0001b6  9810              LDR      r0,[sp,#0x40]         ;503
0001b8  4430              ADD      r0,r0,r6              ;503
0001ba  f8cb0004          STR      r0,[r11,#4]           ;503
                  |L14.446|
0001be  9805              LDR      r0,[sp,#0x14]         ;506
0001c0  4430              ADD      r0,r0,r6              ;506
0001c2  b286              UXTH     r6,r0                 ;506
0001c4  4658              MOV      r0,r11                ;507
0001c6  f7fffffe          BL       pbuf_clen
0001ca  990c              LDR      r1,[sp,#0x30]         ;507
0001cc  4408              ADD      r0,r0,r1              ;507
0001ce  b280              UXTH     r0,r0                 ;507
0001d0  900c              STR      r0,[sp,#0x30]         ;507
0001d2  bf00              NOP                            ;508
                  |L14.468|
0001d4  e009              B        |L14.490|
                  |L14.470|
0001d6  bf00              NOP                            ;511
0001d8  f8b4006a          LDRH     r0,[r4,#0x6a]         ;511
0001dc  b120              CBZ      r0,|L14.488|
0001de  a0c3              ADR      r0,|L14.1260|
0001e0  f7fffffe          BL       __2printf
0001e4  bf00              NOP                            ;511
                  |L14.486|
0001e6  e7fe              B        |L14.486|
                  |L14.488|
0001e8  bf00              NOP                            ;511
                  |L14.490|
0001ea  e0ab              B        |L14.836|
                  |L14.492|
0001ec  1bb8              SUBS     r0,r7,r6              ;524
0001ee  b280              UXTH     r0,r0                 ;524
0001f0  9006              STR      r0,[sp,#0x18]         ;524
0001f2  990b              LDR      r1,[sp,#0x2c]         ;525
0001f4  9807              LDR      r0,[sp,#0x1c]         ;525
0001f6  1a40              SUBS     r0,r0,r1              ;525
0001f8  b280              UXTH     r0,r0                 ;525
0001fa  9005              STR      r0,[sp,#0x14]         ;525
0001fc  e9dd1005          LDRD     r1,r0,[sp,#0x14]      ;526
000200  4288              CMP      r0,r1                 ;526
000202  dd01              BLE      |L14.520|
000204  9805              LDR      r0,[sp,#0x14]         ;526
000206  e000              B        |L14.522|
                  |L14.520|
000208  9806              LDR      r0,[sp,#0x18]         ;526
                  |L14.522|
00020a  9004              STR      r0,[sp,#0x10]         ;526
00020c  9812              LDR      r0,[sp,#0x48]         ;532
00020e  f0000001          AND      r0,r0,#1              ;532
000212  b368              CBZ      r0,|L14.624|
000214  980d              LDR      r0,[sp,#0x34]         ;535
000216  b908              CBNZ     r0,|L14.540|
000218  2101              MOVS     r1,#1                 ;535
00021a  e000              B        |L14.542|
                  |L14.540|
00021c  2100              MOVS     r1,#0                 ;535
                  |L14.542|
00021e  9812              LDR      r0,[sp,#0x48]         ;535
000220  e9cd4000          STRD     r4,r0,[sp,#0]         ;535
000224  9102              STR      r1,[sp,#8]            ;535
000226  9a0b              LDR      r2,[sp,#0x2c]         ;535
000228  9804              LDR      r0,[sp,#0x10]         ;535
00022a  4410              ADD      r0,r0,r2              ;535
00022c  b281              UXTH     r1,r0                 ;535
00022e  ab09              ADD      r3,sp,#0x24           ;535
000230  2000              MOVS     r0,#0                 ;535
000232  9a07              LDR      r2,[sp,#0x1c]         ;535
000234  f7fffffe          BL       tcp_pbuf_prealloc
000238  f1b00900          SUBS     r9,r0,#0              ;535
00023c  d102              BNE      |L14.580|
00023e  bf00              NOP                            ;536
000240  bf00              NOP                            ;536
000242  e1e4              B        |L14.1550|
                  |L14.580|
000244  bf00              NOP                            ;539
000246  f8b9100a          LDRH     r1,[r9,#0xa]          ;539
00024a  9804              LDR      r0,[sp,#0x10]         ;539
00024c  4281              CMP      r1,r0                 ;539
00024e  da04              BGE      |L14.602|
000250  a0b2              ADR      r0,|L14.1308|
000252  f7fffffe          BL       __2printf
000256  bf00              NOP                            ;539
                  |L14.600|
000258  e7fe              B        |L14.600|
                  |L14.602|
00025a  bf00              NOP                            ;539
00025c  9a10              LDR      r2,[sp,#0x40]         ;541
00025e  1991              ADDS     r1,r2,r6              ;541
000260  f8d93004          LDR      r3,[r9,#4]            ;541
000264  9a0b              LDR      r2,[sp,#0x2c]         ;541
000266  1898              ADDS     r0,r3,r2              ;541
000268  9a04              LDR      r2,[sp,#0x10]         ;541
00026a  f7fffffe          BL       __aeabi_memcpy
00026e  e02a              B        |L14.710|
                  |L14.624|
000270  bf00              NOP                            ;550
000272  f8bd0024          LDRH     r0,[sp,#0x24]         ;550
000276  b120              CBZ      r0,|L14.642|
000278  a0b8              ADR      r0,|L14.1372|
00027a  f7fffffe          BL       __2printf
00027e  bf00              NOP                            ;550
                  |L14.640|
000280  e7fe              B        |L14.640|
                  |L14.642|
000282  bf00              NOP                            ;550
000284  2201              MOVS     r2,#1                 ;552
000286  2000              MOVS     r0,#0                 ;552
000288  9904              LDR      r1,[sp,#0x10]         ;552
00028a  f7fffffe          BL       pbuf_alloc
00028e  9003              STR      r0,[sp,#0xc]          ;552
000290  b910              CBNZ     r0,|L14.664|
000292  bf00              NOP                            ;553
000294  bf00              NOP                            ;553
000296  e1ba              B        |L14.1550|
                  |L14.664|
000298  9810              LDR      r0,[sp,#0x40]         ;561
00029a  1981              ADDS     r1,r0,r6              ;561
00029c  9803              LDR      r0,[sp,#0xc]          ;561
00029e  6041              STR      r1,[r0,#4]            ;561
0002a0  2200              MOVS     r2,#0                 ;564
0002a2  4610              MOV      r0,r2                 ;564
0002a4  990b              LDR      r1,[sp,#0x2c]         ;564
0002a6  f7fffffe          BL       pbuf_alloc
0002aa  f1b00900          SUBS     r9,r0,#0              ;564
0002ae  d105              BNE      |L14.700|
0002b0  9803              LDR      r0,[sp,#0xc]          ;567
0002b2  f7fffffe          BL       pbuf_free
0002b6  bf00              NOP                            ;568
0002b8  bf00              NOP                            ;568
0002ba  e1a8              B        |L14.1550|
                  |L14.700|
0002bc  4648              MOV      r0,r9                 ;572
0002be  9903              LDR      r1,[sp,#0xc]          ;572
0002c0  f7fffffe          BL       pbuf_cat
0002c4  bf00              NOP                            ;573
                  |L14.710|
0002c6  4648              MOV      r0,r9                 ;575
0002c8  f7fffffe          BL       pbuf_clen
0002cc  990c              LDR      r1,[sp,#0x30]         ;575
0002ce  4408              ADD      r0,r0,r1              ;575
0002d0  b280              UXTH     r0,r0                 ;575
0002d2  900c              STR      r0,[sp,#0x30]         ;575
0002d4  980c              LDR      r0,[sp,#0x30]         ;580
0002d6  2810              CMP      r0,#0x10              ;580
0002d8  dc04              BGT      |L14.740|
0002da  f64f71fc          MOV      r1,#0xfffc            ;580
0002de  980c              LDR      r0,[sp,#0x30]         ;580
0002e0  4288              CMP      r0,r1                 ;580
0002e2  d905              BLS      |L14.752|
                  |L14.740|
0002e4  bf00              NOP                            ;581
0002e6  bf00              NOP                            ;581
0002e8  4648              MOV      r0,r9                 ;582
0002ea  f7fffffe          BL       pbuf_free
0002ee  e18e              B        |L14.1550|
                  |L14.752|
0002f0  980a              LDR      r0,[sp,#0x28]         ;586
0002f2  9000              STR      r0,[sp,#0]            ;586
0002f4  6de0              LDR      r0,[r4,#0x5c]         ;586
0002f6  1983              ADDS     r3,r0,r6              ;586
0002f8  2200              MOVS     r2,#0                 ;586
0002fa  4649              MOV      r1,r9                 ;586
0002fc  4620              MOV      r0,r4                 ;586
0002fe  f7fffffe          BL       tcp_create_segment
000302  f1b00a00          SUBS     r10,r0,#0             ;586
000306  d100              BNE      |L14.778|
000308  e181              B        |L14.1550|
                  |L14.778|
00030a  f8bd0024          LDRH     r0,[sp,#0x24]         ;590
00030e  f8aa000a          STRH     r0,[r10,#0xa]         ;590
000312  980d              LDR      r0,[sp,#0x34]         ;599
000314  b910              CBNZ     r0,|L14.796|
000316  f8cda034          STR      r10,[sp,#0x34]        ;600
00031a  e00b              B        |L14.820|
                  |L14.796|
00031c  bf00              NOP                            ;603
00031e  980e              LDR      r0,[sp,#0x38]         ;603
000320  b920              CBNZ     r0,|L14.812|
000322  a092              ADR      r0,|L14.1388|
000324  f7fffffe          BL       __2printf
000328  bf00              NOP                            ;603
                  |L14.810|
00032a  e7fe              B        |L14.810|
                  |L14.812|
00032c  bf00              NOP                            ;603
00032e  980e              LDR      r0,[sp,#0x38]         ;604
000330  f8c0a000          STR      r10,[r0,#0]           ;604
                  |L14.820|
000334  f8cda038          STR      r10,[sp,#0x38]        ;607
000338  bf00              NOP                            ;609
00033a  bf00              NOP                            ;609
00033c  9804              LDR      r0,[sp,#0x10]         ;613
00033e  4430              ADD      r0,r0,r6              ;613
000340  b286              UXTH     r6,r0                 ;613
000342  bf00              NOP                            ;614
                  |L14.836|
000344  42be              CMP      r6,r7                 ;522
000346  f6ffaf51          BLT      |L14.492|
00034a  f1b80f00          CMP      r8,#0                 ;626
00034e  dd2f              BLE      |L14.944|
000350  f8d59004          LDR      r9,[r5,#4]            ;629
000354  e017              B        |L14.902|
                  |L14.854|
000356  f8b90008          LDRH     r0,[r9,#8]            ;630
00035a  4440              ADD      r0,r0,r8              ;630
00035c  f8a90008          STRH     r0,[r9,#8]            ;630
000360  f8d90000          LDR      r0,[r9,#0]            ;631
000364  b968              CBNZ     r0,|L14.898|
000366  f8b9200a          LDRH     r2,[r9,#0xa]          ;632
00036a  f8d91004          LDR      r1,[r9,#4]            ;632
00036e  1888              ADDS     r0,r1,r2              ;632
000370  4642              MOV      r2,r8                 ;632
000372  9910              LDR      r1,[sp,#0x40]         ;632
000374  f7fffffe          BL       __aeabi_memcpy
000378  f8b9000a          LDRH     r0,[r9,#0xa]          ;633
00037c  4440              ADD      r0,r0,r8              ;633
00037e  f8a9000a          STRH     r0,[r9,#0xa]          ;633
                  |L14.898|
000382  f8d99000          LDR      r9,[r9,#0]            ;629
                  |L14.902|
000386  f1b90f00          CMP      r9,#0                 ;629
00038a  d1e4              BNE      |L14.854|
00038c  8928              LDRH     r0,[r5,#8]            ;636
00038e  4440              ADD      r0,r0,r8              ;636
000390  8128              STRH     r0,[r5,#8]            ;636
000392  bf00              NOP                            ;638
000394  8968              LDRH     r0,[r5,#0xa]          ;638
000396  4540              CMP      r0,r8                 ;638
000398  da04              BGE      |L14.932|
00039a  a079              ADR      r0,|L14.1408|
00039c  f7fffffe          BL       __2printf
0003a0  bf00              NOP                            ;638
                  |L14.930|
0003a2  e7fe              B        |L14.930|
                  |L14.932|
0003a4  bf00              NOP                            ;638
0003a6  8968              LDRH     r0,[r5,#0xa]          ;640
0003a8  eba00008          SUB      r0,r0,r8              ;640
0003ac  8168              STRH     r0,[r5,#0xa]          ;640
0003ae  bf00              NOP                            ;642
                  |L14.944|
0003b0  f8bd0024          LDRH     r0,[sp,#0x24]         ;643
0003b4  f8a4006a          STRH     r0,[r4,#0x6a]         ;643
0003b8  f1bb0f00          CMP      r11,#0                ;649
0003bc  d010              BEQ      |L14.992|
0003be  bf00              NOP                            ;650
0003c0  b925              CBNZ     r5,|L14.972|
0003c2  a07a              ADR      r0,|L14.1452|
0003c4  f7fffffe          BL       __2printf
0003c8  bf00              NOP                            ;650
                  |L14.970|
0003ca  e7fe              B        |L14.970|
                  |L14.972|
0003cc  bf00              NOP                            ;650
0003ce  4659              MOV      r1,r11                ;652
0003d0  6868              LDR      r0,[r5,#4]            ;652
0003d2  f7fffffe          BL       pbuf_cat
0003d6  8928              LDRH     r0,[r5,#8]            ;653
0003d8  f8bb1008          LDRH     r1,[r11,#8]           ;653
0003dc  4408              ADD      r0,r0,r1              ;653
0003de  8128              STRH     r0,[r5,#8]            ;653
                  |L14.992|
0003e0  b915              CBNZ     r5,|L14.1000|
0003e2  980d              LDR      r0,[sp,#0x34]         ;668
0003e4  66e0              STR      r0,[r4,#0x6c]         ;668
0003e6  e001              B        |L14.1004|
                  |L14.1000|
0003e8  980d              LDR      r0,[sp,#0x34]         ;670
0003ea  6028              STR      r0,[r5,#0]            ;670
                  |L14.1004|
0003ec  f8540f5c          LDR      r0,[r4,#0x5c]!        ;676
0003f0  4438              ADD      r0,r0,r7              ;676
0003f2  6020              STR      r0,[r4,#0]            ;676
0003f4  8960              LDRH     r0,[r4,#0xa]          ;677
0003f6  1bc0              SUBS     r0,r0,r7              ;677
0003f8  8160              STRH     r0,[r4,#0xa]          ;677
0003fa  980c              LDR      r0,[sp,#0x30]         ;678
0003fc  81a0              STRH     r0,[r4,#0xc]          ;678
0003fe  3c5c              SUBS     r4,r4,#0x5c           ;678
000400  bf00              NOP                            ;680
000402  bf00              NOP                            ;680
000404  f8b40068          LDRH     r0,[r4,#0x68]         ;682
000408  b150              CBZ      r0,|L14.1056|
00040a  bf00              NOP                            ;683
00040c  6f20              LDR      r0,[r4,#0x70]         ;683
00040e  b930              CBNZ     r0,|L14.1054|
000410  6ee0              LDR      r0,[r4,#0x6c]         ;683
000412  b920              CBNZ     r0,|L14.1054|
000414  a073              ADR      r0,|L14.1508|
000416  f7fffffe          BL       __2printf
00041a  bf00              NOP                            ;683
                  |L14.1052|
00041c  e7fe              B        |L14.1052|
                  |L14.1054|
00041e  bf00              NOP                            ;683
                  |L14.1056|
000420  f1ba0f00          CMP      r10,#0                ;688
000424  d00e              BEQ      |L14.1092|
000426  f8da0010          LDR      r0,[r10,#0x10]        ;688
00042a  b158              CBZ      r0,|L14.1092|
00042c  9812              LDR      r0,[sp,#0x48]         ;688
00042e  f0000002          AND      r0,r0,#2              ;688
000432  b938              CBNZ     r0,|L14.1092|
000434  2008              MOVS     r0,#8                 ;689
000436  f7fffffe          BL       lwip_htons
00043a  f8da1010          LDR      r1,[r10,#0x10]        ;689
00043e  8989              LDRH     r1,[r1,#0xc]          ;689
000440  4308              ORRS     r0,r0,r1              ;689
000442  e0df              B        |L14.1540|
                  |L14.1092|
000444  e0e1              B        |L14.1546|
000446  0000              DCW      0x0000
                  |L14.1096|
000448  7463705f          DCB      "tcp_write: arg == NULL (programmer violates API)",0
00044c  77726974
000450  653a2061
000454  7267203d
000458  3d204e55
00045c  4c4c2028
000460  70726f67
000464  72616d6d
000468  65722076
00046c  696f6c61
000470  74657320
000474  41504929
000478  00      
000479  00                DCB      0
00047a  00                DCB      0
00047b  00                DCB      0
                  |L14.1148|
00047c  756e7365          DCB      "unsent_oversize mismatch (pcb vs. last_unsent)",0
000480  6e745f6f
000484  76657273
000488  697a6520
00048c  6d69736d
000490  61746368
000494  20287063
000498  62207673
00049c  2e206c61
0004a0  73745f75
0004a4  6e73656e
0004a8  742900  
0004ab  00                DCB      0
                  |L14.1196|
0004ac  696e636f          DCB      "inconsistent oversize vs. space",0
0004b0  6e736973
0004b4  74656e74
0004b8  206f7665
0004bc  7273697a
0004c0  65207673
0004c4  2e207370
0004c8  61636500
                  |L14.1228|
0004cc  696e636f          DCB      "inconsistend oversize vs. len",0
0004d0  6e736973
0004d4  74656e64
0004d8  206f7665
0004dc  7273697a
0004e0  65207673
0004e4  2e206c65
0004e8  6e00    
0004ea  00                DCB      0
0004eb  00                DCB      0
                  |L14.1260|
0004ec  756e7365          DCB      "unsent_oversize mismatch (pcb->unsent is NULL)",0
0004f0  6e745f6f
0004f4  76657273
0004f8  697a6520
0004fc  6d69736d
000500  61746368
000504  20287063
000508  622d3e75
00050c  6e73656e
000510  74206973
000514  204e554c
000518  4c2900  
00051b  00                DCB      0
                  |L14.1308|
00051c  7463705f          DCB      "tcp_write: check that first pbuf can hold the complete "
000520  77726974
000524  653a2063
000528  6865636b
00052c  20746861
000530  74206669
000534  72737420
000538  70627566
00053c  2063616e
000540  20686f6c
000544  64207468
000548  6520636f
00054c  6d706c65
000550  746520  
000553  7365676c          DCB      "seglen",0
000557  656e00  
00055a  00                DCB      0
00055b  00                DCB      0
                  |L14.1372|
00055c  6f766572          DCB      "oversize == 0",0
000560  73697a65
000564  203d3d20
000568  3000    
00056a  00                DCB      0
00056b  00                DCB      0
                  |L14.1388|
00056c  70726576          DCB      "prev_seg != NULL",0
000570  5f736567
000574  20213d20
000578  4e554c4c
00057c  00      
00057d  00                DCB      0
00057e  00                DCB      0
00057f  00                DCB      0
                  |L14.1408|
000580  6c617374          DCB      "last_unsent->oversize_left >= oversize_used",0
000584  5f756e73
000588  656e742d
00058c  3e6f7665
000590  7273697a
000594  655f6c65
000598  6674203e
00059c  3d206f76
0005a0  65727369
0005a4  7a655f75
0005a8  73656400
                  |L14.1452|
0005ac  7463705f          DCB      "tcp_write: cannot concatenate when pcb->unsent is empty"
0005b0  77726974
0005b4  653a2063
0005b8  616e6e6f
0005bc  7420636f
0005c0  6e636174
0005c4  656e6174
0005c8  65207768
0005cc  656e2070
0005d0  63622d3e
0005d4  756e7365
0005d8  6e742069
0005dc  7320656d
0005e0  707479  
0005e3  00                DCB      0
                  |L14.1508|
0005e4  7463705f          DCB      "tcp_write: valid queue length",0
0005e8  77726974
0005ec  653a2076
0005f0  616c6964
0005f4  20717565
0005f8  7565206c
0005fc  656e6774
000600  6800    
000602  00                DCB      0
000603  00                DCB      0
                  |L14.1540|
000604  f8da1010          LDR      r1,[r10,#0x10]        ;689
000608  8188              STRH     r0,[r1,#0xc]          ;689
                  |L14.1546|
00060a  2000              MOVS     r0,#0                 ;692
00060c  e524              B        |L14.88|
                  |L14.1550|
00060e  7fa0              LDRB     r0,[r4,#0x1e]         ;694
000610  f0400080          ORR      r0,r0,#0x80           ;694
000614  77a0              STRB     r0,[r4,#0x1e]         ;694
000616  4813              LDR      r0,|L14.1636|
000618  f8b0009c          LDRH     r0,[r0,#0x9c]         ;695
00061c  1c40              ADDS     r0,r0,#1              ;695
00061e  b281              UXTH     r1,r0                 ;695
000620  4810              LDR      r0,|L14.1636|
000622  f8a0109c          STRH     r1,[r0,#0x9c]         ;695
000626  f1bb0f00          CMP      r11,#0                ;697
00062a  d002              BEQ      |L14.1586|
00062c  4658              MOV      r0,r11                ;698
00062e  f7fffffe          BL       pbuf_free
                  |L14.1586|
000632  980d              LDR      r0,[sp,#0x34]         ;700
000634  b110              CBZ      r0,|L14.1596|
000636  980d              LDR      r0,[sp,#0x34]         ;701
000638  f7fffffe          BL       tcp_segs_free
                  |L14.1596|
00063c  f8b40068          LDRH     r0,[r4,#0x68]         ;703
000640  b158              CBZ      r0,|L14.1626|
000642  bf00              NOP                            ;704
000644  6f20              LDR      r0,[r4,#0x70]         ;704
000646  b938              CBNZ     r0,|L14.1624|
000648  6ee0              LDR      r0,[r4,#0x6c]         ;704
00064a  b928              CBNZ     r0,|L14.1624|
00064c  f2af006c          ADR      r0,|L14.1508|
000650  f7fffffe          BL       __2printf
000654  bf00              NOP                            ;704
                  |L14.1622|
000656  e7fe              B        |L14.1622|
                  |L14.1624|
000658  bf00              NOP                            ;704
                  |L14.1626|
00065a  bf00              NOP                            ;707
00065c  bf00              NOP                            ;707
00065e  f04f30ff          MOV      r0,#0xffffffff        ;708
000662  e4f9              B        |L14.88|
;;;710    
                          ENDP

                  |L14.1636|
                          DCD      lwip_stats

                          AREA ||i.tcp_write_checks||, CODE, READONLY, ALIGN=2

                  tcp_write_checks PROC
;;;293    static err_t
;;;294    tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;295    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;296      /* connection is in invalid state for data transmission? */
;;;297      if ((pcb->state != ESTABLISHED) &&
000006  7e20              LDRB     r0,[r4,#0x18]
000008  2804              CMP      r0,#4
00000a  d00d              BEQ      |L15.40|
;;;298          (pcb->state != CLOSE_WAIT) &&
00000c  7e20              LDRB     r0,[r4,#0x18]
00000e  2807              CMP      r0,#7
000010  d00a              BEQ      |L15.40|
;;;299          (pcb->state != SYN_SENT) &&
000012  7e20              LDRB     r0,[r4,#0x18]
000014  2802              CMP      r0,#2
000016  d007              BEQ      |L15.40|
;;;300          (pcb->state != SYN_RCVD)) {
000018  7e20              LDRB     r0,[r4,#0x18]
00001a  2803              CMP      r0,#3
00001c  d004              BEQ      |L15.40|
;;;301        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
00001e  bf00              NOP      
000020  bf00              NOP      
;;;302        return ERR_CONN;
000022  f06f000c          MVN      r0,#0xc
                  |L15.38|
;;;303      } else if (len == 0) {
;;;304        return ERR_OK;
;;;305      }
;;;306    
;;;307      /* fail on too much data */
;;;308      if (len > pcb->snd_buf) {
;;;309        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
;;;310          len, pcb->snd_buf));
;;;311        pcb->flags |= TF_NAGLEMEMERR;
;;;312        return ERR_MEM;
;;;313      }
;;;314    
;;;315      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;316    
;;;317      /* If total number of pbufs on the unsent/unacked queues exceeds the
;;;318       * configured maximum, return an error */
;;;319      /* check for configured max queuelen and possible overflow */
;;;320      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;321        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
;;;322          pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;323        TCP_STATS_INC(tcp.memerr);
;;;324        pcb->flags |= TF_NAGLEMEMERR;
;;;325        return ERR_MEM;
;;;326      }
;;;327      if (pcb->snd_queuelen != 0) {
;;;328        LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
;;;329          pcb->unacked != NULL || pcb->unsent != NULL);
;;;330      } else {
;;;331        LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
;;;332          pcb->unacked == NULL && pcb->unsent == NULL);
;;;333      }
;;;334      return ERR_OK;
;;;335    }
000026  bd70              POP      {r4-r6,pc}
                  |L15.40|
000028  b90d              CBNZ     r5,|L15.46|
00002a  2000              MOVS     r0,#0                 ;304
00002c  e7fb              B        |L15.38|
                  |L15.46|
00002e  f8b40066          LDRH     r0,[r4,#0x66]         ;308
000032  42a8              CMP      r0,r5                 ;308
000034  da08              BGE      |L15.72|
000036  bf00              NOP                            ;309
000038  bf00              NOP                            ;309
00003a  7fa0              LDRB     r0,[r4,#0x1e]         ;311
00003c  f0400080          ORR      r0,r0,#0x80           ;311
000040  77a0              STRB     r0,[r4,#0x1e]         ;311
000042  f04f30ff          MOV      r0,#0xffffffff        ;312
000046  e7ee              B        |L15.38|
                  |L15.72|
000048  bf00              NOP                            ;315
00004a  bf00              NOP                            ;315
00004c  f8b40068          LDRH     r0,[r4,#0x68]         ;320
000050  2810              CMP      r0,#0x10              ;320
000052  da05              BGE      |L15.96|
000054  f8b40068          LDRH     r0,[r4,#0x68]         ;320
000058  f64f71fc          MOV      r1,#0xfffc            ;320
00005c  4288              CMP      r0,r1                 ;320
00005e  d910              BLS      |L15.130|
                  |L15.96|
000060  bf00              NOP                            ;321
000062  bf00              NOP                            ;321
000064  4814              LDR      r0,|L15.184|
000066  f8b0009c          LDRH     r0,[r0,#0x9c]         ;323
00006a  1c40              ADDS     r0,r0,#1              ;323
00006c  b281              UXTH     r1,r0                 ;323
00006e  4812              LDR      r0,|L15.184|
000070  f8a0109c          STRH     r1,[r0,#0x9c]         ;323
000074  7fa0              LDRB     r0,[r4,#0x1e]         ;324
000076  f0400080          ORR      r0,r0,#0x80           ;324
00007a  77a0              STRB     r0,[r4,#0x1e]         ;324
00007c  f04f30ff          MOV      r0,#0xffffffff        ;325
000080  e7d1              B        |L15.38|
                  |L15.130|
000082  f8b40068          LDRH     r0,[r4,#0x68]         ;327
000086  b150              CBZ      r0,|L15.158|
000088  bf00              NOP                            ;328
00008a  6f20              LDR      r0,[r4,#0x70]         ;328
00008c  b930              CBNZ     r0,|L15.156|
00008e  6ee0              LDR      r0,[r4,#0x6c]         ;328
000090  b920              CBNZ     r0,|L15.156|
000092  a00a              ADR      r0,|L15.188|
000094  f7fffffe          BL       __2printf
000098  bf00              NOP                            ;328
                  |L15.154|
00009a  e7fe              B        |L15.154|
                  |L15.156|
00009c  e00a              B        |L15.180|
                  |L15.158|
00009e  bf00              NOP                            ;331
0000a0  6f20              LDR      r0,[r4,#0x70]         ;331
0000a2  b908              CBNZ     r0,|L15.168|
0000a4  6ee0              LDR      r0,[r4,#0x6c]         ;331
0000a6  b120              CBZ      r0,|L15.178|
                  |L15.168|
0000a8  a013              ADR      r0,|L15.248|
0000aa  f7fffffe          BL       __2printf
0000ae  bf00              NOP                            ;331
                  |L15.176|
0000b0  e7fe              B        |L15.176|
                  |L15.178|
0000b2  bf00              NOP                            ;331
                  |L15.180|
0000b4  2000              MOVS     r0,#0                 ;334
0000b6  e7b6              B        |L15.38|
;;;336    
                          ENDP

                  |L15.184|
                          DCD      lwip_stats
                  |L15.188|
0000bc  7463705f          DCB      "tcp_write: pbufs on queue => at least one queue non-emp"
0000c0  77726974
0000c4  653a2070
0000c8  62756673
0000cc  206f6e20
0000d0  71756575
0000d4  65203d3e
0000d8  20617420
0000dc  6c656173
0000e0  74206f6e
0000e4  65207175
0000e8  65756520
0000ec  6e6f6e2d
0000f0  656d70  
0000f3  747900            DCB      "ty",0
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L15.248|
0000f8  7463705f          DCB      "tcp_write: no pbufs on queue => both queues empty",0
0000fc  77726974
000100  653a206e
000104  6f207062
000108  75667320
00010c  6f6e2071
000110  75657565
000114  203d3e20
000118  626f7468
00011c  20717565
000120  75657320
000124  656d7074
000128  7900    
00012a  00                DCB      0
00012b  00                DCB      0

                          AREA ||i.tcp_zero_window_probe||, CODE, READONLY, ALIGN=2

                  tcp_zero_window_probe PROC
;;;1413   void
;;;1414   tcp_zero_window_probe(struct tcp_pcb *pcb)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1415   {
000004  4605              MOV      r5,r0
;;;1416     struct pbuf *p;
;;;1417     struct tcp_hdr *tcphdr;
;;;1418     struct tcp_seg *seg;
;;;1419     u16_t len;
;;;1420     u8_t is_fin;
;;;1421   
;;;1422     LWIP_DEBUGF(TCP_DEBUG, 
000006  bf00              NOP      
000008  bf00              NOP      
;;;1423                 ("tcp_zero_window_probe: sending ZERO WINDOW probe to %"
;;;1424                  U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;1425                  ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1426                  ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1427   
;;;1428     LWIP_DEBUGF(TCP_DEBUG, 
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;1429                 ("tcp_zero_window_probe: tcp_ticks %"U32_F
;;;1430                  "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
;;;1431                  tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1432   
;;;1433     seg = pcb->unacked;
00000e  6f2c              LDR      r4,[r5,#0x70]
;;;1434   
;;;1435     if(seg == NULL) {
000010  b904              CBNZ     r4,|L16.20|
;;;1436       seg = pcb->unsent;
000012  6eec              LDR      r4,[r5,#0x6c]
                  |L16.20|
;;;1437     }
;;;1438     if(seg == NULL) {
000014  b90c              CBNZ     r4,|L16.26|
                  |L16.22|
;;;1439       return;
;;;1440     }
;;;1441   
;;;1442     is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
;;;1443     /* we want to send one seqno: either FIN or data (no options) */
;;;1444     len = is_fin ? 0 : 1;
;;;1445   
;;;1446     p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
;;;1447     if(p == NULL) {
;;;1448       LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
;;;1449       return;
;;;1450     }
;;;1451     tcphdr = (struct tcp_hdr *)p->payload;
;;;1452   
;;;1453     if (is_fin) {
;;;1454       /* FIN segment, no data */
;;;1455       TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
;;;1456     } else {
;;;1457       /* Data segment, copy in one byte from the head of the unacked queue */
;;;1458       char *d = ((char *)p->payload + TCP_HLEN);
;;;1459       /* Depending on whether the segment has already been sent (unacked) or not
;;;1460          (unsent), seg->p->payload points to the IP header or TCP header.
;;;1461          Ensure we copy the first TCP data byte: */
;;;1462       pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
;;;1463     }
;;;1464   
;;;1465   #if CHECKSUM_GEN_TCP
;;;1466     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
;;;1467                                         IP_PROTO_TCP, p->tot_len);
;;;1468   #endif
;;;1469     TCP_STATS_INC(tcp.xmit);
;;;1470   
;;;1471     /* Send output to IP */
;;;1472   #if LWIP_NETIF_HWADDRHINT
;;;1473     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1474       &(pcb->addr_hint));
;;;1475   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1476     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
;;;1477   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1478   
;;;1479     pbuf_free(p);
;;;1480   
;;;1481     LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
;;;1482                             " ackno %"U32_F".\n",
;;;1483                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1484   }
000016  e8bd87fc          POP      {r2-r10,pc}
                  |L16.26|
00001a  6921              LDR      r1,[r4,#0x10]         ;1442
00001c  8988              LDRH     r0,[r1,#0xc]          ;1442
00001e  f7fffffe          BL       lwip_ntohs
000022  f0000001          AND      r0,r0,#1              ;1442
000026  b118              CBZ      r0,|L16.48|
000028  8920              LDRH     r0,[r4,#8]            ;1442
00002a  b908              CBNZ     r0,|L16.48|
00002c  2001              MOVS     r0,#1                 ;1442
00002e  e000              B        |L16.50|
                  |L16.48|
000030  2000              MOVS     r0,#0                 ;1442
                  |L16.50|
000032  4680              MOV      r8,r0                 ;1442
000034  f1b80f00          CMP      r8,#0                 ;1444
000038  d101              BNE      |L16.62|
00003a  2001              MOVS     r0,#1                 ;1444
00003c  e000              B        |L16.64|
                  |L16.62|
00003e  2000              MOVS     r0,#0                 ;1444
                  |L16.64|
000040  4681              MOV      r9,r0                 ;1444
000042  6920              LDR      r0,[r4,#0x10]         ;1446
000044  6843              LDR      r3,[r0,#4]            ;1446
000046  464a              MOV      r2,r9                 ;1446
000048  2100              MOVS     r1,#0                 ;1446
00004a  4628              MOV      r0,r5                 ;1446
00004c  f7fffffe          BL       tcp_output_alloc_header
000050  4606              MOV      r6,r0                 ;1446
000052  b916              CBNZ     r6,|L16.90|
000054  bf00              NOP                            ;1448
000056  bf00              NOP                            ;1448
000058  e7dd              B        |L16.22|
                  |L16.90|
00005a  6877              LDR      r7,[r6,#4]            ;1451
00005c  f1b80f00          CMP      r8,#0                 ;1453
000060  d009              BEQ      |L16.118|
000062  2011              MOVS     r0,#0x11              ;1455
000064  f7fffffe          BL       lwip_htons
000068  89b9              LDRH     r1,[r7,#0xc]          ;1455
00006a  f24c02ff          MOV      r2,#0xc0ff            ;1455
00006e  4011              ANDS     r1,r1,r2              ;1455
000070  4308              ORRS     r0,r0,r1              ;1455
000072  81b8              STRH     r0,[r7,#0xc]          ;1455
000074  e00d              B        |L16.146|
                  |L16.118|
000076  6870              LDR      r0,[r6,#4]            ;1458
000078  f1000a14          ADD      r10,r0,#0x14          ;1458
00007c  6861              LDR      r1,[r4,#4]            ;1462
00007e  8909              LDRH     r1,[r1,#8]            ;1462
000080  8922              LDRH     r2,[r4,#8]            ;1462
000082  1a89              SUBS     r1,r1,r2              ;1462
000084  b28b              UXTH     r3,r1                 ;1462
000086  2201              MOVS     r2,#1                 ;1462
000088  4651              MOV      r1,r10                ;1462
00008a  6860              LDR      r0,[r4,#4]            ;1462
00008c  f7fffffe          BL       pbuf_copy_partial
000090  bf00              NOP                            ;1463
                  |L16.146|
000092  8930              LDRH     r0,[r6,#8]            ;1466
000094  2306              MOVS     r3,#6                 ;1466
000096  1d2a              ADDS     r2,r5,#4              ;1466
000098  4629              MOV      r1,r5                 ;1466
00009a  9000              STR      r0,[sp,#0]            ;1466
00009c  4630              MOV      r0,r6                 ;1466
00009e  f7fffffe          BL       inet_chksum_pseudo
0000a2  8238              STRH     r0,[r7,#0x10]         ;1466
0000a4  480b              LDR      r0,|L16.212|
0000a6  f8b00090          LDRH     r0,[r0,#0x90]         ;1469  ; lwip_stats
0000aa  1c40              ADDS     r0,r0,#1              ;1469
0000ac  4909              LDR      r1,|L16.212|
0000ae  f8a10090          STRH     r0,[r1,#0x90]         ;1469
0000b2  2006              MOVS     r0,#6                 ;1476
0000b4  2100              MOVS     r1,#0                 ;1476
0000b6  e9cd1000          STRD     r1,r0,[sp,#0]         ;1476
0000ba  7aab              LDRB     r3,[r5,#0xa]          ;1476
0000bc  1d2a              ADDS     r2,r5,#4              ;1476
0000be  4629              MOV      r1,r5                 ;1476
0000c0  4630              MOV      r0,r6                 ;1476
0000c2  f7fffffe          BL       ip_output
0000c6  4630              MOV      r0,r6                 ;1479
0000c8  f7fffffe          BL       pbuf_free
0000cc  bf00              NOP                            ;1481
0000ce  bf00              NOP                            ;1481
0000d0  bf00              NOP      
0000d2  e7a0              B        |L16.22|
;;;1485   #endif /* LWIP_TCP */
                          ENDP

                  |L16.212|
                          DCD      lwip_stats

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  7463705f          DCB      "tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in fl"
000004  656e7175
000008  6575655f
00000c  666c6167
000010  733a206e
000014  65656420
000018  65697468
00001c  65722054
000020  43505f53
000024  594e206f
000028  72205443
00002c  505f4649
000030  4e20696e
000034  20666c  
000037  61677320          DCB      "ags (programmer violates API)",0
00003b  2870726f
00003f  6772616d
000043  6d657220
000047  76696f6c
00004b  61746573
00004f  20415049
000053  2900    
