; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\enc28j60.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\enc28j60.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IE:\git_projects\enc28j60-for-uip\Project\RVMDK\RTE -I"D:\Program Files\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\enc28j60.crf ..\..\lwip\src\arch\ENC28J60.C]
                          THUMB

                          AREA ||i.enc28j60Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  enc28j60Init PROC
;;;186    ****************************************************************************/ 
;;;187    void enc28j60Init(unsigned char* macaddr)
000000  b570              PUSH     {r4-r6,lr}
;;;188    {
000002  4604              MOV      r4,r0
;;;189    	ENC28J60_CSH();	                              //SPI1 ENC28J60片选禁止  
000004  2010              MOVS     r0,#0x10
000006  496a              LDR      r1,|L1.432|
000008  6008              STR      r0,[r1,#0]
;;;190    	/* ENC28J60软件复位 
;;;191    	   系统命令（软件复位）（SC） 1 1 1 | 1 1 1 1 1    N/A */
;;;192    	enc28j60WriteOp(ENC28J60_SOFT_RESET, 0, ENC28J60_SOFT_RESET); 
00000a  22ff              MOVS     r2,#0xff
00000c  2100              MOVS     r1,#0
00000e  4610              MOV      r0,r2
000010  f7fffffe          BL       enc28j60WriteOp
;;;193        /*在上电复位或ENC28J60 从掉电模式恢复
;;;194    	  后，在发送数据包、使能接收数据包或允
;;;195    	  许访问任何MAC、MII 或PHY 寄存器之
;;;196    	  前，必须查询CLKRDY 位。*/
;;;197    	while(!(enc28j60Read(ESTAT) & ESTAT_CLKRDY)); //    
000014  bf00              NOP      
                  |L1.22|
000016  201d              MOVS     r0,#0x1d
000018  f7fffffe          BL       enc28j60Read
00001c  f0000001          AND      r0,r0,#1
000020  2800              CMP      r0,#0
000022  d0f8              BEQ      |L1.22|
;;;198    	// do bank 0 stuff
;;;199    	// initialize receive buffer
;;;200    	// 16-bit transfers, must write low byte first
;;;201    	// 设置接收缓冲区开始地址
;;;202    	NextPacketPtr = RXSTART_INIT;
000024  2000              MOVS     r0,#0
000026  4963              LDR      r1,|L1.436|
000028  6008              STR      r0,[r1,#0]  ; NextPacketPtr
;;;203            // Rx start
;;;204    	//接收缓冲器由一个硬件管理的循环FIFO 缓冲器构成。
;;;205    //寄存器对ERXSTH:ERXSTL 和ERXNDH:ERXNDL 作
;;;206    //为指针，定义缓冲器的容量和其在存储器中的位置。
;;;207    //ERXST和ERXND指向的字节均包含在FIFO缓冲器内。
;;;208    //当从以太网接口接收数据字节时，这些字节被顺序写入
;;;209    //接收缓冲器。 但是当写入由ERXND 指向的存储单元
;;;210    //后，硬件会自动将接收的下一字节写入由ERXST 指向
;;;211    //的存储单元。 因此接收硬件将不会写入FIFO 以外的单
;;;212    //元。
;;;213    	enc28j60Write(ERXSTL, RXSTART_INIT&0xFF);	 //
00002a  2100              MOVS     r1,#0
00002c  2008              MOVS     r0,#8
00002e  f7fffffe          BL       enc28j60Write
;;;214    	enc28j60Write(ERXSTH, RXSTART_INIT>>8);
000032  2100              MOVS     r1,#0
000034  2009              MOVS     r0,#9
000036  f7fffffe          BL       enc28j60Write
;;;215    	// set receive pointer address
;;;216    	//ERXWRPTH:ERXWRPTL 寄存器定义硬件向FIFO 中
;;;217        //的哪个位置写入其接收到的字节。 指针是只读的，在成
;;;218        //功接收到一个数据包后，硬件会自动更新指针。 指针可
;;;219        //用于判断FIFO 内剩余空间的大小  8K-1500。 
;;;220    	enc28j60Write(ERXRDPTL, RXSTART_INIT&0xFF);
00003a  2100              MOVS     r1,#0
00003c  200c              MOVS     r0,#0xc
00003e  f7fffffe          BL       enc28j60Write
;;;221    	enc28j60Write(ERXRDPTH, RXSTART_INIT>>8);
000042  2100              MOVS     r1,#0
000044  200d              MOVS     r0,#0xd
000046  f7fffffe          BL       enc28j60Write
;;;222    	// RX end  规定了接收区位于0---（0x1fff-0x600-1)
;;;223    	enc28j60Write(ERXNDL, RXSTOP_INIT&0xFF);
00004a  21fe              MOVS     r1,#0xfe
00004c  200a              MOVS     r0,#0xa
00004e  f7fffffe          BL       enc28j60Write
;;;224    	enc28j60Write(ERXNDH, RXSTOP_INIT>>8);
000052  2119              MOVS     r1,#0x19
000054  200b              MOVS     r0,#0xb
000056  f7fffffe          BL       enc28j60Write
;;;225    	// TX start	  0x1fff-0x600
;;;226    	enc28j60Write(ETXSTL, TXSTART_INIT&0xFF);
00005a  21ff              MOVS     r1,#0xff
00005c  2004              MOVS     r0,#4
00005e  f7fffffe          BL       enc28j60Write
;;;227    	enc28j60Write(ETXSTH, TXSTART_INIT>>8);
000062  2119              MOVS     r1,#0x19
000064  2005              MOVS     r0,#5
000066  f7fffffe          BL       enc28j60Write
;;;228    	// TX end	  规定了接收区位于0x1fff-0x600---0x1fff	 
;;;229    	enc28j60Write(ETXNDL, TXSTOP_INIT&0xFF);
00006a  21ff              MOVS     r1,#0xff
00006c  2006              MOVS     r0,#6
00006e  f7fffffe          BL       enc28j60Write
;;;230    	enc28j60Write(ETXNDH, TXSTOP_INIT>>8);
000072  211f              MOVS     r1,#0x1f
000074  2007              MOVS     r0,#7
000076  f7fffffe          BL       enc28j60Write
;;;231    	// do bank 1 stuff, packet filter:
;;;232            // For broadcast packets we allow only ARP packtets
;;;233            // All other packets should be unicast only for our mac (MAADR)
;;;234            //
;;;235            // The pattern to match on is therefore
;;;236            // Type     ETH.DST
;;;237            // ARP      BROADCAST
;;;238            // 06 08 -- ff ff ff ff ff ff -> ip checksum for theses bytes=f7f9
;;;239            // in binary these poitions are:11 0000 0011 1111
;;;240            // This is hex 303F->EPMM0=0x3f,EPMM1=0x30
;;;241        //接收过滤器
;;;242    	//UCEN：单播过滤器使能位
;;;243        //当ANDOR = 1 时：
;;;244    	//1 = 目标地址与本地MAC 地址不匹配的数据包将被丢弃
;;;245    	//0 = 禁止过滤器
;;;246    	//当ANDOR = 0 时：
;;;247    	//1 = 目标地址与本地MAC 地址匹配的数据包会被接受
;;;248    	//0 = 禁止过滤器
;;;249    
;;;250        //CRCEN：后过滤器CRC 校验使能位
;;;251    	//1 = 所有CRC 无效的数据包都将被丢弃
;;;252    	//0 = 不考虑CRC 是否有效
;;;253    	
;;;254    	//PMEN：格式匹配过滤器使能位
;;;255    	//当ANDOR = 1 时：
;;;256    	//1 = 数据包必须符合格式匹配条件，否则将被丢弃
;;;257    	//0 = 禁止过滤器
;;;258    	//当ANDOR = 0 时：
;;;259    	//1 = 符合格式匹配条件的数据包将被接受
;;;260    	//0 = 禁止过滤器
;;;261    	enc28j60Write(ERXFCON, ERXFCON_UCEN|ERXFCON_CRCEN|ERXFCON_PMEN);
00007a  21b0              MOVS     r1,#0xb0
00007c  2038              MOVS     r0,#0x38
00007e  f7fffffe          BL       enc28j60Write
;;;262    	enc28j60Write(EPMM0, 0x3f);
000082  213f              MOVS     r1,#0x3f
000084  2028              MOVS     r0,#0x28
000086  f7fffffe          BL       enc28j60Write
;;;263    	enc28j60Write(EPMM1, 0x30);
00008a  2130              MOVS     r1,#0x30
00008c  2029              MOVS     r0,#0x29
00008e  f7fffffe          BL       enc28j60Write
;;;264    	enc28j60Write(EPMCSL, 0xf9);
000092  21f9              MOVS     r1,#0xf9
000094  2030              MOVS     r0,#0x30
000096  f7fffffe          BL       enc28j60Write
;;;265    	enc28j60Write(EPMCSH, 0xf7);
00009a  21f7              MOVS     r1,#0xf7
00009c  2031              MOVS     r0,#0x31
00009e  f7fffffe          BL       enc28j60Write
;;;266            //
;;;267            //
;;;268    	// do bank 2 stuff
;;;269    	// enable MAC receive
;;;270    	//bit 0 MARXEN：MAC 接收使能位
;;;271    		//1 = 允许MAC 接收数据包
;;;272    		//0 = 禁止数据包接收
;;;273    	//bit 3 TXPAUS：暂停控制帧发送使能位
;;;274    		//1 = 允许MAC 发送暂停控制帧（用于全双工模式下的流量控制）
;;;275    		//0 = 禁止暂停帧发送
;;;276    	//bit 2 RXPAUS：暂停控制帧接收使能位
;;;277    		//1 = 当接收到暂停控制帧时，禁止发送（正常操作）
;;;278    		//0 = 忽略接收到的暂停控制帧
;;;279    	enc28j60Write(MACON1, MACON1_MARXEN|MACON1_TXPAUS|MACON1_RXPAUS);
0000a2  210d              MOVS     r1,#0xd
0000a4  20c0              MOVS     r0,#0xc0
0000a6  f7fffffe          BL       enc28j60Write
;;;280    	// bring MAC out of reset
;;;281    	//将MACON2 中的MARST 位清零，使MAC 退出复位状态。
;;;282    	enc28j60Write(MACON2, 0x00);
0000aa  2100              MOVS     r1,#0
0000ac  20c1              MOVS     r0,#0xc1
0000ae  f7fffffe          BL       enc28j60Write
;;;283    	// enable automatic padding to 60bytes and CRC operations
;;;284    	//bit 7-5 PADCFG2:PACDFG0：自动填充和CRC 配置位
;;;285    		//111 = 用0 填充所有短帧至64 字节长，并追加一个有效的CRC
;;;286    		//110 = 不自动填充短帧
;;;287    		//101 = MAC 自动检测具有8100h 类型字段的VLAN 协议帧，并自动填充到64 字节长。如果不
;;;288    		//是VLAN 帧，则填充至60 字节长。填充后还要追加一个有效的CRC
;;;289    		//100 = 不自动填充短帧
;;;290    		//011 = 用0 填充所有短帧至64 字节长，并追加一个有效的CRC
;;;291    		//010 = 不自动填充短帧
;;;292    		//001 = 用0 填充所有短帧至60 字节长，并追加一个有效的CRC
;;;293    		//000 = 不自动填充短帧
;;;294    	//bit 4 TXCRCEN：发送CRC 使能位
;;;295    		//1 = 不管PADCFG如何，MAC都会在发送帧的末尾追加一个有效的CRC。 如果PADCFG规定要
;;;296    		//追加有效的CRC，则必须将TXCRCEN 置1。
;;;297    		//0 = MAC不会追加CRC。 检查最后4 个字节，如果不是有效的CRC 则报告给发送状态向量。
;;;298    	//bit 0 FULDPX：MAC 全双工使能位
;;;299    		//1 = MAC工作在全双工模式下。 PHCON1.PDPXMD 位必须置1。
;;;300    		//0 = MAC工作在半双工模式下。 PHCON1.PDPXMD 位必须清零。
;;;301    	/* 提示 由于ENC28J60不支持802.3的自动协商机制， 所以对端的网络卡需要强制设置为全双工 */
;;;302    	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN|MACON3_FULDPX);
0000b2  2233              MOVS     r2,#0x33
0000b4  21c2              MOVS     r1,#0xc2
0000b6  2080              MOVS     r0,#0x80
0000b8  f7fffffe          BL       enc28j60WriteOp
;;;303    	// set inter-frame gap (non-back-to-back)
;;;304    	//配置非背对背包间间隔寄存器的低字节
;;;305    	//MAIPGL。 大多数应用使用12h 编程该寄存器。
;;;306    	//如果使用半双工模式，应编程非背对背包间间隔
;;;307    	//寄存器的高字节MAIPGH。 大多数应用使用0Ch
;;;308    	//编程该寄存器。
;;;309    	enc28j60Write(MAIPGL, 0x12);
0000bc  2112              MOVS     r1,#0x12
0000be  20c6              MOVS     r0,#0xc6
0000c0  f7fffffe          BL       enc28j60Write
;;;310    	enc28j60Write(MAIPGH, 0x0C);
0000c4  210c              MOVS     r1,#0xc
0000c6  20c7              MOVS     r0,#0xc7
0000c8  f7fffffe          BL       enc28j60Write
;;;311    	// set inter-frame gap (back-to-back)
;;;312    	//配置背对背包间间隔寄存器MABBIPG。当使用
;;;313    	//全双工模式时，大多数应用使用15h 编程该寄存
;;;314    	//器，而使用半双工模式时则使用12h 进行编程。
;;;315    	enc28j60Write(MABBIPG, 0x15);
0000cc  2115              MOVS     r1,#0x15
0000ce  20c4              MOVS     r0,#0xc4
0000d0  f7fffffe          BL       enc28j60Write
;;;316    	// Set the maximum packet size which the controller will accept
;;;317        // Do not send packets longer than MAX_FRAMELEN:
;;;318    	// 最大帧长度  1500
;;;319    	enc28j60Write(MAMXFLL, MAX_FRAMELEN&0xFF);	
0000d4  21dc              MOVS     r1,#0xdc
0000d6  20ca              MOVS     r0,#0xca
0000d8  f7fffffe          BL       enc28j60Write
;;;320    	enc28j60Write(MAMXFLH, MAX_FRAMELEN>>8);
0000dc  2105              MOVS     r1,#5
0000de  20cb              MOVS     r0,#0xcb
0000e0  f7fffffe          BL       enc28j60Write
;;;321    	// do bank 3 stuff
;;;322    	// write MAC address
;;;323    	// NOTE: MAC address in ENC28J60 is byte-backward
;;;324    	enc28j60Write(MAADR5, macaddr[0]);	
0000e4  7821              LDRB     r1,[r4,#0]
0000e6  20e4              MOVS     r0,#0xe4
0000e8  f7fffffe          BL       enc28j60Write
;;;325    	enc28j60Write(MAADR4, macaddr[1]);
0000ec  7861              LDRB     r1,[r4,#1]
0000ee  20e5              MOVS     r0,#0xe5
0000f0  f7fffffe          BL       enc28j60Write
;;;326    	enc28j60Write(MAADR3, macaddr[2]);
0000f4  78a1              LDRB     r1,[r4,#2]
0000f6  20e2              MOVS     r0,#0xe2
0000f8  f7fffffe          BL       enc28j60Write
;;;327    	enc28j60Write(MAADR2, macaddr[3]);
0000fc  78e1              LDRB     r1,[r4,#3]
0000fe  20e3              MOVS     r0,#0xe3
000100  f7fffffe          BL       enc28j60Write
;;;328    	enc28j60Write(MAADR1, macaddr[4]);
000104  7921              LDRB     r1,[r4,#4]
000106  20e0              MOVS     r0,#0xe0
000108  f7fffffe          BL       enc28j60Write
;;;329    	enc28j60Write(MAADR0, macaddr[5]);
00010c  7961              LDRB     r1,[r4,#5]
00010e  20e1              MOVS     r0,#0xe1
000110  f7fffffe          BL       enc28j60Write
;;;330    	if(enc28j60Read(MAADR5)== macaddr[0]){
000114  20e4              MOVS     r0,#0xe4
000116  f7fffffe          BL       enc28j60Read
00011a  7821              LDRB     r1,[r4,#0]
00011c  4288              CMP      r0,r1
00011e  d12f              BNE      |L1.384|
;;;331    		printf("MAADR5 = %x\r\n", enc28j60Read(MAADR5));
000120  20e4              MOVS     r0,#0xe4
000122  f7fffffe          BL       enc28j60Read
000126  4605              MOV      r5,r0
000128  4629              MOV      r1,r5
00012a  a023              ADR      r0,|L1.440|
00012c  f7fffffe          BL       __2printf
;;;332    		printf("MAADR4 = %x\r\n", enc28j60Read(MAADR4));
000130  20e5              MOVS     r0,#0xe5
000132  f7fffffe          BL       enc28j60Read
000136  4605              MOV      r5,r0
000138  4629              MOV      r1,r5
00013a  a023              ADR      r0,|L1.456|
00013c  f7fffffe          BL       __2printf
;;;333    		printf("MAADR3 = %x\r\n", enc28j60Read(MAADR3));
000140  20e2              MOVS     r0,#0xe2
000142  f7fffffe          BL       enc28j60Read
000146  4605              MOV      r5,r0
000148  4629              MOV      r1,r5
00014a  a023              ADR      r0,|L1.472|
00014c  f7fffffe          BL       __2printf
;;;334    		printf("MAADR2 = %x\r\n", enc28j60Read(MAADR2));
000150  20e3              MOVS     r0,#0xe3
000152  f7fffffe          BL       enc28j60Read
000156  4605              MOV      r5,r0
000158  4629              MOV      r1,r5
00015a  a023              ADR      r0,|L1.488|
00015c  f7fffffe          BL       __2printf
;;;335    		printf("MAADR1 = %x\r\n", enc28j60Read(MAADR1));
000160  20e0              MOVS     r0,#0xe0
000162  f7fffffe          BL       enc28j60Read
000166  4605              MOV      r5,r0
000168  4629              MOV      r1,r5
00016a  a023              ADR      r0,|L1.504|
00016c  f7fffffe          BL       __2printf
;;;336    		printf("MAADR0 = %x\r\n", enc28j60Read(MAADR0));
000170  20e1              MOVS     r0,#0xe1
000172  f7fffffe          BL       enc28j60Read
000176  4605              MOV      r5,r0
000178  4629              MOV      r1,r5
00017a  a023              ADR      r0,|L1.520|
00017c  f7fffffe          BL       __2printf
                  |L1.384|
;;;337    	}
;;;338    	//配置PHY为全双工  LEDB为拉电流
;;;339    	enc28j60PhyWrite(PHCON1, PHCON1_PDPXMD);
000180  f44f7180          MOV      r1,#0x100
000184  2000              MOVS     r0,#0
000186  f7fffffe          BL       enc28j60PhyWrite
;;;340    
;;;341    
;;;342    	// no loopback of transmitted frames	 禁止环回
;;;343        //HDLDIS：PHY 半双工环回禁止位
;;;344    		//当PHCON1.PDPXMD = 1 或PHCON1.PLOOPBK = 1 时：
;;;345    		//此位可被忽略。
;;;346    		//当PHCON1.PDPXMD = 0 且PHCON1.PLOOPBK = 0 时：
;;;347    		//1 = 要发送的数据仅通过双绞线接口发出
;;;348    		//0 = 要发送的数据会环回到MAC 并通过双绞线接口发出
;;;349    	enc28j60PhyWrite(PHCON2, PHCON2_HDLDIS);
00018a  f44f7180          MOV      r1,#0x100
00018e  2010              MOVS     r0,#0x10
000190  f7fffffe          BL       enc28j60PhyWrite
;;;350    	// switch to bank 0
;;;351    	//ECON1 寄存器
;;;352    		//寄存器3-1 所示为ECON1 寄存器，它用于控制
;;;353    		//ENC28J60 的主要功能。 ECON1 中包含接收使能、发
;;;354    		//送请求、DMA 控制和存储区选择位。
;;;355    	
;;;356    	enc28j60SetBank(ECON1);
000194  201f              MOVS     r0,#0x1f
000196  f7fffffe          BL       enc28j60SetBank
;;;357    	// enable interrutps
;;;358    	//EIE： 以太网中断允许寄存器
;;;359    	//bit 7 INTIE： 全局INT 中断允许位
;;;360    		//1 = 允许中断事件驱动INT 引脚
;;;361    		//0 = 禁止所有INT 引脚的活动（引脚始终被驱动为高电平）
;;;362    	//bit 6 PKTIE： 接收数据包待处理中断允许位
;;;363    		//1 = 允许接收数据包待处理中断
;;;364    		//0 = 禁止接收数据包待处理中断
;;;365    	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE|EIE_RXERIE);
00019a  22c1              MOVS     r2,#0xc1
00019c  211b              MOVS     r1,#0x1b
00019e  2080              MOVS     r0,#0x80
0001a0  f7fffffe          BL       enc28j60WriteOp
;;;366    	// enable packet reception
;;;367    	//bit 2 RXEN：接收使能位
;;;368    		//1 = 通过当前过滤器的数据包将被写入接收缓冲器
;;;369    		//0 = 忽略所有接收的数据包
;;;370    	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
0001a4  2204              MOVS     r2,#4
0001a6  211f              MOVS     r1,#0x1f
0001a8  2080              MOVS     r0,#0x80
0001aa  f7fffffe          BL       enc28j60WriteOp
;;;371    	}
0001ae  bd70              POP      {r4-r6,pc}
;;;372    
                          ENDP

                  |L1.432|
                          DCD      0x40010810
                  |L1.436|
                          DCD      NextPacketPtr
                  |L1.440|
0001b8  4d414144          DCB      "MAADR5 = %x\r\n",0
0001bc  5235203d
0001c0  2025780d
0001c4  0a00    
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L1.456|
0001c8  4d414144          DCB      "MAADR4 = %x\r\n",0
0001cc  5234203d
0001d0  2025780d
0001d4  0a00    
0001d6  00                DCB      0
0001d7  00                DCB      0
                  |L1.472|
0001d8  4d414144          DCB      "MAADR3 = %x\r\n",0
0001dc  5233203d
0001e0  2025780d
0001e4  0a00    
0001e6  00                DCB      0
0001e7  00                DCB      0
                  |L1.488|
0001e8  4d414144          DCB      "MAADR2 = %x\r\n",0
0001ec  5232203d
0001f0  2025780d
0001f4  0a00    
0001f6  00                DCB      0
0001f7  00                DCB      0
                  |L1.504|
0001f8  4d414144          DCB      "MAADR1 = %x\r\n",0
0001fc  5231203d
000200  2025780d
000204  0a00    
000206  00                DCB      0
000207  00                DCB      0
                  |L1.520|
000208  4d414144          DCB      "MAADR0 = %x\r\n",0
00020c  5230203d
000210  2025780d
000214  0a00    
000216  00                DCB      0
000217  00                DCB      0

                          AREA ||i.enc28j60PacketReceive||, CODE, READONLY, ALIGN=2

                  enc28j60PacketReceive PROC
;;;434    ****************************************************************************/ 
;;;435    unsigned int enc28j60PacketReceive(unsigned int maxlen, unsigned char* packet)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;436    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;437    	unsigned int rxstat;
;;;438    	unsigned int len;
;;;439    
;;;440    	//检查是否收到一个包
;;;441    	if( enc28j60Read(EPKTCNT) ==0 )  			//收到的以太网数据包长度   EPKCNT中记录了接收到的以太网包的数据长度信息；
000008  2039              MOVS     r0,#0x39
00000a  f7fffffe          BL       enc28j60Read
00000e  b910              CBNZ     r0,|L2.22|
;;;442    	{
;;;443    		return(0);
000010  2000              MOVS     r0,#0
                  |L2.18|
;;;444        }
;;;445    
;;;446    	// 设置接收缓冲器读指针
;;;447    	enc28j60Write(ERDPTL, (NextPacketPtr));
;;;448    	enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
;;;449    
;;;450    	// 读下一个包的指针
;;;451    	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
;;;452    	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
;;;453    
;;;454    	// 读包的长度
;;;455    	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
;;;456    	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
;;;457    
;;;458        len-=4; 				//删除CRC计数
;;;459    	// 读接收状态
;;;460    	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
;;;461    	rxstat |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
;;;462    
;;;463    	// 限制检索的长度	  
;;;464        if (len>maxlen-1)
;;;465    	{
;;;466            len=maxlen-1;
;;;467       	}
;;;468    
;;;469        // 检查CRC和符号错误
;;;470        //  ERXFCON.CRCEN是默认设置。通常我们不需要检查
;;;471        if ((rxstat & 0x80)==0)
;;;472    	{
;;;473    	   //无效的
;;;474    	   len=0;
;;;475    	}
;;;476    	else
;;;477    	{
;;;478           // 从接收缓冲器中复制数据包
;;;479            enc28j60ReadBuffer(len, packet);
;;;480        }
;;;481    
;;;482    	//RX读指针移动到下一个接收到的数据包的开始位置 
;;;483    	//释放我们刚才读出过的内存
;;;484    	enc28j60Write(ERXRDPTL, (NextPacketPtr));
;;;485    	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
;;;486    
;;;487    	//递减数据包计数器标志我们已经得到了这个包 
;;;488    	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
;;;489    	return(len);
;;;490    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L2.22|
000016  4829              LDR      r0,|L2.188|
000018  7801              LDRB     r1,[r0,#0]            ;447  ; NextPacketPtr
00001a  2000              MOVS     r0,#0                 ;447
00001c  f7fffffe          BL       enc28j60Write
000020  4826              LDR      r0,|L2.188|
000022  8800              LDRH     r0,[r0,#0]            ;448  ; NextPacketPtr
000024  f3c02107          UBFX     r1,r0,#8,#8           ;448
000028  2001              MOVS     r0,#1                 ;448
00002a  f7fffffe          BL       enc28j60Write
00002e  2100              MOVS     r1,#0                 ;451
000030  203a              MOVS     r0,#0x3a              ;451
000032  f7fffffe          BL       enc28j60ReadOp
000036  4921              LDR      r1,|L2.188|
000038  6008              STR      r0,[r1,#0]            ;451  ; NextPacketPtr
00003a  2100              MOVS     r1,#0                 ;452
00003c  203a              MOVS     r0,#0x3a              ;452
00003e  f7fffffe          BL       enc28j60ReadOp
000042  491e              LDR      r1,|L2.188|
000044  6809              LDR      r1,[r1,#0]            ;452  ; NextPacketPtr
000046  ea412000          ORR      r0,r1,r0,LSL #8       ;452
00004a  491c              LDR      r1,|L2.188|
00004c  6008              STR      r0,[r1,#0]            ;452  ; NextPacketPtr
00004e  2100              MOVS     r1,#0                 ;455
000050  203a              MOVS     r0,#0x3a              ;455
000052  f7fffffe          BL       enc28j60ReadOp
000056  4604              MOV      r4,r0                 ;455
000058  2100              MOVS     r1,#0                 ;456
00005a  203a              MOVS     r0,#0x3a              ;456
00005c  f7fffffe          BL       enc28j60ReadOp
000060  ea442400          ORR      r4,r4,r0,LSL #8       ;456
000064  1f24              SUBS     r4,r4,#4              ;458
000066  2100              MOVS     r1,#0                 ;460
000068  203a              MOVS     r0,#0x3a              ;460
00006a  f7fffffe          BL       enc28j60ReadOp
00006e  4606              MOV      r6,r0                 ;460
000070  2100              MOVS     r1,#0                 ;461
000072  203a              MOVS     r0,#0x3a              ;461
000074  f7fffffe          BL       enc28j60ReadOp
000078  ea462600          ORR      r6,r6,r0,LSL #8       ;461
00007c  1e68              SUBS     r0,r5,#1              ;464
00007e  42a0              CMP      r0,r4                 ;464
000080  d200              BCS      |L2.132|
000082  1e6c              SUBS     r4,r5,#1              ;466
                  |L2.132|
000084  f0060080          AND      r0,r6,#0x80           ;471
000088  b908              CBNZ     r0,|L2.142|
00008a  2400              MOVS     r4,#0                 ;474
00008c  e003              B        |L2.150|
                  |L2.142|
00008e  4639              MOV      r1,r7                 ;479
000090  4620              MOV      r0,r4                 ;479
000092  f7fffffe          BL       enc28j60ReadBuffer
                  |L2.150|
000096  4809              LDR      r0,|L2.188|
000098  7801              LDRB     r1,[r0,#0]            ;484  ; NextPacketPtr
00009a  200c              MOVS     r0,#0xc               ;484
00009c  f7fffffe          BL       enc28j60Write
0000a0  4806              LDR      r0,|L2.188|
0000a2  8800              LDRH     r0,[r0,#0]            ;485  ; NextPacketPtr
0000a4  f3c02107          UBFX     r1,r0,#8,#8           ;485
0000a8  200d              MOVS     r0,#0xd               ;485
0000aa  f7fffffe          BL       enc28j60Write
0000ae  2240              MOVS     r2,#0x40              ;488
0000b0  211e              MOVS     r1,#0x1e              ;488
0000b2  2080              MOVS     r0,#0x80              ;488
0000b4  f7fffffe          BL       enc28j60WriteOp
0000b8  4620              MOV      r0,r4                 ;489
0000ba  e7aa              B        |L2.18|
;;;491    
                          ENDP

                  |L2.188|
                          DCD      NextPacketPtr

                          AREA ||i.enc28j60PacketSend||, CODE, READONLY, ALIGN=1

                  enc28j60PacketSend PROC
;;;396    ****************************************************************************/ 
;;;397    void enc28j60PacketSend(unsigned int len, unsigned char* packet)
000000  b570              PUSH     {r4-r6,lr}
;;;398    	{
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;399    	// 设置发送缓冲区地址写指针入口 Set the write pointer to start of transmit buffer area
;;;400    	while((enc28j60Read(ECON1) & ECON1_TXRTS)!=0); //    
000006  bf00              NOP      
                  |L3.8|
000008  201f              MOVS     r0,#0x1f
00000a  f7fffffe          BL       enc28j60Read
00000e  f0000008          AND      r0,r0,#8
000012  2800              CMP      r0,#0
000014  d1f8              BNE      |L3.8|
;;;401    	enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
000016  21ff              MOVS     r1,#0xff
000018  2002              MOVS     r0,#2
00001a  f7fffffe          BL       enc28j60Write
;;;402    	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
00001e  2119              MOVS     r1,#0x19
000020  2003              MOVS     r0,#3
000022  f7fffffe          BL       enc28j60Write
;;;403    
;;;404    	//设置TXND指针，以对应给定的数据包大小	   
;;;405    	enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
000026  20ff              MOVS     r0,#0xff
000028  4420              ADD      r0,r0,r4
00002a  b2c1              UXTB     r1,r0
00002c  2006              MOVS     r0,#6
00002e  f7fffffe          BL       enc28j60Write
;;;406    	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
000032  f64110ff          MOV      r0,#0x19ff
000036  4420              ADD      r0,r0,r4
000038  f3c02107          UBFX     r1,r0,#8,#8
00003c  2007              MOVS     r0,#7
00003e  f7fffffe          BL       enc28j60Write
;;;407    
;;;408    	// 写每包控制字节（0x00表示使用macon3的设置） 
;;;409    	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
000042  2200              MOVS     r2,#0
000044  4611              MOV      r1,r2
000046  207a              MOVS     r0,#0x7a
000048  f7fffffe          BL       enc28j60WriteOp
;;;410    
;;;411    	// 将数据包复制到发送缓冲区	
;;;412    	enc28j60WriteBuffer(len, packet);
00004c  4629              MOV      r1,r5
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       enc28j60WriteBuffer
;;;413    
;;;414    	// 在网络上发送发送缓冲区的内容  
;;;415    	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
000054  2208              MOVS     r2,#8
000056  211f              MOVS     r1,#0x1f
000058  2080              MOVS     r0,#0x80
00005a  f7fffffe          BL       enc28j60WriteOp
;;;416    
;;;417        // 复位发送逻辑的问题。参见 Rev. B4 Silicon Errata point 12.
;;;418    	if( (enc28j60Read(EIR) & EIR_TXERIF) )
00005e  201c              MOVS     r0,#0x1c
000060  f7fffffe          BL       enc28j60Read
000064  f0000002          AND      r0,r0,#2
000068  b138              CBZ      r0,|L3.122|
;;;419    	{
;;;420    		enc28j60SetBank(ECON1);
00006a  201f              MOVS     r0,#0x1f
00006c  f7fffffe          BL       enc28j60SetBank
;;;421            enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
000070  2208              MOVS     r2,#8
000072  211f              MOVS     r1,#0x1f
000074  20a0              MOVS     r0,#0xa0
000076  f7fffffe          BL       enc28j60WriteOp
                  |L3.122|
;;;422    		//enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRST);
;;;423        }
;;;424    }
00007a  bd70              POP      {r4-r6,pc}
;;;425    /****************************************************************************
                          ENDP


                          AREA ||i.enc28j60PhyWrite||, CODE, READONLY, ALIGN=1

                  enc28j60PhyWrite PROC
;;;155    ****************************************************************************/ 
;;;156    void enc28j60PhyWrite(unsigned char address, unsigned int data)
000000  b570              PUSH     {r4-r6,lr}
;;;157    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;158    	// set the PHY register address
;;;159    	enc28j60Write(MIREGADR, address);
000006  4629              MOV      r1,r5
000008  20d4              MOVS     r0,#0xd4
00000a  f7fffffe          BL       enc28j60Write
;;;160    	// write the PHY data
;;;161    	enc28j60Write(MIWRL, data);
00000e  b2e1              UXTB     r1,r4
000010  20d6              MOVS     r0,#0xd6
000012  f7fffffe          BL       enc28j60Write
;;;162    	enc28j60Write(MIWRH, data>>8);
000016  f3c42107          UBFX     r1,r4,#8,#8
00001a  20d7              MOVS     r0,#0xd7
00001c  f7fffffe          BL       enc28j60Write
;;;163    	// 等待PHY寄存器写入完成
;;;164    	while(enc28j60Read(MISTAT) & MISTAT_BUSY);
000020  bf00              NOP      
                  |L4.34|
000022  20ea              MOVS     r0,#0xea
000024  f7fffffe          BL       enc28j60Read
000028  f0000001          AND      r0,r0,#1
00002c  2800              CMP      r0,#0
00002e  d1f8              BNE      |L4.34|
;;;165    }
000030  bd70              POP      {r4-r6,pc}
;;;166    /****************************************************************************
                          ENDP


                          AREA ||i.enc28j60Read||, CODE, READONLY, ALIGN=1

                  enc28j60Read PROC
;;;125    ****************************************************************************/ 
;;;126    unsigned char enc28j60Read(unsigned char address)
000000  b510              PUSH     {r4,lr}
;;;127    {
000002  4604              MOV      r4,r0
;;;128    	// set the bank
;;;129    	enc28j60SetBank(address);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       enc28j60SetBank
;;;130    	// do the read
;;;131    	return enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
00000a  4621              MOV      r1,r4
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       enc28j60ReadOp
;;;132    }
000012  bd10              POP      {r4,pc}
;;;133    /****************************************************************************
                          ENDP


                          AREA ||i.enc28j60ReadBuffer||, CODE, READONLY, ALIGN=2

                  enc28j60ReadBuffer PROC
;;;61     ****************************************************************************/ 
;;;62     void enc28j60ReadBuffer(unsigned int len, unsigned char* data)
000000  b570              PUSH     {r4-r6,lr}
;;;63     	{
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;64     	ENC28J60_CSL();
000006  2010              MOVS     r0,#0x10
000008  490a              LDR      r1,|L6.52|
00000a  6008              STR      r0,[r1,#0]
;;;65     	// 读命令
;;;66     	SPI1_ReadWrite(ENC28J60_READ_BUF_MEM);
00000c  203a              MOVS     r0,#0x3a
00000e  f7fffffe          BL       SPI1_ReadWrite
;;;67     	while(len)
000012  e005              B        |L6.32|
                  |L6.20|
;;;68     	{
;;;69             len--;
000014  1e6d              SUBS     r5,r5,#1
;;;70             // read data
;;;71             *data = (unsigned char)SPI1_ReadWrite(0);
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       SPI1_ReadWrite
00001c  7020              STRB     r0,[r4,#0]
;;;72             data++;
00001e  1c64              ADDS     r4,r4,#1
                  |L6.32|
000020  2d00              CMP      r5,#0                 ;67
000022  d1f7              BNE      |L6.20|
;;;73     	}
;;;74     	*data='\0';
000024  2000              MOVS     r0,#0
000026  7020              STRB     r0,[r4,#0]
;;;75     	ENC28J60_CSH();
000028  2010              MOVS     r0,#0x10
00002a  4902              LDR      r1,|L6.52|
00002c  1f09              SUBS     r1,r1,#4
00002e  6008              STR      r0,[r1,#0]
;;;76     }
000030  bd70              POP      {r4-r6,pc}
;;;77     /****************************************************************************
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      0x40010814

                          AREA ||i.enc28j60ReadOp||, CODE, READONLY, ALIGN=2

                  enc28j60ReadOp PROC
;;;17     ****************************************************************************/ 
;;;18     unsigned char enc28j60ReadOp(unsigned char op, unsigned char address)
000000  b570              PUSH     {r4-r6,lr}
;;;19     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;20     	unsigned char dat = 0;
000006  2600              MOVS     r6,#0
;;;21     	
;;;22     	ENC28J60_CSL();
000008  2010              MOVS     r0,#0x10
00000a  490d              LDR      r1,|L7.64|
00000c  6008              STR      r0,[r1,#0]
;;;23     	
;;;24     	dat = op | (address & ADDR_MASK);
00000e  f004001f          AND      r0,r4,#0x1f
000012  ea400605          ORR      r6,r0,r5
;;;25     	SPI1_ReadWrite(dat);
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       SPI1_ReadWrite
;;;26     	dat = SPI1_ReadWrite(0xFF);
00001c  20ff              MOVS     r0,#0xff
00001e  f7fffffe          BL       SPI1_ReadWrite
000022  4606              MOV      r6,r0
;;;27     	// do dummy read if needed (for mac and mii, see datasheet page 29)
;;;28     	if(address & 0x80)
000024  f0040080          AND      r0,r4,#0x80
000028  b118              CBZ      r0,|L7.50|
;;;29     	{
;;;30     		dat = SPI1_ReadWrite(0xFF);
00002a  20ff              MOVS     r0,#0xff
00002c  f7fffffe          BL       SPI1_ReadWrite
000030  4606              MOV      r6,r0
                  |L7.50|
;;;31     	}
;;;32     	// release CS
;;;33     	ENC28J60_CSH();
000032  2010              MOVS     r0,#0x10
000034  4902              LDR      r1,|L7.64|
000036  1f09              SUBS     r1,r1,#4
000038  6008              STR      r0,[r1,#0]
;;;34     	return dat;
00003a  4630              MOV      r0,r6
;;;35     }
00003c  bd70              POP      {r4-r6,pc}
;;;36     /****************************************************************************
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      0x40010814

                          AREA ||i.enc28j60SetBank||, CODE, READONLY, ALIGN=2

                  enc28j60SetBank PROC
;;;106    ****************************************************************************/ 
;;;107    void enc28j60SetBank(unsigned char address)
000000  b510              PUSH     {r4,lr}
;;;108    {
000002  4604              MOV      r4,r0
;;;109    	// set the bank (if needed)
;;;110    	if((address & BANK_MASK) != Enc28j60Bank)
000004  f0040060          AND      r0,r4,#0x60
000008  4909              LDR      r1,|L8.48|
00000a  7809              LDRB     r1,[r1,#0]  ; Enc28j60Bank
00000c  4288              CMP      r0,r1
00000e  d00e              BEQ      |L8.46|
;;;111    	{
;;;112            // set the bank
;;;113            enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
000010  2203              MOVS     r2,#3
000012  211f              MOVS     r1,#0x1f
000014  20a0              MOVS     r0,#0xa0
000016  f7fffffe          BL       enc28j60WriteOp
;;;114            enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
00001a  f3c41241          UBFX     r2,r4,#5,#2
00001e  211f              MOVS     r1,#0x1f
000020  2080              MOVS     r0,#0x80
000022  f7fffffe          BL       enc28j60WriteOp
;;;115            Enc28j60Bank = (address & BANK_MASK);
000026  f0040060          AND      r0,r4,#0x60
00002a  4901              LDR      r1,|L8.48|
00002c  7008              STRB     r0,[r1,#0]
                  |L8.46|
;;;116    	}
;;;117    }
00002e  bd10              POP      {r4,pc}
;;;118    /****************************************************************************
                          ENDP

                  |L8.48|
                          DCD      Enc28j60Bank

                          AREA ||i.enc28j60Write||, CODE, READONLY, ALIGN=1

                  enc28j60Write PROC
;;;140    ****************************************************************************/ 
;;;141    void enc28j60Write(unsigned char address, unsigned char data)
000000  b570              PUSH     {r4-r6,lr}
;;;142    	{
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;143    	// set the bank
;;;144    	enc28j60SetBank(address);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       enc28j60SetBank
;;;145    	// do the write
;;;146    	enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
00000c  462a              MOV      r2,r5
00000e  4621              MOV      r1,r4
000010  2040              MOVS     r0,#0x40
000012  f7fffffe          BL       enc28j60WriteOp
;;;147    	}
000016  bd70              POP      {r4-r6,pc}
;;;148    /****************************************************************************
                          ENDP


                          AREA ||i.enc28j60WriteBuffer||, CODE, READONLY, ALIGN=2

                  enc28j60WriteBuffer PROC
;;;84     ****************************************************************************/ 
;;;85     void enc28j60WriteBuffer(unsigned int len, unsigned char* data)
000000  b570              PUSH     {r4-r6,lr}
;;;86     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;87     	ENC28J60_CSL();
000006  2010              MOVS     r0,#0x10
000008  4908              LDR      r1,|L10.44|
00000a  6008              STR      r0,[r1,#0]
;;;88     	// issue write command
;;;89     	SPI1_ReadWrite(ENC28J60_WRITE_BUF_MEM);
00000c  207a              MOVS     r0,#0x7a
00000e  f7fffffe          BL       SPI1_ReadWrite
;;;90     	
;;;91     	while(len)
000012  e004              B        |L10.30|
                  |L10.20|
;;;92     	{
;;;93     		len--;
000014  1e64              SUBS     r4,r4,#1
;;;94     		SPI1_ReadWrite(*data);
000016  7828              LDRB     r0,[r5,#0]
000018  f7fffffe          BL       SPI1_ReadWrite
;;;95     		data++;
00001c  1c6d              ADDS     r5,r5,#1
                  |L10.30|
00001e  2c00              CMP      r4,#0                 ;91
000020  d1f8              BNE      |L10.20|
;;;96     	}
;;;97     	ENC28J60_CSH();
000022  2010              MOVS     r0,#0x10
000024  4901              LDR      r1,|L10.44|
000026  1f09              SUBS     r1,r1,#4
000028  6008              STR      r0,[r1,#0]
;;;98     }
00002a  bd70              POP      {r4-r6,pc}
;;;99     /****************************************************************************
                          ENDP

                  |L10.44|
                          DCD      0x40010814

                          AREA ||i.enc28j60WriteOp||, CODE, READONLY, ALIGN=2

                  enc28j60WriteOp PROC
;;;43     ****************************************************************************/ 
;;;44     void enc28j60WriteOp(unsigned char op, unsigned char address, unsigned char data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;45     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;46     	unsigned char dat = 0;								  	  
00000a  2700              MOVS     r7,#0
;;;47     	ENC28J60_CSL();	                      //使能ENC28J60 SPI片选  		
00000c  2010              MOVS     r0,#0x10
00000e  4909              LDR      r1,|L11.52|
000010  6008              STR      r0,[r1,#0]
;;;48     	dat = op | (address & ADDR_MASK);	  //OP--3位操作码 (address & ADDR_MASK)--5位参数
000012  f005001f          AND      r0,r5,#0x1f
000016  ea400704          ORR      r7,r0,r4
;;;49     	SPI1_ReadWrite(dat);				  //SPI1 写
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       SPI1_ReadWrite
;;;50     	dat = data;
000020  4637              MOV      r7,r6
;;;51     	SPI1_ReadWrite(dat);				  //SPI1 写操作数据
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       SPI1_ReadWrite
;;;52     	ENC28J60_CSH();						  //禁止ENC28J60 SPI片选  完成操作
000028  2010              MOVS     r0,#0x10
00002a  4902              LDR      r1,|L11.52|
00002c  1f09              SUBS     r1,r1,#4
00002e  6008              STR      r0,[r1,#0]
;;;53     }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;54     /****************************************************************************
                          ENDP

                  |L11.52|
                          DCD      0x40010814

                          AREA ||i.enc28j60clkout||, CODE, READONLY, ALIGN=1

                  enc28j60clkout PROC
;;;173    ****************************************************************************/ 
;;;174    void enc28j60clkout(unsigned char clk)
000000  b510              PUSH     {r4,lr}
;;;175    {
000002  4604              MOV      r4,r0
;;;176        //setup clkout: 2 is 12.5MHz:
;;;177    	enc28j60Write(ECOCON, clk & 0x7);
000004  f0040107          AND      r1,r4,#7
000008  2075              MOVS     r0,#0x75
00000a  f7fffffe          BL       enc28j60Write
;;;178    }
00000e  bd10              POP      {r4,pc}
;;;179    /****************************************************************************
                          ENDP


                          AREA ||i.enc28j60getrev||, CODE, READONLY, ALIGN=1

                  enc28j60getrev PROC
;;;380    ****************************************************************************/ 
;;;381    unsigned char enc28j60getrev(void)
000000  b510              PUSH     {r4,lr}
;;;382    {
;;;383    	//在EREVID 内也存储了版本信息。 EREVID 是一个只读控
;;;384    	//制寄存器，包含一个5 位标识符，用来标识器件特定硅片
;;;385    	//的版本号
;;;386    	return(enc28j60Read(EREVID));
000002  2072              MOVS     r0,#0x72
000004  f7fffffe          BL       enc28j60Read
;;;387    }
000008  bd10              POP      {r4,pc}
;;;388    
                          ENDP


                          AREA ||i.mymacinit||, CODE, READONLY, ALIGN=1

                  mymacinit PROC
;;;491    
;;;492    void mymacinit(unsigned char *mymac)
000000  b510              PUSH     {r4,lr}
;;;493    {
000002  4604              MOV      r4,r0
;;;494        enc28j60Init(mymac);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       enc28j60Init
;;;495      	enc28j60PhyWrite(PHLCON,0x0476);	
00000a  f2404176          MOV      r1,#0x476
00000e  2014              MOVS     r0,#0x14
000010  f7fffffe          BL       enc28j60PhyWrite
;;;496    	enc28j60clkout(2);                 // change clkout from 6.25MHz to 12.5MHz
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       enc28j60clkout
;;;497    }
00001a  bd10              POP      {r4,pc}
;;;498    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  Enc28j60Bank
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  NextPacketPtr
                          DCD      0x00000000
