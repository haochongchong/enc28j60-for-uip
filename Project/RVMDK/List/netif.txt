; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\netif.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\netif.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IC:\Users\Administrator\Desktop\lwip.practise\example6-1\Project\RVMDK\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\netif.crf ..\..\lwip\src\core\netif.c]
                          THUMB

                          AREA ||i.netif_add||, CODE, READONLY, ALIGN=2

                  netif_add PROC
;;;138    struct netif *
;;;139    netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;140      ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
;;;141    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9dd5a09          LDRD     r5,r10,[sp,#0x24]
000010  f8dd9020          LDR      r9,[sp,#0x20]
;;;142    
;;;143      LWIP_ASSERT("No init function given", init != NULL);
000014  bf00              NOP      
000016  b925              CBNZ     r5,|L1.34|
000018  a01d              ADR      r0,|L1.144|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L1.32|
000020  e7fe              B        |L1.32|
                  |L1.34|
000022  bf00              NOP      
;;;144    
;;;145      /* reset new interface configuration state */
;;;146      ip_addr_set_zero(&netif->ip_addr);
000024  2000              MOVS     r0,#0
000026  6060              STR      r0,[r4,#4]
;;;147      ip_addr_set_zero(&netif->netmask);
000028  60a0              STR      r0,[r4,#8]
;;;148      ip_addr_set_zero(&netif->gw);
00002a  60e0              STR      r0,[r4,#0xc]
;;;149      netif->flags = 0;
00002c  f8840029          STRB     r0,[r4,#0x29]
;;;150    #if LWIP_DHCP
;;;151      /* netif not under DHCP control by default */
;;;152      netif->dhcp = NULL;
;;;153    #endif /* LWIP_DHCP */
;;;154    #if LWIP_AUTOIP
;;;155      /* netif not under AutoIP control by default */
;;;156      netif->autoip = NULL;
;;;157    #endif /* LWIP_AUTOIP */
;;;158    #if LWIP_NETIF_STATUS_CALLBACK
;;;159      netif->status_callback = NULL;
;;;160    #endif /* LWIP_NETIF_STATUS_CALLBACK */
;;;161    #if LWIP_NETIF_LINK_CALLBACK
;;;162      netif->link_callback = NULL;
;;;163    #endif /* LWIP_NETIF_LINK_CALLBACK */
;;;164    #if LWIP_IGMP
;;;165      netif->igmp_mac_filter = NULL;
;;;166    #endif /* LWIP_IGMP */
;;;167    #if ENABLE_LOOPBACK
;;;168      netif->loop_first = NULL;
000030  6320              STR      r0,[r4,#0x30]
;;;169      netif->loop_last = NULL;
000032  6360              STR      r0,[r4,#0x34]
;;;170    #endif /* ENABLE_LOOPBACK */
;;;171    
;;;172      /* remember netif specific state information data */
;;;173      netif->state = state;
000034  f8c4901c          STR      r9,[r4,#0x1c]
;;;174      netif->num = netif_num++;
000038  481b              LDR      r0,|L1.168|
00003a  7800              LDRB     r0,[r0,#0]  ; netif_num
00003c  f884002c          STRB     r0,[r4,#0x2c]
000040  4819              LDR      r0,|L1.168|
000042  7800              LDRB     r0,[r0,#0]  ; netif_num
000044  1c40              ADDS     r0,r0,#1
000046  4918              LDR      r1,|L1.168|
000048  7008              STRB     r0,[r1,#0]
;;;175      netif->input = input;
00004a  f8c4a010          STR      r10,[r4,#0x10]
;;;176      NETIF_SET_HWADDRHINT(netif, NULL);
;;;177    #if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
;;;178      netif->loop_cnt_current = 0;
;;;179    #endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */
;;;180    
;;;181      netif_set_addr(netif, ipaddr, netmask, gw);
00004e  4643              MOV      r3,r8
000050  463a              MOV      r2,r7
000052  4631              MOV      r1,r6
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       netif_set_addr
;;;182    
;;;183      /* call user specified initialization function for netif */
;;;184      if (init(netif) != ERR_OK) {
00005a  4620              MOV      r0,r4
00005c  47a8              BLX      r5
00005e  b110              CBZ      r0,|L1.102|
;;;185        return NULL;
000060  2000              MOVS     r0,#0
                  |L1.98|
;;;186      }
;;;187    
;;;188      /* add this netif to the list */
;;;189      netif->next = netif_list;
;;;190      netif_list = netif;
;;;191      snmp_inc_iflist();
;;;192    
;;;193    #if LWIP_IGMP
;;;194      /* start IGMP processing */
;;;195      if (netif->flags & NETIF_FLAG_IGMP) {
;;;196        igmp_start(netif);
;;;197      }
;;;198    #endif /* LWIP_IGMP */
;;;199    
;;;200      LWIP_DEBUGF(NETIF_DEBUG, ("netif: added interface %c%c IP addr ",
;;;201        netif->name[0], netif->name[1]));
;;;202      ip_addr_debug_print(NETIF_DEBUG, ipaddr);
;;;203      LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
;;;204      ip_addr_debug_print(NETIF_DEBUG, netmask);
;;;205      LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
;;;206      ip_addr_debug_print(NETIF_DEBUG, gw);
;;;207      LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
;;;208      return netif;
;;;209    }
000062  e8bd87f0          POP      {r4-r10,pc}
                  |L1.102|
000066  4811              LDR      r0,|L1.172|
000068  6800              LDR      r0,[r0,#0]            ;189  ; netif_list
00006a  6020              STR      r0,[r4,#0]            ;189
00006c  480f              LDR      r0,|L1.172|
00006e  6004              STR      r4,[r0,#0]            ;190  ; netif_list
000070  bf00              NOP                            ;200
000072  bf00              NOP                            ;200
000074  bf00              NOP                            ;202
000076  bf00              NOP                            ;202
000078  bf00              NOP                            ;203
00007a  bf00              NOP                            ;203
00007c  bf00              NOP                            ;204
00007e  bf00              NOP                            ;204
000080  bf00              NOP                            ;205
000082  bf00              NOP                            ;205
000084  bf00              NOP                            ;206
000086  bf00              NOP                            ;206
000088  bf00              NOP                            ;207
00008a  bf00              NOP                            ;207
00008c  4620              MOV      r0,r4                 ;208
00008e  e7e8              B        |L1.98|
;;;210    
                          ENDP

                  |L1.144|
000090  4e6f2069          DCB      "No init function given",0
000094  6e697420
000098  66756e63
00009c  74696f6e
0000a0  20676976
0000a4  656e00  
0000a7  00                DCB      0
                  |L1.168|
                          DCD      netif_num
                  |L1.172|
                          DCD      netif_list

                          AREA ||i.netif_find||, CODE, READONLY, ALIGN=2

                  netif_find PROC
;;;289    struct netif *
;;;290    netif_find(char *name)
000000  b510              PUSH     {r4,lr}
;;;291    {
000002  4602              MOV      r2,r0
;;;292      struct netif *netif;
;;;293      u8_t num;
;;;294    
;;;295      if (name == NULL) {
000004  b90a              CBNZ     r2,|L2.10|
;;;296        return NULL;
000006  2000              MOVS     r0,#0
                  |L2.8|
;;;297      }
;;;298    
;;;299      num = name[2] - '0';
;;;300    
;;;301      for(netif = netif_list; netif != NULL; netif = netif->next) {
;;;302        if (num == netif->num &&
;;;303           name[0] == netif->name[0] &&
;;;304           name[1] == netif->name[1]) {
;;;305          LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
;;;306          return netif;
;;;307        }
;;;308      }
;;;309      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
;;;310      return NULL;
;;;311    }
000008  bd10              POP      {r4,pc}
                  |L2.10|
00000a  7890              LDRB     r0,[r2,#2]            ;299
00000c  3830              SUBS     r0,r0,#0x30           ;299
00000e  b2c3              UXTB     r3,r0                 ;299
000010  480d              LDR      r0,|L2.72|
000012  6801              LDR      r1,[r0,#0]            ;301  ; netif_list
000014  e012              B        |L2.60|
                  |L2.22|
000016  f891002c          LDRB     r0,[r1,#0x2c]         ;302
00001a  4298              CMP      r0,r3                 ;302
00001c  d10d              BNE      |L2.58|
00001e  7810              LDRB     r0,[r2,#0]            ;303
000020  f891402a          LDRB     r4,[r1,#0x2a]         ;303
000024  42a0              CMP      r0,r4                 ;303
000026  d108              BNE      |L2.58|
000028  7854              LDRB     r4,[r2,#1]            ;304
00002a  202b              MOVS     r0,#0x2b              ;304
00002c  5c40              LDRB     r0,[r0,r1]            ;304
00002e  4284              CMP      r4,r0                 ;304
000030  d103              BNE      |L2.58|
000032  bf00              NOP                            ;305
000034  bf00              NOP                            ;305
000036  4608              MOV      r0,r1                 ;306
000038  e7e6              B        |L2.8|
                  |L2.58|
00003a  6809              LDR      r1,[r1,#0]            ;301
                  |L2.60|
00003c  2900              CMP      r1,#0                 ;301
00003e  d1ea              BNE      |L2.22|
000040  bf00              NOP                            ;309
000042  bf00              NOP                            ;309
000044  2000              MOVS     r0,#0                 ;310
000046  e7df              B        |L2.8|
;;;312    
                          ENDP

                  |L2.72|
                          DCD      netif_list

                          AREA ||i.netif_init||, CODE, READONLY, ALIGN=2

                  netif_init PROC
;;;105    void
;;;106    netif_init(void)
000000  b500              PUSH     {lr}
;;;107    {
000002  b087              SUB      sp,sp,#0x1c
;;;108    #if LWIP_HAVE_LOOPIF
;;;109      ip_addr_t loop_ipaddr, loop_netmask, loop_gw;
;;;110      IP4_ADDR(&loop_gw, 127,0,0,1);
000004  480a              LDR      r0,|L3.48|
000006  9004              STR      r0,[sp,#0x10]
;;;111      IP4_ADDR(&loop_ipaddr, 127,0,0,1);
000008  9006              STR      r0,[sp,#0x18]
;;;112      IP4_ADDR(&loop_netmask, 255,0,0,0);
00000a  20ff              MOVS     r0,#0xff
00000c  9005              STR      r0,[sp,#0x14]
;;;113    
;;;114    #if NO_SYS
;;;115      netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, ip_input);
00000e  4809              LDR      r0,|L3.52|
000010  4909              LDR      r1,|L3.56|
000012  2200              MOVS     r2,#0
000014  ab04              ADD      r3,sp,#0x10
000016  e9cd2100          STRD     r2,r1,[sp,#0]
00001a  9002              STR      r0,[sp,#8]
00001c  aa05              ADD      r2,sp,#0x14
00001e  a906              ADD      r1,sp,#0x18
000020  4806              LDR      r0,|L3.60|
000022  f7fffffe          BL       netif_add
;;;116    #else  /* NO_SYS */
;;;117      netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, tcpip_input);
;;;118    #endif /* NO_SYS */
;;;119      netif_set_up(&loop_netif);
000026  4805              LDR      r0,|L3.60|
000028  f7fffffe          BL       netif_set_up
;;;120    
;;;121    #endif /* LWIP_HAVE_LOOPIF */
;;;122    }
00002c  b007              ADD      sp,sp,#0x1c
00002e  bd00              POP      {pc}
;;;123    
                          ENDP

                  |L3.48|
                          DCD      0x0100007f
                  |L3.52|
                          DCD      ip_input
                  |L3.56|
                          DCD      netif_loopif_init
                  |L3.60|
                          DCD      loop_netif

                          AREA ||i.netif_loop_output||, CODE, READONLY, ALIGN=2

                  netif_loop_output PROC
;;;609    err_t
;;;610    netif_loop_output(struct netif *netif, struct pbuf *p,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;611           ip_addr_t *ipaddr)
;;;612    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
;;;613      struct pbuf *r;
;;;614      err_t err;
;;;615      struct pbuf *last;
;;;616    #if LWIP_LOOPBACK_MAX_PBUFS
;;;617      u8_t clen = 0;
;;;618    #endif /* LWIP_LOOPBACK_MAX_PBUFS */
;;;619      /* If we have a loopif, SNMP counters are adjusted for it,
;;;620       * if not they are adjusted for 'netif'. */
;;;621    #if LWIP_SNMP
;;;622    #if LWIP_HAVE_LOOPIF
;;;623      struct netif *stats_if = &loop_netif;
;;;624    #else /* LWIP_HAVE_LOOPIF */
;;;625      struct netif *stats_if = netif;
;;;626    #endif /* LWIP_HAVE_LOOPIF */
;;;627    #endif /* LWIP_SNMP */
;;;628      SYS_ARCH_DECL_PROTECT(lev);
;;;629      LWIP_UNUSED_ARG(ipaddr);
;;;630    
;;;631      /* Allocate a new pbuf */
;;;632      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
00000a  8939              LDRH     r1,[r7,#8]
00000c  2200              MOVS     r2,#0
00000e  2002              MOVS     r0,#2
000010  f7fffffe          BL       pbuf_alloc
000014  4605              MOV      r5,r0
;;;633      if (r == NULL) {
000016  b965              CBNZ     r5,|L4.50|
;;;634        LINK_STATS_INC(link.memerr);
000018  481f              LDR      r0,|L4.152|
00001a  8980              LDRH     r0,[r0,#0xc]  ; lwip_stats
00001c  1c40              ADDS     r0,r0,#1
00001e  491e              LDR      r1,|L4.152|
000020  8188              STRH     r0,[r1,#0xc]
;;;635        LINK_STATS_INC(link.drop);
000022  4608              MOV      r0,r1
000024  88c0              LDRH     r0,[r0,#6]  ; lwip_stats
000026  1c40              ADDS     r0,r0,#1
000028  80c8              STRH     r0,[r1,#6]
;;;636        snmp_inc_ifoutdiscards(stats_if);
;;;637        return ERR_MEM;
00002a  f04f30ff          MOV      r0,#0xffffffff
                  |L4.46|
;;;638      }
;;;639    #if LWIP_LOOPBACK_MAX_PBUFS
;;;640      clen = pbuf_clen(r);
;;;641      /* check for overflow or too many pbuf on queue */
;;;642      if(((netif->loop_cnt_current + clen) < netif->loop_cnt_current) ||
;;;643         ((netif->loop_cnt_current + clen) > LWIP_LOOPBACK_MAX_PBUFS)) {
;;;644        pbuf_free(r);
;;;645        LINK_STATS_INC(link.memerr);
;;;646        LINK_STATS_INC(link.drop);
;;;647        snmp_inc_ifoutdiscards(stats_if);
;;;648        return ERR_MEM;
;;;649      }
;;;650      netif->loop_cnt_current += clen;
;;;651    #endif /* LWIP_LOOPBACK_MAX_PBUFS */
;;;652    
;;;653      /* Copy the whole pbuf queue p into the single pbuf r */
;;;654      if ((err = pbuf_copy(r, p)) != ERR_OK) {
;;;655        pbuf_free(r);
;;;656        LINK_STATS_INC(link.memerr);
;;;657        LINK_STATS_INC(link.drop);
;;;658        snmp_inc_ifoutdiscards(stats_if);
;;;659        return err;
;;;660      }
;;;661    
;;;662      /* Put the packet on a linked list which gets emptied through calling
;;;663         netif_poll(). */
;;;664    
;;;665      /* let last point to the last pbuf in chain r */
;;;666      for (last = r; last->next != NULL; last = last->next);
;;;667    
;;;668      SYS_ARCH_PROTECT(lev);
;;;669      if(netif->loop_first != NULL) {
;;;670        LWIP_ASSERT("if first != NULL, last must also be != NULL", netif->loop_last != NULL);
;;;671        netif->loop_last->next = r;
;;;672        netif->loop_last = last;
;;;673      } else {
;;;674        netif->loop_first = r;
;;;675        netif->loop_last = last;
;;;676      }
;;;677      SYS_ARCH_UNPROTECT(lev);
;;;678    
;;;679      LINK_STATS_INC(link.xmit);
;;;680      snmp_add_ifoutoctets(stats_if, p->tot_len);
;;;681      snmp_inc_ifoutucastpkts(stats_if);
;;;682    
;;;683    #if LWIP_NETIF_LOOPBACK_MULTITHREADING
;;;684      /* For multithreading environment, schedule a call to netif_poll */
;;;685      tcpip_callback((tcpip_callback_fn)netif_poll, netif);
;;;686    #endif /* LWIP_NETIF_LOOPBACK_MULTITHREADING */
;;;687    
;;;688      return ERR_OK;
;;;689    }
00002e  e8bd87f0          POP      {r4-r10,pc}
                  |L4.50|
000032  4639              MOV      r1,r7                 ;654
000034  4628              MOV      r0,r5                 ;654
000036  f7fffffe          BL       pbuf_copy
00003a  f1b00800          SUBS     r8,r0,#0              ;654
00003e  d00d              BEQ      |L4.92|
000040  4628              MOV      r0,r5                 ;655
000042  f7fffffe          BL       pbuf_free
000046  4814              LDR      r0,|L4.152|
000048  8980              LDRH     r0,[r0,#0xc]          ;656  ; lwip_stats
00004a  1c40              ADDS     r0,r0,#1              ;656
00004c  4912              LDR      r1,|L4.152|
00004e  8188              STRH     r0,[r1,#0xc]          ;656
000050  4608              MOV      r0,r1                 ;657
000052  88c0              LDRH     r0,[r0,#6]            ;657  ; lwip_stats
000054  1c40              ADDS     r0,r0,#1              ;657
000056  80c8              STRH     r0,[r1,#6]            ;657
000058  4640              MOV      r0,r8                 ;659
00005a  e7e8              B        |L4.46|
                  |L4.92|
00005c  462e              MOV      r6,r5                 ;666
00005e  e000              B        |L4.98|
                  |L4.96|
000060  6836              LDR      r6,[r6,#0]            ;666
                  |L4.98|
000062  6830              LDR      r0,[r6,#0]            ;666
000064  2800              CMP      r0,#0                 ;666
000066  d1fb              BNE      |L4.96|
000068  6b20              LDR      r0,[r4,#0x30]         ;669
00006a  b160              CBZ      r0,|L4.134|
00006c  bf00              NOP                            ;670
00006e  6b60              LDR      r0,[r4,#0x34]         ;670
000070  b920              CBNZ     r0,|L4.124|
000072  a00a              ADR      r0,|L4.156|
000074  f7fffffe          BL       __2printf
000078  bf00              NOP                            ;670
                  |L4.122|
00007a  e7fe              B        |L4.122|
                  |L4.124|
00007c  bf00              NOP                            ;670
00007e  6b60              LDR      r0,[r4,#0x34]         ;671
000080  6005              STR      r5,[r0,#0]            ;671
000082  6366              STR      r6,[r4,#0x34]         ;672
000084  e001              B        |L4.138|
                  |L4.134|
000086  6325              STR      r5,[r4,#0x30]         ;674
000088  6366              STR      r6,[r4,#0x34]         ;675
                  |L4.138|
00008a  4803              LDR      r0,|L4.152|
00008c  8800              LDRH     r0,[r0,#0]            ;679  ; lwip_stats
00008e  1c40              ADDS     r0,r0,#1              ;679
000090  4901              LDR      r1,|L4.152|
000092  8008              STRH     r0,[r1,#0]            ;679
000094  2000              MOVS     r0,#0                 ;688
000096  e7ca              B        |L4.46|
;;;690    
                          ENDP

                  |L4.152|
                          DCD      lwip_stats
                  |L4.156|
00009c  69662066          DCB      "if first != NULL, last must also be != NULL",0
0000a0  69727374
0000a4  20213d20
0000a8  4e554c4c
0000ac  2c206c61
0000b0  7374206d
0000b4  75737420
0000b8  616c736f
0000bc  20626520
0000c0  213d204e
0000c4  554c4c00

                          AREA ||i.netif_loopif_init||, CODE, READONLY, ALIGN=2

                  netif_loopif_init PROC
;;;90     static err_t
;;;91     netif_loopif_init(struct netif *netif)
000000  4601              MOV      r1,r0
;;;92     {
;;;93       /* initialize the snmp variables and counters inside the struct netif
;;;94        * ifSpeed: no assumption can be made!
;;;95        */
;;;96       NETIF_INIT_SNMP(netif, snmp_ifType_softwareLoopback, 0);
;;;97     
;;;98       netif->name[0] = 'l';
000002  206c              MOVS     r0,#0x6c
000004  f881002a          STRB     r0,[r1,#0x2a]
;;;99       netif->name[1] = 'o';
000008  226f              MOVS     r2,#0x6f
00000a  202b              MOVS     r0,#0x2b
00000c  5442              STRB     r2,[r0,r1]
;;;100      netif->output = netif_loop_output;
00000e  4802              LDR      r0,|L5.24|
000010  6148              STR      r0,[r1,#0x14]
;;;101      return ERR_OK;
000012  2000              MOVS     r0,#0
;;;102    }
000014  4770              BX       lr
;;;103    #endif /* LWIP_HAVE_LOOPIF */
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      netif_loop_output

                          AREA ||i.netif_poll||, CODE, READONLY, ALIGN=2

                  netif_poll PROC
;;;697    void
;;;698    netif_poll(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;699    {
000002  4604              MOV      r4,r0
;;;700      struct pbuf *in;
;;;701      /* If we have a loopif, SNMP counters are adjusted for it,
;;;702       * if not they are adjusted for 'netif'. */
;;;703    #if LWIP_SNMP
;;;704    #if LWIP_HAVE_LOOPIF
;;;705      struct netif *stats_if = &loop_netif;
;;;706    #else /* LWIP_HAVE_LOOPIF */
;;;707      struct netif *stats_if = netif;
;;;708    #endif /* LWIP_HAVE_LOOPIF */
;;;709    #endif /* LWIP_SNMP */
;;;710      SYS_ARCH_DECL_PROTECT(lev);
;;;711    
;;;712      do {
000004  bf00              NOP      
                  |L6.6|
;;;713        /* Get a packet from the list. With SYS_LIGHTWEIGHT_PROT=1, this is protected */
;;;714        SYS_ARCH_PROTECT(lev);
;;;715        in = netif->loop_first;
000006  6b26              LDR      r6,[r4,#0x30]
;;;716        if (in != NULL) {
000008  2e00              CMP      r6,#0
00000a  d024              BEQ      |L6.86|
;;;717          struct pbuf *in_end = in;
00000c  4635              MOV      r5,r6
;;;718    #if LWIP_LOOPBACK_MAX_PBUFS
;;;719          u8_t clen = pbuf_clen(in);
;;;720          /* adjust the number of pbufs on queue */
;;;721          LWIP_ASSERT("netif->loop_cnt_current underflow",
;;;722            ((netif->loop_cnt_current - clen) < netif->loop_cnt_current));
;;;723          netif->loop_cnt_current -= clen;
;;;724    #endif /* LWIP_LOOPBACK_MAX_PBUFS */
;;;725          while (in_end->len != in_end->tot_len) {
00000e  e009              B        |L6.36|
                  |L6.16|
;;;726            LWIP_ASSERT("bogus pbuf: len != tot_len but next == NULL!", in_end->next != NULL);
000010  bf00              NOP      
000012  6828              LDR      r0,[r5,#0]
000014  b920              CBNZ     r0,|L6.32|
000016  a019              ADR      r0,|L6.124|
000018  f7fffffe          BL       __2printf
00001c  bf00              NOP      
                  |L6.30|
00001e  e7fe              B        |L6.30|
                  |L6.32|
000020  bf00              NOP      
;;;727            in_end = in_end->next;
000022  682d              LDR      r5,[r5,#0]
                  |L6.36|
000024  8968              LDRH     r0,[r5,#0xa]          ;725
000026  8929              LDRH     r1,[r5,#8]            ;725
000028  4288              CMP      r0,r1                 ;725
00002a  d1f1              BNE      |L6.16|
;;;728          }
;;;729          /* 'in_end' now points to the last pbuf from 'in' */
;;;730          if (in_end == netif->loop_last) {
00002c  6b60              LDR      r0,[r4,#0x34]
00002e  42a8              CMP      r0,r5
000030  d103              BNE      |L6.58|
;;;731            /* this was the last pbuf in the list */
;;;732            netif->loop_first = netif->loop_last = NULL;
000032  2000              MOVS     r0,#0
000034  6360              STR      r0,[r4,#0x34]
000036  6320              STR      r0,[r4,#0x30]
000038  e00a              B        |L6.80|
                  |L6.58|
;;;733          } else {
;;;734            /* pop the pbuf off the list */
;;;735            netif->loop_first = in_end->next;
00003a  6828              LDR      r0,[r5,#0]
00003c  6320              STR      r0,[r4,#0x30]
;;;736            LWIP_ASSERT("should not be null since first != last!", netif->loop_first != NULL);
00003e  bf00              NOP      
000040  6b20              LDR      r0,[r4,#0x30]
000042  b920              CBNZ     r0,|L6.78|
000044  a019              ADR      r0,|L6.172|
000046  f7fffffe          BL       __2printf
00004a  bf00              NOP      
                  |L6.76|
00004c  e7fe              B        |L6.76|
                  |L6.78|
00004e  bf00              NOP      
                  |L6.80|
;;;737          }
;;;738          /* De-queue the pbuf from its successors on the 'loop_' list. */
;;;739          in_end->next = NULL;
000050  2000              MOVS     r0,#0
000052  6028              STR      r0,[r5,#0]
;;;740        }
000054  bf00              NOP      
                  |L6.86|
;;;741        SYS_ARCH_UNPROTECT(lev);
;;;742    
;;;743        if (in != NULL) {
000056  b16e              CBZ      r6,|L6.116|
;;;744          LINK_STATS_INC(link.recv);
000058  481e              LDR      r0,|L6.212|
00005a  8840              LDRH     r0,[r0,#2]  ; lwip_stats
00005c  1c40              ADDS     r0,r0,#1
00005e  491d              LDR      r1,|L6.212|
000060  8048              STRH     r0,[r1,#2]
;;;745          snmp_add_ifinoctets(stats_if, in->tot_len);
;;;746          snmp_inc_ifinucastpkts(stats_if);
;;;747          /* loopback packets are always IP packets! */
;;;748          if (ip_input(in, netif) != ERR_OK) {
000062  4621              MOV      r1,r4
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       ip_input
00006a  b110              CBZ      r0,|L6.114|
;;;749            pbuf_free(in);
00006c  4630              MOV      r0,r6
00006e  f7fffffe          BL       pbuf_free
                  |L6.114|
;;;750          }
;;;751          /* Don't reference the packet any more! */
;;;752          in = NULL;
000072  2600              MOVS     r6,#0
                  |L6.116|
;;;753        }
;;;754      /* go on while there is a packet on the list */
;;;755      } while (netif->loop_first != NULL);
000074  6b20              LDR      r0,[r4,#0x30]
000076  2800              CMP      r0,#0
000078  d1c5              BNE      |L6.6|
;;;756    }
00007a  bd70              POP      {r4-r6,pc}
;;;757    
                          ENDP

                  |L6.124|
00007c  626f6775          DCB      "bogus pbuf: len != tot_len but next == NULL!",0
000080  73207062
000084  75663a20
000088  6c656e20
00008c  213d2074
000090  6f745f6c
000094  656e2062
000098  7574206e
00009c  65787420
0000a0  3d3d204e
0000a4  554c4c21
0000a8  00      
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L6.172|
0000ac  73686f75          DCB      "should not be null since first != last!",0
0000b0  6c64206e
0000b4  6f742062
0000b8  65206e75
0000bc  6c6c2073
0000c0  696e6365
0000c4  20666972
0000c8  73742021
0000cc  3d206c61
0000d0  73742100
                  |L6.212|
                          DCD      lwip_stats

                          AREA ||i.netif_poll_all||, CODE, READONLY, ALIGN=2

                  netif_poll_all PROC
;;;762    void
;;;763    netif_poll_all(void)
000000  b510              PUSH     {r4,lr}
;;;764    {
;;;765      struct netif *netif = netif_list;
000002  4805              LDR      r0,|L7.24|
000004  6804              LDR      r4,[r0,#0]  ; netif_list
;;;766      /* loop through netifs */
;;;767      while (netif != NULL) {
000006  e003              B        |L7.16|
                  |L7.8|
;;;768        netif_poll(netif);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       netif_poll
;;;769        /* proceed to next network interface */
;;;770        netif = netif->next;
00000e  6824              LDR      r4,[r4,#0]
                  |L7.16|
000010  2c00              CMP      r4,#0                 ;767
000012  d1f9              BNE      |L7.8|
;;;771      }
;;;772    }
000014  bd10              POP      {r4,pc}
;;;773    #endif /* !LWIP_NETIF_LOOPBACK_MULTITHREADING */
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      netif_list

                          AREA ||i.netif_remove||, CODE, READONLY, ALIGN=2

                  netif_remove PROC
;;;234    void
;;;235    netif_remove(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;236    {
000002  4604              MOV      r4,r0
;;;237      if (netif == NULL) {
000004  b904              CBNZ     r4,|L8.8|
                  |L8.6|
;;;238        return;
;;;239      }
;;;240    
;;;241    #if LWIP_IGMP
;;;242      /* stop IGMP processing */
;;;243      if (netif->flags & NETIF_FLAG_IGMP) {
;;;244        igmp_stop(netif);
;;;245      }
;;;246    #endif /* LWIP_IGMP */
;;;247      if (netif_is_up(netif)) {
;;;248        /* set netif down before removing (call callback function) */
;;;249        netif_set_down(netif);
;;;250      }
;;;251    
;;;252      snmp_delete_ipaddridx_tree(netif);
;;;253    
;;;254      /*  is it the first netif? */
;;;255      if (netif_list == netif) {
;;;256        netif_list = netif->next;
;;;257      } else {
;;;258        /*  look for netif further down the list */
;;;259        struct netif * tmpNetif;
;;;260        for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
;;;261          if (tmpNetif->next == netif) {
;;;262            tmpNetif->next = netif->next;
;;;263            break;
;;;264          }
;;;265        }
;;;266        if (tmpNetif == NULL)
;;;267          return; /*  we didn't find any netif today */
;;;268      }
;;;269      snmp_dec_iflist();
;;;270      /* this netif is default? */
;;;271      if (netif_default == netif) {
;;;272        /* reset default netif */
;;;273        netif_set_default(NULL);
;;;274      }
;;;275    #if LWIP_NETIF_REMOVE_CALLBACK
;;;276      if (netif->remove_callback) {
;;;277        netif->remove_callback(netif);
;;;278      }
;;;279    #endif /* LWIP_NETIF_REMOVE_CALLBACK */
;;;280      LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
;;;281    }
000006  bd10              POP      {r4,pc}
                  |L8.8|
000008  f8940029          LDRB     r0,[r4,#0x29]         ;247
00000c  f0000001          AND      r0,r0,#1              ;247
000010  b110              CBZ      r0,|L8.24|
000012  4620              MOV      r0,r4                 ;249
000014  f7fffffe          BL       netif_set_down
                  |L8.24|
000018  4811              LDR      r0,|L8.96|
00001a  6800              LDR      r0,[r0,#0]            ;255  ; netif_list
00001c  42a0              CMP      r0,r4                 ;255
00001e  d103              BNE      |L8.40|
000020  490f              LDR      r1,|L8.96|
000022  6820              LDR      r0,[r4,#0]            ;256
000024  6008              STR      r0,[r1,#0]            ;256  ; netif_list
000026  e00f              B        |L8.72|
                  |L8.40|
000028  490d              LDR      r1,|L8.96|
00002a  6808              LDR      r0,[r1,#0]            ;260  ; netif_list
00002c  e006              B        |L8.60|
                  |L8.46|
00002e  6801              LDR      r1,[r0,#0]            ;261
000030  42a1              CMP      r1,r4                 ;261
000032  d102              BNE      |L8.58|
000034  6821              LDR      r1,[r4,#0]            ;262
000036  6001              STR      r1,[r0,#0]            ;262
000038  e002              B        |L8.64|
                  |L8.58|
00003a  6800              LDR      r0,[r0,#0]            ;260
                  |L8.60|
00003c  2800              CMP      r0,#0                 ;260
00003e  d1f6              BNE      |L8.46|
                  |L8.64|
000040  bf00              NOP                            ;263
000042  b900              CBNZ     r0,|L8.70|
000044  e7df              B        |L8.6|
                  |L8.70|
000046  bf00              NOP                            ;268
                  |L8.72|
000048  4806              LDR      r0,|L8.100|
00004a  6800              LDR      r0,[r0,#0]            ;271  ; netif_default
00004c  42a0              CMP      r0,r4                 ;271
00004e  d102              BNE      |L8.86|
000050  2000              MOVS     r0,#0                 ;273
000052  f7fffffe          BL       netif_set_default
                  |L8.86|
000056  bf00              NOP                            ;280
000058  bf00              NOP                            ;280
00005a  bf00              NOP      
00005c  e7d3              B        |L8.6|
;;;282    
                          ENDP

00005e  0000              DCW      0x0000
                  |L8.96|
                          DCD      netif_list
                  |L8.100|
                          DCD      netif_default

                          AREA ||i.netif_set_addr||, CODE, READONLY, ALIGN=1

                  netif_set_addr PROC
;;;220    void
;;;221    netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;222        ip_addr_t *gw)
;;;223    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;224      netif_set_ipaddr(netif, ipaddr);
00000c  4639              MOV      r1,r7
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       netif_set_ipaddr
;;;225      netif_set_netmask(netif, netmask);
000014  4621              MOV      r1,r4
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       netif_set_netmask
;;;226      netif_set_gw(netif, gw);
00001c  4629              MOV      r1,r5
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       netif_set_gw
;;;227    }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;228    
                          ENDP


                          AREA ||i.netif_set_default||, CODE, READONLY, ALIGN=2

                  netif_set_default PROC
;;;429    void
;;;430    netif_set_default(struct netif *netif)
000000  4902              LDR      r1,|L10.12|
;;;431    {
;;;432      if (netif == NULL) {
;;;433        /* remove default route */
;;;434        snmp_delete_iprteidx_tree(1, netif);
;;;435      } else {
;;;436        /* install default route */
;;;437        snmp_insert_iprteidx_tree(1, netif);
;;;438      }
;;;439      netif_default = netif;
000002  6008              STR      r0,[r1,#0]  ; netif_default
;;;440      LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
000004  bf00              NOP      
000006  bf00              NOP      
;;;441               netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
;;;442    }
000008  4770              BX       lr
;;;443    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      netif_default

                          AREA ||i.netif_set_down||, CODE, READONLY, ALIGN=1

                  netif_set_down PROC
;;;489     */ 
;;;490    void netif_set_down(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;491    {
000002  4604              MOV      r4,r0
;;;492      if (netif->flags & NETIF_FLAG_UP) {
000004  f8940029          LDRB     r0,[r4,#0x29]
000008  f0000001          AND      r0,r0,#1
00000c  b160              CBZ      r0,|L11.40|
;;;493        netif->flags &= ~NETIF_FLAG_UP;
00000e  f8140f29          LDRB     r0,[r4,#0x29]!
000012  f0200001          BIC      r0,r0,#1
000016  7020              STRB     r0,[r4,#0]
;;;494    #if LWIP_SNMP
;;;495        snmp_get_sysuptime(&netif->ts);
;;;496    #endif
;;;497    
;;;498    #if LWIP_ARP
;;;499        if (netif->flags & NETIF_FLAG_ETHARP) {
000018  f8140929          LDRB     r0,[r4],#-0x29
00001c  f0000020          AND      r0,r0,#0x20
000020  b110              CBZ      r0,|L11.40|
;;;500          etharp_cleanup_netif(netif);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       etharp_cleanup_netif
                  |L11.40|
;;;501        }
;;;502    #endif /* LWIP_ARP */
;;;503        NETIF_STATUS_CALLBACK(netif);
;;;504      }
;;;505    }
000028  bd10              POP      {r4,pc}
;;;506    
                          ENDP


                          AREA ||i.netif_set_gw||, CODE, READONLY, ALIGN=1

                  netif_set_gw PROC
;;;387    void
;;;388    netif_set_gw(struct netif *netif, ip_addr_t *gw)
000000  b909              CBNZ     r1,|L12.6|
;;;389    {
;;;390      ip_addr_set(&(netif->gw), gw);
000002  2200              MOVS     r2,#0
000004  e000              B        |L12.8|
                  |L12.6|
000006  680a              LDR      r2,[r1,#0]
                  |L12.8|
000008  60c2              STR      r2,[r0,#0xc]
;;;391      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: GW address of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;392        netif->name[0], netif->name[1],
;;;393        ip4_addr1_16(&netif->gw),
;;;394        ip4_addr2_16(&netif->gw),
;;;395        ip4_addr3_16(&netif->gw),
;;;396        ip4_addr4_16(&netif->gw)));
;;;397    }
00000e  4770              BX       lr
;;;398    
                          ENDP


                          AREA ||i.netif_set_ipaddr||, CODE, READONLY, ALIGN=2

                  netif_set_ipaddr PROC
;;;322    void
;;;323    netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;324    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;325      /* TODO: Handling of obsolete pcbs */
;;;326      /* See:  http://mail.gnu.org/archive/html/lwip-users/2003-03/msg00118.html */
;;;327    #if LWIP_TCP
;;;328      struct tcp_pcb *pcb;
;;;329      struct tcp_pcb_listen *lpcb;
;;;330    
;;;331      /* address is actually being changed? */
;;;332      if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
000008  2c00              CMP      r4,#0
00000a  d02e              BEQ      |L13.106|
00000c  6820              LDR      r0,[r4,#0]
00000e  6879              LDR      r1,[r7,#4]
000010  4288              CMP      r0,r1
000012  d101              BNE      |L13.24|
000014  2001              MOVS     r0,#1
000016  e000              B        |L13.26|
                  |L13.24|
000018  2000              MOVS     r0,#0
                  |L13.26|
00001a  bb30              CBNZ     r0,|L13.106|
;;;333        /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
;;;334        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
00001c  bf00              NOP      
00001e  bf00              NOP      
;;;335        pcb = tcp_active_pcbs;
000020  4816              LDR      r0,|L13.124|
000022  6806              LDR      r6,[r0,#0]  ; tcp_active_pcbs
;;;336        while (pcb != NULL) {
000024  e00d              B        |L13.66|
                  |L13.38|
;;;337          /* PCB bound to current local interface address? */
;;;338          if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
000026  6830              LDR      r0,[r6,#0]
000028  6879              LDR      r1,[r7,#4]
00002a  4288              CMP      r0,r1
00002c  d108              BNE      |L13.64|
;;;339    #if LWIP_AUTOIP
;;;340            /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
;;;341            && !ip_addr_islinklocal(&(pcb->local_ip))
;;;342    #endif /* LWIP_AUTOIP */
;;;343            ) {
;;;344            /* this connection must be aborted */
;;;345            struct tcp_pcb *next = pcb->next;
00002e  f8d6800c          LDR      r8,[r6,#0xc]
;;;346            LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
000032  bf00              NOP      
000034  bf00              NOP      
;;;347            tcp_abort(pcb);
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       tcp_abort
;;;348            pcb = next;
00003c  4646              MOV      r6,r8
;;;349          } else {
00003e  e000              B        |L13.66|
                  |L13.64|
;;;350            pcb = pcb->next;
000040  68f6              LDR      r6,[r6,#0xc]
                  |L13.66|
000042  2e00              CMP      r6,#0                 ;336
000044  d1ef              BNE      |L13.38|
;;;351          }
;;;352        }
;;;353        for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
000046  480e              LDR      r0,|L13.128|
000048  6805              LDR      r5,[r0,#0]  ; tcp_listen_pcbs
00004a  e00c              B        |L13.102|
                  |L13.76|
;;;354          /* PCB bound to current local interface address? */
;;;355          if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
00004c  b155              CBZ      r5,|L13.100|
00004e  6828              LDR      r0,[r5,#0]
000050  b140              CBZ      r0,|L13.100|
;;;356              (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
000052  6828              LDR      r0,[r5,#0]
000054  6879              LDR      r1,[r7,#4]
000056  4288              CMP      r0,r1
000058  d104              BNE      |L13.100|
;;;357            /* The PCB is listening to the old ipaddr and
;;;358             * is set to listen to the new one instead */
;;;359            ip_addr_set(&(lpcb->local_ip), ipaddr);
00005a  b90c              CBNZ     r4,|L13.96|
00005c  2000              MOVS     r0,#0
00005e  e000              B        |L13.98|
                  |L13.96|
000060  6820              LDR      r0,[r4,#0]
                  |L13.98|
000062  6028              STR      r0,[r5,#0]
                  |L13.100|
000064  68ed              LDR      r5,[r5,#0xc]          ;353
                  |L13.102|
000066  2d00              CMP      r5,#0                 ;353
000068  d1f0              BNE      |L13.76|
                  |L13.106|
;;;360          }
;;;361        }
;;;362      }
;;;363    #endif
;;;364      snmp_delete_ipaddridx_tree(netif);
;;;365      snmp_delete_iprteidx_tree(0,netif);
;;;366      /* set new IP address to netif */
;;;367      ip_addr_set(&(netif->ip_addr), ipaddr);
00006a  b90c              CBNZ     r4,|L13.112|
00006c  2000              MOVS     r0,#0
00006e  e000              B        |L13.114|
                  |L13.112|
000070  6820              LDR      r0,[r4,#0]
                  |L13.114|
000072  6078              STR      r0,[r7,#4]
;;;368      snmp_insert_ipaddridx_tree(netif);
;;;369      snmp_insert_iprteidx_tree(0,netif);
;;;370    
;;;371      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: IP address of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
000074  bf00              NOP      
000076  bf00              NOP      
;;;372        netif->name[0], netif->name[1],
;;;373        ip4_addr1_16(&netif->ip_addr),
;;;374        ip4_addr2_16(&netif->ip_addr),
;;;375        ip4_addr3_16(&netif->ip_addr),
;;;376        ip4_addr4_16(&netif->ip_addr)));
;;;377    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;378    
                          ENDP

                  |L13.124|
                          DCD      tcp_active_pcbs
                  |L13.128|
                          DCD      tcp_listen_pcbs

                          AREA ||i.netif_set_link_down||, CODE, READONLY, ALIGN=1

                  netif_set_link_down PROC
;;;573     */
;;;574    void netif_set_link_down(struct netif *netif )
000000  f8901029          LDRB     r1,[r0,#0x29]
;;;575    {
;;;576      if (netif->flags & NETIF_FLAG_LINK_UP) {
000004  f0010110          AND      r1,r1,#0x10
000008  b129              CBZ      r1,|L14.22|
;;;577        netif->flags &= ~NETIF_FLAG_LINK_UP;
00000a  f8901029          LDRB     r1,[r0,#0x29]
00000e  f0210110          BIC      r1,r1,#0x10
000012  f8801029          STRB     r1,[r0,#0x29]
                  |L14.22|
;;;578        NETIF_LINK_CALLBACK(netif);
;;;579      }
;;;580    }
000016  4770              BX       lr
;;;581    
                          ENDP


                          AREA ||i.netif_set_link_up||, CODE, READONLY, ALIGN=1

                  netif_set_link_up PROC
;;;534     */
;;;535    void netif_set_link_up(struct netif *netif )
000000  b510              PUSH     {r4,lr}
;;;536    {
000002  4604              MOV      r4,r0
;;;537      if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
000004  f8940029          LDRB     r0,[r4,#0x29]
000008  f0000010          AND      r0,r0,#0x10
00000c  b990              CBNZ     r0,|L15.52|
;;;538        netif->flags |= NETIF_FLAG_LINK_UP;
00000e  f8140f29          LDRB     r0,[r4,#0x29]!
000012  f0400010          ORR      r0,r0,#0x10
000016  7020              STRB     r0,[r4,#0]
;;;539    
;;;540    #if LWIP_DHCP
;;;541        if (netif->dhcp) {
;;;542          dhcp_network_changed(netif);
;;;543        }
;;;544    #endif /* LWIP_DHCP */
;;;545    
;;;546    #if LWIP_AUTOIP
;;;547        if (netif->autoip) {
;;;548          autoip_network_changed(netif);
;;;549        }
;;;550    #endif /* LWIP_AUTOIP */
;;;551    
;;;552        if (netif->flags & NETIF_FLAG_UP) {
000018  f8140929          LDRB     r0,[r4],#-0x29
00001c  f0000001          AND      r0,r0,#1
000020  b140              CBZ      r0,|L15.52|
;;;553    #if LWIP_ARP
;;;554          /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
;;;555          if (netif->flags & NETIF_FLAG_ETHARP) {
000022  f8940029          LDRB     r0,[r4,#0x29]
000026  f0000020          AND      r0,r0,#0x20
00002a  b118              CBZ      r0,|L15.52|
;;;556            etharp_gratuitous(netif);
00002c  1d21              ADDS     r1,r4,#4
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       etharp_request
                  |L15.52|
;;;557          }
;;;558    #endif /* LWIP_ARP */
;;;559    
;;;560    #if LWIP_IGMP
;;;561          /* resend IGMP memberships */
;;;562          if (netif->flags & NETIF_FLAG_IGMP) {
;;;563            igmp_report_groups( netif);
;;;564          }
;;;565    #endif /* LWIP_IGMP */
;;;566        }
;;;567        NETIF_LINK_CALLBACK(netif);
;;;568      }
;;;569    }
000034  bd10              POP      {r4,pc}
;;;570    
                          ENDP


                          AREA ||i.netif_set_netmask||, CODE, READONLY, ALIGN=1

                  netif_set_netmask PROC
;;;408    void
;;;409    netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
000000  b909              CBNZ     r1,|L16.6|
;;;410    {
;;;411      snmp_delete_iprteidx_tree(0, netif);
;;;412      /* set new netmask to netif */
;;;413      ip_addr_set(&(netif->netmask), netmask);
000002  2200              MOVS     r2,#0
000004  e000              B        |L16.8|
                  |L16.6|
000006  680a              LDR      r2,[r1,#0]
                  |L16.8|
000008  6082              STR      r2,[r0,#8]
;;;414      snmp_insert_iprteidx_tree(0, netif);
;;;415      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: netmask of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;416        netif->name[0], netif->name[1],
;;;417        ip4_addr1_16(&netif->netmask),
;;;418        ip4_addr2_16(&netif->netmask),
;;;419        ip4_addr3_16(&netif->netmask),
;;;420        ip4_addr4_16(&netif->netmask)));
;;;421    }
00000e  4770              BX       lr
;;;422    
                          ENDP


                          AREA ||i.netif_set_up||, CODE, READONLY, ALIGN=1

                  netif_set_up PROC
;;;452     */ 
;;;453    void netif_set_up(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;454    {
000002  4604              MOV      r4,r0
;;;455      if (!(netif->flags & NETIF_FLAG_UP)) {
000004  f8940029          LDRB     r0,[r4,#0x29]
000008  f0000001          AND      r0,r0,#1
00000c  b990              CBNZ     r0,|L17.52|
;;;456        netif->flags |= NETIF_FLAG_UP;
00000e  f8140f29          LDRB     r0,[r4,#0x29]!
000012  f0400001          ORR      r0,r0,#1
000016  7020              STRB     r0,[r4,#0]
;;;457        
;;;458    #if LWIP_SNMP
;;;459        snmp_get_sysuptime(&netif->ts);
;;;460    #endif /* LWIP_SNMP */
;;;461    
;;;462        NETIF_STATUS_CALLBACK(netif);
;;;463    
;;;464        if (netif->flags & NETIF_FLAG_LINK_UP) {
000018  f8140929          LDRB     r0,[r4],#-0x29
00001c  f0000010          AND      r0,r0,#0x10
000020  b140              CBZ      r0,|L17.52|
;;;465    #if LWIP_ARP
;;;466          /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
;;;467          if (netif->flags & (NETIF_FLAG_ETHARP)) {
000022  f8940029          LDRB     r0,[r4,#0x29]
000026  f0000020          AND      r0,r0,#0x20
00002a  b118              CBZ      r0,|L17.52|
;;;468            etharp_gratuitous(netif);
00002c  1d21              ADDS     r1,r4,#4
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       etharp_request
                  |L17.52|
;;;469          }
;;;470    #endif /* LWIP_ARP */
;;;471    
;;;472    #if LWIP_IGMP
;;;473          /* resend IGMP memberships */
;;;474          if (netif->flags & NETIF_FLAG_IGMP) {
;;;475            igmp_report_groups( netif);
;;;476          }
;;;477    #endif /* LWIP_IGMP */
;;;478        }
;;;479      }
;;;480    }
000034  bd10              POP      {r4,pc}
;;;481    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  loop_netif
                          %        56

                          AREA ||.data||, DATA, ALIGN=2

                  netif_list
                          DCD      0x00000000
                  netif_default
                          DCD      0x00000000
                  netif_num
000008  00                DCB      0x00
