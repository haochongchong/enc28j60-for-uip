; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IE:\git_projects\enc28j60-for-uip\Project\RVMDK\RTE -I"D:\Program Files\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\main.crf ..\..\Source\src\main.c]
                          THUMB

                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;126    ****************************************************************************/  
;;;127    void GPIO_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;128    {
;;;129      
;;;130      GPIO_InitTypeDef GPIO_InitStructure;
;;;131      RCC_APB2PeriphClockCmd( RCC_APB2Periph_USART1 |RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB |
000002  2101              MOVS     r1,#1
000004  f244007c          MOV      r0,#0x407c
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;132                             RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD |
;;;133                             RCC_APB2Periph_GPIOE, ENABLE);
;;;134      	
;;;135      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;				     //LED1控制
00000c  2020              MOVS     r0,#0x20
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;136      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000012  2010              MOVS     r0,#0x10
000014  f88d0003          STRB     r0,[sp,#3]
;;;137      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2003              MOVS     r0,#3
00001a  f88d0002          STRB     r0,[sp,#2]
;;;138      GPIO_Init(GPIOB, &GPIO_InitStructure);					 
00001e  4669              MOV      r1,sp
000020  4818              LDR      r0,|L1.132|
000022  f7fffffe          BL       GPIO_Init
;;;139    
;;;140      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_3;		 //LED2, LED3控制
000026  2048              MOVS     r0,#0x48
000028  f8ad0000          STRH     r0,[sp,#0]
;;;141      GPIO_Init(GPIOD, &GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  4816              LDR      r0,|L1.136|
000030  f7fffffe          BL       GPIO_Init
;;;142    
;;;143      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;					 //SST25VF016B SPI片选
000034  2010              MOVS     r0,#0x10
000036  f8ad0000          STRH     r0,[sp,#0]
;;;144      GPIO_Init(GPIOC, &GPIO_InitStructure);
00003a  4669              MOV      r1,sp
00003c  4813              LDR      r0,|L1.140|
00003e  f7fffffe          BL       GPIO_Init
;;;145      
;;;146      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12|GPIO_Pin_7;		 //PB12---VS1003 SPI片选（V2.1) 
000042  f44f5084          MOV      r0,#0x1080
000046  f8ad0000          STRH     r0,[sp,#0]
;;;147      GPIO_Init(GPIOB, &GPIO_InitStructure);					 //PB7---触摸屏芯片XPT2046 SPI 片选
00004a  4669              MOV      r1,sp
00004c  480d              LDR      r0,|L1.132|
00004e  f7fffffe          BL       GPIO_Init
;;;148      
;;;149      /* 禁止SPI1总线上的其他设备 */
;;;150      GPIO_SetBits(GPIOB, GPIO_Pin_7);						     //触摸屏芯片XPT2046 SPI 片选禁止  
000052  2180              MOVS     r1,#0x80
000054  480b              LDR      r0,|L1.132|
000056  f7fffffe          BL       GPIO_SetBits
;;;151      GPIO_SetBits(GPIOB, GPIO_Pin_12);						     //VS1003 SPI片选（V2.1)禁止 
00005a  f44f5180          MOV      r1,#0x1000
00005e  4809              LDR      r0,|L1.132|
000060  f7fffffe          BL       GPIO_SetBits
;;;152      GPIO_SetBits(GPIOC, GPIO_Pin_4);						     //SST25VF016B SPI片选禁止  
000064  2110              MOVS     r1,#0x10
000066  4809              LDR      r0,|L1.140|
000068  f7fffffe          BL       GPIO_SetBits
;;;153    
;;;154      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;	         	 	//ENC28J60接收完成中断引脚 
00006c  2002              MOVS     r0,#2
00006e  f8ad0000          STRH     r0,[sp,#0]
;;;155      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;   	 		//内部上拉输入
000072  2048              MOVS     r0,#0x48
000074  f88d0003          STRB     r0,[sp,#3]
;;;156      GPIO_Init(GPIOA, &GPIO_InitStructure);		 
000078  4669              MOV      r1,sp
00007a  4805              LDR      r0,|L1.144|
00007c  f7fffffe          BL       GPIO_Init
;;;157    
;;;158    
;;;159    //  GPIO_ResetBits(GPIOE, GPIO_Pin_1);						 //复位ENC28J60
;;;160    //  Delay(0xAFFF);					   
;;;161    //  GPIO_SetBits(GPIOE, GPIO_Pin_1 );		 	 	             
;;;162    //  Delay(0xAFFF);	
;;;163    }
000080  bd08              POP      {r3,pc}
;;;164    
                          ENDP

000082  0000              DCW      0x0000
                  |L1.132|
                          DCD      0x40010c00
                  |L1.136|
                          DCD      0x40011400
                  |L1.140|
                          DCD      0x40011000
                  |L1.144|
                          DCD      0x40010800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;40     ****************************************************************************/ 
;;;41     void NVIC_Configuration(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;42     {
;;;43       NVIC_InitTypeDef NVIC_InitStructure;
;;;44       EXTI_InitTypeDef EXTI_InitStructure;
;;;45       /* Configure one bit for preemption priority */
;;;46       /* 优先级组 说明了抢占优先级所用的位数，和子优先级所用的位数   在这里是1， 7 */    
;;;47       NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
000002  f44f60c0          MOV      r0,#0x600
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;48       
;;;49       /* Enable the EXTI2 Interrupt */
;;;50       NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;				 //外部中断2
00000a  2007              MOVS     r0,#7
00000c  f88d0008          STRB     r0,[sp,#8]
;;;51       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;	     //抢占优先级 0
000010  2000              MOVS     r0,#0
000012  f88d0009          STRB     r0,[sp,#9]
;;;52       NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;			 //子优先级0  
000016  f88d000a          STRB     r0,[sp,#0xa]
;;;53       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;				 //使能
00001a  2001              MOVS     r0,#1
00001c  f88d000b          STRB     r0,[sp,#0xb]
;;;54       NVIC_Init(&NVIC_InitStructure);
000020  a802              ADD      r0,sp,#8
000022  f7fffffe          BL       NVIC_Init
;;;55     
;;;56       																  //用于选择EXTI1外部中断的输入源是PA1。
;;;57       GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource1);     //外部中断配置,网卡中断
000026  2101              MOVS     r1,#1
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       GPIO_EXTILineConfig
;;;58     
;;;59       EXTI_InitStructure.EXTI_Line = EXTI_Line1;					  //配置外部中断1
00002e  2002              MOVS     r0,#2
000030  9000              STR      r0,[sp,#0]
;;;60       EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;			  //中断模式
000032  2000              MOVS     r0,#0
000034  f88d0004          STRB     r0,[sp,#4]
;;;61       EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;		  //下降沿触发
000038  200c              MOVS     r0,#0xc
00003a  f88d0005          STRB     r0,[sp,#5]
;;;62       //EXTI_InitStructure.EXTI_LineCmd = ENABLE;
;;;63       EXTI_Init(&EXTI_InitStructure);
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       EXTI_Init
;;;64     }
000044  bd0e              POP      {r1-r3,pc}
;;;65     /****************************************************************************
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_Configuration PROC
;;;110    ****************************************************************************/ 
;;;111    void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;112    {
;;;113       SystemInit(); 
000002  f7fffffe          BL       SystemInit
;;;114       RCC_APB2PeriphClockCmd( RCC_APB2Periph_AFIO  , ENABLE);  
000006  2101              MOVS     r1,#1
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;115     
;;;116    }
00000e  bd10              POP      {r4,pc}
;;;117    
                          ENDP


                          AREA ||i.Usart1_Init||, CODE, READONLY, ALIGN=2

                  Usart1_Init PROC
;;;72     ****************************************************************************/
;;;73     void Usart1_Init(void)
000000  b500              PUSH     {lr}
;;;74     {
000002  b085              SUB      sp,sp,#0x14
;;;75       GPIO_InitTypeDef GPIO_InitStructure;
;;;76       USART_InitTypeDef USART_InitStructure;
;;;77      
;;;78       RCC_APB2PeriphClockCmd( RCC_APB2Periph_USART1 , ENABLE);	 		//使能串口1时钟
000004  2101              MOVS     r1,#1
000006  0388              LSLS     r0,r1,#14
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;79     
;;;80       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;	         		 		//USART1 TX
00000c  f44f7000          MOV      r0,#0x200
000010  f8ad0010          STRH     r0,[sp,#0x10]
;;;81       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000014  2003              MOVS     r0,#3
000016  f88d0012          STRB     r0,[sp,#0x12]
;;;82       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;    		 		//复用推挽输出
00001a  2018              MOVS     r0,#0x18
00001c  f88d0013          STRB     r0,[sp,#0x13]
;;;83       GPIO_Init(GPIOA, &GPIO_InitStructure);		    		 		//A端口 
000020  a904              ADD      r1,sp,#0x10
000022  4813              LDR      r0,|L4.112|
000024  f7fffffe          BL       GPIO_Init
;;;84     
;;;85       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;	         	 		//USART1 RX
000028  f44f6080          MOV      r0,#0x400
00002c  f8ad0010          STRH     r0,[sp,#0x10]
;;;86       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;   	 		//复用开漏输入
000030  2004              MOVS     r0,#4
000032  f88d0013          STRB     r0,[sp,#0x13]
;;;87       GPIO_Init(GPIOA, &GPIO_InitStructure);		         	 		//A端口 
000036  a904              ADD      r1,sp,#0x10
000038  480d              LDR      r0,|L4.112|
00003a  f7fffffe          BL       GPIO_Init
;;;88     
;;;89       USART_InitStructure.USART_BaudRate = 115200;						//速率115200bps
00003e  f44f30e1          MOV      r0,#0x1c200
000042  9000              STR      r0,[sp,#0]
;;;90       USART_InitStructure.USART_WordLength = USART_WordLength_8b;		//数据位8位
000044  2000              MOVS     r0,#0
000046  f8ad0004          STRH     r0,[sp,#4]
;;;91       USART_InitStructure.USART_StopBits = USART_StopBits_1;			//停止位1位
00004a  f8ad0006          STRH     r0,[sp,#6]
;;;92       USART_InitStructure.USART_Parity = USART_Parity_No;				//无校验位
00004e  f8ad0008          STRH     r0,[sp,#8]
;;;93       USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;   //无硬件流控
000052  f8ad000c          STRH     r0,[sp,#0xc]
;;;94       USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;					//收发模式
000056  200c              MOVS     r0,#0xc
000058  f8ad000a          STRH     r0,[sp,#0xa]
;;;95     
;;;96       /* Configure USART1 */
;;;97       USART_Init(USART1, &USART_InitStructure);							//配置串口参数函数   
00005c  4669              MOV      r1,sp
00005e  4805              LDR      r0,|L4.116|
000060  f7fffffe          BL       USART_Init
;;;98        /* Enable the USART1 */
;;;99       USART_Cmd(USART1, ENABLE);	
000064  2101              MOVS     r1,#1
000066  4803              LDR      r0,|L4.116|
000068  f7fffffe          BL       USART_Cmd
;;;100      
;;;101    }
00006c  b005              ADD      sp,sp,#0x14
00006e  bd00              POP      {pc}
;;;102    
                          ENDP

                  |L4.112|
                          DCD      0x40010800
                  |L4.116|
                          DCD      0x40013800

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;179    
;;;180    int main(void)
000000  bf00              NOP      
;;;181    {
;;;182    	uint8_t i;
;;;183    	u8 tcp_server_tsta=0XFF;
;;;184    	u8 tcp_client_tsta=0XFF;
000002  bf00              NOP      
;;;185    	
;;;186    	RCC_Configuration();				 //系统时钟设置
000004  f7fffffe          BL       RCC_Configuration
;;;187    	NVIC_Configuration();
000008  f7fffffe          BL       NVIC_Configuration
;;;188    	GPIO_Configuration();                //IO口初始化
00000c  f7fffffe          BL       GPIO_Configuration
;;;189    	Usart1_Init();                       //串口1初始化
000010  f7fffffe          BL       Usart1_Init
;;;190    
;;;191    	/* 配置systic作为20ms中断 */
;;;192    	if (SysTick_Config(20*72000))		//时钟节拍中断，20ms一次
000014  495c              LDR      r1,|L5.392|
000016  f1b17f80          CMP      r1,#0x1000000
00001a  d301              BCC      |L5.32|
00001c  2001              MOVS     r0,#1
00001e  e01d              B        |L5.92|
                  |L5.32|
000020  f021407f          BIC      r0,r1,#0xff000000
000024  1e40              SUBS     r0,r0,#1
000026  f04f22e0          MOV      r2,#0xe000e000
00002a  6150              STR      r0,[r2,#0x14]
00002c  1750              ASRS     r0,r2,#29
00002e  220f              MOVS     r2,#0xf
000030  2800              CMP      r0,#0
000032  da07              BGE      |L5.68|
000034  0713              LSLS     r3,r2,#28
000036  0e1e              LSRS     r6,r3,#24
000038  4b54              LDR      r3,|L5.396|
00003a  f000050f          AND      r5,r0,#0xf
00003e  1f2d              SUBS     r5,r5,#4
000040  555e              STRB     r6,[r3,r5]
000042  e003              B        |L5.76|
                  |L5.68|
000044  0713              LSLS     r3,r2,#28
000046  0e1d              LSRS     r5,r3,#24
000048  4b51              LDR      r3,|L5.400|
00004a  541d              STRB     r5,[r3,r0]
                  |L5.76|
00004c  bf00              NOP      
00004e  2000              MOVS     r0,#0
000050  f04f22e0          MOV      r2,#0xe000e000
000054  6190              STR      r0,[r2,#0x18]
000056  2007              MOVS     r0,#7
000058  6110              STR      r0,[r2,#0x10]
00005a  2000              MOVS     r0,#0
                  |L5.92|
00005c  b108              CBZ      r0,|L5.98|
;;;193        { 
;;;194        	/* error handle*/ 
;;;195         	while (1);
00005e  bf00              NOP      
                  |L5.96|
000060  e7fe              B        |L5.96|
                  |L5.98|
;;;196        }
;;;197    
;;;198    	/* 向串口1发送开机字符 */
;;;199        printf("****       (C) COPYRIGHT 2013 制造者科技    *******\r\n");    	  //。
000062  a04c              ADR      r0,|L5.404|
000064  f7fffffe          BL       __2printf
;;;200        printf("*                                                 *\r\n");  
000068  a058              ADR      r0,|L5.460|
00006a  f7fffffe          BL       __2printf
;;;201        printf("*                                                 *\r\n");    	  	
00006e  a057              ADR      r0,|L5.460|
000070  f7fffffe          BL       __2printf
;;;202        printf("*     MCU平台:STM32F103VET6                       *\r\n");    	
000074  a063              ADR      r0,|L5.516|
000076  f7fffffe          BL       __2printf
;;;203        printf("*     以太网硬件:ENC28J60                         *\r\n");    	  	
00007a  a070              ADR      r0,|L5.572|
00007c  f7fffffe          BL       __2printf
;;;204        printf("*     固件库：3.5                                 *\r\n");    	
000080  a07c              ADR      r0,|L5.628|
000082  f7fffffe          BL       __2printf
;;;205        printf("*     例程版本: 0.2                               *\r\n");     
000086  a089              ADR      r0,|L5.684|
000088  f7fffffe          BL       __2printf
;;;206        printf("*                                                 *\r\n");    	 	
00008c  a04f              ADR      r0,|L5.460|
00008e  f7fffffe          BL       __2printf
;;;207        printf("***************************************************\r\n");  	
000092  a094              ADR      r0,|L5.740|
000094  f7fffffe          BL       __2printf
;;;208    
;;;209    	SPI1_Init();	      //SPI口初始化，用于网卡间传输数据
000098  f7fffffe          BL       SPI1_Init
;;;210    
;;;211    	tapdev_init();
00009c  f7fffffe          BL       tapdev_init
;;;212    	uip_init();				//uIP初始化	  
0000a0  f7fffffe          BL       uip_init
;;;213    	
;;;214    	
;;;215    	uip_ipaddr(ipaddr, 192,168,1,16);	//设置本地设置IP地址
0000a4  bf00              NOP      
0000a6  f64a00c0          MOV      r0,#0xa8c0
0000aa  499c              LDR      r1,|L5.796|
0000ac  8008              STRH     r0,[r1,#0]
0000ae  f2410001          MOV      r0,#0x1001
0000b2  8048              STRH     r0,[r1,#2]
0000b4  bf00              NOP      
;;;216    	uip_sethostaddr(ipaddr);					    
0000b6  bf00              NOP      
0000b8  4608              MOV      r0,r1
0000ba  8800              LDRH     r0,[r0,#0]  ; ipaddr
0000bc  4998              LDR      r1,|L5.800|
0000be  8008              STRH     r0,[r1,#0]
0000c0  4896              LDR      r0,|L5.796|
0000c2  8840              LDRH     r0,[r0,#2]  ; ipaddr
0000c4  8048              STRH     r0,[r1,#2]
0000c6  bf00              NOP      
;;;217    	uip_ipaddr(ipaddr, 192,168,1,1); 	//设置网关IP地址(其实就是你路由器的IP地址)
0000c8  bf00              NOP      
0000ca  f64a00c0          MOV      r0,#0xa8c0
0000ce  4993              LDR      r1,|L5.796|
0000d0  8008              STRH     r0,[r1,#0]
0000d2  f2401001          MOV      r0,#0x101
0000d6  8048              STRH     r0,[r1,#2]
0000d8  bf00              NOP      
;;;218    	uip_setdraddr(ipaddr);						 
0000da  bf00              NOP      
0000dc  4608              MOV      r0,r1
0000de  8800              LDRH     r0,[r0,#0]  ; ipaddr
0000e0  4990              LDR      r1,|L5.804|
0000e2  8008              STRH     r0,[r1,#0]
0000e4  488d              LDR      r0,|L5.796|
0000e6  8840              LDRH     r0,[r0,#2]  ; ipaddr
0000e8  8048              STRH     r0,[r1,#2]
0000ea  bf00              NOP      
;;;219    	uip_ipaddr(ipaddr, 255,255,255,0);	//设置网络掩码
0000ec  bf00              NOP      
0000ee  f64f70ff          MOV      r0,#0xffff
0000f2  498a              LDR      r1,|L5.796|
0000f4  8008              STRH     r0,[r1,#0]
0000f6  20ff              MOVS     r0,#0xff
0000f8  8048              STRH     r0,[r1,#2]
0000fa  bf00              NOP      
;;;220    	uip_setnetmask(ipaddr);
0000fc  bf00              NOP      
0000fe  4608              MOV      r0,r1
000100  8800              LDRH     r0,[r0,#0]  ; ipaddr
000102  4989              LDR      r1,|L5.808|
000104  8008              STRH     r0,[r1,#0]
000106  4885              LDR      r0,|L5.796|
000108  8840              LDRH     r0,[r0,#2]  ; ipaddr
00010a  8048              STRH     r0,[r1,#2]
00010c  bf00              NOP      
;;;221    
;;;222    	//uip_listen(HTONS(1200));			//监听1200端口,用于TCP Server
;;;223    	//uip_listen(HTONS(80));				//监听80 端口,用于Web Server
;;;224      	//tcp_client_reconnect();	   		    //尝试连接到TCP Server端,用于TCP Client
;;;225    	
;;;226        
;;;227        
;;;228        
;;;229    //================================================================================================
;;;230    
;;;231    //1. 首先初始化所有的UDP链接
;;;232    	for( i = 0; i< UIP_UDP_CONNS; i++)
00010e  2400              MOVS     r4,#0
000110  e00e              B        |L5.304|
                  |L5.274|
;;;233    	{
;;;234    		if(&uip_udp_conns[i] != NULL)
000112  eb040084          ADD      r0,r4,r4,LSL #2
000116  4985              LDR      r1,|L5.812|
000118  eb010040          ADD      r0,r1,r0,LSL #1
00011c  b130              CBZ      r0,|L5.300|
;;;235    		{
;;;236    			uip_udp_remove(&uip_udp_conns[i]);
00011e  2000              MOVS     r0,#0
000120  eb040184          ADD      r1,r4,r4,LSL #2
000124  4a81              LDR      r2,|L5.812|
000126  eb020141          ADD      r1,r2,r1,LSL #1
00012a  8088              STRH     r0,[r1,#4]
                  |L5.300|
00012c  1c60              ADDS     r0,r4,#1              ;232
00012e  b2c4              UXTB     r4,r0                 ;232
                  |L5.304|
000130  2c0a              CMP      r4,#0xa               ;232
000132  dbee              BLT      |L5.274|
;;;237    		}
;;;238    	}
;;;239    	
;;;240    	
;;;241    //2. 新建一个链接,为这个链接指定远程IP和远程端口         远程端口：8087   远程IP：192.168.1.17
;;;242    	uip_ipaddr(ipaddr, 192,168,1,17);
000134  bf00              NOP      
000136  f64a00c0          MOV      r0,#0xa8c0
00013a  4978              LDR      r1,|L5.796|
00013c  8008              STRH     r0,[r1,#0]
00013e  f2411001          MOV      r0,#0x1101
000142  8048              STRH     r0,[r1,#2]
000144  bf00              NOP      
;;;243    	UIP_udp_conn = uip_udp_new(&ipaddr, HTONS(8087));
000146  f249711f          MOV      r1,#0x971f
00014a  4874              LDR      r0,|L5.796|
00014c  f7fffffe          BL       uip_udp_new
000150  4977              LDR      r1,|L5.816|
000152  6008              STR      r0,[r1,#0]  ; UIP_udp_conn
;;;244    //3. 将生成的链接绑定的一个指定的本地端口上              本地端口：8081
;;;245    	if(UIP_udp_conn != NULL) {
000154  4608              MOV      r0,r1
000156  6800              LDR      r0,[r0,#0]  ; UIP_udp_conn
000158  b118              CBZ      r0,|L5.354|
;;;246    		uip_udp_bind(UIP_udp_conn, HTONS(8081));
00015a  f249101f          MOV      r0,#0x911f
00015e  6809              LDR      r1,[r1,#0]  ; UIP_udp_conn
000160  8088              STRH     r0,[r1,#4]
                  |L5.354|
;;;247    	}
;;;248        UIP_udp_conn = uip_udp_new(&ipaddr, HTONS(8087));
000162  f249711f          MOV      r1,#0x971f
000166  486d              LDR      r0,|L5.796|
000168  f7fffffe          BL       uip_udp_new
00016c  4970              LDR      r1,|L5.816|
00016e  6008              STR      r0,[r1,#0]  ; UIP_udp_conn
;;;249    //3. 将生成的链接绑定的一个指定的本地端口上              本地端口：8082
;;;250    	if(UIP_udp_conn != NULL) {
000170  4608              MOV      r0,r1
000172  6800              LDR      r0,[r0,#0]  ; UIP_udp_conn
000174  b118              CBZ      r0,|L5.382|
;;;251    		uip_udp_bind(UIP_udp_conn, HTONS(8082));
000176  f249201f          MOV      r0,#0x921f
00017a  6809              LDR      r1,[r1,#0]  ; UIP_udp_conn
00017c  8088              STRH     r0,[r1,#4]
                  |L5.382|
;;;252    	}
;;;253    //================================================================================================	
;;;254    	while (1)
00017e  e001              B        |L5.388|
                  |L5.384|
;;;255    	{
;;;256    		uip_polling();	//处理uip事件，必须插入到用户程序的循环体中  
000180  f7fffffe          BL       uip_polling
                  |L5.388|
000184  e7fc              B        |L5.384|
;;;257    	}
;;;258    //		if(tcp_server_tsta!=tcp_server_sta)//TCP Server状态改变
;;;259    //		{															 
;;;260    //			if(tcp_server_sta&(1<<7))
;;;261    //			{
;;;262    //				printf("TCP Server Connected   ");
;;;263    //			}
;;;264    //			else
;;;265    //			{
;;;266    //				printf("TCP Server Disconnected");
;;;267    //			}
;;;268    // 			if(tcp_server_sta&(1<<6))	//收到新数据
;;;269    //			{
;;;270    //    			printf("TCP Server RX:%s\r\n",tcp_server_databuf);//打印数据
;;;271    //				tcp_server_sta&=~(1<<6);		//标记数据已经被处理	
;;;272    //			}
;;;273    //			tcp_server_tsta=tcp_server_sta;
;;;274    //		}
;;;275    //		if(1)//TCP Server 请求发送数据
;;;276    //		{
;;;277    //			if(tcp_server_sta&(1<<7))	//连接还存在
;;;278    //			{
;;;279    //				sprintf((char*)tcp_server_databuf,"TCP Server OK %d\r\n",tcnt);	 
;;;280    //				tcp_server_sta|=1<<5;//标记有数据需要发送
;;;281    //				tcnt++;
;;;282    //			}
;;;283    //		}
;;;284    //		if(tcp_client_tsta!=tcp_client_sta)//TCP Client状态改变
;;;285    //		{															 
;;;286    //			if(tcp_client_sta&(1<<7))
;;;287    //			{
;;;288    //				printf("TCP Client Connected   ");
;;;289    //			}
;;;290    //			else
;;;291    //			{
;;;292    //				printf("TCP Client Disconnected");
;;;293    //			}
;;;294    // 			if(tcp_client_sta&(1<<6))	//收到新数据
;;;295    //			{
;;;296    //    			printf("TCP Client RX:%s\r\n",tcp_client_databuf);//打印数据
;;;297    //				tcp_client_sta&=~(1<<6);		//标记数据已经被处理	
;;;298    //			}
;;;299    //			tcp_client_tsta=tcp_client_sta;
;;;300    //		}
;;;301    //		if(0)//TCP Client 请求发送数据
;;;302    //		{
;;;303    //			if(tcp_client_sta&(1<<7))	//连接还存在
;;;304    //			{
;;;305    //				sprintf((char*)tcp_client_databuf,"TCP Client OK %d\r\n",tcnt);	 
;;;306    //				tcp_client_sta|=1<<5;//标记有数据需要发送
;;;307    //				tcnt++;
;;;308    //			}
;;;309    //		}
;;;310    //	} 
;;;311    //	
;;;312    	//lwip_demo(NULL);	  //初始化内核，启动LwIP相关
;;;313    
;;;314    	while (1)
;;;315    	{
;;;316    	    //exit(0);	
;;;317    	}
;;;318    }
;;;319    
                          ENDP

000186  0000              DCW      0x0000
                  |L5.392|
                          DCD      0x0015f900
                  |L5.396|
                          DCD      0xe000ed18
                  |L5.400|
                          DCD      0xe000e400
                  |L5.404|
000194  2a2a2a2a          DCB      "****       (C) COPYRIGHT 2013 ",214,198,212,236,213,223
000198  20202020
00019c  20202028
0001a0  43292043
0001a4  4f505952
0001a8  49474854
0001ac  20323031
0001b0  3320d6c6
0001b4  d4ecd5df
0001b8  bfc6bcbc          DCB      191,198,188,188,"    *******\r\n",0
0001bc  20202020
0001c0  2a2a2a2a
0001c4  2a2a2a0d
0001c8  0a00    
0001ca  00                DCB      0
0001cb  00                DCB      0
                  |L5.460|
0001cc  2a202020          DCB      "*                                                 *\r\n"
0001d0  20202020
0001d4  20202020
0001d8  20202020
0001dc  20202020
0001e0  20202020
0001e4  20202020
0001e8  20202020
0001ec  20202020
0001f0  20202020
0001f4  20202020
0001f8  20202020
0001fc  20202a0d
000200  0a      
000201  00                DCB      0
000202  00                DCB      0
000203  00                DCB      0
                  |L5.516|
000204  2a202020          DCB      "*     MCU",198,189,204,168,":STM32F103VET6             "
000208  20204d43
00020c  55c6bdcc
000210  a83a5354
000214  4d333246
000218  31303356
00021c  45543620
000220  20202020
000224  20202020
000228  20202020
00022c  20202020          DCB      "          *\r\n",0
000230  20202020
000234  20202a0d
000238  0a00    
00023a  00                DCB      0
00023b  00                DCB      0
                  |L5.572|
00023c  2a202020          DCB      "*     ",210,212,204,171,205,248,211,178,188,254,":ENC28"
000240  2020d2d4
000244  ccabcdf8
000248  d3b2bcfe
00024c  3a454e43
000250  3238    
000252  4a363020          DCB      "J60                         *\r\n",0
000256  20202020
00025a  20202020
00025e  20202020
000262  20202020
000266  20202020
00026a  20202020
00026e  2a0d0a00
000272  00                DCB      0
000273  00                DCB      0
                  |L5.628|
000274  2a202020          DCB      "*     ",185,204,188,254,191,226,163,186,"3.5           "
000278  2020b9cc
00027c  bcfebfe2
000280  a3ba332e
000284  35202020
000288  20202020
00028c  20202020
000290  20202020          DCB      "                      *\r\n",0
000294  20202020
000298  20202020
00029c  20202020
0002a0  20202020
0002a4  20202a0d
0002a8  0a00    
0002aa  00                DCB      0
0002ab  00                DCB      0
                  |L5.684|
0002ac  2a202020          DCB      "*     ",192,253,179,204,176,230,177,190,": 0.2         "
0002b0  2020c0fd
0002b4  b3ccb0e6
0002b8  b1be3a20
0002bc  302e3220
0002c0  20202020
0002c4  20202020
0002c8  20202020          DCB      "                      *\r\n",0
0002cc  20202020
0002d0  20202020
0002d4  20202020
0002d8  20202020
0002dc  20202a0d
0002e0  0a00    
0002e2  00                DCB      0
0002e3  00                DCB      0
                  |L5.740|
0002e4  2a2a2a2a          DCB      "***************************************************\r\n"
0002e8  2a2a2a2a
0002ec  2a2a2a2a
0002f0  2a2a2a2a
0002f4  2a2a2a2a
0002f8  2a2a2a2a
0002fc  2a2a2a2a
000300  2a2a2a2a
000304  2a2a2a2a
000308  2a2a2a2a
00030c  2a2a2a2a
000310  2a2a2a2a
000314  2a2a2a0d
000318  0a      
000319  00                DCB      0
00031a  00                DCB      0
00031b  00                DCB      0
                  |L5.796|
                          DCD      ipaddr
                  |L5.800|
                          DCD      uip_hostaddr
                  |L5.804|
                          DCD      uip_draddr
                  |L5.808|
                          DCD      uip_netmask
                  |L5.812|
                          DCD      uip_udp_conns
                  |L5.816|
                          DCD      UIP_udp_conn

                          AREA ||i.sys_now||, CODE, READONLY, ALIGN=2

                  sys_now PROC
;;;26     unsigned int system_tick_num = 0;
;;;27     unsigned int sys_now(void)
000000  4801              LDR      r0,|L6.8|
;;;28     {
;;;29         return system_tick_num;
000002  6800              LDR      r0,[r0,#0]  ; system_tick_num
;;;30     }
000004  4770              BX       lr
;;;31     
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      system_tick_num

                          AREA ||i.uip_polling||, CODE, READONLY, ALIGN=2

                  uip_polling PROC
;;;320    #define HBUF ((struct uip_eth_hdr *)&uip_buf[0])	 
;;;321    void uip_polling(void)
000000  b510              PUSH     {r4,lr}
;;;322    {
;;;323    	u8 i;
;;;324    	static struct timer periodic_timer, arp_timer;
;;;325    	static u8 timer_ok=0;	 
;;;326    	if(timer_ok==0)//仅初始化一次
000002  4841              LDR      r0,|L7.264|
000004  7800              LDRB     r0,[r0,#0]  ; timer_ok
000006  b958              CBNZ     r0,|L7.32|
;;;327    	{
;;;328    		timer_ok = 1;
000008  2001              MOVS     r0,#1
00000a  493f              LDR      r1,|L7.264|
00000c  7008              STRB     r0,[r1,#0]
;;;329    		timer_set(&periodic_timer,CLOCK_SECOND/2);  //创建1个0.5秒的定时器 
00000e  2132              MOVS     r1,#0x32
000010  483e              LDR      r0,|L7.268|
000012  f7fffffe          BL       timer_set
;;;330    		timer_set(&arp_timer,CLOCK_SECOND*10);	   	//创建1个10秒的定时器 
000016  f44f717a          MOV      r1,#0x3e8
00001a  483d              LDR      r0,|L7.272|
00001c  f7fffffe          BL       timer_set
                  |L7.32|
;;;331    	}				 
;;;332    	uip_len=tapdev_read();	//从网络设备读取一个IP包,得到数据长度.uip_len在uip.c中定义
000020  f7fffffe          BL       tapdev_read
000024  493b              LDR      r1,|L7.276|
000026  8008              STRH     r0,[r1,#0]
;;;333    	if(uip_len>0) 			//有数据
000028  4608              MOV      r0,r1
00002a  8800              LDRH     r0,[r0,#0]  ; uip_len
00002c  2800              CMP      r0,#0
00002e  dd24              BLE      |L7.122|
;;;334    	{   
;;;335    		//处理IP数据包(只有校验通过的IP包才会被接收) 
;;;336    		if(HBUF->type == htons(UIP_ETHTYPE_IP))//是否是IP包? 
000030  f44f6000          MOV      r0,#0x800
000034  f7fffffe          BL       htons
000038  4937              LDR      r1,|L7.280|
00003a  8989              LDRH     r1,[r1,#0xc]  ; uip_buf
00003c  4288              CMP      r0,r1
00003e  d10b              BNE      |L7.88|
;;;337    		{
;;;338    			uip_arp_ipin();	//去除以太网头结构，更新ARP表
;;;339    			uip_input();   	//IP包处理
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       uip_process
;;;340    			//uip_process(UIP_UDP_TIMER);
;;;341    			//当上面的函数执行后，如果需要发送数据，则全局变量 uip_len > 0
;;;342    			//需要发送的数据在uip_buf, 长度是uip_len  (这是2个全局变量)		    
;;;343    			if(uip_len>0)//需要回应数据
000046  4833              LDR      r0,|L7.276|
000048  8800              LDRH     r0,[r0,#0]  ; uip_len
00004a  2800              CMP      r0,#0
00004c  dd5a              BLE      |L7.260|
;;;344    			{
;;;345    				uip_arp_out();//加以太网头结构，在主动连接时可能要构造ARP请求
00004e  f7fffffe          BL       uip_arp_out
;;;346    				tapdev_send();//发送数据到以太网
000052  f7fffffe          BL       tapdev_send
000056  e055              B        |L7.260|
                  |L7.88|
;;;347    			}
;;;348    		}else if (HBUF->type==htons(UIP_ETHTYPE_ARP))//处理arp报文,是否是ARP请求包?
000058  f6400006          MOV      r0,#0x806
00005c  f7fffffe          BL       htons
000060  492d              LDR      r1,|L7.280|
000062  8989              LDRH     r1,[r1,#0xc]  ; uip_buf
000064  4288              CMP      r0,r1
000066  d14d              BNE      |L7.260|
;;;349    		{
;;;350    			uip_arp_arpin();
000068  f7fffffe          BL       uip_arp_arpin
;;;351     			//当上面的函数执行后，如果需要发送数据，则全局变量uip_len>0
;;;352    			//需要发送的数据在uip_buf, 长度是uip_len(这是2个全局变量)
;;;353     			if(uip_len>0)
00006c  4829              LDR      r0,|L7.276|
00006e  8800              LDRH     r0,[r0,#0]  ; uip_len
000070  2800              CMP      r0,#0
000072  dd47              BLE      |L7.260|
;;;354    			{
;;;355    				tapdev_send();//需要发送数据,则通过tapdev_send发送	 
000074  f7fffffe          BL       tapdev_send
000078  e044              B        |L7.260|
                  |L7.122|
;;;356    			}
;;;357    		}
;;;358    	}else if(timer_expired(&periodic_timer))	//0.5秒定时器超时
00007a  4824              LDR      r0,|L7.268|
00007c  f7fffffe          BL       timer_expired
000080  2800              CMP      r0,#0
000082  d03f              BEQ      |L7.260|
;;;359    	{
;;;360    		timer_reset(&periodic_timer);		//复位0.5秒定时器 
000084  4821              LDR      r0,|L7.268|
000086  f7fffffe          BL       timer_reset
;;;361    		//轮流处理每个TCP连接, UIP_CONNS缺省是40个  
;;;362    		for(i=0;i<UIP_CONNS;i++)
00008a  2400              MOVS     r4,#0
00008c  e015              B        |L7.186|
                  |L7.142|
;;;363    		{
;;;364    			uip_periodic(i);	//处理TCP通信事件  
00008e  bf00              NOP      
000090  eb040084          ADD      r0,r4,r4,LSL #2
000094  4921              LDR      r1,|L7.284|
000096  eb0100c0          ADD      r0,r1,r0,LSL #3
00009a  4921              LDR      r1,|L7.288|
00009c  6008              STR      r0,[r1,#0]  ; uip_conn
00009e  2002              MOVS     r0,#2
0000a0  f7fffffe          BL       uip_process
0000a4  bf00              NOP      
;;;365    	 		//当上面的函数执行后，如果需要发送数据，则全局变量uip_len>0
;;;366    			//需要发送的数据在uip_buf, 长度是uip_len (这是2个全局变量)
;;;367    	 		if(uip_len>0)
0000a6  481b              LDR      r0,|L7.276|
0000a8  8800              LDRH     r0,[r0,#0]  ; uip_len
0000aa  2800              CMP      r0,#0
0000ac  dd03              BLE      |L7.182|
;;;368    			{
;;;369    				uip_arp_out();//加以太网头结构，在主动连接时可能要构造ARP请求
0000ae  f7fffffe          BL       uip_arp_out
;;;370    				tapdev_send();//发送数据到以太网
0000b2  f7fffffe          BL       tapdev_send
                  |L7.182|
0000b6  1c60              ADDS     r0,r4,#1              ;362
0000b8  b2c4              UXTB     r4,r0                 ;362
                  |L7.186|
0000ba  2c28              CMP      r4,#0x28              ;362
0000bc  dbe7              BLT      |L7.142|
;;;371    			}
;;;372    		}
;;;373    #if UIP_UDP	//UIP_UDP 
;;;374    		//轮流处理每个UDP连接, UIP_UDP_CONNS缺省是10个
;;;375    		for(i=0;i<UIP_UDP_CONNS;i++)
0000be  2400              MOVS     r4,#0
0000c0  e015              B        |L7.238|
                  |L7.194|
;;;376    		{
;;;377    			//uip_udp_periodic(i);	//处理UDP通信事件
;;;378                do 
0000c2  bf00              NOP      
;;;379                { 
;;;380                    uip_udp_conn = &uip_udp_conns[i]; 
0000c4  eb040084          ADD      r0,r4,r4,LSL #2
0000c8  4916              LDR      r1,|L7.292|
0000ca  eb010040          ADD      r0,r1,r0,LSL #1
0000ce  4916              LDR      r1,|L7.296|
0000d0  6008              STR      r0,[r1,#0]  ; uip_udp_conn
;;;381                    uip_process(UIP_UDP_TIMER); 
0000d2  2005              MOVS     r0,#5
0000d4  f7fffffe          BL       uip_process
;;;382                } while (0);
0000d8  bf00              NOP      
;;;383    	 		//当上面的函数执行后，如果需要发送数据，则全局变量uip_len>0
;;;384    			//需要发送的数据在uip_buf, 长度是uip_len (这是2个全局变量)
;;;385    			if(uip_len > 0)
0000da  480e              LDR      r0,|L7.276|
0000dc  8800              LDRH     r0,[r0,#0]  ; uip_len
0000de  2800              CMP      r0,#0
0000e0  dd03              BLE      |L7.234|
;;;386    			{
;;;387    				uip_arp_out();//加以太网头结构，在主动连接时可能要构造ARP请求
0000e2  f7fffffe          BL       uip_arp_out
;;;388    				tapdev_send();//发送数据到以太网
0000e6  f7fffffe          BL       tapdev_send
                  |L7.234|
0000ea  1c60              ADDS     r0,r4,#1              ;375
0000ec  b2c4              UXTB     r4,r0                 ;375
                  |L7.238|
0000ee  2c0a              CMP      r4,#0xa               ;375
0000f0  dbe7              BLT      |L7.194|
;;;389    			}
;;;390    		}
;;;391    #endif 
;;;392    		//每隔10秒调用1次ARP定时器函数 用于定期ARP处理,ARP表10秒更新一次，旧的条目会被抛弃
;;;393    		if(timer_expired(&arp_timer))
0000f2  4807              LDR      r0,|L7.272|
0000f4  f7fffffe          BL       timer_expired
0000f8  b120              CBZ      r0,|L7.260|
;;;394    		{
;;;395    			timer_reset(&arp_timer);
0000fa  4805              LDR      r0,|L7.272|
0000fc  f7fffffe          BL       timer_reset
;;;396    			uip_arp_timer();
000100  f7fffffe          BL       uip_arp_timer
                  |L7.260|
;;;397    		}
;;;398    	}
;;;399    }
000104  bd10              POP      {r4,pc}
;;;400    
                          ENDP

000106  0000              DCW      0x0000
                  |L7.264|
                          DCD      timer_ok
                  |L7.268|
                          DCD      periodic_timer
                  |L7.272|
                          DCD      arp_timer
                  |L7.276|
                          DCD      uip_len
                  |L7.280|
                          DCD      uip_buf
                  |L7.284|
                          DCD      uip_conns
                  |L7.288|
                          DCD      uip_conn
                  |L7.292|
                          DCD      uip_udp_conns
                  |L7.296|
                          DCD      uip_udp_conn

                          AREA ||.data||, DATA, ALIGN=2

                  system_tick_num
                          DCD      0x00000000
                  ipaddr
                          DCD      0x00000000
                  tcnt
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  UIP_udp_conn
                          DCD      0x00000000
                  periodic_timer
                          %        8
                  arp_timer
                          %        8
                  timer_ok
000020  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\Source\\src\\main.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |EnableInt|
#line 415
|EnableInt| PROC
#line 416


 MRS R0, PRIMASK
 CPSID I
 BX LR

	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |DisableInt|
#line 423
|DisableInt| PROC
#line 424


 MSR PRIMASK, R0
 BX LR

	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
