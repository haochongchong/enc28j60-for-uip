; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IC:\Users\Administrator\Desktop\lwip.practise\example6-1\Project\RVMDK\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\main.crf ..\..\Source\src\main.c]
                          THUMB

                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;126    ****************************************************************************/  
;;;127    void GPIO_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;128    {
;;;129      
;;;130      GPIO_InitTypeDef GPIO_InitStructure;
;;;131      RCC_APB2PeriphClockCmd( RCC_APB2Periph_USART1 |RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB |
000002  2101              MOVS     r1,#1
000004  f244007c          MOV      r0,#0x407c
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;132                             RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD |
;;;133                             RCC_APB2Periph_GPIOE, ENABLE);
;;;134      	
;;;135      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;				     //LED1控制
00000c  2020              MOVS     r0,#0x20
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;136      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000012  2010              MOVS     r0,#0x10
000014  f88d0003          STRB     r0,[sp,#3]
;;;137      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2003              MOVS     r0,#3
00001a  f88d0002          STRB     r0,[sp,#2]
;;;138      GPIO_Init(GPIOB, &GPIO_InitStructure);					 
00001e  4669              MOV      r1,sp
000020  4818              LDR      r0,|L1.132|
000022  f7fffffe          BL       GPIO_Init
;;;139    
;;;140      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_3;		 //LED2, LED3控制
000026  2048              MOVS     r0,#0x48
000028  f8ad0000          STRH     r0,[sp,#0]
;;;141      GPIO_Init(GPIOD, &GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  4816              LDR      r0,|L1.136|
000030  f7fffffe          BL       GPIO_Init
;;;142    
;;;143      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;					 //SST25VF016B SPI片选
000034  2010              MOVS     r0,#0x10
000036  f8ad0000          STRH     r0,[sp,#0]
;;;144      GPIO_Init(GPIOC, &GPIO_InitStructure);
00003a  4669              MOV      r1,sp
00003c  4813              LDR      r0,|L1.140|
00003e  f7fffffe          BL       GPIO_Init
;;;145      
;;;146      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12|GPIO_Pin_7;		 //PB12---VS1003 SPI片选（V2.1) 
000042  f44f5084          MOV      r0,#0x1080
000046  f8ad0000          STRH     r0,[sp,#0]
;;;147      GPIO_Init(GPIOB, &GPIO_InitStructure);					 //PB7---触摸屏芯片XPT2046 SPI 片选
00004a  4669              MOV      r1,sp
00004c  480d              LDR      r0,|L1.132|
00004e  f7fffffe          BL       GPIO_Init
;;;148      
;;;149      /* 禁止SPI1总线上的其他设备 */
;;;150      GPIO_SetBits(GPIOB, GPIO_Pin_7);						     //触摸屏芯片XPT2046 SPI 片选禁止  
000052  2180              MOVS     r1,#0x80
000054  480b              LDR      r0,|L1.132|
000056  f7fffffe          BL       GPIO_SetBits
;;;151      GPIO_SetBits(GPIOB, GPIO_Pin_12);						     //VS1003 SPI片选（V2.1)禁止 
00005a  f44f5180          MOV      r1,#0x1000
00005e  4809              LDR      r0,|L1.132|
000060  f7fffffe          BL       GPIO_SetBits
;;;152      GPIO_SetBits(GPIOC, GPIO_Pin_4);						     //SST25VF016B SPI片选禁止  
000064  2110              MOVS     r1,#0x10
000066  4809              LDR      r0,|L1.140|
000068  f7fffffe          BL       GPIO_SetBits
;;;153    
;;;154      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;	         	 	//ENC28J60接收完成中断引脚 
00006c  2002              MOVS     r0,#2
00006e  f8ad0000          STRH     r0,[sp,#0]
;;;155      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;   	 		//内部上拉输入
000072  2048              MOVS     r0,#0x48
000074  f88d0003          STRB     r0,[sp,#3]
;;;156      GPIO_Init(GPIOA, &GPIO_InitStructure);		 
000078  4669              MOV      r1,sp
00007a  4805              LDR      r0,|L1.144|
00007c  f7fffffe          BL       GPIO_Init
;;;157    
;;;158    
;;;159    //  GPIO_ResetBits(GPIOE, GPIO_Pin_1);						 //复位ENC28J60
;;;160    //  Delay(0xAFFF);					   
;;;161    //  GPIO_SetBits(GPIOE, GPIO_Pin_1 );		 	 	             
;;;162    //  Delay(0xAFFF);	
;;;163    }
000080  bd08              POP      {r3,pc}
;;;164    
                          ENDP

000082  0000              DCW      0x0000
                  |L1.132|
                          DCD      0x40010c00
                  |L1.136|
                          DCD      0x40011400
                  |L1.140|
                          DCD      0x40011000
                  |L1.144|
                          DCD      0x40010800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;40     ****************************************************************************/ 
;;;41     void NVIC_Configuration(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;42     {
;;;43       NVIC_InitTypeDef NVIC_InitStructure;
;;;44       EXTI_InitTypeDef EXTI_InitStructure;
;;;45       /* Configure one bit for preemption priority */
;;;46       /* 优先级组 说明了抢占优先级所用的位数，和子优先级所用的位数   在这里是1， 7 */    
;;;47       NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
000002  f44f60c0          MOV      r0,#0x600
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;48       
;;;49       /* Enable the EXTI2 Interrupt */
;;;50       NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;				 //外部中断2
00000a  2007              MOVS     r0,#7
00000c  f88d0008          STRB     r0,[sp,#8]
;;;51       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;	     //抢占优先级 0
000010  2000              MOVS     r0,#0
000012  f88d0009          STRB     r0,[sp,#9]
;;;52       NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;			 //子优先级0  
000016  f88d000a          STRB     r0,[sp,#0xa]
;;;53       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;				 //使能
00001a  2001              MOVS     r0,#1
00001c  f88d000b          STRB     r0,[sp,#0xb]
;;;54       NVIC_Init(&NVIC_InitStructure);
000020  a802              ADD      r0,sp,#8
000022  f7fffffe          BL       NVIC_Init
;;;55     
;;;56       																  //用于选择EXTI1外部中断的输入源是PA1。
;;;57       GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource1);     //外部中断配置,网卡中断
000026  2101              MOVS     r1,#1
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       GPIO_EXTILineConfig
;;;58     
;;;59       EXTI_InitStructure.EXTI_Line = EXTI_Line1;					  //配置外部中断1
00002e  2002              MOVS     r0,#2
000030  9000              STR      r0,[sp,#0]
;;;60       EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;			  //中断模式
000032  2000              MOVS     r0,#0
000034  f88d0004          STRB     r0,[sp,#4]
;;;61       EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;		  //下降沿触发
000038  200c              MOVS     r0,#0xc
00003a  f88d0005          STRB     r0,[sp,#5]
;;;62       //EXTI_InitStructure.EXTI_LineCmd = ENABLE;
;;;63       EXTI_Init(&EXTI_InitStructure);
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       EXTI_Init
;;;64     }
000044  bd0e              POP      {r1-r3,pc}
;;;65     /****************************************************************************
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_Configuration PROC
;;;110    ****************************************************************************/ 
;;;111    void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;112    {
;;;113       SystemInit(); 
000002  f7fffffe          BL       SystemInit
;;;114       RCC_APB2PeriphClockCmd( RCC_APB2Periph_AFIO  , ENABLE);  
000006  2101              MOVS     r1,#1
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;115     
;;;116    }
00000e  bd10              POP      {r4,pc}
;;;117    
                          ENDP


                          AREA ||i.Usart1_Init||, CODE, READONLY, ALIGN=2

                  Usart1_Init PROC
;;;72     ****************************************************************************/
;;;73     void Usart1_Init(void)
000000  b500              PUSH     {lr}
;;;74     {
000002  b085              SUB      sp,sp,#0x14
;;;75       GPIO_InitTypeDef GPIO_InitStructure;
;;;76       USART_InitTypeDef USART_InitStructure;
;;;77      
;;;78       RCC_APB2PeriphClockCmd( RCC_APB2Periph_USART1 , ENABLE);	 		//使能串口1时钟
000004  2101              MOVS     r1,#1
000006  0388              LSLS     r0,r1,#14
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;79     
;;;80       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;	         		 		//USART1 TX
00000c  f44f7000          MOV      r0,#0x200
000010  f8ad0010          STRH     r0,[sp,#0x10]
;;;81       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000014  2003              MOVS     r0,#3
000016  f88d0012          STRB     r0,[sp,#0x12]
;;;82       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;    		 		//复用推挽输出
00001a  2018              MOVS     r0,#0x18
00001c  f88d0013          STRB     r0,[sp,#0x13]
;;;83       GPIO_Init(GPIOA, &GPIO_InitStructure);		    		 		//A端口 
000020  a904              ADD      r1,sp,#0x10
000022  4813              LDR      r0,|L4.112|
000024  f7fffffe          BL       GPIO_Init
;;;84     
;;;85       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;	         	 		//USART1 RX
000028  f44f6080          MOV      r0,#0x400
00002c  f8ad0010          STRH     r0,[sp,#0x10]
;;;86       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;   	 		//复用开漏输入
000030  2004              MOVS     r0,#4
000032  f88d0013          STRB     r0,[sp,#0x13]
;;;87       GPIO_Init(GPIOA, &GPIO_InitStructure);		         	 		//A端口 
000036  a904              ADD      r1,sp,#0x10
000038  480d              LDR      r0,|L4.112|
00003a  f7fffffe          BL       GPIO_Init
;;;88     
;;;89       USART_InitStructure.USART_BaudRate = 115200;						//速率115200bps
00003e  f44f30e1          MOV      r0,#0x1c200
000042  9000              STR      r0,[sp,#0]
;;;90       USART_InitStructure.USART_WordLength = USART_WordLength_8b;		//数据位8位
000044  2000              MOVS     r0,#0
000046  f8ad0004          STRH     r0,[sp,#4]
;;;91       USART_InitStructure.USART_StopBits = USART_StopBits_1;			//停止位1位
00004a  f8ad0006          STRH     r0,[sp,#6]
;;;92       USART_InitStructure.USART_Parity = USART_Parity_No;				//无校验位
00004e  f8ad0008          STRH     r0,[sp,#8]
;;;93       USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;   //无硬件流控
000052  f8ad000c          STRH     r0,[sp,#0xc]
;;;94       USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;					//收发模式
000056  200c              MOVS     r0,#0xc
000058  f8ad000a          STRH     r0,[sp,#0xa]
;;;95     
;;;96       /* Configure USART1 */
;;;97       USART_Init(USART1, &USART_InitStructure);							//配置串口参数函数   
00005c  4669              MOV      r1,sp
00005e  4805              LDR      r0,|L4.116|
000060  f7fffffe          BL       USART_Init
;;;98        /* Enable the USART1 */
;;;99       USART_Cmd(USART1, ENABLE);	
000064  2101              MOVS     r1,#1
000066  4803              LDR      r0,|L4.116|
000068  f7fffffe          BL       USART_Cmd
;;;100      
;;;101    }
00006c  b005              ADD      sp,sp,#0x14
00006e  bd00              POP      {pc}
;;;102    
                          ENDP

                  |L4.112|
                          DCD      0x40010800
                  |L4.116|
                          DCD      0x40013800

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  main PROC
;;;178    
;;;179    int main(void)
000000  24ff              MOVS     r4,#0xff
;;;180    {
;;;181    	u8 tcp_server_tsta=0XFF;
;;;182    	u8 tcp_client_tsta=0XFF;
000002  25ff              MOVS     r5,#0xff
;;;183    	
;;;184    	RCC_Configuration();				 //系统时钟设置
000004  f7fffffe          BL       RCC_Configuration
;;;185    	NVIC_Configuration();
000008  f7fffffe          BL       NVIC_Configuration
;;;186    	GPIO_Configuration();                //IO口初始化
00000c  f7fffffe          BL       GPIO_Configuration
;;;187    	Usart1_Init();                       //串口1初始化
000010  f7fffffe          BL       Usart1_Init
;;;188    
;;;189    	/* 配置systic作为20ms中断 */
;;;190    	if (SysTick_Config(20*72000))		//时钟节拍中断，20ms一次
000014  4971              LDR      r1,|L5.476|
000016  f1b17f80          CMP      r1,#0x1000000
00001a  d301              BCC      |L5.32|
00001c  2001              MOVS     r0,#1
00001e  e01d              B        |L5.92|
                  |L5.32|
000020  f021407f          BIC      r0,r1,#0xff000000
000024  1e40              SUBS     r0,r0,#1
000026  f04f22e0          MOV      r2,#0xe000e000
00002a  6150              STR      r0,[r2,#0x14]
00002c  1750              ASRS     r0,r2,#29
00002e  220f              MOVS     r2,#0xf
000030  2800              CMP      r0,#0
000032  da07              BGE      |L5.68|
000034  0713              LSLS     r3,r2,#28
000036  0e1f              LSRS     r7,r3,#24
000038  4b69              LDR      r3,|L5.480|
00003a  f000060f          AND      r6,r0,#0xf
00003e  1f36              SUBS     r6,r6,#4
000040  559f              STRB     r7,[r3,r6]
000042  e003              B        |L5.76|
                  |L5.68|
000044  0713              LSLS     r3,r2,#28
000046  0e1e              LSRS     r6,r3,#24
000048  4b66              LDR      r3,|L5.484|
00004a  541e              STRB     r6,[r3,r0]
                  |L5.76|
00004c  bf00              NOP      
00004e  2000              MOVS     r0,#0
000050  f04f22e0          MOV      r2,#0xe000e000
000054  6190              STR      r0,[r2,#0x18]
000056  2007              MOVS     r0,#7
000058  6110              STR      r0,[r2,#0x10]
00005a  2000              MOVS     r0,#0
                  |L5.92|
00005c  b108              CBZ      r0,|L5.98|
;;;191        { 
;;;192        	/* error handle*/ 
;;;193         	while (1);
00005e  bf00              NOP      
                  |L5.96|
000060  e7fe              B        |L5.96|
                  |L5.98|
;;;194        }
;;;195    
;;;196    	/* 向串口1发送开机字符 */
;;;197        printf("****       (C) COPYRIGHT 2013 制造者科技    *******\r\n");    	  //。
000062  a061              ADR      r0,|L5.488|
000064  f7fffffe          BL       __2printf
;;;198        printf("*                                                 *\r\n");  
000068  a06d              ADR      r0,|L5.544|
00006a  f7fffffe          BL       __2printf
;;;199        printf("*                                                 *\r\n");    	  	
00006e  a06c              ADR      r0,|L5.544|
000070  f7fffffe          BL       __2printf
;;;200        printf("*     MCU平台:STM32F103VET6                       *\r\n");    	
000074  a078              ADR      r0,|L5.600|
000076  f7fffffe          BL       __2printf
;;;201        printf("*     以太网硬件:ENC28J60                         *\r\n");    	  	
00007a  a085              ADR      r0,|L5.656|
00007c  f7fffffe          BL       __2printf
;;;202        printf("*     固件库：3.5                                 *\r\n");    	
000080  a091              ADR      r0,|L5.712|
000082  f7fffffe          BL       __2printf
;;;203        printf("*     例程版本: 0.2                               *\r\n");     
000086  a09e              ADR      r0,|L5.768|
000088  f7fffffe          BL       __2printf
;;;204        printf("*                                                 *\r\n");    	 	
00008c  a064              ADR      r0,|L5.544|
00008e  f7fffffe          BL       __2printf
;;;205        printf("***************************************************\r\n");  	
000092  a0a9              ADR      r0,|L5.824|
000094  f7fffffe          BL       __2printf
;;;206    
;;;207    	SPI1_Init();	      //SPI口初始化，用于网卡间传输数据
000098  f7fffffe          BL       SPI1_Init
;;;208    
;;;209    	tapdev_init();
00009c  f7fffffe          BL       tapdev_init
;;;210    	uip_init();				//uIP初始化	  
0000a0  f7fffffe          BL       uip_init
;;;211    	
;;;212    	
;;;213    	uip_ipaddr(ipaddr, 192,168,1,16);	//设置本地设置IP地址
0000a4  bf00              NOP      
0000a6  f64a00c0          MOV      r0,#0xa8c0
0000aa  49b1              LDR      r1,|L5.880|
0000ac  8008              STRH     r0,[r1,#0]
0000ae  f2410001          MOV      r0,#0x1001
0000b2  8048              STRH     r0,[r1,#2]
0000b4  bf00              NOP      
;;;214    	uip_sethostaddr(ipaddr);					    
0000b6  bf00              NOP      
0000b8  4608              MOV      r0,r1
0000ba  8800              LDRH     r0,[r0,#0]  ; ipaddr
0000bc  49ad              LDR      r1,|L5.884|
0000be  8008              STRH     r0,[r1,#0]
0000c0  48ab              LDR      r0,|L5.880|
0000c2  8840              LDRH     r0,[r0,#2]  ; ipaddr
0000c4  8048              STRH     r0,[r1,#2]
0000c6  bf00              NOP      
;;;215    	uip_ipaddr(ipaddr, 192,168,1,1); 	//设置网关IP地址(其实就是你路由器的IP地址)
0000c8  bf00              NOP      
0000ca  f64a00c0          MOV      r0,#0xa8c0
0000ce  49a8              LDR      r1,|L5.880|
0000d0  8008              STRH     r0,[r1,#0]
0000d2  f2401001          MOV      r0,#0x101
0000d6  8048              STRH     r0,[r1,#2]
0000d8  bf00              NOP      
;;;216    	uip_setdraddr(ipaddr);						 
0000da  bf00              NOP      
0000dc  4608              MOV      r0,r1
0000de  8800              LDRH     r0,[r0,#0]  ; ipaddr
0000e0  49a5              LDR      r1,|L5.888|
0000e2  8008              STRH     r0,[r1,#0]
0000e4  48a2              LDR      r0,|L5.880|
0000e6  8840              LDRH     r0,[r0,#2]  ; ipaddr
0000e8  8048              STRH     r0,[r1,#2]
0000ea  bf00              NOP      
;;;217    	uip_ipaddr(ipaddr, 255,255,255,0);	//设置网络掩码
0000ec  bf00              NOP      
0000ee  f64f70ff          MOV      r0,#0xffff
0000f2  499f              LDR      r1,|L5.880|
0000f4  8008              STRH     r0,[r1,#0]
0000f6  20ff              MOVS     r0,#0xff
0000f8  8048              STRH     r0,[r1,#2]
0000fa  bf00              NOP      
;;;218    	uip_setnetmask(ipaddr);
0000fc  bf00              NOP      
0000fe  4608              MOV      r0,r1
000100  8800              LDRH     r0,[r0,#0]  ; ipaddr
000102  499e              LDR      r1,|L5.892|
000104  8008              STRH     r0,[r1,#0]
000106  489a              LDR      r0,|L5.880|
000108  8840              LDRH     r0,[r0,#2]  ; ipaddr
00010a  8048              STRH     r0,[r1,#2]
00010c  bf00              NOP      
;;;219    
;;;220    	uip_listen(HTONS(1200));			//监听1200端口,用于TCP Server
00010e  f24b0004          MOV      r0,#0xb004
000112  f7fffffe          BL       uip_listen
;;;221    	uip_listen(HTONS(80));				//监听80端口,用于Web Server
000116  f44f40a0          MOV      r0,#0x5000
00011a  f7fffffe          BL       uip_listen
;;;222      	tcp_client_reconnect();	   		    //尝试连接到TCP Server端,用于TCP Client
00011e  f7fffffe          BL       tcp_client_reconnect
;;;223    	
;;;224    	
;;;225    	while (1)
000122  e059              B        |L5.472|
                  |L5.292|
;;;226    	{
;;;227    		uip_polling();	//处理uip事件，必须插入到用户程序的循环体中  
000124  f7fffffe          BL       uip_polling
;;;228    		if(tcp_server_tsta!=tcp_server_sta)//TCP Server状态改变
000128  4895              LDR      r0,|L5.896|
00012a  7800              LDRB     r0,[r0,#0]  ; tcp_server_sta
00012c  4284              CMP      r4,r0
00012e  d01c              BEQ      |L5.362|
;;;229    		{															 
;;;230    			if(tcp_server_sta&(1<<7))
000130  4893              LDR      r0,|L5.896|
000132  7800              LDRB     r0,[r0,#0]  ; tcp_server_sta
000134  f0000080          AND      r0,r0,#0x80
000138  b118              CBZ      r0,|L5.322|
;;;231    			{
;;;232    				printf("TCP Server Connected   ");
00013a  a092              ADR      r0,|L5.900|
00013c  f7fffffe          BL       __2printf
000140  e002              B        |L5.328|
                  |L5.322|
;;;233    			}
;;;234    			else
;;;235    			{
;;;236    				printf("TCP Server Disconnected");
000142  a096              ADR      r0,|L5.924|
000144  f7fffffe          BL       __2printf
                  |L5.328|
;;;237    			}
;;;238     			if(tcp_server_sta&(1<<6))	//收到新数据
000148  488d              LDR      r0,|L5.896|
00014a  7800              LDRB     r0,[r0,#0]  ; tcp_server_sta
00014c  f0000040          AND      r0,r0,#0x40
000150  b148              CBZ      r0,|L5.358|
;;;239    			{
;;;240        			printf("TCP Server RX:%s\r\n",tcp_server_databuf);//打印数据
000152  4998              LDR      r1,|L5.948|
000154  a098              ADR      r0,|L5.952|
000156  f7fffffe          BL       __2printf
;;;241    				tcp_server_sta&=~(1<<6);		//标记数据已经被处理	
00015a  4889              LDR      r0,|L5.896|
00015c  7800              LDRB     r0,[r0,#0]  ; tcp_server_sta
00015e  f0200040          BIC      r0,r0,#0x40
000162  4987              LDR      r1,|L5.896|
000164  7008              STRB     r0,[r1,#0]
                  |L5.358|
;;;242    			}
;;;243    			tcp_server_tsta=tcp_server_sta;
000166  4886              LDR      r0,|L5.896|
000168  7804              LDRB     r4,[r0,#0]  ; tcp_server_sta
                  |L5.362|
;;;244    		}
;;;245    		if(1)//TCP Server 请求发送数据
;;;246    		{
;;;247    			if(tcp_server_sta&(1<<7))	//连接还存在
00016a  4885              LDR      r0,|L5.896|
00016c  7800              LDRB     r0,[r0,#0]  ; tcp_server_sta
00016e  f0000080          AND      r0,r0,#0x80
000172  b180              CBZ      r0,|L5.406|
;;;248    			{
;;;249    				sprintf((char*)tcp_server_databuf,"TCP Server OK %d\r\n",tcnt);	 
000174  4895              LDR      r0,|L5.972|
000176  8802              LDRH     r2,[r0,#0]  ; tcnt
000178  a195              ADR      r1,|L5.976|
00017a  488e              LDR      r0,|L5.948|
00017c  f7fffffe          BL       __2sprintf
;;;250    				tcp_server_sta|=1<<5;//标记有数据需要发送
000180  487f              LDR      r0,|L5.896|
000182  7800              LDRB     r0,[r0,#0]  ; tcp_server_sta
000184  f0400020          ORR      r0,r0,#0x20
000188  497d              LDR      r1,|L5.896|
00018a  7008              STRB     r0,[r1,#0]
;;;251    				tcnt++;
00018c  488f              LDR      r0,|L5.972|
00018e  8800              LDRH     r0,[r0,#0]  ; tcnt
000190  1c40              ADDS     r0,r0,#1
000192  498e              LDR      r1,|L5.972|
000194  8008              STRH     r0,[r1,#0]
                  |L5.406|
;;;252    			}
;;;253    		}
;;;254    		if(tcp_client_tsta!=tcp_client_sta)//TCP Client状态改变
000196  4893              LDR      r0,|L5.996|
000198  7800              LDRB     r0,[r0,#0]  ; tcp_client_sta
00019a  4285              CMP      r5,r0
00019c  d01c              BEQ      |L5.472|
;;;255    		{															 
;;;256    			if(tcp_client_sta&(1<<7))
00019e  4891              LDR      r0,|L5.996|
0001a0  7800              LDRB     r0,[r0,#0]  ; tcp_client_sta
0001a2  f0000080          AND      r0,r0,#0x80
0001a6  b118              CBZ      r0,|L5.432|
;;;257    			{
;;;258    				printf("TCP Client Connected   ");
0001a8  a08f              ADR      r0,|L5.1000|
0001aa  f7fffffe          BL       __2printf
0001ae  e002              B        |L5.438|
                  |L5.432|
;;;259    			}
;;;260    			else
;;;261    			{
;;;262    				printf("TCP Client Disconnected");
0001b0  a093              ADR      r0,|L5.1024|
0001b2  f7fffffe          BL       __2printf
                  |L5.438|
;;;263    			}
;;;264     			if(tcp_client_sta&(1<<6))	//收到新数据
0001b6  488b              LDR      r0,|L5.996|
0001b8  7800              LDRB     r0,[r0,#0]  ; tcp_client_sta
0001ba  f0000040          AND      r0,r0,#0x40
0001be  b148              CBZ      r0,|L5.468|
;;;265    			{
;;;266        			printf("TCP Client RX:%s\r\n",tcp_client_databuf);//打印数据
0001c0  4995              LDR      r1,|L5.1048|
0001c2  a096              ADR      r0,|L5.1052|
0001c4  f7fffffe          BL       __2printf
;;;267    				tcp_client_sta&=~(1<<6);		//标记数据已经被处理	
0001c8  4886              LDR      r0,|L5.996|
0001ca  7800              LDRB     r0,[r0,#0]  ; tcp_client_sta
0001cc  f0200040          BIC      r0,r0,#0x40
0001d0  4984              LDR      r1,|L5.996|
0001d2  7008              STRB     r0,[r1,#0]
                  |L5.468|
;;;268    			}
;;;269    			tcp_client_tsta=tcp_client_sta;
0001d4  4883              LDR      r0,|L5.996|
0001d6  7805              LDRB     r5,[r0,#0]  ; tcp_client_sta
                  |L5.472|
0001d8  e7a4              B        |L5.292|
;;;270    		}
;;;271    		if(0)//TCP Client 请求发送数据
;;;272    		{
;;;273    			if(tcp_client_sta&(1<<7))	//连接还存在
;;;274    			{
;;;275    				sprintf((char*)tcp_client_databuf,"TCP Client OK %d\r\n",tcnt);	 
;;;276    				tcp_client_sta|=1<<5;//标记有数据需要发送
;;;277    				tcnt++;
;;;278    			}
;;;279    		}
;;;280    	} 
;;;281    	
;;;282    	//lwip_demo(NULL);	  //初始化内核，启动LwIP相关
;;;283    
;;;284    	while (1)
;;;285    	{
;;;286    	    //exit(0);	
;;;287    	}
;;;288    }
;;;289    
                          ENDP

0001da  0000              DCW      0x0000
                  |L5.476|
                          DCD      0x0015f900
                  |L5.480|
                          DCD      0xe000ed18
                  |L5.484|
                          DCD      0xe000e400
                  |L5.488|
0001e8  2a2a2a2a          DCB      "****       (C) COPYRIGHT 2013 ",214,198,212,236,213,223
0001ec  20202020
0001f0  20202028
0001f4  43292043
0001f8  4f505952
0001fc  49474854
000200  20323031
000204  3320d6c6
000208  d4ecd5df
00020c  bfc6bcbc          DCB      191,198,188,188,"    *******\r\n",0
000210  20202020
000214  2a2a2a2a
000218  2a2a2a0d
00021c  0a00    
00021e  00                DCB      0
00021f  00                DCB      0
                  |L5.544|
000220  2a202020          DCB      "*                                                 *\r\n"
000224  20202020
000228  20202020
00022c  20202020
000230  20202020
000234  20202020
000238  20202020
00023c  20202020
000240  20202020
000244  20202020
000248  20202020
00024c  20202020
000250  20202a0d
000254  0a      
000255  00                DCB      0
000256  00                DCB      0
000257  00                DCB      0
                  |L5.600|
000258  2a202020          DCB      "*     MCU",198,189,204,168,":STM32F103VET6             "
00025c  20204d43
000260  55c6bdcc
000264  a83a5354
000268  4d333246
00026c  31303356
000270  45543620
000274  20202020
000278  20202020
00027c  20202020
000280  20202020          DCB      "          *\r\n",0
000284  20202020
000288  20202a0d
00028c  0a00    
00028e  00                DCB      0
00028f  00                DCB      0
                  |L5.656|
000290  2a202020          DCB      "*     ",210,212,204,171,205,248,211,178,188,254,":ENC28"
000294  2020d2d4
000298  ccabcdf8
00029c  d3b2bcfe
0002a0  3a454e43
0002a4  3238    
0002a6  4a363020          DCB      "J60                         *\r\n",0
0002aa  20202020
0002ae  20202020
0002b2  20202020
0002b6  20202020
0002ba  20202020
0002be  20202020
0002c2  2a0d0a00
0002c6  00                DCB      0
0002c7  00                DCB      0
                  |L5.712|
0002c8  2a202020          DCB      "*     ",185,204,188,254,191,226,163,186,"3.5           "
0002cc  2020b9cc
0002d0  bcfebfe2
0002d4  a3ba332e
0002d8  35202020
0002dc  20202020
0002e0  20202020
0002e4  20202020          DCB      "                      *\r\n",0
0002e8  20202020
0002ec  20202020
0002f0  20202020
0002f4  20202020
0002f8  20202a0d
0002fc  0a00    
0002fe  00                DCB      0
0002ff  00                DCB      0
                  |L5.768|
000300  2a202020          DCB      "*     ",192,253,179,204,176,230,177,190,": 0.2         "
000304  2020c0fd
000308  b3ccb0e6
00030c  b1be3a20
000310  302e3220
000314  20202020
000318  20202020
00031c  20202020          DCB      "                      *\r\n",0
000320  20202020
000324  20202020
000328  20202020
00032c  20202020
000330  20202a0d
000334  0a00    
000336  00                DCB      0
000337  00                DCB      0
                  |L5.824|
000338  2a2a2a2a          DCB      "***************************************************\r\n"
00033c  2a2a2a2a
000340  2a2a2a2a
000344  2a2a2a2a
000348  2a2a2a2a
00034c  2a2a2a2a
000350  2a2a2a2a
000354  2a2a2a2a
000358  2a2a2a2a
00035c  2a2a2a2a
000360  2a2a2a2a
000364  2a2a2a2a
000368  2a2a2a0d
00036c  0a      
00036d  00                DCB      0
00036e  00                DCB      0
00036f  00                DCB      0
                  |L5.880|
                          DCD      ipaddr
                  |L5.884|
                          DCD      uip_hostaddr
                  |L5.888|
                          DCD      uip_draddr
                  |L5.892|
                          DCD      uip_netmask
                  |L5.896|
                          DCD      tcp_server_sta
                  |L5.900|
000384  54435020          DCB      "TCP Server Connected   ",0
000388  53657276
00038c  65722043
000390  6f6e6e65
000394  63746564
000398  20202000
                  |L5.924|
00039c  54435020          DCB      "TCP Server Disconnected",0
0003a0  53657276
0003a4  65722044
0003a8  6973636f
0003ac  6e6e6563
0003b0  74656400
                  |L5.948|
                          DCD      tcp_server_databuf
                  |L5.952|
0003b8  54435020          DCB      "TCP Server RX:%s\r\n",0
0003bc  53657276
0003c0  65722052
0003c4  583a2573
0003c8  0d0a00  
0003cb  00                DCB      0
                  |L5.972|
                          DCD      tcnt
                  |L5.976|
0003d0  54435020          DCB      "TCP Server OK %d\r\n",0
0003d4  53657276
0003d8  6572204f
0003dc  4b202564
0003e0  0d0a00  
0003e3  00                DCB      0
                  |L5.996|
                          DCD      tcp_client_sta
                  |L5.1000|
0003e8  54435020          DCB      "TCP Client Connected   ",0
0003ec  436c6965
0003f0  6e742043
0003f4  6f6e6e65
0003f8  63746564
0003fc  20202000
                  |L5.1024|
000400  54435020          DCB      "TCP Client Disconnected",0
000404  436c6965
000408  6e742044
00040c  6973636f
000410  6e6e6563
000414  74656400
                  |L5.1048|
                          DCD      tcp_client_databuf
                  |L5.1052|
00041c  54435020          DCB      "TCP Client RX:%s\r\n",0
000420  436c6965
000424  6e742052
000428  583a2573
00042c  0d0a00  
00042f  00                DCB      0

                          AREA ||i.sys_now||, CODE, READONLY, ALIGN=2

                  sys_now PROC
;;;26     unsigned int system_tick_num = 0;
;;;27     unsigned int sys_now(void)
000000  4801              LDR      r0,|L6.8|
;;;28     {
;;;29         return system_tick_num;
000002  6800              LDR      r0,[r0,#0]  ; system_tick_num
;;;30     }
000004  4770              BX       lr
;;;31     
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      system_tick_num

                          AREA ||i.uip_polling||, CODE, READONLY, ALIGN=2

                  uip_polling PROC
;;;290    #define BUF ((struct uip_eth_hdr *)&uip_buf[0])	 
;;;291    void uip_polling(void)
000000  b510              PUSH     {r4,lr}
;;;292    {
;;;293    	u8 i;
;;;294    	static struct timer periodic_timer, arp_timer;
;;;295    	static u8 timer_ok=0;	 
;;;296    	if(timer_ok==0)//仅初始化一次
000002  4833              LDR      r0,|L7.208|
000004  7800              LDRB     r0,[r0,#0]  ; timer_ok
000006  b958              CBNZ     r0,|L7.32|
;;;297    	{
;;;298    		timer_ok = 1;
000008  2001              MOVS     r0,#1
00000a  4931              LDR      r1,|L7.208|
00000c  7008              STRB     r0,[r1,#0]
;;;299    		timer_set(&periodic_timer,CLOCK_SECOND/2);  //创建1个0.5秒的定时器 
00000e  2132              MOVS     r1,#0x32
000010  4830              LDR      r0,|L7.212|
000012  f7fffffe          BL       timer_set
;;;300    		timer_set(&arp_timer,CLOCK_SECOND*10);	   	//创建1个10秒的定时器 
000016  f44f717a          MOV      r1,#0x3e8
00001a  482f              LDR      r0,|L7.216|
00001c  f7fffffe          BL       timer_set
                  |L7.32|
;;;301    	}				 
;;;302    	uip_len=tapdev_read();	//从网络设备读取一个IP包,得到数据长度.uip_len在uip.c中定义
000020  f7fffffe          BL       tapdev_read
000024  492d              LDR      r1,|L7.220|
000026  8008              STRH     r0,[r1,#0]
;;;303    	if(uip_len>0) 			//有数据
000028  4608              MOV      r0,r1
00002a  8800              LDRH     r0,[r0,#0]  ; uip_len
00002c  2800              CMP      r0,#0
00002e  dd24              BLE      |L7.122|
;;;304    	{   
;;;305    		//处理IP数据包(只有校验通过的IP包才会被接收) 
;;;306    		if(BUF->type == htons(UIP_ETHTYPE_IP))//是否是IP包? 
000030  f44f6000          MOV      r0,#0x800
000034  f7fffffe          BL       htons
000038  4929              LDR      r1,|L7.224|
00003a  8989              LDRH     r1,[r1,#0xc]  ; uip_buf
00003c  4288              CMP      r0,r1
00003e  d10b              BNE      |L7.88|
;;;307    		{
;;;308    			uip_arp_ipin();	//去除以太网头结构，更新ARP表
;;;309    			uip_input();   	//IP包处理
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       uip_process
;;;310    			//当上面的函数执行后，如果需要发送数据，则全局变量 uip_len > 0
;;;311    			//需要发送的数据在uip_buf, 长度是uip_len  (这是2个全局变量)		    
;;;312    			if(uip_len>0)//需要回应数据
000046  4825              LDR      r0,|L7.220|
000048  8800              LDRH     r0,[r0,#0]  ; uip_len
00004a  2800              CMP      r0,#0
00004c  dd3f              BLE      |L7.206|
;;;313    			{
;;;314    				uip_arp_out();//加以太网头结构，在主动连接时可能要构造ARP请求
00004e  f7fffffe          BL       uip_arp_out
;;;315    				tapdev_send();//发送数据到以太网
000052  f7fffffe          BL       tapdev_send
000056  e03a              B        |L7.206|
                  |L7.88|
;;;316    			}
;;;317    		}else if (BUF->type==htons(UIP_ETHTYPE_ARP))//处理arp报文,是否是ARP请求包?
000058  f6400006          MOV      r0,#0x806
00005c  f7fffffe          BL       htons
000060  491f              LDR      r1,|L7.224|
000062  8989              LDRH     r1,[r1,#0xc]  ; uip_buf
000064  4288              CMP      r0,r1
000066  d132              BNE      |L7.206|
;;;318    		{
;;;319    			uip_arp_arpin();
000068  f7fffffe          BL       uip_arp_arpin
;;;320     			//当上面的函数执行后，如果需要发送数据，则全局变量uip_len>0
;;;321    			//需要发送的数据在uip_buf, 长度是uip_len(这是2个全局变量)
;;;322     			if(uip_len>0)tapdev_send();//需要发送数据,则通过tapdev_send发送	 
00006c  481b              LDR      r0,|L7.220|
00006e  8800              LDRH     r0,[r0,#0]  ; uip_len
000070  2800              CMP      r0,#0
000072  dd2c              BLE      |L7.206|
000074  f7fffffe          BL       tapdev_send
000078  e029              B        |L7.206|
                  |L7.122|
;;;323    		}
;;;324    	}else if(timer_expired(&periodic_timer))	//0.5秒定时器超时
00007a  4816              LDR      r0,|L7.212|
00007c  f7fffffe          BL       timer_expired
000080  b328              CBZ      r0,|L7.206|
;;;325    	{
;;;326    		timer_reset(&periodic_timer);		//复位0.5秒定时器 
000082  4814              LDR      r0,|L7.212|
000084  f7fffffe          BL       timer_reset
;;;327    		//轮流处理每个TCP连接, UIP_CONNS缺省是40个  
;;;328    		for(i=0;i<UIP_CONNS;i++)
000088  2400              MOVS     r4,#0
00008a  e015              B        |L7.184|
                  |L7.140|
;;;329    		{
;;;330    			uip_periodic(i);	//处理TCP通信事件  
00008c  bf00              NOP      
00008e  eb040084          ADD      r0,r4,r4,LSL #2
000092  4914              LDR      r1,|L7.228|
000094  eb0100c0          ADD      r0,r1,r0,LSL #3
000098  4913              LDR      r1,|L7.232|
00009a  6008              STR      r0,[r1,#0]  ; uip_conn
00009c  2002              MOVS     r0,#2
00009e  f7fffffe          BL       uip_process
0000a2  bf00              NOP      
;;;331    	 		//当上面的函数执行后，如果需要发送数据，则全局变量uip_len>0
;;;332    			//需要发送的数据在uip_buf, 长度是uip_len (这是2个全局变量)
;;;333    	 		if(uip_len>0)
0000a4  480d              LDR      r0,|L7.220|
0000a6  8800              LDRH     r0,[r0,#0]  ; uip_len
0000a8  2800              CMP      r0,#0
0000aa  dd03              BLE      |L7.180|
;;;334    			{
;;;335    				uip_arp_out();//加以太网头结构，在主动连接时可能要构造ARP请求
0000ac  f7fffffe          BL       uip_arp_out
;;;336    				tapdev_send();//发送数据到以太网
0000b0  f7fffffe          BL       tapdev_send
                  |L7.180|
0000b4  1c60              ADDS     r0,r4,#1              ;328
0000b6  b2c4              UXTB     r4,r0                 ;328
                  |L7.184|
0000b8  2c28              CMP      r4,#0x28              ;328
0000ba  dbe7              BLT      |L7.140|
;;;337    			}
;;;338    		}
;;;339    #if UIP_UDP	//UIP_UDP 
;;;340    		//轮流处理每个UDP连接, UIP_UDP_CONNS缺省是10个
;;;341    		for(i=0;i<UIP_UDP_CONNS;i++)
;;;342    		{
;;;343    			uip_udp_periodic(i);	//处理UDP通信事件
;;;344    	 		//当上面的函数执行后，如果需要发送数据，则全局变量uip_len>0
;;;345    			//需要发送的数据在uip_buf, 长度是uip_len (这是2个全局变量)
;;;346    			if(uip_len > 0)
;;;347    			{
;;;348    				uip_arp_out();//加以太网头结构，在主动连接时可能要构造ARP请求
;;;349    				tapdev_send();//发送数据到以太网
;;;350    			}
;;;351    		}
;;;352    #endif 
;;;353    		//每隔10秒调用1次ARP定时器函数 用于定期ARP处理,ARP表10秒更新一次，旧的条目会被抛弃
;;;354    		if(timer_expired(&arp_timer))
0000bc  4806              LDR      r0,|L7.216|
0000be  f7fffffe          BL       timer_expired
0000c2  b120              CBZ      r0,|L7.206|
;;;355    		{
;;;356    			timer_reset(&arp_timer);
0000c4  4804              LDR      r0,|L7.216|
0000c6  f7fffffe          BL       timer_reset
;;;357    			uip_arp_timer();
0000ca  f7fffffe          BL       uip_arp_timer
                  |L7.206|
;;;358    		}
;;;359    	}
;;;360    }
0000ce  bd10              POP      {r4,pc}
;;;361    
                          ENDP

                  |L7.208|
                          DCD      timer_ok
                  |L7.212|
                          DCD      periodic_timer
                  |L7.216|
                          DCD      arp_timer
                  |L7.220|
                          DCD      uip_len
                  |L7.224|
                          DCD      uip_buf
                  |L7.228|
                          DCD      uip_conns
                  |L7.232|
                          DCD      uip_conn

                          AREA ||.data||, DATA, ALIGN=2

                  system_tick_num
                          DCD      0x00000000
                  ipaddr
                          DCD      0x00000000
                  tcnt
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  periodic_timer
                          %        8
                  arp_timer
                          %        8
                  timer_ok
00001c  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\Source\\src\\main.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |EnableInt|
#line 376
|EnableInt| PROC
#line 377


 MRS R0, PRIMASK
 CPSID I
 BX LR

	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |DisableInt|
#line 384
|DisableInt| PROC
#line 385


 MSR PRIMASK, R0
 BX LR

	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
