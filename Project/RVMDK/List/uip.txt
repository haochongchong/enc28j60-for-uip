; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uip.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\uip.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IC:\Users\Administrator\Desktop\lwip.practise\example6-1\Project\RVMDK\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\uip.crf ..\..\Source\uIP-1.0\uip\uip.c]
                          THUMB

                          AREA ||i.chksum||, CODE, READONLY, ALIGN=1

                  chksum PROC
;;;280    static u16_t
;;;281    chksum(u16_t sum, const u8_t *data, u16_t len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;282    {
000002  460b              MOV      r3,r1
000004  4614              MOV      r4,r2
;;;283      u16_t t;
;;;284      const u8_t *dataptr;
;;;285      const u8_t *last_byte;
;;;286    
;;;287      dataptr = data;
000006  4619              MOV      r1,r3
;;;288      last_byte = data + len - 1;
000008  191e              ADDS     r6,r3,r4
00000a  1e75              SUBS     r5,r6,#1
;;;289      
;;;290      while(dataptr < last_byte) {	/* At least two more bytes */
00000c  e00b              B        |L1.38|
                  |L1.14|
;;;291        t = (dataptr[0] << 8) + dataptr[1];
00000e  784e              LDRB     r6,[r1,#1]
000010  780f              LDRB     r7,[r1,#0]
000012  eb062607          ADD      r6,r6,r7,LSL #8
000016  b2b2              UXTH     r2,r6
;;;292        sum += t;
000018  1886              ADDS     r6,r0,r2
00001a  b2b0              UXTH     r0,r6
;;;293        if(sum < t) {
00001c  4290              CMP      r0,r2
00001e  da01              BGE      |L1.36|
;;;294          sum++;		/* carry */
000020  1c46              ADDS     r6,r0,#1
000022  b2b0              UXTH     r0,r6
                  |L1.36|
;;;295        }
;;;296        dataptr += 2;
000024  1c89              ADDS     r1,r1,#2
                  |L1.38|
000026  42a9              CMP      r1,r5                 ;290
000028  d3f1              BCC      |L1.14|
;;;297      }
;;;298      
;;;299      if(dataptr == last_byte) {
00002a  42a9              CMP      r1,r5
00002c  d10a              BNE      |L1.68|
;;;300        t = (dataptr[0] << 8) + 0;
00002e  780e              LDRB     r6,[r1,#0]
000030  2700              MOVS     r7,#0
000032  eb072606          ADD      r6,r7,r6,LSL #8
000036  b2b2              UXTH     r2,r6
;;;301        sum += t;
000038  1886              ADDS     r6,r0,r2
00003a  b2b0              UXTH     r0,r6
;;;302        if(sum < t) {
00003c  4290              CMP      r0,r2
00003e  da01              BGE      |L1.68|
;;;303          sum++;		/* carry */
000040  1c46              ADDS     r6,r0,#1
000042  b2b0              UXTH     r0,r6
                  |L1.68|
;;;304        }
;;;305      }
;;;306    
;;;307      /* Return sum in host byte order. */
;;;308      return sum;
;;;309    }
000044  bdf0              POP      {r4-r7,pc}
;;;310    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.htons||, CODE, READONLY, ALIGN=1

                  htons PROC
;;;1883   u16_t
;;;1884   htons(u16_t val)
000000  4601              MOV      r1,r0
;;;1885   {
;;;1886     return HTONS(val);
000002  0208              LSLS     r0,r1,#8
000004  ea402021          ORR      r0,r0,r1,ASR #8
000008  b280              UXTH     r0,r0
;;;1887   }
00000a  4770              BX       lr
;;;1888   /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.uip_add32||, CODE, READONLY, ALIGN=2

                  uip_add32 PROC
;;;249    void
;;;250    uip_add32(u8_t *op32, u16_t op16)
000000  78c2              LDRB     r2,[r0,#3]
;;;251    {
;;;252      uip_acc32[3] = op32[3] + (op16 & 0xff);
000002  440a              ADD      r2,r2,r1
000004  4b19              LDR      r3,|L3.108|
000006  70da              STRB     r2,[r3,#3]
;;;253      uip_acc32[2] = op32[2] + (op16 >> 8);
000008  7882              LDRB     r2,[r0,#2]
00000a  eb022221          ADD      r2,r2,r1,ASR #8
00000e  709a              STRB     r2,[r3,#2]
;;;254      uip_acc32[1] = op32[1];
000010  7842              LDRB     r2,[r0,#1]
000012  705a              STRB     r2,[r3,#1]
;;;255      uip_acc32[0] = op32[0];
000014  7802              LDRB     r2,[r0,#0]
000016  701a              STRB     r2,[r3,#0]
;;;256      
;;;257      if(uip_acc32[2] < (op16 >> 8)) {
000018  461a              MOV      r2,r3
00001a  7892              LDRB     r2,[r2,#2]  ; uip_acc32
00001c  ebb22f21          CMP      r2,r1,ASR #8
000020  da0a              BGE      |L3.56|
;;;258        ++uip_acc32[1];
000022  461a              MOV      r2,r3
000024  7852              LDRB     r2,[r2,#1]  ; uip_acc32
000026  1c52              ADDS     r2,r2,#1
000028  705a              STRB     r2,[r3,#1]
;;;259        if(uip_acc32[1] == 0) {
00002a  461a              MOV      r2,r3
00002c  7852              LDRB     r2,[r2,#1]  ; uip_acc32
00002e  b91a              CBNZ     r2,|L3.56|
;;;260          ++uip_acc32[0];
000030  461a              MOV      r2,r3
000032  7812              LDRB     r2,[r2,#0]  ; uip_acc32
000034  1c52              ADDS     r2,r2,#1
000036  701a              STRB     r2,[r3,#0]
                  |L3.56|
;;;261        }
;;;262      }
;;;263      
;;;264      
;;;265      if(uip_acc32[3] < (op16 & 0xff)) {
000038  4a0c              LDR      r2,|L3.108|
00003a  78d2              LDRB     r2,[r2,#3]  ; uip_acc32
00003c  b2cb              UXTB     r3,r1
00003e  429a              CMP      r2,r3
000040  da12              BGE      |L3.104|
;;;266        ++uip_acc32[2];
000042  4a0a              LDR      r2,|L3.108|
000044  7892              LDRB     r2,[r2,#2]  ; uip_acc32
000046  1c52              ADDS     r2,r2,#1
000048  4b08              LDR      r3,|L3.108|
00004a  709a              STRB     r2,[r3,#2]
;;;267        if(uip_acc32[2] == 0) {
00004c  461a              MOV      r2,r3
00004e  7892              LDRB     r2,[r2,#2]  ; uip_acc32
000050  b952              CBNZ     r2,|L3.104|
;;;268          ++uip_acc32[1];
000052  461a              MOV      r2,r3
000054  7852              LDRB     r2,[r2,#1]  ; uip_acc32
000056  1c52              ADDS     r2,r2,#1
000058  705a              STRB     r2,[r3,#1]
;;;269          if(uip_acc32[1] == 0) {
00005a  461a              MOV      r2,r3
00005c  7852              LDRB     r2,[r2,#1]  ; uip_acc32
00005e  b91a              CBNZ     r2,|L3.104|
;;;270    	++uip_acc32[0];
000060  461a              MOV      r2,r3
000062  7812              LDRB     r2,[r2,#0]  ; uip_acc32
000064  1c52              ADDS     r2,r2,#1
000066  701a              STRB     r2,[r3,#0]
                  |L3.104|
;;;271          }
;;;272        }
;;;273      }
;;;274    }
000068  4770              BX       lr
;;;275    
                          ENDP

00006a  0000              DCW      0x0000
                  |L3.108|
                          DCD      uip_acc32

                          AREA ||i.uip_add_rcv_nxt||, CODE, READONLY, ALIGN=2

                  uip_add_rcv_nxt PROC
;;;672    static void
;;;673    uip_add_rcv_nxt(u16_t n)
000000  b510              PUSH     {r4,lr}
;;;674    {
000002  4604              MOV      r4,r0
;;;675      uip_add32(uip_conn->rcv_nxt, n);
000004  4621              MOV      r1,r4
000006  480d              LDR      r0,|L4.60|
000008  6800              LDR      r0,[r0,#0]  ; uip_conn
00000a  3008              ADDS     r0,r0,#8
00000c  f7fffffe          BL       uip_add32
;;;676      uip_conn->rcv_nxt[0] = uip_acc32[0];
000010  480b              LDR      r0,|L4.64|
000012  7800              LDRB     r0,[r0,#0]  ; uip_acc32
000014  4909              LDR      r1,|L4.60|
000016  6809              LDR      r1,[r1,#0]  ; uip_conn
000018  7208              STRB     r0,[r1,#8]
;;;677      uip_conn->rcv_nxt[1] = uip_acc32[1];
00001a  4809              LDR      r0,|L4.64|
00001c  7841              LDRB     r1,[r0,#1]  ; uip_acc32
00001e  4807              LDR      r0,|L4.60|
000020  6800              LDR      r0,[r0,#0]  ; uip_conn
000022  7241              STRB     r1,[r0,#9]
;;;678      uip_conn->rcv_nxt[2] = uip_acc32[2];
000024  4806              LDR      r0,|L4.64|
000026  7881              LDRB     r1,[r0,#2]  ; uip_acc32
000028  4804              LDR      r0,|L4.60|
00002a  6800              LDR      r0,[r0,#0]  ; uip_conn
00002c  7281              STRB     r1,[r0,#0xa]
;;;679      uip_conn->rcv_nxt[3] = uip_acc32[3];
00002e  4804              LDR      r0,|L4.64|
000030  78c1              LDRB     r1,[r0,#3]  ; uip_acc32
000032  4802              LDR      r0,|L4.60|
000034  6800              LDR      r0,[r0,#0]  ; uip_conn
000036  72c1              STRB     r1,[r0,#0xb]
;;;680    }
000038  bd10              POP      {r4,pc}
;;;681    /*---------------------------------------------------------------------------*/
                          ENDP

00003a  0000              DCW      0x0000
                  |L4.60|
                          DCD      uip_conn
                  |L4.64|
                          DCD      uip_acc32

                          AREA ||i.uip_chksum||, CODE, READONLY, ALIGN=1

                  uip_chksum PROC
;;;311    u16_t
;;;312    uip_chksum(u16_t *data, u16_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;313    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;314      return htons(chksum(0, (u8_t *)data, len));
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       chksum
000010  4606              MOV      r6,r0
000012  f7fffffe          BL       htons
;;;315    }
000016  bd70              POP      {r4-r6,pc}
;;;316    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.uip_connect||, CODE, READONLY, ALIGN=2

                  uip_connect PROC
;;;407    struct uip_conn *
;;;408    uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
000000  b530              PUSH     {r4,r5,lr}
;;;409    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;410      register struct uip_conn *conn, *cconn;
;;;411      
;;;412      /* Find an unused local port. */
;;;413     again:
000006  bf00              NOP      
                  |L6.8|
;;;414      ++lastport;
000008  483d              LDR      r0,|L6.256|
00000a  8800              LDRH     r0,[r0,#0]  ; lastport
00000c  1c40              ADDS     r0,r0,#1
00000e  493c              LDR      r1,|L6.256|
000010  8008              STRH     r0,[r1,#0]
;;;415    
;;;416      if(lastport >= 32000) {
000012  4608              MOV      r0,r1
000014  8800              LDRH     r0,[r0,#0]  ; lastport
000016  f5b04ffa          CMP      r0,#0x7d00
00001a  db02              BLT      |L6.34|
;;;417        lastport = 4096;
00001c  f44f5080          MOV      r0,#0x1000
000020  8008              STRH     r0,[r1,#0]
                  |L6.34|
;;;418      }
;;;419    
;;;420      /* Check if this port is already in use, and if so try to find
;;;421         another one. */
;;;422      for(c = 0; c < UIP_CONNS; ++c) {
000022  2000              MOVS     r0,#0
000024  4937              LDR      r1,|L6.260|
000026  7008              STRB     r0,[r1,#0]
000028  e015              B        |L6.86|
                  |L6.42|
;;;423        conn = &uip_conns[c];
00002a  4836              LDR      r0,|L6.260|
00002c  7800              LDRB     r0,[r0,#0]  ; c
00002e  eb000080          ADD      r0,r0,r0,LSL #2
000032  4935              LDR      r1,|L6.264|
000034  eb0102c0          ADD      r2,r1,r0,LSL #3
;;;424        if(conn->tcpstateflags != UIP_CLOSED &&
000038  7e50              LDRB     r0,[r2,#0x19]
00003a  b138              CBZ      r0,|L6.76|
;;;425           conn->lport == htons(lastport)) {
00003c  4830              LDR      r0,|L6.256|
00003e  8800              LDRH     r0,[r0,#0]  ; lastport
000040  f7fffffe          BL       htons
000044  8891              LDRH     r1,[r2,#4]
000046  4288              CMP      r0,r1
000048  d100              BNE      |L6.76|
;;;426          goto again;
00004a  e7dd              B        |L6.8|
                  |L6.76|
00004c  482d              LDR      r0,|L6.260|
00004e  7800              LDRB     r0,[r0,#0]            ;422  ; c
000050  1c40              ADDS     r0,r0,#1              ;422
000052  492c              LDR      r1,|L6.260|
000054  7008              STRB     r0,[r1,#0]            ;422
                  |L6.86|
000056  482b              LDR      r0,|L6.260|
000058  7800              LDRB     r0,[r0,#0]            ;422  ; c
00005a  2828              CMP      r0,#0x28              ;422
00005c  dbe5              BLT      |L6.42|
;;;427        }
;;;428      }
;;;429    
;;;430      conn = 0;
00005e  2200              MOVS     r2,#0
;;;431      for(c = 0; c < UIP_CONNS; ++c) {
000060  2000              MOVS     r0,#0
000062  4928              LDR      r1,|L6.260|
000064  7008              STRB     r0,[r1,#0]
000066  e018              B        |L6.154|
                  |L6.104|
;;;432        cconn = &uip_conns[c];
000068  4826              LDR      r0,|L6.260|
00006a  7800              LDRB     r0,[r0,#0]  ; c
00006c  eb000080          ADD      r0,r0,r0,LSL #2
000070  4925              LDR      r1,|L6.264|
000072  eb0103c0          ADD      r3,r1,r0,LSL #3
;;;433        if(cconn->tcpstateflags == UIP_CLOSED) {
000076  7e58              LDRB     r0,[r3,#0x19]
000078  b908              CBNZ     r0,|L6.126|
;;;434          conn = cconn;
00007a  461a              MOV      r2,r3
;;;435          break;
00007c  e011              B        |L6.162|
                  |L6.126|
;;;436        }
;;;437        if(cconn->tcpstateflags == UIP_TIME_WAIT) {
00007e  7e58              LDRB     r0,[r3,#0x19]
000080  2807              CMP      r0,#7
000082  d105              BNE      |L6.144|
;;;438          if(conn == 0 ||
000084  b11a              CBZ      r2,|L6.142|
;;;439    	 cconn->timer > conn->timer) {
000086  7e98              LDRB     r0,[r3,#0x1a]
000088  7e91              LDRB     r1,[r2,#0x1a]
00008a  4288              CMP      r0,r1
00008c  dd00              BLE      |L6.144|
                  |L6.142|
;;;440    	conn = cconn;
00008e  461a              MOV      r2,r3
                  |L6.144|
000090  481c              LDR      r0,|L6.260|
000092  7800              LDRB     r0,[r0,#0]            ;431  ; c
000094  1c40              ADDS     r0,r0,#1              ;431
000096  491b              LDR      r1,|L6.260|
000098  7008              STRB     r0,[r1,#0]            ;431
                  |L6.154|
00009a  481a              LDR      r0,|L6.260|
00009c  7800              LDRB     r0,[r0,#0]            ;431  ; c
00009e  2828              CMP      r0,#0x28              ;431
0000a0  dbe2              BLT      |L6.104|
                  |L6.162|
0000a2  bf00              NOP                            ;435
;;;441          }
;;;442        }
;;;443      }
;;;444    
;;;445      if(conn == 0) {
0000a4  b90a              CBNZ     r2,|L6.170|
;;;446        return 0;
0000a6  2000              MOVS     r0,#0
                  |L6.168|
;;;447      }
;;;448      
;;;449      conn->tcpstateflags = UIP_SYN_SENT;
;;;450    
;;;451      conn->snd_nxt[0] = iss[0];
;;;452      conn->snd_nxt[1] = iss[1];
;;;453      conn->snd_nxt[2] = iss[2];
;;;454      conn->snd_nxt[3] = iss[3];
;;;455    
;;;456      conn->initialmss = conn->mss = UIP_TCP_MSS;
;;;457      
;;;458      conn->len = 1;   /* TCP length of the SYN is one. */
;;;459      conn->nrtx = 0;
;;;460      conn->timer = 1; /* Send the SYN next time around. */
;;;461      conn->rto = UIP_RTO;
;;;462      conn->sa = 0;
;;;463      conn->sv = 16;   /* Initial value of the RTT variance. */
;;;464      conn->lport = htons(lastport);
;;;465      conn->rport = rport;
;;;466      uip_ipaddr_copy(&conn->ripaddr, ripaddr);
;;;467      
;;;468      return conn;
;;;469    }
0000a8  bd30              POP      {r4,r5,pc}
                  |L6.170|
0000aa  2002              MOVS     r0,#2                 ;449
0000ac  7650              STRB     r0,[r2,#0x19]         ;449
0000ae  4817              LDR      r0,|L6.268|
0000b0  7800              LDRB     r0,[r0,#0]            ;451  ; iss
0000b2  7310              STRB     r0,[r2,#0xc]          ;451
0000b4  4815              LDR      r0,|L6.268|
0000b6  7841              LDRB     r1,[r0,#1]            ;452  ; iss
0000b8  7351              STRB     r1,[r2,#0xd]          ;452
0000ba  7881              LDRB     r1,[r0,#2]            ;453  ; iss
0000bc  7391              STRB     r1,[r2,#0xe]          ;453
0000be  78c1              LDRB     r1,[r0,#3]            ;454  ; iss
0000c0  73d1              STRB     r1,[r2,#0xf]          ;454
0000c2  f64070ca          MOV      r0,#0xfca             ;456
0000c6  8250              STRH     r0,[r2,#0x12]         ;456
0000c8  8290              STRH     r0,[r2,#0x14]         ;456
0000ca  2001              MOVS     r0,#1                 ;458
0000cc  8210              STRH     r0,[r2,#0x10]         ;458
0000ce  2000              MOVS     r0,#0                 ;459
0000d0  76d0              STRB     r0,[r2,#0x1b]         ;459
0000d2  2001              MOVS     r0,#1                 ;460
0000d4  7690              STRB     r0,[r2,#0x1a]         ;460
0000d6  2003              MOVS     r0,#3                 ;461
0000d8  7610              STRB     r0,[r2,#0x18]         ;461
0000da  2000              MOVS     r0,#0                 ;462
0000dc  7590              STRB     r0,[r2,#0x16]         ;462
0000de  2010              MOVS     r0,#0x10              ;463
0000e0  75d0              STRB     r0,[r2,#0x17]         ;463
0000e2  4807              LDR      r0,|L6.256|
0000e4  8800              LDRH     r0,[r0,#0]            ;464  ; lastport
0000e6  f7fffffe          BL       htons
0000ea  8090              STRH     r0,[r2,#4]            ;464
0000ec  80d5              STRH     r5,[r2,#6]            ;465
0000ee  bf00              NOP                            ;466
0000f0  8820              LDRH     r0,[r4,#0]            ;466
0000f2  8010              STRH     r0,[r2,#0]            ;466
0000f4  8860              LDRH     r0,[r4,#2]            ;466
0000f6  8050              STRH     r0,[r2,#2]            ;466
0000f8  bf00              NOP                            ;466
0000fa  4610              MOV      r0,r2                 ;468
0000fc  e7d4              B        |L6.168|
;;;470    #endif /* UIP_ACTIVE_OPEN */
                          ENDP

0000fe  0000              DCW      0x0000
                  |L6.256|
                          DCD      lastport
                  |L6.260|
                          DCD      c
                  |L6.264|
                          DCD      uip_conns
                  |L6.268|
                          DCD      iss

                          AREA ||i.uip_init||, CODE, READONLY, ALIGN=2

                  uip_init PROC
;;;379    void
;;;380    uip_init(void)
000000  2000              MOVS     r0,#0
;;;381    {
;;;382      for(c = 0; c < UIP_LISTENPORTS; ++c) {
000002  4916              LDR      r1,|L7.92|
000004  7008              STRB     r0,[r1,#0]
000006  e00a              B        |L7.30|
                  |L7.8|
;;;383        uip_listenports[c] = 0;
000008  2000              MOVS     r0,#0
00000a  4915              LDR      r1,|L7.96|
00000c  4a13              LDR      r2,|L7.92|
00000e  7812              LDRB     r2,[r2,#0]  ; c
000010  f8210012          STRH     r0,[r1,r2,LSL #1]
000014  4811              LDR      r0,|L7.92|
000016  7800              LDRB     r0,[r0,#0]            ;382  ; c
000018  1c40              ADDS     r0,r0,#1              ;382
00001a  4910              LDR      r1,|L7.92|
00001c  7008              STRB     r0,[r1,#0]            ;382
                  |L7.30|
00001e  480f              LDR      r0,|L7.92|
000020  7800              LDRB     r0,[r0,#0]            ;382  ; c
000022  2828              CMP      r0,#0x28              ;382
000024  dbf0              BLT      |L7.8|
;;;384      }
;;;385      for(c = 0; c < UIP_CONNS; ++c) {
000026  2000              MOVS     r0,#0
000028  490c              LDR      r1,|L7.92|
00002a  7008              STRB     r0,[r1,#0]
00002c  e00d              B        |L7.74|
                  |L7.46|
;;;386        uip_conns[c].tcpstateflags = UIP_CLOSED;
00002e  2000              MOVS     r0,#0
000030  490a              LDR      r1,|L7.92|
000032  7809              LDRB     r1,[r1,#0]  ; c
000034  eb010181          ADD      r1,r1,r1,LSL #2
000038  4a0a              LDR      r2,|L7.100|
00003a  eb0201c1          ADD      r1,r2,r1,LSL #3
00003e  7648              STRB     r0,[r1,#0x19]
000040  4806              LDR      r0,|L7.92|
000042  7800              LDRB     r0,[r0,#0]            ;385  ; c
000044  1c40              ADDS     r0,r0,#1              ;385
000046  4905              LDR      r1,|L7.92|
000048  7008              STRB     r0,[r1,#0]            ;385
                  |L7.74|
00004a  4804              LDR      r0,|L7.92|
00004c  7800              LDRB     r0,[r0,#0]            ;385  ; c
00004e  2828              CMP      r0,#0x28              ;385
000050  dbed              BLT      |L7.46|
;;;387      }
;;;388    #if UIP_ACTIVE_OPEN
;;;389      lastport = 1024;
000052  f44f6080          MOV      r0,#0x400
000056  4904              LDR      r1,|L7.104|
000058  8008              STRH     r0,[r1,#0]
;;;390    #endif /* UIP_ACTIVE_OPEN */
;;;391    
;;;392    #if UIP_UDP
;;;393      for(c = 0; c < UIP_UDP_CONNS; ++c) {
;;;394        uip_udp_conns[c].lport = 0;
;;;395      }
;;;396    #endif /* UIP_UDP */
;;;397      
;;;398    
;;;399      /* IPv4 initialization. */
;;;400    #if UIP_FIXEDADDR == 0
;;;401      /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
;;;402    #endif /* UIP_FIXEDADDR */
;;;403    
;;;404    }
00005a  4770              BX       lr
;;;405    /*---------------------------------------------------------------------------*/
                          ENDP

                  |L7.92|
                          DCD      c
                  |L7.96|
                          DCD      uip_listenports
                  |L7.100|
                          DCD      uip_conns
                  |L7.104|
                          DCD      lastport

                          AREA ||i.uip_ipchksum||, CODE, READONLY, ALIGN=2

                  uip_ipchksum PROC
;;;318    u16_t
;;;319    uip_ipchksum(void)
000000  b510              PUSH     {r4,lr}
;;;320    {
;;;321      u16_t sum;
;;;322    
;;;323      sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
000002  2214              MOVS     r2,#0x14
000004  4906              LDR      r1,|L8.32|
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       chksum
00000c  4604              MOV      r4,r0
;;;324      DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
;;;325      return (sum == 0) ? 0xffff : htons(sum);
00000e  b914              CBNZ     r4,|L8.22|
000010  f64f70ff          MOV      r0,#0xffff
                  |L8.20|
;;;326    }
000014  bd10              POP      {r4,pc}
                  |L8.22|
000016  4620              MOV      r0,r4                 ;325
000018  f7fffffe          BL       htons
00001c  e7fa              B        |L8.20|
;;;327    #endif
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      uip_buf+0xe

                          AREA ||i.uip_listen||, CODE, READONLY, ALIGN=2

                  uip_listen PROC
;;;529    void
;;;530    uip_listen(u16_t port)
000000  2100              MOVS     r1,#0
;;;531    {
;;;532      for(c = 0; c < UIP_LISTENPORTS; ++c) {
000002  4a0d              LDR      r2,|L9.56|
000004  7011              STRB     r1,[r2,#0]
000006  e010              B        |L9.42|
                  |L9.8|
;;;533        if(uip_listenports[c] == 0) {
000008  490c              LDR      r1,|L9.60|
00000a  4a0b              LDR      r2,|L9.56|
00000c  7812              LDRB     r2,[r2,#0]  ; c
00000e  f8311012          LDRH     r1,[r1,r2,LSL #1]
000012  b929              CBNZ     r1,|L9.32|
;;;534          uip_listenports[c] = port;
000014  4909              LDR      r1,|L9.60|
000016  4a08              LDR      r2,|L9.56|
000018  7812              LDRB     r2,[r2,#0]  ; c
00001a  f8210012          STRH     r0,[r1,r2,LSL #1]
                  |L9.30|
;;;535          return;
;;;536        }
;;;537      }
;;;538    }
00001e  4770              BX       lr
                  |L9.32|
000020  4905              LDR      r1,|L9.56|
000022  7809              LDRB     r1,[r1,#0]            ;532  ; c
000024  1c49              ADDS     r1,r1,#1              ;532
000026  4a04              LDR      r2,|L9.56|
000028  7011              STRB     r1,[r2,#0]            ;532
                  |L9.42|
00002a  4903              LDR      r1,|L9.56|
00002c  7809              LDRB     r1,[r1,#0]            ;532  ; c
00002e  2928              CMP      r1,#0x28              ;532
000030  dbea              BLT      |L9.8|
000032  bf00              NOP      
000034  e7f3              B        |L9.30|
;;;539    /*---------------------------------------------------------------------------*/
                          ENDP

000036  0000              DCW      0x0000
                  |L9.56|
                          DCD      c
                  |L9.60|
                          DCD      uip_listenports

                          AREA ||i.uip_process||, CODE, READONLY, ALIGN=2

                  uip_process PROC
;;;682    void
;;;683    uip_process(u8_t flag)
000000  b570              PUSH     {r4-r6,lr}
;;;684    {
000002  4605              MOV      r5,r0
;;;685      register struct uip_conn *uip_connr = uip_conn;
000004  48fa              LDR      r0,|L10.1008|
000006  6804              LDR      r4,[r0,#0]  ; uip_conn
;;;686    
;;;687    #if UIP_UDP
;;;688      if(flag == UIP_UDP_SEND_CONN) {
;;;689        goto udp_send;
;;;690      }
;;;691    #endif /* UIP_UDP */
;;;692      
;;;693      uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
000008  48fa              LDR      r0,|L10.1012|
00000a  49fb              LDR      r1,|L10.1016|
00000c  6008              STR      r0,[r1,#0]  ; uip_appdata
00000e  49fb              LDR      r1,|L10.1020|
000010  6008              STR      r0,[r1,#0]  ; uip_sappdata
;;;694    
;;;695      /* Check if we were invoked because of a poll request for a
;;;696         particular connection. */
;;;697      if(flag == UIP_POLL_REQUEST) {
000012  2d03              CMP      r5,#3
000014  d10e              BNE      |L10.52|
;;;698        if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
000016  7e60              LDRB     r0,[r4,#0x19]
000018  f000000f          AND      r0,r0,#0xf
00001c  2803              CMP      r0,#3
00001e  d107              BNE      |L10.48|
;;;699           !uip_outstanding(uip_connr)) {
000020  8a20              LDRH     r0,[r4,#0x10]
000022  b928              CBNZ     r0,|L10.48|
;;;700    	uip_flags = UIP_POLL;
000024  2008              MOVS     r0,#8
000026  49f6              LDR      r1,|L10.1024|
000028  7008              STRB     r0,[r1,#0]
;;;701    	UIP_APPCALL();
00002a  f7fffffe          BL       tcp_demo_appcall
                  |L10.46|
;;;702    	goto appsend;
00002e  e3f8              B        |L10.2082|
                  |L10.48|
;;;703        }
;;;704        goto drop;
000030  f000bfa9          B.W      |L10.3974|
                  |L10.52|
;;;705        
;;;706        /* Check if we were invoked because of the perodic timer fireing. */
;;;707      } else if(flag == UIP_TIMER) {
000034  2d02              CMP      r5,#2
000036  d173              BNE      |L10.288|
;;;708    #if UIP_REASSEMBLY
;;;709        if(uip_reasstmr != 0) {
;;;710          --uip_reasstmr;
;;;711        }
;;;712    #endif /* UIP_REASSEMBLY */
;;;713        /* Increase the initial sequence number. */
;;;714        if(++iss[3] == 0) {
000038  48f2              LDR      r0,|L10.1028|
00003a  78c0              LDRB     r0,[r0,#3]  ; iss
00003c  1c40              ADDS     r0,r0,#1
00003e  b2c0              UXTB     r0,r0
000040  49f0              LDR      r1,|L10.1028|
000042  70c8              STRB     r0,[r1,#3]
000044  b978              CBNZ     r0,|L10.102|
;;;715          if(++iss[2] == 0) {
000046  4608              MOV      r0,r1
000048  7880              LDRB     r0,[r0,#2]  ; iss
00004a  1c40              ADDS     r0,r0,#1
00004c  b2c0              UXTB     r0,r0
00004e  7088              STRB     r0,[r1,#2]
000050  b948              CBNZ     r0,|L10.102|
;;;716    	if(++iss[1] == 0) {
000052  4608              MOV      r0,r1
000054  7840              LDRB     r0,[r0,#1]  ; iss
000056  1c40              ADDS     r0,r0,#1
000058  b2c0              UXTB     r0,r0
00005a  7048              STRB     r0,[r1,#1]
00005c  b918              CBNZ     r0,|L10.102|
;;;717    	  ++iss[0];
00005e  4608              MOV      r0,r1
000060  7800              LDRB     r0,[r0,#0]  ; iss
000062  1c40              ADDS     r0,r0,#1
000064  7008              STRB     r0,[r1,#0]
                  |L10.102|
;;;718    	}
;;;719          }
;;;720        }
;;;721    
;;;722        /* Reset the length variables. */
;;;723        uip_len = 0;
000066  2000              MOVS     r0,#0
000068  49e7              LDR      r1,|L10.1032|
00006a  8008              STRH     r0,[r1,#0]
;;;724        uip_slen = 0;
00006c  49e7              LDR      r1,|L10.1036|
00006e  8008              STRH     r0,[r1,#0]
;;;725    
;;;726        /* Check if the connection is in a state in which we simply wait
;;;727           for the connection to time out. If so, we increase the
;;;728           connection's timer and remove the connection if it times
;;;729           out. */
;;;730        if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
000070  7e60              LDRB     r0,[r4,#0x19]
000072  2807              CMP      r0,#7
000074  d002              BEQ      |L10.124|
;;;731           uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
000076  7e60              LDRB     r0,[r4,#0x19]
000078  2805              CMP      r0,#5
00007a  d108              BNE      |L10.142|
                  |L10.124|
;;;732          ++(uip_connr->timer);
00007c  7ea0              LDRB     r0,[r4,#0x1a]
00007e  1c40              ADDS     r0,r0,#1
000080  76a0              STRB     r0,[r4,#0x1a]
;;;733          if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
000082  7ea0              LDRB     r0,[r4,#0x1a]
000084  2878              CMP      r0,#0x78
000086  d160              BNE      |L10.330|
;;;734    	uip_connr->tcpstateflags = UIP_CLOSED;
000088  2000              MOVS     r0,#0
00008a  7660              STRB     r0,[r4,#0x19]
00008c  e05d              B        |L10.330|
                  |L10.142|
;;;735          }
;;;736        } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
00008e  7e60              LDRB     r0,[r4,#0x19]
000090  2800              CMP      r0,#0
000092  d05a              BEQ      |L10.330|
;;;737          /* If the connection has outstanding data, we increase the
;;;738    	 connection's timer and see if it has reached the RTO value
;;;739    	 in which case we retransmit. */
;;;740          if(uip_outstanding(uip_connr)) {
000094  8a20              LDRH     r0,[r4,#0x10]
000096  2800              CMP      r0,#0
000098  d04c              BEQ      |L10.308|
;;;741    	if(uip_connr->timer-- == 0) {
00009a  7ea1              LDRB     r1,[r4,#0x1a]
00009c  1e48              SUBS     r0,r1,#1
00009e  76a0              STRB     r0,[r4,#0x1a]
0000a0  2900              CMP      r1,#0
0000a2  d152              BNE      |L10.330|
;;;742    	  if(uip_connr->nrtx == UIP_MAXRTX ||
0000a4  7ee0              LDRB     r0,[r4,#0x1b]
0000a6  2808              CMP      r0,#8
0000a8  d008              BEQ      |L10.188|
;;;743    	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
0000aa  7e60              LDRB     r0,[r4,#0x19]
0000ac  2802              CMP      r0,#2
0000ae  d002              BEQ      |L10.182|
;;;744    	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
0000b0  7e60              LDRB     r0,[r4,#0x19]
0000b2  2801              CMP      r0,#1
0000b4  d10f              BNE      |L10.214|
                  |L10.182|
;;;745    	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
0000b6  7ee0              LDRB     r0,[r4,#0x1b]
0000b8  2805              CMP      r0,#5
0000ba  d10c              BNE      |L10.214|
                  |L10.188|
;;;746    	    uip_connr->tcpstateflags = UIP_CLOSED;
0000bc  2000              MOVS     r0,#0
0000be  7660              STRB     r0,[r4,#0x19]
;;;747    
;;;748    	    /* We call UIP_APPCALL() with uip_flags set to
;;;749    	       UIP_TIMEDOUT to inform the application that the
;;;750    	       connection has timed out. */
;;;751    	    uip_flags = UIP_TIMEDOUT;
0000c0  2080              MOVS     r0,#0x80
0000c2  49cf              LDR      r1,|L10.1024|
0000c4  7008              STRB     r0,[r1,#0]
;;;752    	    UIP_APPCALL();
0000c6  f7fffffe          BL       tcp_demo_appcall
;;;753    
;;;754    	    /* We also send a reset packet to the remote host. */
;;;755    	    BUF->flags = TCP_RST | TCP_ACK;
0000ca  2114              MOVS     r1,#0x14
0000cc  48c9              LDR      r0,|L10.1012|
0000ce  3836              SUBS     r0,r0,#0x36
0000d0  f880102f          STRB     r1,[r0,#0x2f]
;;;756    	    goto tcp_send_nodata;
0000d4  e3fe              B        |L10.2260|
                  |L10.214|
;;;757    	  }
;;;758    
;;;759    	  /* Exponential backoff. */
;;;760    	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
0000d6  7ee0              LDRB     r0,[r4,#0x1b]
0000d8  2804              CMP      r0,#4
0000da  dd01              BLE      |L10.224|
;;;761    					 4:
0000dc  2004              MOVS     r0,#4
0000de  e000              B        |L10.226|
                  |L10.224|
;;;762    					 uip_connr->nrtx);
0000e0  7ee0              LDRB     r0,[r4,#0x1b]
                  |L10.226|
0000e2  2103              MOVS     r1,#3
0000e4  4081              LSLS     r1,r1,r0
0000e6  76a1              STRB     r1,[r4,#0x1a]
;;;763    	  ++(uip_connr->nrtx);
0000e8  7ee0              LDRB     r0,[r4,#0x1b]
0000ea  1c40              ADDS     r0,r0,#1
0000ec  76e0              STRB     r0,[r4,#0x1b]
;;;764    	  
;;;765    	  /* Ok, so we need to retransmit. We do this differently
;;;766    	     depending on which state we are in. In ESTABLISHED, we
;;;767    	     call upon the application so that it may prepare the
;;;768    	     data for the retransmit. In SYN_RCVD, we resend the
;;;769    	     SYNACK that we sent earlier and in LAST_ACK we have to
;;;770    	     retransmit our FINACK. */
;;;771    	  UIP_STAT(++uip_stat.tcp.rexmit);
0000ee  48c8              LDR      r0,|L10.1040|
0000f0  8cc0              LDRH     r0,[r0,#0x26]
0000f2  1c40              ADDS     r0,r0,#1
0000f4  b281              UXTH     r1,r0
0000f6  48c6              LDR      r0,|L10.1040|
0000f8  84c1              STRH     r1,[r0,#0x26]
;;;772    	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
0000fa  7e60              LDRB     r0,[r4,#0x19]
0000fc  f000000f          AND      r0,r0,#0xf
000100  2809              CMP      r0,#9
000102  d222              BCS      |L10.330|
000104  e8dff000          TBB      [pc,r0]
000108  2105060d          DCB      0x21,0x05,0x06,0x0d
00010c  13211421          DCB      0x13,0x21,0x14,0x21
000110  1500              DCB      0x15,0x00
;;;773    	  case UIP_SYN_RCVD:
;;;774    	    /* In the SYN_RCVD state, we should retransmit our
;;;775                   SYNACK. */
;;;776    	    goto tcp_send_synack;
000112  e357              B        |L10.1988|
;;;777    	    
;;;778    #if UIP_ACTIVE_OPEN
;;;779    	  case UIP_SYN_SENT:
;;;780    	    /* In the SYN_SENT state, we retransmit out SYN. */
;;;781    	    BUF->flags = 0;
000114  2100              MOVS     r1,#0
000116  48b7              LDR      r0,|L10.1012|
000118  3836              SUBS     r0,r0,#0x36
00011a  f880102f          STRB     r1,[r0,#0x2f]
;;;782    	    goto tcp_send_syn;
00011e  e356              B        |L10.1998|
                  |L10.288|
000120  e014              B        |L10.332|
;;;783    #endif /* UIP_ACTIVE_OPEN */
;;;784    	    
;;;785    	  case UIP_ESTABLISHED:
;;;786    	    /* In the ESTABLISHED state, we call upon the application
;;;787                   to do the actual retransmit after which we jump into
;;;788                   the code for sending out the packet (the apprexmit
;;;789                   label). */
;;;790    	    uip_flags = UIP_REXMIT;
000122  2004              MOVS     r0,#4
000124  49b6              LDR      r1,|L10.1024|
000126  7008              STRB     r0,[r1,#0]
;;;791    	    UIP_APPCALL();
000128  f7fffffe          BL       tcp_demo_appcall
;;;792    	    goto apprexmit;
00012c  e3df              B        |L10.2286|
;;;793    	    
;;;794    	  case UIP_FIN_WAIT_1:
;;;795    	  case UIP_CLOSING:
00012e  bf00              NOP      
;;;796    	  case UIP_LAST_ACK:
000130  bf00              NOP      
;;;797    	    /* In all these states we should retransmit a FINACK. */
;;;798    	    goto tcp_send_finack;
000132  e3dd              B        |L10.2288|
                  |L10.308|
;;;799    	    
;;;800    	  }
;;;801    	}
;;;802          } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
000134  7e60              LDRB     r0,[r4,#0x19]
000136  f000000f          AND      r0,r0,#0xf
00013a  2803              CMP      r0,#3
00013c  d105              BNE      |L10.330|
;;;803    	/* If there was no need for a retransmission, we poll the
;;;804               application for new data. */
;;;805    	uip_flags = UIP_POLL;
00013e  2008              MOVS     r0,#8
000140  49af              LDR      r1,|L10.1024|
000142  7008              STRB     r0,[r1,#0]
;;;806    	UIP_APPCALL();
000144  f7fffffe          BL       tcp_demo_appcall
;;;807    	goto appsend;
000148  e771              B        |L10.46|
                  |L10.330|
;;;808          }
;;;809        }
;;;810        goto drop;
00014a  e771              B        |L10.48|
                  |L10.332|
;;;811      }
;;;812    #if UIP_UDP
;;;813      if(flag == UIP_UDP_TIMER) {
;;;814        if(uip_udp_conn->lport != 0) {
;;;815          uip_conn = NULL;
;;;816          uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
;;;817          uip_len = uip_slen = 0;
;;;818          uip_flags = UIP_POLL;
;;;819          UIP_UDP_APPCALL();
;;;820          goto udp_send;
;;;821        } else {
;;;822          goto drop;
;;;823        }
;;;824      }
;;;825    #endif
;;;826    
;;;827      /* This is where the input processing starts. */
;;;828      UIP_STAT(++uip_stat.ip.recv);
00014c  48b0              LDR      r0,|L10.1040|
00014e  8840              LDRH     r0,[r0,#2]  ; uip_stat
000150  1c40              ADDS     r0,r0,#1
000152  49af              LDR      r1,|L10.1040|
000154  8048              STRH     r0,[r1,#2]
;;;829    
;;;830      /* Start of IP input header processing code. */
;;;831      
;;;832    #if UIP_CONF_IPV6
;;;833      /* Check validity of the IP header. */
;;;834      if((BUF->vtc & 0xf0) != 0x60)  { /* IP version and header length. */
;;;835        UIP_STAT(++uip_stat.ip.drop);
;;;836        UIP_STAT(++uip_stat.ip.vhlerr);
;;;837        UIP_LOG("ipv6: invalid version.");
;;;838        goto drop;
;;;839      }
;;;840    #else /* UIP_CONF_IPV6 */
;;;841      /* Check validity of the IP header. */
;;;842      if(BUF->vhl != 0x45)  { /* IP version and header length. */
000156  48a7              LDR      r0,|L10.1012|
000158  3836              SUBS     r0,r0,#0x36
00015a  7b80              LDRB     r0,[r0,#0xe]  ; uip_buf
00015c  2845              CMP      r0,#0x45
00015e  d00b              BEQ      |L10.376|
;;;843        UIP_STAT(++uip_stat.ip.drop);
000160  4608              MOV      r0,r1
000162  8800              LDRH     r0,[r0,#0]  ; uip_stat
000164  1c40              ADDS     r0,r0,#1
000166  8008              STRH     r0,[r1,#0]
;;;844        UIP_STAT(++uip_stat.ip.vhlerr);
000168  4608              MOV      r0,r1
00016a  88c0              LDRH     r0,[r0,#6]  ; uip_stat
00016c  1c40              ADDS     r0,r0,#1
00016e  80c8              STRH     r0,[r1,#6]
;;;845        UIP_LOG("ip: invalid version or header length.");
000170  a0a8              ADR      r0,|L10.1044|
000172  f7fffffe          BL       uip_log
;;;846        goto drop;
000176  e75b              B        |L10.48|
                  |L10.376|
;;;847      }
;;;848    #endif /* UIP_CONF_IPV6 */
;;;849      
;;;850      /* Check the size of the packet. If the size reported to us in
;;;851         uip_len is smaller the size reported in the IP header, we assume
;;;852         that the packet has been corrupted in transit. If the size of
;;;853         uip_len is larger than the size reported in the IP packet header,
;;;854         the packet has been padded and we set uip_len to the correct
;;;855         value.. */
;;;856    
;;;857      if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
000178  489e              LDR      r0,|L10.1012|
00017a  3836              SUBS     r0,r0,#0x36
00017c  7c41              LDRB     r1,[r0,#0x11]
00017e  7c00              LDRB     r0,[r0,#0x10]
000180  eb012000          ADD      r0,r1,r0,LSL #8
000184  49a0              LDR      r1,|L10.1032|
000186  8809              LDRH     r1,[r1,#0]  ; uip_len
000188  4288              CMP      r0,r1
00018a  dc08              BGT      |L10.414|
;;;858        uip_len = (BUF->len[0] << 8) + BUF->len[1];
00018c  4899              LDR      r0,|L10.1012|
00018e  3836              SUBS     r0,r0,#0x36
000190  7c41              LDRB     r1,[r0,#0x11]
000192  7c00              LDRB     r0,[r0,#0x10]
000194  eb012000          ADD      r0,r1,r0,LSL #8
000198  499b              LDR      r1,|L10.1032|
00019a  8008              STRH     r0,[r1,#0]
00019c  e003              B        |L10.422|
                  |L10.414|
;;;859    #if UIP_CONF_IPV6
;;;860        uip_len += 40; /* The length reported in the IPv6 header is the
;;;861    		      length of the payload that follows the
;;;862    		      header. However, uIP uses the uip_len variable
;;;863    		      for holding the size of the entire packet,
;;;864    		      including the IP header. For IPv4 this is not a
;;;865    		      problem as the length field in the IPv4 header
;;;866    		      contains the length of the entire packet. But
;;;867    		      for IPv6 we need to add the size of the IPv6
;;;868    		      header (40 bytes). */
;;;869    #endif /* UIP_CONF_IPV6 */
;;;870      } else {
;;;871        UIP_LOG("ip: packet shorter than reported in IP header.");
00019e  a0a7              ADR      r0,|L10.1084|
0001a0  f7fffffe          BL       uip_log
;;;872        goto drop;
0001a4  e744              B        |L10.48|
                  |L10.422|
;;;873      }
;;;874    
;;;875    #if !UIP_CONF_IPV6
;;;876      /* Check the fragment flag. */
;;;877      if((BUF->ipoffset[0] & 0x3f) != 0 ||
0001a6  4893              LDR      r0,|L10.1012|
0001a8  3836              SUBS     r0,r0,#0x36
0001aa  7d00              LDRB     r0,[r0,#0x14]
0001ac  f000003f          AND      r0,r0,#0x3f
0001b0  b918              CBNZ     r0,|L10.442|
;;;878         BUF->ipoffset[1] != 0) {
0001b2  4890              LDR      r0,|L10.1012|
0001b4  3836              SUBS     r0,r0,#0x36
0001b6  7d40              LDRB     r0,[r0,#0x15]
0001b8  b160              CBZ      r0,|L10.468|
                  |L10.442|
;;;879    #if UIP_REASSEMBLY
;;;880        uip_len = uip_reass();
;;;881        if(uip_len == 0) {
;;;882          goto drop;
;;;883        }
;;;884    #else /* UIP_REASSEMBLY */
;;;885        UIP_STAT(++uip_stat.ip.drop);
0001ba  4895              LDR      r0,|L10.1040|
0001bc  8800              LDRH     r0,[r0,#0]  ; uip_stat
0001be  1c40              ADDS     r0,r0,#1
0001c0  4993              LDR      r1,|L10.1040|
0001c2  8008              STRH     r0,[r1,#0]
;;;886        UIP_STAT(++uip_stat.ip.fragerr);
0001c4  4608              MOV      r0,r1
0001c6  8980              LDRH     r0,[r0,#0xc]  ; uip_stat
0001c8  1c40              ADDS     r0,r0,#1
0001ca  8188              STRH     r0,[r1,#0xc]
;;;887        UIP_LOG("ip: fragment dropped.");
0001cc  a0a7              ADR      r0,|L10.1132|
0001ce  f7fffffe          BL       uip_log
;;;888        goto drop;
0001d2  e72d              B        |L10.48|
                  |L10.468|
;;;889    #endif /* UIP_REASSEMBLY */
;;;890      }
;;;891    #endif /* UIP_CONF_IPV6 */
;;;892    
;;;893      if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) {
0001d4  48ab              LDR      r0,|L10.1156|
0001d6  8800              LDRH     r0,[r0,#0]  ; uip_hostaddr
0001d8  49ab              LDR      r1,|L10.1160|
0001da  8809              LDRH     r1,[r1,#0]  ; all_zeroes_addr
0001dc  4288              CMP      r0,r1
0001de  d105              BNE      |L10.492|
0001e0  48a8              LDR      r0,|L10.1156|
0001e2  8840              LDRH     r0,[r0,#2]  ; uip_hostaddr
0001e4  49a8              LDR      r1,|L10.1160|
0001e6  8849              LDRH     r1,[r1,#2]  ; all_zeroes_addr
0001e8  4288              CMP      r0,r1
0001ea  d013              BEQ      |L10.532|
                  |L10.492|
;;;894        /* If we are configured to use ping IP address configuration and
;;;895           hasn't been assigned an IP address yet, we accept all ICMP
;;;896           packets. */
;;;897    #if UIP_PINGADDRCONF && !UIP_CONF_IPV6
;;;898        if(BUF->proto == UIP_PROTO_ICMP) {
;;;899          UIP_LOG("ip: possible ping config packet received.");
;;;900          goto icmp_input;
;;;901        } else {
;;;902          UIP_LOG("ip: packet dropped since no address assigned.");
;;;903          goto drop;
;;;904        }
;;;905    #endif /* UIP_PINGADDRCONF */
;;;906    
;;;907      } else {
;;;908        /* If IP broadcast support is configured, we check for a broadcast
;;;909           UDP packet, which may be destined to us. */
;;;910    #if UIP_BROADCAST
;;;911        DEBUG_PRINTF("UDP IP checksum 0x%04x\n", uip_ipchksum());
;;;912        if(BUF->proto == UIP_PROTO_UDP &&
;;;913           uip_ipaddr_cmp(BUF->destipaddr, all_ones_addr)
;;;914           /*&&
;;;915    	 uip_ipchksum() == 0xffff*/) {
;;;916          goto udp_input;
;;;917        }
;;;918    #endif /* UIP_BROADCAST */
;;;919        
;;;920        /* Check if the packet is destined for our IP address. */
;;;921    #if !UIP_CONF_IPV6
;;;922        if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr)) {
0001ec  4881              LDR      r0,|L10.1012|
0001ee  3836              SUBS     r0,r0,#0x36
0001f0  8bc0              LDRH     r0,[r0,#0x1e]
0001f2  49a4              LDR      r1,|L10.1156|
0001f4  8809              LDRH     r1,[r1,#0]  ; uip_hostaddr
0001f6  4288              CMP      r0,r1
0001f8  d106              BNE      |L10.520|
0001fa  487e              LDR      r0,|L10.1012|
0001fc  3836              SUBS     r0,r0,#0x36
0001fe  8c00              LDRH     r0,[r0,#0x20]
000200  49a0              LDR      r1,|L10.1156|
000202  8849              LDRH     r1,[r1,#2]  ; uip_hostaddr
000204  4288              CMP      r0,r1
000206  d005              BEQ      |L10.532|
                  |L10.520|
;;;923          UIP_STAT(++uip_stat.ip.drop);
000208  4881              LDR      r0,|L10.1040|
00020a  8800              LDRH     r0,[r0,#0]  ; uip_stat
00020c  1c40              ADDS     r0,r0,#1
00020e  4980              LDR      r1,|L10.1040|
000210  8008              STRH     r0,[r1,#0]
;;;924          goto drop;
000212  e70d              B        |L10.48|
                  |L10.532|
;;;925        }
;;;926    #else /* UIP_CONF_IPV6 */
;;;927        /* For IPv6, packet reception is a little trickier as we need to
;;;928           make sure that we listen to certain multicast addresses (all
;;;929           hosts multicast address, and the solicited-node multicast
;;;930           address) as well. However, we will cheat here and accept all
;;;931           multicast packets that are sent to the ff02::/16 addresses. */
;;;932        if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr) &&
;;;933           BUF->destipaddr[0] != HTONS(0xff02)) {
;;;934          UIP_STAT(++uip_stat.ip.drop);
;;;935          goto drop;
;;;936        }
;;;937    #endif /* UIP_CONF_IPV6 */
;;;938      }
;;;939    
;;;940    #if !UIP_CONF_IPV6
;;;941      if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
000214  f7fffffe          BL       uip_ipchksum
000218  f64f71ff          MOV      r1,#0xffff
00021c  4288              CMP      r0,r1
00021e  d00c              BEQ      |L10.570|
;;;942    				    checksum. */
;;;943        UIP_STAT(++uip_stat.ip.drop);
000220  487b              LDR      r0,|L10.1040|
000222  8800              LDRH     r0,[r0,#0]  ; uip_stat
000224  1c40              ADDS     r0,r0,#1
000226  497a              LDR      r1,|L10.1040|
000228  8008              STRH     r0,[r1,#0]
;;;944        UIP_STAT(++uip_stat.ip.chkerr);
00022a  4608              MOV      r0,r1
00022c  89c0              LDRH     r0,[r0,#0xe]  ; uip_stat
00022e  1c40              ADDS     r0,r0,#1
000230  81c8              STRH     r0,[r1,#0xe]
;;;945        UIP_LOG("ip: bad checksum.");
000232  a096              ADR      r0,|L10.1164|
000234  f7fffffe          BL       uip_log
;;;946        goto drop;
000238  e6fa              B        |L10.48|
                  |L10.570|
;;;947      }
;;;948    #endif /* UIP_CONF_IPV6 */
;;;949    
;;;950      if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
00023a  486e              LDR      r0,|L10.1012|
00023c  3836              SUBS     r0,r0,#0x36
00023e  7dc0              LDRB     r0,[r0,#0x17]
000240  2806              CMP      r0,#6
000242  d100              BNE      |L10.582|
;;;951    				       proceed with TCP input
;;;952    				       processing. */
;;;953        goto tcp_input;
000244  e062              B        |L10.780|
                  |L10.582|
;;;954      }
;;;955    
;;;956    #if UIP_UDP
;;;957      if(BUF->proto == UIP_PROTO_UDP) {
;;;958        goto udp_input;
;;;959      }
;;;960    #endif /* UIP_UDP */
;;;961    
;;;962    #if !UIP_CONF_IPV6
;;;963      /* ICMPv4 processing code follows. */
;;;964      if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
000246  486b              LDR      r0,|L10.1012|
000248  3836              SUBS     r0,r0,#0x36
00024a  7dc0              LDRB     r0,[r0,#0x17]
00024c  2801              CMP      r0,#1
00024e  d00c              BEQ      |L10.618|
;;;965    					here. */
;;;966        UIP_STAT(++uip_stat.ip.drop);
000250  486f              LDR      r0,|L10.1040|
000252  8800              LDRH     r0,[r0,#0]  ; uip_stat
000254  1c40              ADDS     r0,r0,#1
000256  496e              LDR      r1,|L10.1040|
000258  8008              STRH     r0,[r1,#0]
;;;967        UIP_STAT(++uip_stat.ip.protoerr);
00025a  4608              MOV      r0,r1
00025c  8a00              LDRH     r0,[r0,#0x10]  ; uip_stat
00025e  1c40              ADDS     r0,r0,#1
000260  8208              STRH     r0,[r1,#0x10]
;;;968        UIP_LOG("ip: neither tcp nor icmp.");
000262  a08f              ADR      r0,|L10.1184|
000264  f7fffffe          BL       uip_log
;;;969        goto drop;
000268  e6e2              B        |L10.48|
                  |L10.618|
;;;970      }
;;;971    
;;;972    #if UIP_PINGADDRCONF
;;;973     icmp_input:
;;;974    #endif /* UIP_PINGADDRCONF */
;;;975      UIP_STAT(++uip_stat.icmp.recv);
00026a  4869              LDR      r0,|L10.1040|
00026c  8a80              LDRH     r0,[r0,#0x14]
00026e  1c40              ADDS     r0,r0,#1
000270  b281              UXTH     r1,r0
000272  4867              LDR      r0,|L10.1040|
000274  8281              STRH     r1,[r0,#0x14]
;;;976    
;;;977      /* ICMP echo (i.e., ping) processing. This is simple, we only change
;;;978         the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
;;;979         checksum before we return the packet. */
;;;980      if(ICMPBUF->type != ICMP_ECHO) {
000276  485f              LDR      r0,|L10.1012|
000278  3836              SUBS     r0,r0,#0x36
00027a  f8900022          LDRB     r0,[r0,#0x22]
00027e  2808              CMP      r0,#8
000280  d00e              BEQ      |L10.672|
;;;981        UIP_STAT(++uip_stat.icmp.drop);
000282  4863              LDR      r0,|L10.1040|
000284  8a40              LDRH     r0,[r0,#0x12]  ; uip_stat
000286  1c40              ADDS     r0,r0,#1
000288  4961              LDR      r1,|L10.1040|
00028a  8248              STRH     r0,[r1,#0x12]
;;;982        UIP_STAT(++uip_stat.icmp.typeerr);
00028c  4608              MOV      r0,r1
00028e  8b00              LDRH     r0,[r0,#0x18]
000290  1c40              ADDS     r0,r0,#1
000292  b281              UXTH     r1,r0
000294  485e              LDR      r0,|L10.1040|
000296  8301              STRH     r1,[r0,#0x18]
;;;983        UIP_LOG("icmp: not icmp echo.");
000298  a088              ADR      r0,|L10.1212|
00029a  f7fffffe          BL       uip_log
;;;984        goto drop;
00029e  e6c7              B        |L10.48|
                  |L10.672|
;;;985      }
;;;986    
;;;987      /* If we are configured to use ping IP address assignment, we use
;;;988         the destination IP address of this ping packet and assign it to
;;;989         ourself. */
;;;990    #if UIP_PINGADDRCONF
;;;991      if((uip_hostaddr[0] | uip_hostaddr[1]) == 0) {
;;;992        uip_hostaddr[0] = BUF->destipaddr[0];
;;;993        uip_hostaddr[1] = BUF->destipaddr[1];
;;;994      }
;;;995    #endif /* UIP_PINGADDRCONF */
;;;996    
;;;997      ICMPBUF->type = ICMP_ECHO_REPLY;
0002a0  2100              MOVS     r1,#0
0002a2  4854              LDR      r0,|L10.1012|
0002a4  3836              SUBS     r0,r0,#0x36
0002a6  f8801022          STRB     r1,[r0,#0x22]
;;;998    
;;;999      if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
0002aa  8c80              LDRH     r0,[r0,#0x24]
0002ac  f64f71f7          MOV      r1,#0xfff7
0002b0  4288              CMP      r0,r1
0002b2  db08              BLT      |L10.710|
;;;1000       ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
0002b4  484f              LDR      r0,|L10.1012|
0002b6  3836              SUBS     r0,r0,#0x36
0002b8  8c80              LDRH     r0,[r0,#0x24]
0002ba  3009              ADDS     r0,r0,#9
0002bc  b281              UXTH     r1,r0
0002be  484d              LDR      r0,|L10.1012|
0002c0  3836              SUBS     r0,r0,#0x36
0002c2  8481              STRH     r1,[r0,#0x24]
0002c4  e007              B        |L10.726|
                  |L10.710|
;;;1001     } else {
;;;1002       ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
0002c6  484b              LDR      r0,|L10.1012|
0002c8  3836              SUBS     r0,r0,#0x36
0002ca  8c80              LDRH     r0,[r0,#0x24]
0002cc  3008              ADDS     r0,r0,#8
0002ce  b281              UXTH     r1,r0
0002d0  4848              LDR      r0,|L10.1012|
0002d2  3836              SUBS     r0,r0,#0x36
0002d4  8481              STRH     r1,[r0,#0x24]
                  |L10.726|
;;;1003     }
;;;1004   
;;;1005     /* Swap IP addresses. */
;;;1006     uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
0002d6  bf00              NOP      
0002d8  4846              LDR      r0,|L10.1012|
0002da  3836              SUBS     r0,r0,#0x36
0002dc  8b41              LDRH     r1,[r0,#0x1a]
0002de  83c1              STRH     r1,[r0,#0x1e]
0002e0  8b81              LDRH     r1,[r0,#0x1c]
0002e2  8401              STRH     r1,[r0,#0x20]
0002e4  bf00              NOP      
;;;1007     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
0002e6  bf00              NOP      
0002e8  4866              LDR      r0,|L10.1156|
0002ea  8801              LDRH     r1,[r0,#0]  ; uip_hostaddr
0002ec  4841              LDR      r0,|L10.1012|
0002ee  3836              SUBS     r0,r0,#0x36
0002f0  8341              STRH     r1,[r0,#0x1a]
0002f2  4864              LDR      r0,|L10.1156|
0002f4  8841              LDRH     r1,[r0,#2]  ; uip_hostaddr
0002f6  483f              LDR      r0,|L10.1012|
0002f8  3836              SUBS     r0,r0,#0x36
0002fa  8381              STRH     r1,[r0,#0x1c]
0002fc  bf00              NOP      
;;;1008   
;;;1009     UIP_STAT(++uip_stat.icmp.sent);
0002fe  4844              LDR      r0,|L10.1040|
000300  8ac0              LDRH     r0,[r0,#0x16]
000302  1c40              ADDS     r0,r0,#1
000304  b281              UXTH     r1,r0
000306  4842              LDR      r0,|L10.1040|
000308  82c1              STRH     r1,[r0,#0x16]
;;;1010     goto send;
00030a  e3f4              B        |L10.2806|
                  |L10.780|
;;;1011   
;;;1012     /* End of IPv4 input header processing code. */
;;;1013   #else /* !UIP_CONF_IPV6 */
;;;1014   
;;;1015     /* This is IPv6 ICMPv6 processing code. */
;;;1016     DEBUG_PRINTF("icmp6_input: length %d\n", uip_len);
;;;1017   
;;;1018     if(BUF->proto != UIP_PROTO_ICMP6) { /* We only allow ICMPv6 packets from
;;;1019   					 here. */
;;;1020       UIP_STAT(++uip_stat.ip.drop);
;;;1021       UIP_STAT(++uip_stat.ip.protoerr);
;;;1022       UIP_LOG("ip: neither tcp nor icmp6.");
;;;1023       goto drop;
;;;1024     }
;;;1025   
;;;1026     UIP_STAT(++uip_stat.icmp.recv);
;;;1027   
;;;1028     /* If we get a neighbor solicitation for our address we should send
;;;1029        a neighbor advertisement message back. */
;;;1030     if(ICMPBUF->type == ICMP6_NEIGHBOR_SOLICITATION) {
;;;1031       if(uip_ipaddr_cmp(ICMPBUF->icmp6data, uip_hostaddr)) {
;;;1032   
;;;1033         if(ICMPBUF->options[0] == ICMP6_OPTION_SOURCE_LINK_ADDRESS) {
;;;1034   	/* Save the sender's address in our neighbor list. */
;;;1035   	uip_neighbor_add(ICMPBUF->srcipaddr, &(ICMPBUF->options[2]));
;;;1036         }
;;;1037         
;;;1038         /* We should now send a neighbor advertisement back to where the
;;;1039   	 neighbor solicication came from. */
;;;1040         ICMPBUF->type = ICMP6_NEIGHBOR_ADVERTISEMENT;
;;;1041         ICMPBUF->flags = ICMP6_FLAG_S; /* Solicited flag. */
;;;1042         
;;;1043         ICMPBUF->reserved1 = ICMPBUF->reserved2 = ICMPBUF->reserved3 = 0;
;;;1044         
;;;1045         uip_ipaddr_copy(ICMPBUF->destipaddr, ICMPBUF->srcipaddr);
;;;1046         uip_ipaddr_copy(ICMPBUF->srcipaddr, uip_hostaddr);
;;;1047         ICMPBUF->options[0] = ICMP6_OPTION_TARGET_LINK_ADDRESS;
;;;1048         ICMPBUF->options[1] = 1;  /* Options length, 1 = 8 bytes. */
;;;1049         memcpy(&(ICMPBUF->options[2]), &uip_ethaddr, sizeof(uip_ethaddr));
;;;1050         ICMPBUF->icmpchksum = 0;
;;;1051         ICMPBUF->icmpchksum = ~uip_icmp6chksum();
;;;1052         goto send;
;;;1053         
;;;1054       }
;;;1055       goto drop;
;;;1056     } else if(ICMPBUF->type == ICMP6_ECHO) {
;;;1057       /* ICMP echo (i.e., ping) processing. This is simple, we only
;;;1058          change the ICMP type from ECHO to ECHO_REPLY and update the
;;;1059          ICMP checksum before we return the packet. */
;;;1060   
;;;1061       ICMPBUF->type = ICMP6_ECHO_REPLY;
;;;1062       
;;;1063       uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
;;;1064       uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
;;;1065       ICMPBUF->icmpchksum = 0;
;;;1066       ICMPBUF->icmpchksum = ~uip_icmp6chksum();
;;;1067       
;;;1068       UIP_STAT(++uip_stat.icmp.sent);
;;;1069       goto send;
;;;1070     } else {
;;;1071       DEBUG_PRINTF("Unknown icmp6 message type %d\n", ICMPBUF->type);
;;;1072       UIP_STAT(++uip_stat.icmp.drop);
;;;1073       UIP_STAT(++uip_stat.icmp.typeerr);
;;;1074       UIP_LOG("icmp: unknown ICMP message.");
;;;1075       goto drop;
;;;1076     }
;;;1077   
;;;1078     /* End of IPv6 ICMP processing. */
;;;1079     
;;;1080   #endif /* !UIP_CONF_IPV6 */
;;;1081   
;;;1082   #if UIP_UDP
;;;1083     /* UDP input processing. */
;;;1084    udp_input:
;;;1085     /* UDP processing is really just a hack. We don't do anything to the
;;;1086        UDP/IP headers, but let the UDP application do all the hard
;;;1087        work. If the application sets uip_slen, it has a packet to
;;;1088        send. */
;;;1089   #if UIP_UDP_CHECKSUMS
;;;1090     uip_len = uip_len - UIP_IPUDPH_LEN;
;;;1091     uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
;;;1092     if(UDPBUF->udpchksum != 0 && uip_udpchksum() != 0xffff) {
;;;1093       UIP_STAT(++uip_stat.udp.drop);
;;;1094       UIP_STAT(++uip_stat.udp.chkerr);
;;;1095       UIP_LOG("udp: bad checksum.");
;;;1096       goto drop;
;;;1097     }
;;;1098   #else /* UIP_UDP_CHECKSUMS */
;;;1099     uip_len = uip_len - UIP_IPUDPH_LEN;
;;;1100   #endif /* UIP_UDP_CHECKSUMS */
;;;1101     /* Demultiplex this UDP packet between the UDP "connections". */
;;;1102     for(uip_udp_conn = &uip_udp_conns[0];
;;;1103         uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
;;;1104         ++uip_udp_conn) {
;;;1105       /* If the local UDP port is non-zero, the connection is considered
;;;1106          to be used. If so, the local port number is checked against the
;;;1107          destination port number in the received packet. If the two port
;;;1108          numbers match, the remote port number is checked if the
;;;1109          connection is bound to a remote port. Finally, if the
;;;1110          connection is bound to a remote IP address, the source IP
;;;1111          address of the packet is checked. */
;;;1112       if(uip_udp_conn->lport != 0 &&
;;;1113          UDPBUF->destport == uip_udp_conn->lport &&
;;;1114          (uip_udp_conn->rport == 0 ||
;;;1115           UDPBUF->srcport == uip_udp_conn->rport) &&
;;;1116          (uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_zeroes_addr) ||
;;;1117   	uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_ones_addr) ||
;;;1118   	uip_ipaddr_cmp(BUF->srcipaddr, uip_udp_conn->ripaddr))) {
;;;1119         goto udp_found;
;;;1120       }
;;;1121     }
;;;1122     UIP_LOG("udp: no matching connection found");
;;;1123     goto drop;
;;;1124     
;;;1125    udp_found:
;;;1126     uip_conn = NULL;
;;;1127     uip_flags = UIP_NEWDATA;
;;;1128     uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
;;;1129     uip_slen = 0;
;;;1130     UIP_UDP_APPCALL();
;;;1131    udp_send:
;;;1132     if(uip_slen == 0) {
;;;1133       goto drop;
;;;1134     }
;;;1135     uip_len = uip_slen + UIP_IPUDPH_LEN;
;;;1136   
;;;1137   #if UIP_CONF_IPV6
;;;1138     /* For IPv6, the IP length field does not include the IPv6 IP header
;;;1139        length. */
;;;1140     BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
;;;1141     BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
;;;1142   #else /* UIP_CONF_IPV6 */
;;;1143     BUF->len[0] = (uip_len >> 8);
;;;1144     BUF->len[1] = (uip_len & 0xff);
;;;1145   #endif /* UIP_CONF_IPV6 */
;;;1146   
;;;1147     BUF->ttl = uip_udp_conn->ttl;
;;;1148     BUF->proto = UIP_PROTO_UDP;
;;;1149   
;;;1150     UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
;;;1151     UDPBUF->udpchksum = 0;
;;;1152   
;;;1153     BUF->srcport  = uip_udp_conn->lport;
;;;1154     BUF->destport = uip_udp_conn->rport;
;;;1155   
;;;1156     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
;;;1157     uip_ipaddr_copy(BUF->destipaddr, uip_udp_conn->ripaddr);
;;;1158      
;;;1159     uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
;;;1160   
;;;1161   #if UIP_UDP_CHECKSUMS
;;;1162     /* Calculate UDP checksum. */
;;;1163     UDPBUF->udpchksum = ~(uip_udpchksum());
;;;1164     if(UDPBUF->udpchksum == 0) {
;;;1165       UDPBUF->udpchksum = 0xffff;
;;;1166     }
;;;1167   #endif /* UIP_UDP_CHECKSUMS */
;;;1168     
;;;1169     goto ip_send_nolen;
;;;1170   #endif /* UIP_UDP */
;;;1171     
;;;1172     /* TCP input processing. */
;;;1173    tcp_input:
;;;1174     UIP_STAT(++uip_stat.tcp.recv);
00030c  4840              LDR      r0,|L10.1040|
00030e  8b80              LDRH     r0,[r0,#0x1c]
000310  1c40              ADDS     r0,r0,#1
000312  b281              UXTH     r1,r0
000314  483e              LDR      r0,|L10.1040|
000316  8381              STRH     r1,[r0,#0x1c]
;;;1175   
;;;1176     /* Start of TCP input header processing code. */
;;;1177     
;;;1178     if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
000318  f7fffffe          BL       uip_tcpchksum
00031c  f64f71ff          MOV      r1,#0xffff
000320  4288              CMP      r0,r1
000322  d00e              BEQ      |L10.834|
;;;1179   				       checksum. */
;;;1180       UIP_STAT(++uip_stat.tcp.drop);
000324  483a              LDR      r0,|L10.1040|
000326  8b40              LDRH     r0,[r0,#0x1a]  ; uip_stat
000328  1c40              ADDS     r0,r0,#1
00032a  4939              LDR      r1,|L10.1040|
00032c  8348              STRH     r0,[r1,#0x1a]
;;;1181       UIP_STAT(++uip_stat.tcp.chkerr);
00032e  4608              MOV      r0,r1
000330  8c00              LDRH     r0,[r0,#0x20]
000332  1c40              ADDS     r0,r0,#1
000334  b281              UXTH     r1,r0
000336  4836              LDR      r0,|L10.1040|
000338  8401              STRH     r1,[r0,#0x20]
;;;1182       UIP_LOG("tcp: bad checksum.");
00033a  a066              ADR      r0,|L10.1236|
00033c  f7fffffe          BL       uip_log
;;;1183       goto drop;
000340  e676              B        |L10.48|
                  |L10.834|
;;;1184     }
;;;1185     
;;;1186     
;;;1187     /* Demultiplex this segment. */
;;;1188     /* First check any active connections. */
;;;1189     for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
000342  4c69              LDR      r4,|L10.1256|
000344  e01b              B        |L10.894|
                  |L10.838|
;;;1190         ++uip_connr) {
;;;1191       if(uip_connr->tcpstateflags != UIP_CLOSED &&
000346  7e60              LDRB     r0,[r4,#0x19]
000348  b1c0              CBZ      r0,|L10.892|
;;;1192          BUF->destport == uip_connr->lport &&
00034a  482a              LDR      r0,|L10.1012|
00034c  3836              SUBS     r0,r0,#0x36
00034e  8c80              LDRH     r0,[r0,#0x24]
000350  88a1              LDRH     r1,[r4,#4]
000352  4288              CMP      r0,r1
000354  d112              BNE      |L10.892|
;;;1193          BUF->srcport == uip_connr->rport &&
000356  4827              LDR      r0,|L10.1012|
000358  3836              SUBS     r0,r0,#0x36
00035a  8c40              LDRH     r0,[r0,#0x22]
00035c  88e1              LDRH     r1,[r4,#6]
00035e  4288              CMP      r0,r1
000360  d10c              BNE      |L10.892|
;;;1194          uip_ipaddr_cmp(BUF->srcipaddr, uip_connr->ripaddr)) {
000362  4824              LDR      r0,|L10.1012|
000364  3836              SUBS     r0,r0,#0x36
000366  8b40              LDRH     r0,[r0,#0x1a]
000368  8821              LDRH     r1,[r4,#0]
00036a  4288              CMP      r0,r1
00036c  d106              BNE      |L10.892|
00036e  4821              LDR      r0,|L10.1012|
000370  3836              SUBS     r0,r0,#0x36
000372  8b80              LDRH     r0,[r0,#0x1c]
000374  8861              LDRH     r1,[r4,#2]
000376  4288              CMP      r0,r1
000378  d100              BNE      |L10.892|
;;;1195         goto found;
00037a  e244              B        |L10.2054|
                  |L10.892|
00037c  3428              ADDS     r4,r4,#0x28           ;1190
                  |L10.894|
00037e  485b              LDR      r0,|L10.1260|
000380  4284              CMP      r4,r0                 ;1189
000382  d9e0              BLS      |L10.838|
;;;1196       }
;;;1197     }
;;;1198   
;;;1199     /* If we didn't find and active connection that expected the packet,
;;;1200        either this packet is an old duplicate, or this is a SYN packet
;;;1201        destined for a connection in LISTEN. If the SYN flag isn't set,
;;;1202        it is an old packet and we send a RST. */
;;;1203     if((BUF->flags & TCP_CTL) != TCP_SYN) {
000384  481b              LDR      r0,|L10.1012|
000386  3836              SUBS     r0,r0,#0x36
000388  f890002f          LDRB     r0,[r0,#0x2f]
00038c  f000003f          AND      r0,r0,#0x3f
000390  2802              CMP      r0,#2
000392  d000              BEQ      |L10.918|
;;;1204       goto reset;
000394  e022              B        |L10.988|
                  |L10.918|
;;;1205     }
;;;1206     
;;;1207     tmp16 = BUF->destport;
000396  4817              LDR      r0,|L10.1012|
000398  3836              SUBS     r0,r0,#0x36
00039a  8c80              LDRH     r0,[r0,#0x24]
00039c  4954              LDR      r1,|L10.1264|
00039e  8008              STRH     r0,[r1,#0]
;;;1208     /* Next, check listening connections. */
;;;1209     for(c = 0; c < UIP_LISTENPORTS; ++c) {
0003a0  2000              MOVS     r0,#0
0003a2  4954              LDR      r1,|L10.1268|
0003a4  7008              STRB     r0,[r1,#0]
0003a6  e00e              B        |L10.966|
                  |L10.936|
;;;1210       if(tmp16 == uip_listenports[c])
0003a8  4853              LDR      r0,|L10.1272|
0003aa  4952              LDR      r1,|L10.1268|
0003ac  7809              LDRB     r1,[r1,#0]  ; c
0003ae  f8300011          LDRH     r0,[r0,r1,LSL #1]
0003b2  494f              LDR      r1,|L10.1264|
0003b4  8809              LDRH     r1,[r1,#0]  ; tmp16
0003b6  4288              CMP      r0,r1
0003b8  d100              BNE      |L10.956|
;;;1211         goto found_listen;
0003ba  e123              B        |L10.1540|
                  |L10.956|
0003bc  484d              LDR      r0,|L10.1268|
0003be  7800              LDRB     r0,[r0,#0]            ;1209  ; c
0003c0  1c40              ADDS     r0,r0,#1              ;1209
0003c2  494c              LDR      r1,|L10.1268|
0003c4  7008              STRB     r0,[r1,#0]            ;1209
                  |L10.966|
0003c6  484b              LDR      r0,|L10.1268|
0003c8  7800              LDRB     r0,[r0,#0]            ;1209  ; c
0003ca  2828              CMP      r0,#0x28              ;1209
0003cc  dbec              BLT      |L10.936|
;;;1212     }
;;;1213     
;;;1214     /* No matching connection found, so we send a RST packet. */
;;;1215     UIP_STAT(++uip_stat.tcp.synrst);
0003ce  4810              LDR      r0,|L10.1040|
0003d0  8d40              LDRH     r0,[r0,#0x2a]
0003d2  1c40              ADDS     r0,r0,#1
0003d4  b281              UXTH     r1,r0
0003d6  480e              LDR      r0,|L10.1040|
0003d8  8541              STRH     r1,[r0,#0x2a]
;;;1216    reset:
0003da  bf00              NOP      
                  |L10.988|
;;;1217   
;;;1218     /* We do not send resets in response to resets. */
;;;1219     if(BUF->flags & TCP_RST) {
0003dc  4805              LDR      r0,|L10.1012|
0003de  3836              SUBS     r0,r0,#0x36
0003e0  f890002f          LDRB     r0,[r0,#0x2f]
0003e4  f0000004          AND      r0,r0,#4
0003e8  b100              CBZ      r0,|L10.1004|
;;;1220       goto drop;
0003ea  e621              B        |L10.48|
                  |L10.1004|
0003ec  e086              B        |L10.1276|
0003ee  0000              DCW      0x0000
                  |L10.1008|
                          DCD      uip_conn
                  |L10.1012|
                          DCD      uip_buf+0x36
                  |L10.1016|
                          DCD      uip_appdata
                  |L10.1020|
                          DCD      uip_sappdata
                  |L10.1024|
                          DCD      uip_flags
                  |L10.1028|
                          DCD      iss
                  |L10.1032|
                          DCD      uip_len
                  |L10.1036|
                          DCD      uip_slen
                  |L10.1040|
                          DCD      uip_stat
                  |L10.1044|
000414  69703a20          DCB      "ip: invalid version or header length.",0
000418  696e7661
00041c  6c696420
000420  76657273
000424  696f6e20
000428  6f722068
00042c  65616465
000430  72206c65
000434  6e677468
000438  2e00    
00043a  00                DCB      0
00043b  00                DCB      0
                  |L10.1084|
00043c  69703a20          DCB      "ip: packet shorter than reported in IP header.",0
000440  7061636b
000444  65742073
000448  686f7274
00044c  65722074
000450  68616e20
000454  7265706f
000458  72746564
00045c  20696e20
000460  49502068
000464  65616465
000468  722e00  
00046b  00                DCB      0
                  |L10.1132|
00046c  69703a20          DCB      "ip: fragment dropped.",0
000470  66726167
000474  6d656e74
000478  2064726f
00047c  70706564
000480  2e00    
000482  00                DCB      0
000483  00                DCB      0
                  |L10.1156|
                          DCD      uip_hostaddr
                  |L10.1160|
                          DCD      all_zeroes_addr
                  |L10.1164|
00048c  69703a20          DCB      "ip: bad checksum.",0
000490  62616420
000494  63686563
000498  6b73756d
00049c  2e00    
00049e  00                DCB      0
00049f  00                DCB      0
                  |L10.1184|
0004a0  69703a20          DCB      "ip: neither tcp nor icmp.",0
0004a4  6e656974
0004a8  68657220
0004ac  74637020
0004b0  6e6f7220
0004b4  69636d70
0004b8  2e00    
0004ba  00                DCB      0
0004bb  00                DCB      0
                  |L10.1212|
0004bc  69636d70          DCB      "icmp: not icmp echo.",0
0004c0  3a206e6f
0004c4  74206963
0004c8  6d702065
0004cc  63686f2e
0004d0  00      
0004d1  00                DCB      0
0004d2  00                DCB      0
0004d3  00                DCB      0
                  |L10.1236|
0004d4  7463703a          DCB      "tcp: bad checksum.",0
0004d8  20626164
0004dc  20636865
0004e0  636b7375
0004e4  6d2e00  
0004e7  00                DCB      0
                  |L10.1256|
                          DCD      uip_conns
                  |L10.1260|
                          DCD      uip_conns+0x618
                  |L10.1264|
                          DCD      tmp16
                  |L10.1268|
                          DCD      c
                  |L10.1272|
                          DCD      uip_listenports
                  |L10.1276|
;;;1221     }
;;;1222   
;;;1223     UIP_STAT(++uip_stat.tcp.rst);
0004fc  48fd              LDR      r0,|L10.2292|
0004fe  8c80              LDRH     r0,[r0,#0x24]
000500  1c40              ADDS     r0,r0,#1
000502  b281              UXTH     r1,r0
000504  48fb              LDR      r0,|L10.2292|
000506  8481              STRH     r1,[r0,#0x24]
;;;1224     
;;;1225     BUF->flags = TCP_RST | TCP_ACK;
000508  2114              MOVS     r1,#0x14
00050a  48fb              LDR      r0,|L10.2296|
00050c  f880102f          STRB     r1,[r0,#0x2f]
;;;1226     uip_len = UIP_IPTCPH_LEN;
000510  2028              MOVS     r0,#0x28
000512  49fa              LDR      r1,|L10.2300|
000514  8008              STRH     r0,[r1,#0]
;;;1227     BUF->tcpoffset = 5 << 4;
000516  2150              MOVS     r1,#0x50
000518  48f7              LDR      r0,|L10.2296|
00051a  f880102e          STRB     r1,[r0,#0x2e]
;;;1228   
;;;1229     /* Flip the seqno and ackno fields in the TCP header. */
;;;1230     c = BUF->seqno[3];
00051e  f8900029          LDRB     r0,[r0,#0x29]
000522  49f7              LDR      r1,|L10.2304|
000524  7008              STRB     r0,[r1,#0]
;;;1231     BUF->seqno[3] = BUF->ackno[3];
000526  48f4              LDR      r0,|L10.2296|
000528  f890102d          LDRB     r1,[r0,#0x2d]
00052c  f8801029          STRB     r1,[r0,#0x29]
;;;1232     BUF->ackno[3] = c;
000530  48f3              LDR      r0,|L10.2304|
000532  7801              LDRB     r1,[r0,#0]  ; c
000534  48f0              LDR      r0,|L10.2296|
000536  f880102d          STRB     r1,[r0,#0x2d]
;;;1233     
;;;1234     c = BUF->seqno[2];
00053a  f8900028          LDRB     r0,[r0,#0x28]
00053e  49f0              LDR      r1,|L10.2304|
000540  7008              STRB     r0,[r1,#0]
;;;1235     BUF->seqno[2] = BUF->ackno[2];
000542  48ed              LDR      r0,|L10.2296|
000544  f890102c          LDRB     r1,[r0,#0x2c]
000548  f8801028          STRB     r1,[r0,#0x28]
;;;1236     BUF->ackno[2] = c;
00054c  48ec              LDR      r0,|L10.2304|
00054e  7801              LDRB     r1,[r0,#0]  ; c
000550  48e9              LDR      r0,|L10.2296|
000552  f880102c          STRB     r1,[r0,#0x2c]
;;;1237     
;;;1238     c = BUF->seqno[1];
000556  f8900027          LDRB     r0,[r0,#0x27]
00055a  49e9              LDR      r1,|L10.2304|
00055c  7008              STRB     r0,[r1,#0]
;;;1239     BUF->seqno[1] = BUF->ackno[1];
00055e  48e6              LDR      r0,|L10.2296|
000560  f890102b          LDRB     r1,[r0,#0x2b]
000564  f8801027          STRB     r1,[r0,#0x27]
;;;1240     BUF->ackno[1] = c;
000568  48e5              LDR      r0,|L10.2304|
00056a  7801              LDRB     r1,[r0,#0]  ; c
00056c  48e2              LDR      r0,|L10.2296|
00056e  f880102b          STRB     r1,[r0,#0x2b]
;;;1241     
;;;1242     c = BUF->seqno[0];
000572  f8900026          LDRB     r0,[r0,#0x26]
000576  49e2              LDR      r1,|L10.2304|
000578  7008              STRB     r0,[r1,#0]
;;;1243     BUF->seqno[0] = BUF->ackno[0];
00057a  48df              LDR      r0,|L10.2296|
00057c  f890102a          LDRB     r1,[r0,#0x2a]
000580  f8801026          STRB     r1,[r0,#0x26]
;;;1244     BUF->ackno[0] = c;
000584  48de              LDR      r0,|L10.2304|
000586  7801              LDRB     r1,[r0,#0]  ; c
000588  48db              LDR      r0,|L10.2296|
00058a  f880102a          STRB     r1,[r0,#0x2a]
;;;1245   
;;;1246     /* We also have to increase the sequence number we are
;;;1247        acknowledging. If the least significant byte overflowed, we need
;;;1248        to propagate the carry to the other bytes as well. */
;;;1249     if(++BUF->ackno[3] == 0) {
00058e  f890002d          LDRB     r0,[r0,#0x2d]
000592  1c40              ADDS     r0,r0,#1
000594  b2c1              UXTB     r1,r0
000596  48d8              LDR      r0,|L10.2296|
000598  f880102d          STRB     r1,[r0,#0x2d]
00059c  b9b1              CBNZ     r1,|L10.1484|
;;;1250       if(++BUF->ackno[2] == 0) {
00059e  f890002c          LDRB     r0,[r0,#0x2c]
0005a2  1c40              ADDS     r0,r0,#1
0005a4  b2c1              UXTB     r1,r0
0005a6  48d4              LDR      r0,|L10.2296|
0005a8  f880102c          STRB     r1,[r0,#0x2c]
0005ac  b971              CBNZ     r1,|L10.1484|
;;;1251         if(++BUF->ackno[1] == 0) {
0005ae  f890002b          LDRB     r0,[r0,#0x2b]
0005b2  1c40              ADDS     r0,r0,#1
0005b4  b2c1              UXTB     r1,r0
0005b6  48d0              LDR      r0,|L10.2296|
0005b8  f880102b          STRB     r1,[r0,#0x2b]
0005bc  b931              CBNZ     r1,|L10.1484|
;;;1252   	++BUF->ackno[0];
0005be  f890002a          LDRB     r0,[r0,#0x2a]
0005c2  1c40              ADDS     r0,r0,#1
0005c4  b2c1              UXTB     r1,r0
0005c6  48cc              LDR      r0,|L10.2296|
0005c8  f880102a          STRB     r1,[r0,#0x2a]
                  |L10.1484|
;;;1253         }
;;;1254       }
;;;1255     }
;;;1256    
;;;1257     /* Swap port numbers. */
;;;1258     tmp16 = BUF->srcport;
0005cc  48ca              LDR      r0,|L10.2296|
0005ce  8c40              LDRH     r0,[r0,#0x22]
0005d0  49cc              LDR      r1,|L10.2308|
0005d2  8008              STRH     r0,[r1,#0]
;;;1259     BUF->srcport = BUF->destport;
0005d4  48c8              LDR      r0,|L10.2296|
0005d6  8c81              LDRH     r1,[r0,#0x24]
0005d8  8441              STRH     r1,[r0,#0x22]
;;;1260     BUF->destport = tmp16;
0005da  48ca              LDR      r0,|L10.2308|
0005dc  8801              LDRH     r1,[r0,#0]  ; tmp16
0005de  48c6              LDR      r0,|L10.2296|
0005e0  8481              STRH     r1,[r0,#0x24]
;;;1261     
;;;1262     /* Swap IP addresses. */
;;;1263     uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
0005e2  bf00              NOP      
0005e4  8b41              LDRH     r1,[r0,#0x1a]
0005e6  83c1              STRH     r1,[r0,#0x1e]
0005e8  8b81              LDRH     r1,[r0,#0x1c]
0005ea  8401              STRH     r1,[r0,#0x20]
0005ec  bf00              NOP      
;;;1264     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
0005ee  bf00              NOP      
0005f0  48c5              LDR      r0,|L10.2312|
0005f2  8801              LDRH     r1,[r0,#0]  ; uip_hostaddr
0005f4  48c0              LDR      r0,|L10.2296|
0005f6  8341              STRH     r1,[r0,#0x1a]
0005f8  48c3              LDR      r0,|L10.2312|
0005fa  8841              LDRH     r1,[r0,#2]  ; uip_hostaddr
0005fc  48be              LDR      r0,|L10.2296|
0005fe  8381              STRH     r1,[r0,#0x1c]
000600  bf00              NOP      
;;;1265     
;;;1266     /* And send out the RST packet! */
;;;1267     goto tcp_send_noconn;
000602  e3f5              B        |L10.3568|
                  |L10.1540|
;;;1268   
;;;1269     /* This label will be jumped to if we matched the incoming packet
;;;1270        with a connection in LISTEN. In that case, we should create a new
;;;1271        connection and send a SYNACK in return. */
;;;1272    found_listen:
;;;1273     /* First we check if there are any connections avaliable. Unused
;;;1274        connections are kept in the same table as used connections, but
;;;1275        unused ones have the tcpstate set to CLOSED. Also, connections in
;;;1276        TIME_WAIT are kept track of and we'll use the oldest one if no
;;;1277        CLOSED connections are found. Thanks to Eddie C. Dost for a very
;;;1278        nice algorithm for the TIME_WAIT search. */
;;;1279     uip_connr = 0;
000604  2400              MOVS     r4,#0
;;;1280     for(c = 0; c < UIP_CONNS; ++c) {
000606  2000              MOVS     r0,#0
000608  49bd              LDR      r1,|L10.2304|
00060a  7008              STRB     r0,[r1,#0]
00060c  e030              B        |L10.1648|
                  |L10.1550|
;;;1281       if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
00060e  48bc              LDR      r0,|L10.2304|
000610  7800              LDRB     r0,[r0,#0]  ; c
000612  eb000080          ADD      r0,r0,r0,LSL #2
000616  49bd              LDR      r1,|L10.2316|
000618  eb0100c0          ADD      r0,r1,r0,LSL #3
00061c  7e40              LDRB     r0,[r0,#0x19]
00061e  b930              CBNZ     r0,|L10.1582|
;;;1282         uip_connr = &uip_conns[c];
000620  48b7              LDR      r0,|L10.2304|
000622  7800              LDRB     r0,[r0,#0]  ; c
000624  eb000080          ADD      r0,r0,r0,LSL #2
000628  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;1283         break;
00062c  e024              B        |L10.1656|
                  |L10.1582|
;;;1284       }
;;;1285       if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
00062e  48b4              LDR      r0,|L10.2304|
000630  7800              LDRB     r0,[r0,#0]  ; c
000632  eb000080          ADD      r0,r0,r0,LSL #2
000636  49b5              LDR      r1,|L10.2316|
000638  eb0100c0          ADD      r0,r1,r0,LSL #3
00063c  7e40              LDRB     r0,[r0,#0x19]
00063e  2807              CMP      r0,#7
000640  d111              BNE      |L10.1638|
;;;1286         if(uip_connr == 0 ||
000642  b14c              CBZ      r4,|L10.1624|
;;;1287   	 uip_conns[c].timer > uip_connr->timer) {
000644  48ae              LDR      r0,|L10.2304|
000646  7800              LDRB     r0,[r0,#0]  ; c
000648  eb000080          ADD      r0,r0,r0,LSL #2
00064c  eb0100c0          ADD      r0,r1,r0,LSL #3
000650  7e80              LDRB     r0,[r0,#0x1a]
000652  7ea1              LDRB     r1,[r4,#0x1a]
000654  4288              CMP      r0,r1
000656  dd06              BLE      |L10.1638|
                  |L10.1624|
;;;1288   	uip_connr = &uip_conns[c];
000658  48a9              LDR      r0,|L10.2304|
00065a  7800              LDRB     r0,[r0,#0]  ; c
00065c  eb000080          ADD      r0,r0,r0,LSL #2
000660  49aa              LDR      r1,|L10.2316|
000662  eb0104c0          ADD      r4,r1,r0,LSL #3
                  |L10.1638|
000666  48a6              LDR      r0,|L10.2304|
000668  7800              LDRB     r0,[r0,#0]            ;1280  ; c
00066a  1c40              ADDS     r0,r0,#1              ;1280
00066c  49a4              LDR      r1,|L10.2304|
00066e  7008              STRB     r0,[r1,#0]            ;1280
                  |L10.1648|
000670  48a3              LDR      r0,|L10.2304|
000672  7800              LDRB     r0,[r0,#0]            ;1280  ; c
000674  2828              CMP      r0,#0x28              ;1280
000676  dbca              BLT      |L10.1550|
                  |L10.1656|
000678  bf00              NOP                            ;1283
;;;1289         }
;;;1290       }
;;;1291     }
;;;1292   
;;;1293     if(uip_connr == 0) {
00067a  b94c              CBNZ     r4,|L10.1680|
;;;1294       /* All connections are used already, we drop packet and hope that
;;;1295          the remote end will retransmit the packet at a time when we
;;;1296          have more spare connections. */
;;;1297       UIP_STAT(++uip_stat.tcp.syndrop);
00067c  489d              LDR      r0,|L10.2292|
00067e  8d00              LDRH     r0,[r0,#0x28]
000680  1c40              ADDS     r0,r0,#1
000682  b281              UXTH     r1,r0
000684  489b              LDR      r0,|L10.2292|
000686  8501              STRH     r1,[r0,#0x28]
;;;1298       UIP_LOG("tcp: found no unused connections.");
000688  a0a1              ADR      r0,|L10.2320|
00068a  f7fffffe          BL       uip_log
;;;1299       goto drop;
00068e  e4cf              B        |L10.48|
                  |L10.1680|
;;;1300     }
;;;1301     uip_conn = uip_connr;
000690  48a8              LDR      r0,|L10.2356|
000692  6004              STR      r4,[r0,#0]  ; uip_conn
;;;1302     
;;;1303     /* Fill in the necessary fields for the new connection. */
;;;1304     uip_connr->rto = uip_connr->timer = UIP_RTO;
000694  2003              MOVS     r0,#3
000696  76a0              STRB     r0,[r4,#0x1a]
000698  7620              STRB     r0,[r4,#0x18]
;;;1305     uip_connr->sa = 0;
00069a  2000              MOVS     r0,#0
00069c  75a0              STRB     r0,[r4,#0x16]
;;;1306     uip_connr->sv = 4;
00069e  2004              MOVS     r0,#4
0006a0  75e0              STRB     r0,[r4,#0x17]
;;;1307     uip_connr->nrtx = 0;
0006a2  2000              MOVS     r0,#0
0006a4  76e0              STRB     r0,[r4,#0x1b]
;;;1308     uip_connr->lport = BUF->destport;
0006a6  4894              LDR      r0,|L10.2296|
0006a8  8c80              LDRH     r0,[r0,#0x24]
0006aa  80a0              STRH     r0,[r4,#4]
;;;1309     uip_connr->rport = BUF->srcport;
0006ac  4892              LDR      r0,|L10.2296|
0006ae  8c40              LDRH     r0,[r0,#0x22]
0006b0  80e0              STRH     r0,[r4,#6]
;;;1310     uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
0006b2  bf00              NOP      
0006b4  4890              LDR      r0,|L10.2296|
0006b6  8b40              LDRH     r0,[r0,#0x1a]
0006b8  8020              STRH     r0,[r4,#0]
0006ba  488f              LDR      r0,|L10.2296|
0006bc  8b80              LDRH     r0,[r0,#0x1c]
0006be  8060              STRH     r0,[r4,#2]
0006c0  bf00              NOP      
;;;1311     uip_connr->tcpstateflags = UIP_SYN_RCVD;
0006c2  2001              MOVS     r0,#1
0006c4  7660              STRB     r0,[r4,#0x19]
;;;1312   
;;;1313     uip_connr->snd_nxt[0] = iss[0];
0006c6  489c              LDR      r0,|L10.2360|
0006c8  7800              LDRB     r0,[r0,#0]  ; iss
0006ca  7320              STRB     r0,[r4,#0xc]
;;;1314     uip_connr->snd_nxt[1] = iss[1];
0006cc  489a              LDR      r0,|L10.2360|
0006ce  7841              LDRB     r1,[r0,#1]  ; iss
0006d0  7361              STRB     r1,[r4,#0xd]
;;;1315     uip_connr->snd_nxt[2] = iss[2];
0006d2  7881              LDRB     r1,[r0,#2]  ; iss
0006d4  73a1              STRB     r1,[r4,#0xe]
;;;1316     uip_connr->snd_nxt[3] = iss[3];
0006d6  78c1              LDRB     r1,[r0,#3]  ; iss
0006d8  73e1              STRB     r1,[r4,#0xf]
;;;1317     uip_connr->len = 1;
0006da  2001              MOVS     r0,#1
0006dc  8220              STRH     r0,[r4,#0x10]
;;;1318   
;;;1319     /* rcv_nxt should be the seqno from the incoming packet + 1. */
;;;1320     uip_connr->rcv_nxt[3] = BUF->seqno[3];
0006de  4886              LDR      r0,|L10.2296|
0006e0  f8901029          LDRB     r1,[r0,#0x29]
0006e4  72e1              STRB     r1,[r4,#0xb]
;;;1321     uip_connr->rcv_nxt[2] = BUF->seqno[2];
0006e6  f8901028          LDRB     r1,[r0,#0x28]
0006ea  72a1              STRB     r1,[r4,#0xa]
;;;1322     uip_connr->rcv_nxt[1] = BUF->seqno[1];
0006ec  f8901027          LDRB     r1,[r0,#0x27]
0006f0  7261              STRB     r1,[r4,#9]
;;;1323     uip_connr->rcv_nxt[0] = BUF->seqno[0];
0006f2  f8900026          LDRB     r0,[r0,#0x26]
0006f6  7220              STRB     r0,[r4,#8]
;;;1324     uip_add_rcv_nxt(1);
0006f8  2001              MOVS     r0,#1
0006fa  f7fffffe          BL       uip_add_rcv_nxt
;;;1325   
;;;1326     /* Parse the TCP MSS option, if present. */
;;;1327     if((BUF->tcpoffset & 0xf0) > 0x50) {
0006fe  487e              LDR      r0,|L10.2296|
000700  f890002e          LDRB     r0,[r0,#0x2e]
000704  f00000f0          AND      r0,r0,#0xf0
000708  2850              CMP      r0,#0x50
00070a  dd5a              BLE      |L10.1986|
;;;1328       for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
00070c  2000              MOVS     r0,#0
00070e  497c              LDR      r1,|L10.2304|
000710  7008              STRB     r0,[r1,#0]
000712  e04a              B        |L10.1962|
                  |L10.1812|
;;;1329         opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
000714  487a              LDR      r0,|L10.2304|
000716  7800              LDRB     r0,[r0,#0]  ; c
000718  3036              ADDS     r0,r0,#0x36
00071a  4977              LDR      r1,|L10.2296|
00071c  5c08              LDRB     r0,[r1,r0]
00071e  4987              LDR      r1,|L10.2364|
000720  7008              STRB     r0,[r1,#0]
;;;1330         if(opt == TCP_OPT_END) {
000722  4608              MOV      r0,r1
000724  7800              LDRB     r0,[r0,#0]  ; opt
000726  b900              CBNZ     r0,|L10.1834|
;;;1331   	/* End of options. */
;;;1332   	break;
000728  e04a              B        |L10.1984|
                  |L10.1834|
;;;1333         } else if(opt == TCP_OPT_NOOP) {
00072a  4884              LDR      r0,|L10.2364|
00072c  7800              LDRB     r0,[r0,#0]  ; opt
00072e  2801              CMP      r0,#1
000730  d105              BNE      |L10.1854|
;;;1334   	++c;
000732  4873              LDR      r0,|L10.2304|
000734  7800              LDRB     r0,[r0,#0]  ; c
000736  1c40              ADDS     r0,r0,#1
000738  4971              LDR      r1,|L10.2304|
00073a  7008              STRB     r0,[r1,#0]
00073c  e035              B        |L10.1962|
                  |L10.1854|
;;;1335   	/* NOP option. */
;;;1336         } else if(opt == TCP_OPT_MSS &&
00073e  487f              LDR      r0,|L10.2364|
000740  7800              LDRB     r0,[r0,#0]  ; opt
000742  2802              CMP      r0,#2
000744  d120              BNE      |L10.1928|
;;;1337   		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
000746  486e              LDR      r0,|L10.2304|
000748  7800              LDRB     r0,[r0,#0]  ; c
00074a  3037              ADDS     r0,r0,#0x37
00074c  496a              LDR      r1,|L10.2296|
00074e  5c08              LDRB     r0,[r1,r0]
000750  2804              CMP      r0,#4
000752  d119              BNE      |L10.1928|
;;;1338   	/* An MSS option with the right option length. */
;;;1339   	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
000754  486a              LDR      r0,|L10.2304|
000756  7800              LDRB     r0,[r0,#0]  ; c
000758  3039              ADDS     r0,r0,#0x39
00075a  5c09              LDRB     r1,[r1,r0]
00075c  4868              LDR      r0,|L10.2304|
00075e  7800              LDRB     r0,[r0,#0]  ; c
000760  3038              ADDS     r0,r0,#0x38
000762  4a65              LDR      r2,|L10.2296|
000764  5c10              LDRB     r0,[r2,r0]
000766  ea412000          ORR      r0,r1,r0,LSL #8
00076a  4966              LDR      r1,|L10.2308|
00076c  8008              STRH     r0,[r1,#0]
;;;1340   	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
;;;1341   	uip_connr->initialmss = uip_connr->mss =
00076e  4608              MOV      r0,r1
000770  8800              LDRH     r0,[r0,#0]  ; tmp16
000772  f64071ca          MOV      r1,#0xfca
000776  4288              CMP      r0,r1
000778  dd01              BLE      |L10.1918|
;;;1342   	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
00077a  4608              MOV      r0,r1
00077c  e001              B        |L10.1922|
                  |L10.1918|
00077e  4861              LDR      r0,|L10.2308|
000780  8800              LDRH     r0,[r0,#0]  ; tmp16
                  |L10.1922|
000782  8260              STRH     r0,[r4,#0x12]
000784  82a0              STRH     r0,[r4,#0x14]
;;;1343   	
;;;1344   	/* And we are done processing options. */
;;;1345   	break;
000786  e01b              B        |L10.1984|
                  |L10.1928|
;;;1346         } else {
;;;1347   	/* All other options have a length field, so that we easily
;;;1348   	   can skip past them. */
;;;1349   	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
000788  485d              LDR      r0,|L10.2304|
00078a  7800              LDRB     r0,[r0,#0]  ; c
00078c  3037              ADDS     r0,r0,#0x37
00078e  495a              LDR      r1,|L10.2296|
000790  5c08              LDRB     r0,[r1,r0]
000792  b900              CBNZ     r0,|L10.1942|
;;;1350   	  /* If the length field is zero, the options are malformed
;;;1351   	     and we don't process them further. */
;;;1352   	  break;
000794  e014              B        |L10.1984|
                  |L10.1942|
;;;1353   	}
;;;1354   	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
000796  485a              LDR      r0,|L10.2304|
000798  7800              LDRB     r0,[r0,#0]  ; c
00079a  3037              ADDS     r0,r0,#0x37
00079c  4956              LDR      r1,|L10.2296|
00079e  5c08              LDRB     r0,[r1,r0]
0007a0  4957              LDR      r1,|L10.2304|
0007a2  7809              LDRB     r1,[r1,#0]  ; c
0007a4  4408              ADD      r0,r0,r1
0007a6  4956              LDR      r1,|L10.2304|
0007a8  7008              STRB     r0,[r1,#0]
                  |L10.1962|
0007aa  4853              LDR      r0,|L10.2296|
0007ac  f890002e          LDRB     r0,[r0,#0x2e]         ;1328
0007b0  2105              MOVS     r1,#5                 ;1328
0007b2  ebc11020          RSB      r0,r1,r0,ASR #4       ;1328
0007b6  4952              LDR      r1,|L10.2304|
0007b8  7809              LDRB     r1,[r1,#0]            ;1328  ; c
0007ba  ebb10f80          CMP      r1,r0,LSL #2          ;1328
0007be  dba9              BLT      |L10.1812|
                  |L10.1984|
0007c0  bf00              NOP                            ;1332
                  |L10.1986|
;;;1355         }
;;;1356       }
;;;1357     }
;;;1358     
;;;1359     /* Our response will be a SYNACK. */
;;;1360   #if UIP_ACTIVE_OPEN
;;;1361    tcp_send_synack:
0007c2  bf00              NOP      
                  |L10.1988|
;;;1362     BUF->flags = TCP_ACK;
0007c4  2110              MOVS     r1,#0x10
0007c6  484c              LDR      r0,|L10.2296|
0007c8  f880102f          STRB     r1,[r0,#0x2f]
;;;1363     
;;;1364    tcp_send_syn:
0007cc  bf00              NOP      
                  |L10.1998|
;;;1365     BUF->flags |= TCP_SYN;
0007ce  484a              LDR      r0,|L10.2296|
0007d0  f890002f          LDRB     r0,[r0,#0x2f]
0007d4  f0400102          ORR      r1,r0,#2
0007d8  4847              LDR      r0,|L10.2296|
0007da  f880102f          STRB     r1,[r0,#0x2f]
;;;1366   #else /* UIP_ACTIVE_OPEN */
;;;1367    tcp_send_synack:
;;;1368     BUF->flags = TCP_SYN | TCP_ACK;
;;;1369   #endif /* UIP_ACTIVE_OPEN */
;;;1370     
;;;1371     /* We send out the TCP Maximum Segment Size option with our
;;;1372        SYNACK. */
;;;1373     BUF->optdata[0] = TCP_OPT_MSS;
0007de  2102              MOVS     r1,#2
0007e0  f8801036          STRB     r1,[r0,#0x36]
;;;1374     BUF->optdata[1] = TCP_OPT_MSS_LEN;
0007e4  2104              MOVS     r1,#4
0007e6  f8801037          STRB     r1,[r0,#0x37]
;;;1375     BUF->optdata[2] = (UIP_TCP_MSS) / 256;
0007ea  210f              MOVS     r1,#0xf
0007ec  f8801038          STRB     r1,[r0,#0x38]
;;;1376     BUF->optdata[3] = (UIP_TCP_MSS) & 255;
0007f0  21ca              MOVS     r1,#0xca
0007f2  f8801039          STRB     r1,[r0,#0x39]
;;;1377     uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
0007f6  202c              MOVS     r0,#0x2c
0007f8  4940              LDR      r1,|L10.2300|
0007fa  8008              STRH     r0,[r1,#0]
;;;1378     BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
0007fc  2160              MOVS     r1,#0x60
0007fe  483e              LDR      r0,|L10.2296|
000800  f880102e          STRB     r1,[r0,#0x2e]
;;;1379     goto tcp_send;
000804  e337              B        |L10.3702|
                  |L10.2054|
;;;1380   
;;;1381     /* This label will be jumped to if we found an active connection. */
;;;1382    found:
;;;1383     uip_conn = uip_connr;
000806  484b              LDR      r0,|L10.2356|
000808  6004              STR      r4,[r0,#0]  ; uip_conn
;;;1384     uip_flags = 0;
00080a  2000              MOVS     r0,#0
00080c  494c              LDR      r1,|L10.2368|
00080e  7008              STRB     r0,[r1,#0]
;;;1385     /* We do a very naive form of TCP reset processing; we just accept
;;;1386        any RST and kill our connection. We should in fact check if the
;;;1387        sequence number of this reset is wihtin our advertised window
;;;1388        before we accept the reset. */
;;;1389     if(BUF->flags & TCP_RST) {
000810  4839              LDR      r0,|L10.2296|
000812  f890002f          LDRB     r0,[r0,#0x2f]
000816  f0000004          AND      r0,r0,#4
00081a  b160              CBZ      r0,|L10.2102|
;;;1390       uip_connr->tcpstateflags = UIP_CLOSED;
00081c  2000              MOVS     r0,#0
00081e  7660              STRB     r0,[r4,#0x19]
;;;1391       UIP_LOG("tcp: got reset, aborting connection.");
000820  e000              B        |L10.2084|
                  |L10.2082|
000822  e22f              B        |L10.3204|
                  |L10.2084|
000824  a047              ADR      r0,|L10.2372|
000826  f7fffffe          BL       uip_log
;;;1392       uip_flags = UIP_ABORT;
00082a  2020              MOVS     r0,#0x20
00082c  4944              LDR      r1,|L10.2368|
00082e  7008              STRB     r0,[r1,#0]
;;;1393       UIP_APPCALL();
000830  f7fffffe          BL       tcp_demo_appcall
;;;1394       goto drop;
000834  e3a7              B        |L10.3974|
                  |L10.2102|
;;;1395     }
;;;1396     /* Calculated the length of the data, if the application has sent
;;;1397        any data to us. */
;;;1398     c = (BUF->tcpoffset >> 4) << 2;
000836  4830              LDR      r0,|L10.2296|
000838  f890002e          LDRB     r0,[r0,#0x2e]
00083c  1100              ASRS     r0,r0,#4
00083e  0080              LSLS     r0,r0,#2
000840  492f              LDR      r1,|L10.2304|
000842  7008              STRB     r0,[r1,#0]
;;;1399     /* uip_len will contain the length of the actual TCP data. This is
;;;1400        calculated by subtracing the length of the TCP header (in
;;;1401        c) and the length of the IP header (20 bytes). */
;;;1402     uip_len = uip_len - c - UIP_IPH_LEN;
000844  482d              LDR      r0,|L10.2300|
000846  8800              LDRH     r0,[r0,#0]  ; uip_len
000848  7809              LDRB     r1,[r1,#0]  ; c
00084a  1a40              SUBS     r0,r0,r1
00084c  3814              SUBS     r0,r0,#0x14
00084e  492b              LDR      r1,|L10.2300|
000850  8008              STRH     r0,[r1,#0]
;;;1403   
;;;1404     /* First, check if the sequence number of the incoming packet is
;;;1405        what we're expecting next. If not, we send out an ACK with the
;;;1406        correct numbers in. */
;;;1407     if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
000852  7e60              LDRB     r0,[r4,#0x19]
000854  f000000f          AND      r0,r0,#0xf
000858  2802              CMP      r0,#2
00085a  d106              BNE      |L10.2154|
00085c  4826              LDR      r0,|L10.2296|
00085e  f890002f          LDRB     r0,[r0,#0x2f]
000862  f000003f          AND      r0,r0,#0x3f
000866  2812              CMP      r0,#0x12
000868  d022              BEQ      |L10.2224|
                  |L10.2154|
;;;1408          ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
;;;1409       if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
00086a  4824              LDR      r0,|L10.2300|
00086c  8800              LDRH     r0,[r0,#0]  ; uip_len
00086e  2800              CMP      r0,#0
000870  dc05              BGT      |L10.2174|
000872  4821              LDR      r0,|L10.2296|
000874  f890002f          LDRB     r0,[r0,#0x2f]
000878  f0000003          AND      r0,r0,#3
00087c  b1c0              CBZ      r0,|L10.2224|
                  |L10.2174|
;;;1410          (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
00087e  481e              LDR      r0,|L10.2296|
000880  f8900026          LDRB     r0,[r0,#0x26]
000884  7a21              LDRB     r1,[r4,#8]
000886  4288              CMP      r0,r1
000888  d111              BNE      |L10.2222|
;;;1411   	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
00088a  481b              LDR      r0,|L10.2296|
00088c  f8901027          LDRB     r1,[r0,#0x27]
000890  7a60              LDRB     r0,[r4,#9]
000892  4281              CMP      r1,r0
000894  d10b              BNE      |L10.2222|
;;;1412   	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
000896  4818              LDR      r0,|L10.2296|
000898  f8901028          LDRB     r1,[r0,#0x28]
00089c  7aa0              LDRB     r0,[r4,#0xa]
00089e  4281              CMP      r1,r0
0008a0  d105              BNE      |L10.2222|
;;;1413   	BUF->seqno[3] != uip_connr->rcv_nxt[3])) {
0008a2  4815              LDR      r0,|L10.2296|
0008a4  f8901029          LDRB     r1,[r0,#0x29]
0008a8  7ae0              LDRB     r0,[r4,#0xb]
0008aa  4281              CMP      r1,r0
0008ac  d000              BEQ      |L10.2224|
                  |L10.2222|
;;;1414         goto tcp_send_ack;
0008ae  e2d4              B        |L10.3674|
                  |L10.2224|
;;;1415       }
;;;1416     }
;;;1417   
;;;1418     /* Next, check if the incoming segment acknowledges any outstanding
;;;1419        data. If so, we update the sequence number, reset the length of
;;;1420        the outstanding data, calculate RTT estimations, and reset the
;;;1421        retransmission timer. */
;;;1422     if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
0008b0  4811              LDR      r0,|L10.2296|
0008b2  f890002f          LDRB     r0,[r0,#0x2f]
0008b6  f0000010          AND      r0,r0,#0x10
0008ba  b1d0              CBZ      r0,|L10.2290|
0008bc  8a20              LDRH     r0,[r4,#0x10]
0008be  b1c0              CBZ      r0,|L10.2290|
;;;1423       uip_add32(uip_connr->snd_nxt, uip_connr->len);
0008c0  8a21              LDRH     r1,[r4,#0x10]
0008c2  f104000c          ADD      r0,r4,#0xc
0008c6  f7fffffe          BL       uip_add32
;;;1424   
;;;1425       if(BUF->ackno[0] == uip_acc32[0] &&
0008ca  480b              LDR      r0,|L10.2296|
0008cc  f890002a          LDRB     r0,[r0,#0x2a]
0008d0  4926              LDR      r1,|L10.2412|
0008d2  e000              B        |L10.2262|
                  |L10.2260|
0008d4  e2c6              B        |L10.3684|
                  |L10.2262|
0008d6  7809              LDRB     r1,[r1,#0]  ; uip_acc32
0008d8  4288              CMP      r0,r1
0008da  d10a              BNE      |L10.2290|
;;;1426          BUF->ackno[1] == uip_acc32[1] &&
0008dc  4806              LDR      r0,|L10.2296|
0008de  f890002b          LDRB     r0,[r0,#0x2b]
0008e2  4922              LDR      r1,|L10.2412|
0008e4  7849              LDRB     r1,[r1,#1]  ; uip_acc32
0008e6  4288              CMP      r0,r1
0008e8  d17e              BNE      |L10.2536|
;;;1427          BUF->ackno[2] == uip_acc32[2] &&
0008ea  4803              LDR      r0,|L10.2296|
0008ec  e040              B        |L10.2416|
                  |L10.2286|
0008ee  e20b              B        |L10.3336|
                  |L10.2288|
0008f0  e16c              B        |L10.3020|
                  |L10.2290|
0008f2  e079              B        |L10.2536|
                  |L10.2292|
                          DCD      uip_stat
                  |L10.2296|
                          DCD      uip_buf
                  |L10.2300|
                          DCD      uip_len
                  |L10.2304|
                          DCD      c
                  |L10.2308|
                          DCD      tmp16
                  |L10.2312|
                          DCD      uip_hostaddr
                  |L10.2316|
                          DCD      uip_conns
                  |L10.2320|
000910  7463703a          DCB      "tcp: found no unused connections.",0
000914  20666f75
000918  6e64206e
00091c  6f20756e
000920  75736564
000924  20636f6e
000928  6e656374
00092c  696f6e73
000930  2e00    
000932  00                DCB      0
000933  00                DCB      0
                  |L10.2356|
                          DCD      uip_conn
                  |L10.2360|
                          DCD      iss
                  |L10.2364|
                          DCD      opt
                  |L10.2368|
                          DCD      uip_flags
                  |L10.2372|
000944  7463703a          DCB      "tcp: got reset, aborting connection.",0
000948  20676f74
00094c  20726573
000950  65742c20
000954  61626f72
000958  74696e67
00095c  20636f6e
000960  6e656374
000964  696f6e2e
000968  00      
000969  00                DCB      0
00096a  00                DCB      0
00096b  00                DCB      0
                  |L10.2412|
                          DCD      uip_acc32
                  |L10.2416|
000970  f890002c          LDRB     r0,[r0,#0x2c]
000974  49fc              LDR      r1,|L10.3432|
000976  7889              LDRB     r1,[r1,#2]  ; uip_acc32
000978  4288              CMP      r0,r1
00097a  d135              BNE      |L10.2536|
;;;1428          BUF->ackno[3] == uip_acc32[3]) {
00097c  48fb              LDR      r0,|L10.3436|
00097e  f890002d          LDRB     r0,[r0,#0x2d]
000982  49f9              LDR      r1,|L10.3432|
000984  78c9              LDRB     r1,[r1,#3]  ; uip_acc32
000986  4288              CMP      r0,r1
000988  d12e              BNE      |L10.2536|
;;;1429         /* Update sequence number. */
;;;1430         uip_connr->snd_nxt[0] = uip_acc32[0];
00098a  48f7              LDR      r0,|L10.3432|
00098c  7800              LDRB     r0,[r0,#0]  ; uip_acc32
00098e  7320              STRB     r0,[r4,#0xc]
;;;1431         uip_connr->snd_nxt[1] = uip_acc32[1];
000990  48f5              LDR      r0,|L10.3432|
000992  7841              LDRB     r1,[r0,#1]  ; uip_acc32
000994  7361              STRB     r1,[r4,#0xd]
;;;1432         uip_connr->snd_nxt[2] = uip_acc32[2];
000996  7881              LDRB     r1,[r0,#2]  ; uip_acc32
000998  73a1              STRB     r1,[r4,#0xe]
;;;1433         uip_connr->snd_nxt[3] = uip_acc32[3];
00099a  78c1              LDRB     r1,[r0,#3]  ; uip_acc32
00099c  73e1              STRB     r1,[r4,#0xf]
;;;1434   	
;;;1435   
;;;1436         /* Do RTT estimation, unless we have done retransmissions. */
;;;1437         if(uip_connr->nrtx == 0) {
00099e  7ee0              LDRB     r0,[r4,#0x1b]
0009a0  b9d8              CBNZ     r0,|L10.2522|
;;;1438   	signed char m;
;;;1439   	m = uip_connr->rto - uip_connr->timer;
0009a2  7e21              LDRB     r1,[r4,#0x18]
0009a4  7ea2              LDRB     r2,[r4,#0x1a]
0009a6  1a89              SUBS     r1,r1,r2
0009a8  b248              SXTB     r0,r1
;;;1440   	/* This is taken directly from VJs original code in his paper */
;;;1441   	m = m - (uip_connr->sa >> 3);
0009aa  7da1              LDRB     r1,[r4,#0x16]
0009ac  eba001e1          SUB      r1,r0,r1,ASR #3
0009b0  b248              SXTB     r0,r1
;;;1442   	uip_connr->sa += m;
0009b2  7da1              LDRB     r1,[r4,#0x16]
0009b4  4401              ADD      r1,r1,r0
0009b6  75a1              STRB     r1,[r4,#0x16]
;;;1443   	if(m < 0) {
0009b8  2800              CMP      r0,#0
0009ba  da01              BGE      |L10.2496|
;;;1444   	  m = -m;
0009bc  4241              RSBS     r1,r0,#0
0009be  b248              SXTB     r0,r1
                  |L10.2496|
;;;1445   	}
;;;1446   	m = m - (uip_connr->sv >> 2);
0009c0  7de1              LDRB     r1,[r4,#0x17]
0009c2  eba001a1          SUB      r1,r0,r1,ASR #2
0009c6  b248              SXTB     r0,r1
;;;1447   	uip_connr->sv += m;
0009c8  7de1              LDRB     r1,[r4,#0x17]
0009ca  4401              ADD      r1,r1,r0
0009cc  75e1              STRB     r1,[r4,#0x17]
;;;1448   	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
0009ce  7de1              LDRB     r1,[r4,#0x17]
0009d0  7da2              LDRB     r2,[r4,#0x16]
0009d2  eb0101e2          ADD      r1,r1,r2,ASR #3
0009d6  7621              STRB     r1,[r4,#0x18]
;;;1449   
;;;1450         }
0009d8  bf00              NOP      
                  |L10.2522|
;;;1451         /* Set the acknowledged flag. */
;;;1452         uip_flags = UIP_ACKDATA;
0009da  2001              MOVS     r0,#1
0009dc  49e4              LDR      r1,|L10.3440|
0009de  7008              STRB     r0,[r1,#0]
;;;1453         /* Reset the retransmission timer. */
;;;1454         uip_connr->timer = uip_connr->rto;
0009e0  7e20              LDRB     r0,[r4,#0x18]
0009e2  76a0              STRB     r0,[r4,#0x1a]
;;;1455   
;;;1456         /* Reset length of outstanding data. */
;;;1457         uip_connr->len = 0;
0009e4  2000              MOVS     r0,#0
0009e6  8220              STRH     r0,[r4,#0x10]
                  |L10.2536|
;;;1458       }
;;;1459       
;;;1460     }
;;;1461   
;;;1462     /* Do different things depending on in what state the connection is. */
;;;1463     switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
0009e8  7e60              LDRB     r0,[r4,#0x19]
0009ea  f000000f          AND      r0,r0,#0xf
0009ee  2809              CMP      r0,#9
0009f0  d26b              BCS      |L10.2762|
0009f2  e8dff000          TBB      [pc,r0]
0009f6  6a05              DCB      0x6a,0x05
0009f8  25c0f4f3          DCB      0x25,0xc0,0xf4,0xf3
0009fc  f2f1f000          DCB      0xf2,0xf1,0xf0,0x00
;;;1464       /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
;;;1465   	implemented, since we force the application to close when the
;;;1466   	peer sends a FIN (hence the application goes directly from
;;;1467   	ESTABLISHED to LAST_ACK). */
;;;1468     case UIP_SYN_RCVD:
;;;1469       /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
;;;1470          we are waiting for an ACK that acknowledges the data we sent
;;;1471          out the last time. Therefore, we want to have the UIP_ACKDATA
;;;1472          flag set. If so, we enter the ESTABLISHED state. */
;;;1473       if(uip_flags & UIP_ACKDATA) {
000a00  48db              LDR      r0,|L10.3440|
000a02  7800              LDRB     r0,[r0,#0]  ; uip_flags
000a04  f0000001          AND      r0,r0,#1
000a08  b1c8              CBZ      r0,|L10.2622|
;;;1474         uip_connr->tcpstateflags = UIP_ESTABLISHED;
000a0a  2003              MOVS     r0,#3
000a0c  7660              STRB     r0,[r4,#0x19]
;;;1475         uip_flags = UIP_CONNECTED;
000a0e  2040              MOVS     r0,#0x40
000a10  49d7              LDR      r1,|L10.3440|
000a12  7008              STRB     r0,[r1,#0]
;;;1476         uip_connr->len = 0;
000a14  2000              MOVS     r0,#0
000a16  8220              STRH     r0,[r4,#0x10]
;;;1477         if(uip_len > 0) {
000a18  48d6              LDR      r0,|L10.3444|
000a1a  8800              LDRH     r0,[r0,#0]  ; uip_len
000a1c  2800              CMP      r0,#0
000a1e  dd08              BLE      |L10.2610|
;;;1478           uip_flags |= UIP_NEWDATA;
000a20  4608              MOV      r0,r1
000a22  7800              LDRB     r0,[r0,#0]  ; uip_flags
000a24  f0400002          ORR      r0,r0,#2
000a28  7008              STRB     r0,[r1,#0]
;;;1479           uip_add_rcv_nxt(uip_len);
000a2a  48d2              LDR      r0,|L10.3444|
000a2c  8800              LDRH     r0,[r0,#0]  ; uip_len
000a2e  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.2610|
;;;1480         }
;;;1481         uip_slen = 0;
000a32  2000              MOVS     r0,#0
000a34  49d0              LDR      r1,|L10.3448|
000a36  8008              STRH     r0,[r1,#0]
;;;1482         UIP_APPCALL();
000a38  f7fffffe          BL       tcp_demo_appcall
;;;1483         goto appsend;
000a3c  e122              B        |L10.3204|
                  |L10.2622|
;;;1484       }
;;;1485       goto drop;
000a3e  e2a2              B        |L10.3974|
;;;1486   #if UIP_ACTIVE_OPEN
;;;1487     case UIP_SYN_SENT:
;;;1488       /* In SYN_SENT, we wait for a SYNACK that is sent in response to
;;;1489          our SYN. The rcv_nxt is set to sequence number in the SYNACK
;;;1490          plus one, and we send an ACK. We move into the ESTABLISHED
;;;1491          state. */
;;;1492       if((uip_flags & UIP_ACKDATA) &&
000a40  48cb              LDR      r0,|L10.3440|
000a42  7800              LDRB     r0,[r0,#0]  ; uip_flags
000a44  f0000001          AND      r0,r0,#1
000a48  b3f0              CBZ      r0,|L10.2760|
;;;1493          (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
000a4a  48c8              LDR      r0,|L10.3436|
000a4c  f890002f          LDRB     r0,[r0,#0x2f]
000a50  f000003f          AND      r0,r0,#0x3f
000a54  2812              CMP      r0,#0x12
000a56  d137              BNE      |L10.2760|
;;;1494   
;;;1495         /* Parse the TCP MSS option, if present. */
;;;1496         if((BUF->tcpoffset & 0xf0) > 0x50) {
000a58  48c4              LDR      r0,|L10.3436|
000a5a  f890002e          LDRB     r0,[r0,#0x2e]
000a5e  f00000f0          AND      r0,r0,#0xf0
000a62  2850              CMP      r0,#0x50
000a64  dd5e              BLE      |L10.2852|
;;;1497   	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
000a66  2000              MOVS     r0,#0
000a68  49c4              LDR      r1,|L10.3452|
000a6a  7008              STRB     r0,[r1,#0]
000a6c  e04e              B        |L10.2828|
                  |L10.2670|
;;;1498   	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
000a6e  48c3              LDR      r0,|L10.3452|
000a70  7800              LDRB     r0,[r0,#0]  ; c
000a72  3036              ADDS     r0,r0,#0x36
000a74  49bd              LDR      r1,|L10.3436|
000a76  5c08              LDRB     r0,[r1,r0]
000a78  49c1              LDR      r1,|L10.3456|
000a7a  7008              STRB     r0,[r1,#0]
;;;1499   	  if(opt == TCP_OPT_END) {
000a7c  4608              MOV      r0,r1
000a7e  7800              LDRB     r0,[r0,#0]  ; opt
000a80  b900              CBNZ     r0,|L10.2692|
;;;1500   	    /* End of options. */
;;;1501   	    break;
000a82  e04e              B        |L10.2850|
                  |L10.2692|
;;;1502   	  } else if(opt == TCP_OPT_NOOP) {
000a84  48be              LDR      r0,|L10.3456|
000a86  7800              LDRB     r0,[r0,#0]  ; opt
000a88  2801              CMP      r0,#1
000a8a  d105              BNE      |L10.2712|
;;;1503   	    ++c;
000a8c  48bb              LDR      r0,|L10.3452|
000a8e  7800              LDRB     r0,[r0,#0]  ; c
000a90  1c40              ADDS     r0,r0,#1
000a92  49ba              LDR      r1,|L10.3452|
000a94  7008              STRB     r0,[r1,#0]
000a96  e039              B        |L10.2828|
                  |L10.2712|
;;;1504   	    /* NOP option. */
;;;1505   	  } else if(opt == TCP_OPT_MSS &&
000a98  48b9              LDR      r0,|L10.3456|
000a9a  7800              LDRB     r0,[r0,#0]  ; opt
000a9c  2802              CMP      r0,#2
000a9e  d123              BNE      |L10.2792|
;;;1506   		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
000aa0  48b6              LDR      r0,|L10.3452|
000aa2  7800              LDRB     r0,[r0,#0]  ; c
000aa4  3037              ADDS     r0,r0,#0x37
000aa6  49b1              LDR      r1,|L10.3436|
000aa8  5c08              LDRB     r0,[r1,r0]
000aaa  2804              CMP      r0,#4
000aac  d11c              BNE      |L10.2792|
;;;1507   	    /* An MSS option with the right option length. */
;;;1508   	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
000aae  48b3              LDR      r0,|L10.3452|
000ab0  7800              LDRB     r0,[r0,#0]  ; c
000ab2  3039              ADDS     r0,r0,#0x39
000ab4  5c09              LDRB     r1,[r1,r0]
000ab6  48b1              LDR      r0,|L10.3452|
000ab8  7800              LDRB     r0,[r0,#0]  ; c
000aba  3038              ADDS     r0,r0,#0x38
000abc  4aab              LDR      r2,|L10.3436|
000abe  5c10              LDRB     r0,[r2,r0]
000ac0  ea412000          ORR      r0,r1,r0,LSL #8
000ac4  49af              LDR      r1,|L10.3460|
000ac6  e001              B        |L10.2764|
                  |L10.2760|
000ac8  e04b              B        |L10.2914|
                  |L10.2762|
000aca  e1c4              B        |L10.3670|
                  |L10.2764|
000acc  8008              STRH     r0,[r1,#0]
;;;1509   	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
;;;1510   	    uip_connr->initialmss =
000ace  4608              MOV      r0,r1
000ad0  8800              LDRH     r0,[r0,#0]  ; tmp16
000ad2  f64071ca          MOV      r1,#0xfca
000ad6  4288              CMP      r0,r1
000ad8  dd01              BLE      |L10.2782|
;;;1511   	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
000ada  4608              MOV      r0,r1
000adc  e001              B        |L10.2786|
                  |L10.2782|
000ade  48a9              LDR      r0,|L10.3460|
000ae0  8800              LDRH     r0,[r0,#0]  ; tmp16
                  |L10.2786|
000ae2  8260              STRH     r0,[r4,#0x12]
000ae4  82a0              STRH     r0,[r4,#0x14]
;;;1512   
;;;1513   	    /* And we are done processing options. */
;;;1514   	    break;
000ae6  e01c              B        |L10.2850|
                  |L10.2792|
;;;1515   	  } else {
;;;1516   	    /* All other options have a length field, so that we easily
;;;1517   	       can skip past them. */
;;;1518   	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
000ae8  48a4              LDR      r0,|L10.3452|
000aea  7800              LDRB     r0,[r0,#0]  ; c
000aec  3037              ADDS     r0,r0,#0x37
000aee  499f              LDR      r1,|L10.3436|
000af0  5c08              LDRB     r0,[r1,r0]
000af2  b908              CBNZ     r0,|L10.2808|
;;;1519   	      /* If the length field is zero, the options are malformed
;;;1520   		 and we don't process them further. */
;;;1521   	      break;
000af4  e015              B        |L10.2850|
                  |L10.2806|
000af6  e23d              B        |L10.3956|
                  |L10.2808|
;;;1522   	    }
;;;1523   	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
000af8  48a0              LDR      r0,|L10.3452|
000afa  7800              LDRB     r0,[r0,#0]  ; c
000afc  3037              ADDS     r0,r0,#0x37
000afe  499b              LDR      r1,|L10.3436|
000b00  5c08              LDRB     r0,[r1,r0]
000b02  499e              LDR      r1,|L10.3452|
000b04  7809              LDRB     r1,[r1,#0]  ; c
000b06  4408              ADD      r0,r0,r1
000b08  499c              LDR      r1,|L10.3452|
000b0a  7008              STRB     r0,[r1,#0]
                  |L10.2828|
000b0c  4897              LDR      r0,|L10.3436|
000b0e  f890002e          LDRB     r0,[r0,#0x2e]         ;1497
000b12  2105              MOVS     r1,#5                 ;1497
000b14  ebc11020          RSB      r0,r1,r0,ASR #4       ;1497
000b18  4998              LDR      r1,|L10.3452|
000b1a  7809              LDRB     r1,[r1,#0]            ;1497  ; c
000b1c  ebb10f80          CMP      r1,r0,LSL #2          ;1497
000b20  dba5              BLT      |L10.2670|
                  |L10.2850|
000b22  bf00              NOP                            ;1501
                  |L10.2852|
;;;1524   	  }
;;;1525   	}
;;;1526         }
;;;1527         uip_connr->tcpstateflags = UIP_ESTABLISHED;
000b24  2003              MOVS     r0,#3
000b26  7660              STRB     r0,[r4,#0x19]
;;;1528         uip_connr->rcv_nxt[0] = BUF->seqno[0];
000b28  4890              LDR      r0,|L10.3436|
000b2a  f8900026          LDRB     r0,[r0,#0x26]
000b2e  7220              STRB     r0,[r4,#8]
;;;1529         uip_connr->rcv_nxt[1] = BUF->seqno[1];
000b30  488e              LDR      r0,|L10.3436|
000b32  f8901027          LDRB     r1,[r0,#0x27]
000b36  7261              STRB     r1,[r4,#9]
;;;1530         uip_connr->rcv_nxt[2] = BUF->seqno[2];
000b38  f8901028          LDRB     r1,[r0,#0x28]
000b3c  72a1              STRB     r1,[r4,#0xa]
;;;1531         uip_connr->rcv_nxt[3] = BUF->seqno[3];
000b3e  f8901029          LDRB     r1,[r0,#0x29]
000b42  72e1              STRB     r1,[r4,#0xb]
;;;1532         uip_add_rcv_nxt(1);
000b44  2001              MOVS     r0,#1
000b46  f7fffffe          BL       uip_add_rcv_nxt
;;;1533         uip_flags = UIP_CONNECTED | UIP_NEWDATA;
000b4a  2042              MOVS     r0,#0x42
000b4c  4988              LDR      r1,|L10.3440|
000b4e  7008              STRB     r0,[r1,#0]
;;;1534         uip_connr->len = 0;
000b50  2000              MOVS     r0,#0
000b52  8220              STRH     r0,[r4,#0x10]
;;;1535         uip_len = 0;
000b54  4987              LDR      r1,|L10.3444|
000b56  8008              STRH     r0,[r1,#0]
;;;1536         uip_slen = 0;
000b58  4987              LDR      r1,|L10.3448|
000b5a  8008              STRH     r0,[r1,#0]
;;;1537         UIP_APPCALL();
000b5c  f7fffffe          BL       tcp_demo_appcall
;;;1538         goto appsend;
000b60  e090              B        |L10.3204|
                  |L10.2914|
;;;1539       }
;;;1540       /* Inform the application that the connection failed */
;;;1541       uip_flags = UIP_ABORT;
000b62  2020              MOVS     r0,#0x20
000b64  4982              LDR      r1,|L10.3440|
000b66  7008              STRB     r0,[r1,#0]
;;;1542       UIP_APPCALL();
000b68  f7fffffe          BL       tcp_demo_appcall
;;;1543       /* The connection is closed after we send the RST */
;;;1544       uip_conn->tcpstateflags = UIP_CLOSED;
000b6c  2000              MOVS     r0,#0
000b6e  4986              LDR      r1,|L10.3464|
000b70  6809              LDR      r1,[r1,#0]  ; uip_conn
000b72  7648              STRB     r0,[r1,#0x19]
;;;1545       goto reset;
000b74  e432              B        |L10.988|
;;;1546   #endif /* UIP_ACTIVE_OPEN */
;;;1547       
;;;1548     case UIP_ESTABLISHED:
;;;1549       /* In the ESTABLISHED state, we call upon the application to feed
;;;1550       data into the uip_buf. If the UIP_ACKDATA flag is set, the
;;;1551       application should put new data into the buffer, otherwise we are
;;;1552       retransmitting an old segment, and the application should put that
;;;1553       data into the buffer.
;;;1554   
;;;1555       If the incoming packet is a FIN, we should close the connection on
;;;1556       this side as well, and we send out a FIN and enter the LAST_ACK
;;;1557       state. We require that there is no outstanding data; otherwise the
;;;1558       sequence numbers will be screwed up. */
;;;1559   
;;;1560       if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
000b76  487d              LDR      r0,|L10.3436|
000b78  f890002f          LDRB     r0,[r0,#0x2f]
000b7c  f0000001          AND      r0,r0,#1
000b80  b370              CBZ      r0,|L10.3040|
000b82  7e60              LDRB     r0,[r4,#0x19]
000b84  f0000010          AND      r0,r0,#0x10
000b88  bb50              CBNZ     r0,|L10.3040|
;;;1561         if(uip_outstanding(uip_connr)) {
000b8a  8a20              LDRH     r0,[r4,#0x10]
000b8c  b100              CBZ      r0,|L10.2960|
;;;1562   	goto drop;
000b8e  e1fa              B        |L10.3974|
                  |L10.2960|
;;;1563         }
;;;1564         uip_add_rcv_nxt(1 + uip_len);
000b90  4978              LDR      r1,|L10.3444|
000b92  8809              LDRH     r1,[r1,#0]  ; uip_len
000b94  1c49              ADDS     r1,r1,#1
000b96  b288              UXTH     r0,r1
000b98  f7fffffe          BL       uip_add_rcv_nxt
;;;1565         uip_flags |= UIP_CLOSE;
000b9c  4874              LDR      r0,|L10.3440|
000b9e  7800              LDRB     r0,[r0,#0]  ; uip_flags
000ba0  f0400010          ORR      r0,r0,#0x10
000ba4  4972              LDR      r1,|L10.3440|
000ba6  7008              STRB     r0,[r1,#0]
;;;1566         if(uip_len > 0) {
000ba8  4872              LDR      r0,|L10.3444|
000baa  8800              LDRH     r0,[r0,#0]  ; uip_len
000bac  2800              CMP      r0,#0
000bae  dd04              BLE      |L10.3002|
;;;1567   	uip_flags |= UIP_NEWDATA;
000bb0  4608              MOV      r0,r1
000bb2  7800              LDRB     r0,[r0,#0]  ; uip_flags
000bb4  f0400002          ORR      r0,r0,#2
000bb8  7008              STRB     r0,[r1,#0]
                  |L10.3002|
;;;1568         }
;;;1569         UIP_APPCALL();
000bba  f7fffffe          BL       tcp_demo_appcall
;;;1570         uip_connr->len = 1;
000bbe  2001              MOVS     r0,#1
000bc0  8220              STRH     r0,[r4,#0x10]
;;;1571         uip_connr->tcpstateflags = UIP_LAST_ACK;
000bc2  2008              MOVS     r0,#8
000bc4  7660              STRB     r0,[r4,#0x19]
;;;1572         uip_connr->nrtx = 0;
000bc6  2000              MOVS     r0,#0
000bc8  76e0              STRB     r0,[r4,#0x1b]
;;;1573       tcp_send_finack:
000bca  bf00              NOP      
                  |L10.3020|
;;;1574         BUF->flags = TCP_FIN | TCP_ACK;
000bcc  2111              MOVS     r1,#0x11
000bce  4867              LDR      r0,|L10.3436|
000bd0  f880102f          STRB     r1,[r0,#0x2f]
;;;1575         goto tcp_send_nodata;
000bd4  e146              B        |L10.3684|
000bd6  e0b9              B        |L10.3404|
000bd8  e132              B        |L10.3648|
000bda  e132              B        |L10.3650|
000bdc  e10f              B        |L10.3582|
000bde  e0d9              B        |L10.3476|
                  |L10.3040|
000be0  e7ff              B        |L10.3042|
                  |L10.3042|
;;;1576       }
;;;1577   
;;;1578       /* Check the URG flag. If this is set, the segment carries urgent
;;;1579          data that we must pass to the application. */
;;;1580       if((BUF->flags & TCP_URG) != 0) {
000be2  4862              LDR      r0,|L10.3436|
000be4  f890002f          LDRB     r0,[r0,#0x2f]
000be8  f0000020          AND      r0,r0,#0x20
000bec  b1b8              CBZ      r0,|L10.3102|
;;;1581   #if UIP_URGDATA > 0
;;;1582         uip_urglen = (BUF->urgp[0] << 8) | BUF->urgp[1];
;;;1583         if(uip_urglen > uip_len) {
;;;1584   	/* There is more urgent data in the next segment to come. */
;;;1585   	uip_urglen = uip_len;
;;;1586         }
;;;1587         uip_add_rcv_nxt(uip_urglen);
;;;1588         uip_len -= uip_urglen;
;;;1589         uip_urgdata = uip_appdata;
;;;1590         uip_appdata += uip_urglen;
;;;1591       } else {
;;;1592         uip_urglen = 0;
;;;1593   #else /* UIP_URGDATA > 0 */
;;;1594         uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
000bee  485f              LDR      r0,|L10.3436|
000bf0  f8901035          LDRB     r1,[r0,#0x35]
000bf4  f8900034          LDRB     r0,[r0,#0x34]
000bf8  ea412000          ORR      r0,r1,r0,LSL #8
000bfc  4963              LDR      r1,|L10.3468|
000bfe  6809              LDR      r1,[r1,#0]  ; uip_appdata
000c00  4408              ADD      r0,r0,r1
000c02  4962              LDR      r1,|L10.3468|
000c04  6008              STR      r0,[r1,#0]  ; uip_appdata
;;;1595         uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
000c06  4859              LDR      r0,|L10.3436|
000c08  f8901035          LDRB     r1,[r0,#0x35]
000c0c  f8900034          LDRB     r0,[r0,#0x34]
000c10  ea412000          ORR      r0,r1,r0,LSL #8
000c14  4957              LDR      r1,|L10.3444|
000c16  8809              LDRH     r1,[r1,#0]  ; uip_len
000c18  1a08              SUBS     r0,r1,r0
000c1a  4956              LDR      r1,|L10.3444|
000c1c  8008              STRH     r0,[r1,#0]
                  |L10.3102|
;;;1596   #endif /* UIP_URGDATA > 0 */
;;;1597       }
;;;1598   
;;;1599       /* If uip_len > 0 we have TCP data in the packet, and we flag this
;;;1600          by setting the UIP_NEWDATA flag and update the sequence number
;;;1601          we acknowledge. If the application has stopped the dataflow
;;;1602          using uip_stop(), we must not accept any data packets from the
;;;1603          remote host. */
;;;1604       if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
000c1e  4855              LDR      r0,|L10.3444|
000c20  8800              LDRH     r0,[r0,#0]  ; uip_len
000c22  2800              CMP      r0,#0
000c24  dd0d              BLE      |L10.3138|
000c26  7e60              LDRB     r0,[r4,#0x19]
000c28  f0000010          AND      r0,r0,#0x10
000c2c  b948              CBNZ     r0,|L10.3138|
;;;1605         uip_flags |= UIP_NEWDATA;
000c2e  4850              LDR      r0,|L10.3440|
000c30  7800              LDRB     r0,[r0,#0]  ; uip_flags
000c32  f0400002          ORR      r0,r0,#2
000c36  494e              LDR      r1,|L10.3440|
000c38  7008              STRB     r0,[r1,#0]
;;;1606         uip_add_rcv_nxt(uip_len);
000c3a  484e              LDR      r0,|L10.3444|
000c3c  8800              LDRH     r0,[r0,#0]  ; uip_len
000c3e  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.3138|
;;;1607       }
;;;1608   
;;;1609       /* Check if the available buffer space advertised by the other end
;;;1610          is smaller than the initial MSS for this connection. If so, we
;;;1611          set the current MSS to the window size to ensure that the
;;;1612          application does not send more data than the other end can
;;;1613          handle.
;;;1614   
;;;1615          If the remote host advertises a zero window, we set the MSS to
;;;1616          the initial MSS so that the application will send an entire MSS
;;;1617          of data. This data will not be acknowledged by the receiver,
;;;1618          and the application will retransmit it. This is called the
;;;1619          "persistent timer" and uses the retransmission mechanim.
;;;1620       */
;;;1621       tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
000c42  484a              LDR      r0,|L10.3436|
000c44  f8901031          LDRB     r1,[r0,#0x31]
000c48  f8900030          LDRB     r0,[r0,#0x30]
000c4c  eb012000          ADD      r0,r1,r0,LSL #8
000c50  494c              LDR      r1,|L10.3460|
000c52  8008              STRH     r0,[r1,#0]
;;;1622       if(tmp16 > uip_connr->initialmss ||
000c54  8aa0              LDRH     r0,[r4,#0x14]
000c56  8809              LDRH     r1,[r1,#0]  ; tmp16
000c58  4288              CMP      r0,r1
000c5a  db02              BLT      |L10.3170|
;;;1623          tmp16 == 0) {
000c5c  4849              LDR      r0,|L10.3460|
000c5e  8800              LDRH     r0,[r0,#0]  ; tmp16
000c60  b910              CBNZ     r0,|L10.3176|
                  |L10.3170|
;;;1624         tmp16 = uip_connr->initialmss;
000c62  8aa0              LDRH     r0,[r4,#0x14]
000c64  4947              LDR      r1,|L10.3460|
000c66  8008              STRH     r0,[r1,#0]
                  |L10.3176|
;;;1625       }
;;;1626       uip_connr->mss = tmp16;
000c68  4846              LDR      r0,|L10.3460|
000c6a  8800              LDRH     r0,[r0,#0]  ; tmp16
000c6c  8260              STRH     r0,[r4,#0x12]
;;;1627   
;;;1628       /* If this packet constitutes an ACK for outstanding data (flagged
;;;1629          by the UIP_ACKDATA flag, we should call the application since it
;;;1630          might want to send more data. If the incoming packet had data
;;;1631          from the peer (as flagged by the UIP_NEWDATA flag), the
;;;1632          application must also be notified.
;;;1633   
;;;1634          When the application is called, the global variable uip_len
;;;1635          contains the length of the incoming data. The application can
;;;1636          access the incoming data through the global pointer
;;;1637          uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN
;;;1638          bytes into the uip_buf array.
;;;1639   
;;;1640          If the application wishes to send any data, this data should be
;;;1641          put into the uip_appdata and the length of the data should be
;;;1642          put into uip_len. If the application don't have any data to
;;;1643          send, uip_len must be set to 0. */
;;;1644       if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
000c6e  4840              LDR      r0,|L10.3440|
000c70  7800              LDRB     r0,[r0,#0]  ; uip_flags
000c72  f0000003          AND      r0,r0,#3
000c76  b3e8              CBZ      r0,|L10.3316|
;;;1645         uip_slen = 0;
000c78  2000              MOVS     r0,#0
000c7a  493f              LDR      r1,|L10.3448|
000c7c  8008              STRH     r0,[r1,#0]
;;;1646         UIP_APPCALL();
000c7e  f7fffffe          BL       tcp_demo_appcall
;;;1647   
;;;1648       appsend:
000c82  bf00              NOP      
                  |L10.3204|
;;;1649         
;;;1650         if(uip_flags & UIP_ABORT) {
000c84  483a              LDR      r0,|L10.3440|
000c86  7800              LDRB     r0,[r0,#0]  ; uip_flags
000c88  f0000020          AND      r0,r0,#0x20
000c8c  b140              CBZ      r0,|L10.3232|
;;;1651   	uip_slen = 0;
000c8e  2000              MOVS     r0,#0
000c90  4939              LDR      r1,|L10.3448|
000c92  8008              STRH     r0,[r1,#0]
;;;1652   	uip_connr->tcpstateflags = UIP_CLOSED;
000c94  7660              STRB     r0,[r4,#0x19]
;;;1653   	BUF->flags = TCP_RST | TCP_ACK;
000c96  2114              MOVS     r1,#0x14
000c98  4834              LDR      r0,|L10.3436|
000c9a  f880102f          STRB     r1,[r0,#0x2f]
;;;1654   	goto tcp_send_nodata;
000c9e  e0e1              B        |L10.3684|
                  |L10.3232|
;;;1655         }
;;;1656   
;;;1657         if(uip_flags & UIP_CLOSE) {
000ca0  4833              LDR      r0,|L10.3440|
000ca2  7800              LDRB     r0,[r0,#0]  ; uip_flags
000ca4  f0000010          AND      r0,r0,#0x10
000ca8  b168              CBZ      r0,|L10.3270|
;;;1658   	uip_slen = 0;
000caa  2000              MOVS     r0,#0
000cac  4932              LDR      r1,|L10.3448|
000cae  8008              STRH     r0,[r1,#0]
;;;1659   	uip_connr->len = 1;
000cb0  2001              MOVS     r0,#1
000cb2  8220              STRH     r0,[r4,#0x10]
;;;1660   	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
000cb4  2004              MOVS     r0,#4
000cb6  7660              STRB     r0,[r4,#0x19]
;;;1661   	uip_connr->nrtx = 0;
000cb8  2000              MOVS     r0,#0
000cba  76e0              STRB     r0,[r4,#0x1b]
;;;1662   	BUF->flags = TCP_FIN | TCP_ACK;
000cbc  2111              MOVS     r1,#0x11
000cbe  482b              LDR      r0,|L10.3436|
000cc0  f880102f          STRB     r1,[r0,#0x2f]
;;;1663   	goto tcp_send_nodata;
000cc4  e0ce              B        |L10.3684|
                  |L10.3270|
;;;1664         }
;;;1665   
;;;1666         /* If uip_slen > 0, the application has data to be sent. */
;;;1667         if(uip_slen > 0) {
000cc6  482c              LDR      r0,|L10.3448|
000cc8  8800              LDRH     r0,[r0,#0]  ; uip_slen
000cca  2800              CMP      r0,#0
000ccc  dd19              BLE      |L10.3330|
;;;1668   
;;;1669   	/* If the connection has acknowledged data, the contents of
;;;1670   	   the ->len variable should be discarded. */
;;;1671   	if((uip_flags & UIP_ACKDATA) != 0) {
000cce  4828              LDR      r0,|L10.3440|
000cd0  7800              LDRB     r0,[r0,#0]  ; uip_flags
000cd2  f0000001          AND      r0,r0,#1
000cd6  b108              CBZ      r0,|L10.3292|
;;;1672   	  uip_connr->len = 0;
000cd8  2000              MOVS     r0,#0
000cda  8220              STRH     r0,[r4,#0x10]
                  |L10.3292|
;;;1673   	}
;;;1674   
;;;1675   	/* If the ->len variable is non-zero the connection has
;;;1676   	   already data in transit and cannot send anymore right
;;;1677   	   now. */
;;;1678   	if(uip_connr->len == 0) {
000cdc  8a20              LDRH     r0,[r4,#0x10]
000cde  b968              CBNZ     r0,|L10.3324|
;;;1679   
;;;1680   	  /* The application cannot send more than what is allowed by
;;;1681   	     the mss (the minumum of the MSS and the available
;;;1682   	     window). */
;;;1683   	  if(uip_slen > uip_connr->mss) {
000ce0  8a60              LDRH     r0,[r4,#0x12]
000ce2  4925              LDR      r1,|L10.3448|
000ce4  8809              LDRH     r1,[r1,#0]  ; uip_slen
000ce6  4288              CMP      r0,r1
000ce8  da02              BGE      |L10.3312|
;;;1684   	    uip_slen = uip_connr->mss;
000cea  8a60              LDRH     r0,[r4,#0x12]
000cec  4922              LDR      r1,|L10.3448|
000cee  8008              STRH     r0,[r1,#0]
                  |L10.3312|
;;;1685   	  }
;;;1686   
;;;1687   	  /* Remember how much data we send out now so that we know
;;;1688   	     when everything has been acknowledged. */
;;;1689   	  uip_connr->len = uip_slen;
000cf0  4821              LDR      r0,|L10.3448|
000cf2  e000              B        |L10.3318|
                  |L10.3316|
000cf4  e029              B        |L10.3402|
                  |L10.3318|
000cf6  8800              LDRH     r0,[r0,#0]  ; uip_slen
000cf8  8220              STRH     r0,[r4,#0x10]
000cfa  e002              B        |L10.3330|
                  |L10.3324|
;;;1690   	} else {
;;;1691   
;;;1692   	  /* If the application already had unacknowledged data, we
;;;1693   	     make sure that the application does not send (i.e.,
;;;1694   	     retransmit) out more than it previously sent out. */
;;;1695   	  uip_slen = uip_connr->len;
000cfc  8a20              LDRH     r0,[r4,#0x10]
000cfe  491e              LDR      r1,|L10.3448|
000d00  8008              STRH     r0,[r1,#0]
                  |L10.3330|
;;;1696   	}
;;;1697         }
;;;1698         uip_connr->nrtx = 0;
000d02  2000              MOVS     r0,#0
000d04  76e0              STRB     r0,[r4,#0x1b]
;;;1699       apprexmit:
000d06  bf00              NOP      
                  |L10.3336|
;;;1700         uip_appdata = uip_sappdata;
000d08  4821              LDR      r0,|L10.3472|
000d0a  6800              LDR      r0,[r0,#0]  ; uip_sappdata
000d0c  491f              LDR      r1,|L10.3468|
000d0e  6008              STR      r0,[r1,#0]  ; uip_appdata
;;;1701         
;;;1702         /* If the application has data to be sent, or if the incoming
;;;1703            packet had new data in it, we must send out a packet. */
;;;1704         if(uip_slen > 0 && uip_connr->len > 0) {
000d10  4819              LDR      r0,|L10.3448|
000d12  8800              LDRH     r0,[r0,#0]  ; uip_slen
000d14  2800              CMP      r0,#0
000d16  dd0b              BLE      |L10.3376|
000d18  8a20              LDRH     r0,[r4,#0x10]
000d1a  2800              CMP      r0,#0
000d1c  dd08              BLE      |L10.3376|
;;;1705   	/* Add the length of the IP and TCP headers. */
;;;1706   	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
000d1e  8a20              LDRH     r0,[r4,#0x10]
000d20  3028              ADDS     r0,r0,#0x28
000d22  4914              LDR      r1,|L10.3444|
000d24  8008              STRH     r0,[r1,#0]
;;;1707   	/* We always set the ACK flag in response packets. */
;;;1708   	BUF->flags = TCP_ACK | TCP_PSH;
000d26  2118              MOVS     r1,#0x18
000d28  4810              LDR      r0,|L10.3436|
000d2a  f880102f          STRB     r1,[r0,#0x2f]
;;;1709   	/* Send the packet. */
;;;1710   	goto tcp_send_noopts;
000d2e  e09d              B        |L10.3692|
                  |L10.3376|
;;;1711         }
;;;1712         /* If there is no data to send, just send out a pure ACK if
;;;1713   	 there is newdata. */
;;;1714         if(uip_flags & UIP_NEWDATA) {
000d30  480f              LDR      r0,|L10.3440|
000d32  7800              LDRB     r0,[r0,#0]  ; uip_flags
000d34  f0000002          AND      r0,r0,#2
000d38  b138              CBZ      r0,|L10.3402|
;;;1715   	uip_len = UIP_TCPIP_HLEN;
000d3a  2028              MOVS     r0,#0x28
000d3c  490d              LDR      r1,|L10.3444|
000d3e  8008              STRH     r0,[r1,#0]
;;;1716   	BUF->flags = TCP_ACK;
000d40  2110              MOVS     r1,#0x10
000d42  480a              LDR      r0,|L10.3436|
000d44  f880102f          STRB     r1,[r0,#0x2f]
;;;1717   	goto tcp_send_noopts;
000d48  e090              B        |L10.3692|
                  |L10.3402|
;;;1718         }
;;;1719       }
;;;1720       goto drop;
000d4a  e11c              B        |L10.3974|
                  |L10.3404|
;;;1721     case UIP_LAST_ACK:
;;;1722       /* We can close this connection if the peer has acknowledged our
;;;1723          FIN. This is indicated by the UIP_ACKDATA flag. */
;;;1724       if(uip_flags & UIP_ACKDATA) {
000d4c  4808              LDR      r0,|L10.3440|
000d4e  7800              LDRB     r0,[r0,#0]  ; uip_flags
000d50  f0000001          AND      r0,r0,#1
000d54  b130              CBZ      r0,|L10.3428|
;;;1725         uip_connr->tcpstateflags = UIP_CLOSED;
000d56  2000              MOVS     r0,#0
000d58  7660              STRB     r0,[r4,#0x19]
;;;1726         uip_flags = UIP_CLOSE;
000d5a  2010              MOVS     r0,#0x10
000d5c  4904              LDR      r1,|L10.3440|
000d5e  7008              STRB     r0,[r1,#0]
;;;1727         UIP_APPCALL();
000d60  f7fffffe          BL       tcp_demo_appcall
                  |L10.3428|
;;;1728       }
;;;1729       break;
000d64  e077              B        |L10.3670|
000d66  0000              DCW      0x0000
                  |L10.3432|
                          DCD      uip_acc32
                  |L10.3436|
                          DCD      uip_buf
                  |L10.3440|
                          DCD      uip_flags
                  |L10.3444|
                          DCD      uip_len
                  |L10.3448|
                          DCD      uip_slen
                  |L10.3452|
                          DCD      c
                  |L10.3456|
                          DCD      opt
                  |L10.3460|
                          DCD      tmp16
                  |L10.3464|
                          DCD      uip_conn
                  |L10.3468|
                          DCD      uip_appdata
                  |L10.3472|
                          DCD      uip_sappdata
                  |L10.3476|
;;;1730       
;;;1731     case UIP_FIN_WAIT_1:
;;;1732       /* The application has closed the connection, but the remote host
;;;1733          hasn't closed its end yet. Thus we do nothing but wait for a
;;;1734          FIN from the other side. */
;;;1735       if(uip_len > 0) {
000d94  487f              LDR      r0,|L10.3988|
000d96  8800              LDRH     r0,[r0,#0]  ; uip_len
000d98  2800              CMP      r0,#0
000d9a  dd03              BLE      |L10.3492|
;;;1736         uip_add_rcv_nxt(uip_len);
000d9c  487d              LDR      r0,|L10.3988|
000d9e  8800              LDRH     r0,[r0,#0]  ; uip_len
000da0  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.3492|
;;;1737       }
;;;1738       if(BUF->flags & TCP_FIN) {
000da4  487c              LDR      r0,|L10.3992|
000da6  f890002f          LDRB     r0,[r0,#0x2f]
000daa  f0000001          AND      r0,r0,#1
000dae  b1a8              CBZ      r0,|L10.3548|
;;;1739         if(uip_flags & UIP_ACKDATA) {
000db0  487a              LDR      r0,|L10.3996|
000db2  7800              LDRB     r0,[r0,#0]  ; uip_flags
000db4  f0000001          AND      r0,r0,#1
000db8  b128              CBZ      r0,|L10.3526|
;;;1740   	uip_connr->tcpstateflags = UIP_TIME_WAIT;
000dba  2007              MOVS     r0,#7
000dbc  7660              STRB     r0,[r4,#0x19]
;;;1741   	uip_connr->timer = 0;
000dbe  2000              MOVS     r0,#0
000dc0  76a0              STRB     r0,[r4,#0x1a]
;;;1742   	uip_connr->len = 0;
000dc2  8220              STRH     r0,[r4,#0x10]
000dc4  e001              B        |L10.3530|
                  |L10.3526|
;;;1743         } else {
;;;1744   	uip_connr->tcpstateflags = UIP_CLOSING;
000dc6  2006              MOVS     r0,#6
000dc8  7660              STRB     r0,[r4,#0x19]
                  |L10.3530|
;;;1745         }
;;;1746         uip_add_rcv_nxt(1);
000dca  2001              MOVS     r0,#1
000dcc  f7fffffe          BL       uip_add_rcv_nxt
;;;1747         uip_flags = UIP_CLOSE;
000dd0  2010              MOVS     r0,#0x10
000dd2  4972              LDR      r1,|L10.3996|
000dd4  7008              STRB     r0,[r1,#0]
;;;1748         UIP_APPCALL();
000dd6  f7fffffe          BL       tcp_demo_appcall
;;;1749         goto tcp_send_ack;
000dda  e03e              B        |L10.3674|
                  |L10.3548|
;;;1750       } else if(uip_flags & UIP_ACKDATA) {
000ddc  486f              LDR      r0,|L10.3996|
000dde  7800              LDRB     r0,[r0,#0]  ; uip_flags
000de0  f0000001          AND      r0,r0,#1
000de4  b128              CBZ      r0,|L10.3570|
;;;1751         uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
000de6  2005              MOVS     r0,#5
000de8  7660              STRB     r0,[r4,#0x19]
;;;1752         uip_connr->len = 0;
000dea  2000              MOVS     r0,#0
000dec  8220              STRH     r0,[r4,#0x10]
;;;1753         goto drop;
000dee  e0ca              B        |L10.3974|
                  |L10.3568|
000df0  e083              B        |L10.3834|
                  |L10.3570|
;;;1754       }
;;;1755       if(uip_len > 0) {
000df2  4868              LDR      r0,|L10.3988|
000df4  8800              LDRH     r0,[r0,#0]  ; uip_len
000df6  2800              CMP      r0,#0
000df8  dd00              BLE      |L10.3580|
;;;1756         goto tcp_send_ack;
000dfa  e02e              B        |L10.3674|
                  |L10.3580|
;;;1757       }
;;;1758       goto drop;
000dfc  e0c3              B        |L10.3974|
                  |L10.3582|
;;;1759         
;;;1760     case UIP_FIN_WAIT_2:
;;;1761       if(uip_len > 0) {
000dfe  4865              LDR      r0,|L10.3988|
000e00  8800              LDRH     r0,[r0,#0]  ; uip_len
000e02  2800              CMP      r0,#0
000e04  dd03              BLE      |L10.3598|
;;;1762         uip_add_rcv_nxt(uip_len);
000e06  4863              LDR      r0,|L10.3988|
000e08  8800              LDRH     r0,[r0,#0]  ; uip_len
000e0a  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.3598|
;;;1763       }
;;;1764       if(BUF->flags & TCP_FIN) {
000e0e  4862              LDR      r0,|L10.3992|
000e10  f890002f          LDRB     r0,[r0,#0x2f]
000e14  f0000001          AND      r0,r0,#1
000e18  b160              CBZ      r0,|L10.3636|
;;;1765         uip_connr->tcpstateflags = UIP_TIME_WAIT;
000e1a  2007              MOVS     r0,#7
000e1c  7660              STRB     r0,[r4,#0x19]
;;;1766         uip_connr->timer = 0;
000e1e  2000              MOVS     r0,#0
000e20  76a0              STRB     r0,[r4,#0x1a]
;;;1767         uip_add_rcv_nxt(1);
000e22  2001              MOVS     r0,#1
000e24  f7fffffe          BL       uip_add_rcv_nxt
;;;1768         uip_flags = UIP_CLOSE;
000e28  2010              MOVS     r0,#0x10
000e2a  495c              LDR      r1,|L10.3996|
000e2c  7008              STRB     r0,[r1,#0]
;;;1769         UIP_APPCALL();
000e2e  f7fffffe          BL       tcp_demo_appcall
;;;1770         goto tcp_send_ack;
000e32  e012              B        |L10.3674|
                  |L10.3636|
;;;1771       }
;;;1772       if(uip_len > 0) {
000e34  4857              LDR      r0,|L10.3988|
000e36  8800              LDRH     r0,[r0,#0]  ; uip_len
000e38  2800              CMP      r0,#0
000e3a  dd00              BLE      |L10.3646|
;;;1773         goto tcp_send_ack;
000e3c  e00d              B        |L10.3674|
                  |L10.3646|
;;;1774       }
;;;1775       goto drop;
000e3e  e0a2              B        |L10.3974|
                  |L10.3648|
;;;1776   
;;;1777     case UIP_TIME_WAIT:
;;;1778       goto tcp_send_ack;
000e40  e00b              B        |L10.3674|
                  |L10.3650|
;;;1779       
;;;1780     case UIP_CLOSING:
;;;1781       if(uip_flags & UIP_ACKDATA) {
000e42  4856              LDR      r0,|L10.3996|
000e44  7800              LDRB     r0,[r0,#0]  ; uip_flags
000e46  f0000001          AND      r0,r0,#1
000e4a  b118              CBZ      r0,|L10.3668|
;;;1782         uip_connr->tcpstateflags = UIP_TIME_WAIT;
000e4c  2007              MOVS     r0,#7
000e4e  7660              STRB     r0,[r4,#0x19]
;;;1783         uip_connr->timer = 0;
000e50  2000              MOVS     r0,#0
000e52  76a0              STRB     r0,[r4,#0x1a]
                  |L10.3668|
000e54  bf00              NOP                            ;1463
                  |L10.3670|
000e56  bf00              NOP                            ;1729
;;;1784       }
;;;1785     }
;;;1786     goto drop;
000e58  e095              B        |L10.3974|
                  |L10.3674|
;;;1787     
;;;1788   
;;;1789     /* We jump here when we are ready to send the packet, and just want
;;;1790        to set the appropriate TCP sequence numbers in the TCP header. */
;;;1791    tcp_send_ack:
;;;1792     BUF->flags = TCP_ACK;
000e5a  2110              MOVS     r1,#0x10
000e5c  484e              LDR      r0,|L10.3992|
000e5e  f880102f          STRB     r1,[r0,#0x2f]
;;;1793    tcp_send_nodata:
000e62  bf00              NOP      
                  |L10.3684|
;;;1794     uip_len = UIP_IPTCPH_LEN;
000e64  2028              MOVS     r0,#0x28
000e66  494b              LDR      r1,|L10.3988|
000e68  8008              STRH     r0,[r1,#0]
;;;1795    tcp_send_noopts:
000e6a  bf00              NOP      
                  |L10.3692|
;;;1796     BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
000e6c  2150              MOVS     r1,#0x50
000e6e  484a              LDR      r0,|L10.3992|
000e70  f880102e          STRB     r1,[r0,#0x2e]
;;;1797    tcp_send:
000e74  bf00              NOP      
                  |L10.3702|
;;;1798     /* We're done with the input processing. We are now ready to send a
;;;1799        reply. Our job is to fill in all the fields of the TCP and IP
;;;1800        headers before calculating the checksum and finally send the
;;;1801        packet. */
;;;1802     BUF->ackno[0] = uip_connr->rcv_nxt[0];
000e76  7a21              LDRB     r1,[r4,#8]
000e78  4847              LDR      r0,|L10.3992|
000e7a  f880102a          STRB     r1,[r0,#0x2a]
;;;1803     BUF->ackno[1] = uip_connr->rcv_nxt[1];
000e7e  7a61              LDRB     r1,[r4,#9]
000e80  f880102b          STRB     r1,[r0,#0x2b]
;;;1804     BUF->ackno[2] = uip_connr->rcv_nxt[2];
000e84  7aa1              LDRB     r1,[r4,#0xa]
000e86  f880102c          STRB     r1,[r0,#0x2c]
;;;1805     BUF->ackno[3] = uip_connr->rcv_nxt[3];
000e8a  7ae1              LDRB     r1,[r4,#0xb]
000e8c  f880102d          STRB     r1,[r0,#0x2d]
;;;1806     
;;;1807     BUF->seqno[0] = uip_connr->snd_nxt[0];
000e90  7b21              LDRB     r1,[r4,#0xc]
000e92  f8801026          STRB     r1,[r0,#0x26]
;;;1808     BUF->seqno[1] = uip_connr->snd_nxt[1];
000e96  7b61              LDRB     r1,[r4,#0xd]
000e98  f8801027          STRB     r1,[r0,#0x27]
;;;1809     BUF->seqno[2] = uip_connr->snd_nxt[2];
000e9c  7ba1              LDRB     r1,[r4,#0xe]
000e9e  f8801028          STRB     r1,[r0,#0x28]
;;;1810     BUF->seqno[3] = uip_connr->snd_nxt[3];
000ea2  7be1              LDRB     r1,[r4,#0xf]
000ea4  f8801029          STRB     r1,[r0,#0x29]
;;;1811   
;;;1812     BUF->proto = UIP_PROTO_TCP;
000ea8  2106              MOVS     r1,#6
000eaa  75c1              STRB     r1,[r0,#0x17]
;;;1813     
;;;1814     BUF->srcport  = uip_connr->lport;
000eac  88a1              LDRH     r1,[r4,#4]
000eae  8441              STRH     r1,[r0,#0x22]
;;;1815     BUF->destport = uip_connr->rport;
000eb0  88e1              LDRH     r1,[r4,#6]
000eb2  8481              STRH     r1,[r0,#0x24]
;;;1816   
;;;1817     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
000eb4  bf00              NOP      
000eb6  483a              LDR      r0,|L10.4000|
000eb8  8801              LDRH     r1,[r0,#0]  ; uip_hostaddr
000eba  4837              LDR      r0,|L10.3992|
000ebc  8341              STRH     r1,[r0,#0x1a]
000ebe  4838              LDR      r0,|L10.4000|
000ec0  8841              LDRH     r1,[r0,#2]  ; uip_hostaddr
000ec2  4835              LDR      r0,|L10.3992|
000ec4  8381              STRH     r1,[r0,#0x1c]
000ec6  bf00              NOP      
;;;1818     uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);
000ec8  bf00              NOP      
000eca  8821              LDRH     r1,[r4,#0]
000ecc  83c1              STRH     r1,[r0,#0x1e]
000ece  8861              LDRH     r1,[r4,#2]
000ed0  8401              STRH     r1,[r0,#0x20]
000ed2  bf00              NOP      
;;;1819   
;;;1820     if(uip_connr->tcpstateflags & UIP_STOPPED) {
000ed4  7e60              LDRB     r0,[r4,#0x19]
000ed6  f0000010          AND      r0,r0,#0x10
000eda  b130              CBZ      r0,|L10.3818|
;;;1821       /* If the connection has issued uip_stop(), we advertise a zero
;;;1822          window so that the remote host will stop sending data. */
;;;1823       BUF->wnd[0] = BUF->wnd[1] = 0;
000edc  2100              MOVS     r1,#0
000ede  482e              LDR      r0,|L10.3992|
000ee0  f8801031          STRB     r1,[r0,#0x31]
000ee4  f8801030          STRB     r1,[r0,#0x30]
000ee8  e006              B        |L10.3832|
                  |L10.3818|
;;;1824     } else {
;;;1825       BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
000eea  210f              MOVS     r1,#0xf
000eec  482a              LDR      r0,|L10.3992|
000eee  f8801030          STRB     r1,[r0,#0x30]
;;;1826       BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
000ef2  21ca              MOVS     r1,#0xca
000ef4  f8801031          STRB     r1,[r0,#0x31]
                  |L10.3832|
;;;1827     }
;;;1828   
;;;1829    tcp_send_noconn:
000ef8  bf00              NOP      
                  |L10.3834|
;;;1830     BUF->ttl = UIP_TTL;
000efa  2140              MOVS     r1,#0x40
000efc  4826              LDR      r0,|L10.3992|
000efe  7581              STRB     r1,[r0,#0x16]
;;;1831   #if UIP_CONF_IPV6
;;;1832     /* For IPv6, the IP length field does not include the IPv6 IP header
;;;1833        length. */
;;;1834     BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
;;;1835     BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
;;;1836   #else /* UIP_CONF_IPV6 */
;;;1837     BUF->len[0] = (uip_len >> 8);
000f00  4824              LDR      r0,|L10.3988|
000f02  8800              LDRH     r0,[r0,#0]  ; uip_len
000f04  1201              ASRS     r1,r0,#8
000f06  4824              LDR      r0,|L10.3992|
000f08  7401              STRB     r1,[r0,#0x10]
;;;1838     BUF->len[1] = (uip_len & 0xff);
000f0a  4822              LDR      r0,|L10.3988|
000f0c  7801              LDRB     r1,[r0,#0]  ; uip_len
000f0e  4822              LDR      r0,|L10.3992|
000f10  7441              STRB     r1,[r0,#0x11]
;;;1839   #endif /* UIP_CONF_IPV6 */
;;;1840   
;;;1841     BUF->urgp[0] = BUF->urgp[1] = 0;
000f12  2100              MOVS     r1,#0
000f14  f8801035          STRB     r1,[r0,#0x35]
000f18  f8801034          STRB     r1,[r0,#0x34]
;;;1842     
;;;1843     /* Calculate TCP checksum. */
;;;1844     BUF->tcpchksum = 0;
000f1c  8641              STRH     r1,[r0,#0x32]
;;;1845     BUF->tcpchksum = ~(uip_tcpchksum());
000f1e  f7fffffe          BL       uip_tcpchksum
000f22  43c0              MVNS     r0,r0
000f24  b281              UXTH     r1,r0
000f26  481c              LDR      r0,|L10.3992|
000f28  8641              STRH     r1,[r0,#0x32]
;;;1846     
;;;1847   #if UIP_UDP
;;;1848    ip_send_nolen:
;;;1849   #endif
;;;1850   
;;;1851   #if UIP_CONF_IPV6
;;;1852     BUF->vtc = 0x60;
;;;1853     BUF->tcflow = 0x00;
;;;1854     BUF->flow = 0x00;
;;;1855   #else /* UIP_CONF_IPV6 */
;;;1856     BUF->vhl = 0x45;
000f2a  2045              MOVS     r0,#0x45
000f2c  491a              LDR      r1,|L10.3992|
000f2e  7388              STRB     r0,[r1,#0xe]
;;;1857     BUF->tos = 0;
000f30  2100              MOVS     r1,#0
000f32  4819              LDR      r0,|L10.3992|
000f34  73c1              STRB     r1,[r0,#0xf]
;;;1858     BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
000f36  7541              STRB     r1,[r0,#0x15]
000f38  7501              STRB     r1,[r0,#0x14]
;;;1859     ++ipid;
000f3a  481a              LDR      r0,|L10.4004|
000f3c  8800              LDRH     r0,[r0,#0]  ; ipid
000f3e  1c40              ADDS     r0,r0,#1
000f40  4918              LDR      r1,|L10.4004|
000f42  8008              STRH     r0,[r1,#0]
;;;1860     BUF->ipid[0] = ipid >> 8;
000f44  4608              MOV      r0,r1
000f46  8800              LDRH     r0,[r0,#0]  ; ipid
000f48  1201              ASRS     r1,r0,#8
000f4a  4813              LDR      r0,|L10.3992|
000f4c  7481              STRB     r1,[r0,#0x12]
;;;1861     BUF->ipid[1] = ipid & 0xff;
000f4e  4815              LDR      r0,|L10.4004|
000f50  7801              LDRB     r1,[r0,#0]  ; ipid
000f52  4811              LDR      r0,|L10.3992|
000f54  74c1              STRB     r1,[r0,#0x13]
;;;1862     /* Calculate IP checksum. */
;;;1863     BUF->ipchksum = 0;
000f56  2100              MOVS     r1,#0
000f58  8301              STRH     r1,[r0,#0x18]
;;;1864     BUF->ipchksum = ~(uip_ipchksum());
000f5a  f7fffffe          BL       uip_ipchksum
000f5e  43c0              MVNS     r0,r0
000f60  b281              UXTH     r1,r0
000f62  480d              LDR      r0,|L10.3992|
000f64  8301              STRH     r1,[r0,#0x18]
;;;1865     DEBUG_PRINTF("uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum());
;;;1866   #endif /* UIP_CONF_IPV6 */
;;;1867      
;;;1868     UIP_STAT(++uip_stat.tcp.sent);
000f66  4810              LDR      r0,|L10.4008|
000f68  8bc0              LDRH     r0,[r0,#0x1e]
000f6a  1c40              ADDS     r0,r0,#1
000f6c  b281              UXTH     r1,r0
000f6e  480e              LDR      r0,|L10.4008|
000f70  83c1              STRH     r1,[r0,#0x1e]
;;;1869    send:
000f72  bf00              NOP      
                  |L10.3956|
;;;1870     DEBUG_PRINTF("Sending packet with length %d (%d)\n", uip_len,
;;;1871   	       (BUF->len[0] << 8) | BUF->len[1]);
;;;1872     
;;;1873     UIP_STAT(++uip_stat.ip.sent);
000f74  480c              LDR      r0,|L10.4008|
000f76  8880              LDRH     r0,[r0,#4]  ; uip_stat
000f78  1c40              ADDS     r0,r0,#1
000f7a  490b              LDR      r1,|L10.4008|
000f7c  8088              STRH     r0,[r1,#4]
;;;1874     /* Return and let the caller do the actual transmission. */
;;;1875     uip_flags = 0;
000f7e  2000              MOVS     r0,#0
000f80  4906              LDR      r1,|L10.3996|
000f82  7008              STRB     r0,[r1,#0]
                  |L10.3972|
;;;1876     return;
;;;1877    drop:
;;;1878     uip_len = 0;
;;;1879     uip_flags = 0;
;;;1880     return;
;;;1881   }
000f84  bd70              POP      {r4-r6,pc}
                  |L10.3974|
000f86  2000              MOVS     r0,#0                 ;1878
000f88  4902              LDR      r1,|L10.3988|
000f8a  8008              STRH     r0,[r1,#0]            ;1878
000f8c  4903              LDR      r1,|L10.3996|
000f8e  7008              STRB     r0,[r1,#0]            ;1879
000f90  bf00              NOP                            ;1880
000f92  e7f7              B        |L10.3972|
;;;1882   /*---------------------------------------------------------------------------*/
                          ENDP

                  |L10.3988|
                          DCD      uip_len
                  |L10.3992|
                          DCD      uip_buf
                  |L10.3996|
                          DCD      uip_flags
                  |L10.4000|
                          DCD      uip_hostaddr
                  |L10.4004|
                          DCD      ipid
                  |L10.4008|
                          DCD      uip_stat

                          AREA ||i.uip_send||, CODE, READONLY, ALIGN=2

                  uip_send PROC
;;;1889   void
;;;1890   uip_send(const void *data, int len)
000000  b570              PUSH     {r4-r6,lr}
;;;1891   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1892     if(len > 0) {
000006  2d00              CMP      r5,#0
000008  dd0c              BLE      |L11.36|
;;;1893       uip_slen = len;
00000a  4907              LDR      r1,|L11.40|
00000c  800d              STRH     r5,[r1,#0]
;;;1894       if(data != uip_sappdata) {
00000e  4807              LDR      r0,|L11.44|
000010  6800              LDR      r0,[r0,#0]  ; uip_sappdata
000012  4284              CMP      r4,r0
000014  d006              BEQ      |L11.36|
;;;1895         memcpy(uip_sappdata, (data), uip_slen);
000016  4608              MOV      r0,r1
000018  8802              LDRH     r2,[r0,#0]  ; uip_slen
00001a  4621              MOV      r1,r4
00001c  4803              LDR      r0,|L11.44|
00001e  6800              LDR      r0,[r0,#0]  ; uip_sappdata
000020  f7fffffe          BL       __aeabi_memcpy
                  |L11.36|
;;;1896       }
;;;1897     }
;;;1898   }
000024  bd70              POP      {r4-r6,pc}
;;;1899   /** @} */
                          ENDP

000026  0000              DCW      0x0000
                  |L11.40|
                          DCD      uip_slen
                  |L11.44|
                          DCD      uip_sappdata

                          AREA ||i.uip_setipid||, CODE, READONLY, ALIGN=2

                  uip_setipid PROC
;;;181    
;;;182    void uip_setipid(u16_t id) { ipid = id; }
000000  4901              LDR      r1,|L12.8|
000002  8008              STRH     r0,[r1,#0]
000004  4770              BX       lr
;;;183    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ipid

                          AREA ||i.uip_tcpchksum||, CODE, READONLY, ALIGN=1

                  uip_tcpchksum PROC
;;;364    u16_t
;;;365    uip_tcpchksum(void)
000000  b510              PUSH     {r4,lr}
;;;366    {
;;;367      return upper_layer_chksum(UIP_PROTO_TCP);
000002  2006              MOVS     r0,#6
000004  f7fffffe          BL       upper_layer_chksum
;;;368    }
000008  bd10              POP      {r4,pc}
;;;369    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.uip_udpchksum||, CODE, READONLY, ALIGN=1

                  uip_udpchksum PROC
;;;371    u16_t
;;;372    uip_udpchksum(void)
000000  b510              PUSH     {r4,lr}
;;;373    {
;;;374      return upper_layer_chksum(UIP_PROTO_UDP);
000002  2011              MOVS     r0,#0x11
000004  f7fffffe          BL       upper_layer_chksum
;;;375    }
000008  bd10              POP      {r4,pc}
;;;376    #endif /* UIP_UDP_CHECKSUMS */
                          ENDP


                          AREA ||i.uip_unlisten||, CODE, READONLY, ALIGN=2

                  uip_unlisten PROC
;;;518    void
;;;519    uip_unlisten(u16_t port)
000000  2100              MOVS     r1,#0
;;;520    {
;;;521      for(c = 0; c < UIP_LISTENPORTS; ++c) {
000002  4a0e              LDR      r2,|L15.60|
000004  7011              STRB     r1,[r2,#0]
000006  e012              B        |L15.46|
                  |L15.8|
;;;522        if(uip_listenports[c] == port) {
000008  490d              LDR      r1,|L15.64|
00000a  4a0c              LDR      r2,|L15.60|
00000c  7812              LDRB     r2,[r2,#0]  ; c
00000e  f8311012          LDRH     r1,[r1,r2,LSL #1]
000012  4281              CMP      r1,r0
000014  d106              BNE      |L15.36|
;;;523          uip_listenports[c] = 0;
000016  2100              MOVS     r1,#0
000018  4a09              LDR      r2,|L15.64|
00001a  4b08              LDR      r3,|L15.60|
00001c  781b              LDRB     r3,[r3,#0]  ; c
00001e  f8221013          STRH     r1,[r2,r3,LSL #1]
                  |L15.34|
;;;524          return;
;;;525        }
;;;526      }
;;;527    }
000022  4770              BX       lr
                  |L15.36|
000024  4905              LDR      r1,|L15.60|
000026  7809              LDRB     r1,[r1,#0]            ;521  ; c
000028  1c49              ADDS     r1,r1,#1              ;521
00002a  4a04              LDR      r2,|L15.60|
00002c  7011              STRB     r1,[r2,#0]            ;521
                  |L15.46|
00002e  4903              LDR      r1,|L15.60|
000030  7809              LDRB     r1,[r1,#0]            ;521  ; c
000032  2928              CMP      r1,#0x28              ;521
000034  dbe8              BLT      |L15.8|
000036  bf00              NOP      
000038  e7f3              B        |L15.34|
;;;528    /*---------------------------------------------------------------------------*/
                          ENDP

00003a  0000              DCW      0x0000
                  |L15.60|
                          DCD      c
                  |L15.64|
                          DCD      uip_listenports

                          AREA ||i.upper_layer_chksum||, CODE, READONLY, ALIGN=2

                  upper_layer_chksum PROC
;;;329    static u16_t
;;;330    upper_layer_chksum(u8_t proto)
000000  b570              PUSH     {r4-r6,lr}
;;;331    {
000002  4604              MOV      r4,r0
;;;332      u16_t upper_layer_len;
;;;333      u16_t sum;
;;;334      
;;;335    #if UIP_CONF_IPV6
;;;336      upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
;;;337    #else /* UIP_CONF_IPV6 */
;;;338      upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
000004  480f              LDR      r0,|L16.68|
000006  7c41              LDRB     r1,[r0,#0x11]
000008  7c00              LDRB     r0,[r0,#0x10]
00000a  eb012000          ADD      r0,r1,r0,LSL #8
00000e  3814              SUBS     r0,r0,#0x14
000010  b285              UXTH     r5,r0
;;;339    #endif /* UIP_CONF_IPV6 */
;;;340      
;;;341      /* First sum pseudoheader. */
;;;342      
;;;343      /* IP protocol and length fields. This addition cannot carry. */
;;;344      sum = upper_layer_len + proto;
000012  1928              ADDS     r0,r5,r4
000014  b286              UXTH     r6,r0
;;;345      /* Sum IP source and destination addresses. */
;;;346      sum = chksum(sum, (u8_t *)&BUF->srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
000016  2208              MOVS     r2,#8
000018  490a              LDR      r1,|L16.68|
00001a  311a              ADDS     r1,r1,#0x1a
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       chksum
000022  4606              MOV      r6,r0
;;;347    
;;;348      /* Sum TCP header and data. */
;;;349      sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
000024  462a              MOV      r2,r5
000026  4907              LDR      r1,|L16.68|
000028  3122              ADDS     r1,r1,#0x22
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       chksum
000030  4606              MOV      r6,r0
;;;350    	       upper_layer_len);
;;;351        
;;;352      return (sum == 0) ? 0xffff : htons(sum);
000032  b916              CBNZ     r6,|L16.58|
000034  f64f70ff          MOV      r0,#0xffff
                  |L16.56|
;;;353    }
000038  bd70              POP      {r4-r6,pc}
                  |L16.58|
00003a  4630              MOV      r0,r6                 ;352
00003c  f7fffffe          BL       htons
000040  e7fa              B        |L16.56|
;;;354    /*---------------------------------------------------------------------------*/
                          ENDP

000042  0000              DCW      0x0000
                  |L16.68|
                          DCD      uip_buf

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uip_buf
                          %        4100
                  uip_conns
                          %        1600
                  uip_listenports
                          %        80
                  uip_stat
                          %        44

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  all_zeroes_addr
000000  00000000          DCW      0x0000,0x0000

                          AREA ||.data||, DATA, ALIGN=2

                  uip_hostaddr
                          DCD      0x00000000
                  uip_draddr
                          DCD      0x00000000
                  uip_netmask
                          DCD      0x00000000
                  uip_ethaddr
00000c  00000000          DCB      0x00,0x00,0x00,0x00
000010  00000000          DCB      0x00,0x00,0x00,0x00
                  uip_appdata
                          DCD      0x00000000
                  uip_sappdata
                          DCD      0x00000000
                  uip_len
00001c  0000              DCB      0x00,0x00
                  uip_slen
00001e  0000              DCB      0x00,0x00
                  uip_flags
000020  00000000          DCB      0x00,0x00,0x00,0x00
                  uip_conn
                          DCD      0x00000000
                  ipid
000028  0000              DCB      0x00,0x00
                  iss
00002a  0000              DCB      0x00,0x00
00002c  0000              DCB      0x00,0x00
                  lastport
00002e  0000              DCB      0x00,0x00
                  uip_acc32
                          DCD      0x00000000
                  c
000034  00                DCB      0x00
                  opt
000035  00                DCB      0x00
                  tmp16
000036  0000              DCB      0x00,0x00
