; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uip.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\uip.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\ -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\lwip\src\api -I..\..\lwip\src\arch -I..\..\lwip\src\include -I..\..\lwip\src\netif -I..\..\lwip\src\include\ipv4 -I..\..\Source\inc -I..\..\lwip\src -I..\..\Source\uIP-1.0\uip -I..\..\Source\uIP-APP -I..\..\Source\uIP-1.0\apps\webserver -IE:\git_projects\enc28j60-for-uip\Project\RVMDK\RTE -I"D:\Program Files\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include" -I"D:\Program Files\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=518 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\uip.crf ..\..\Source\uIP-1.0\uip\uip.c]
                          THUMB

                          AREA ||i.chksum||, CODE, READONLY, ALIGN=1

                  chksum PROC
;;;280    static u16_t
;;;281    chksum(u16_t sum, const u8_t *data, u16_t len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;282    {
000002  460b              MOV      r3,r1
000004  4614              MOV      r4,r2
;;;283      u16_t t;
;;;284      const u8_t *dataptr;
;;;285      const u8_t *last_byte;
;;;286    
;;;287      dataptr = data;
000006  4619              MOV      r1,r3
;;;288      last_byte = data + len - 1;
000008  191e              ADDS     r6,r3,r4
00000a  1e75              SUBS     r5,r6,#1
;;;289      
;;;290      while(dataptr < last_byte) {	/* At least two more bytes */
00000c  e00b              B        |L1.38|
                  |L1.14|
;;;291        t = (dataptr[0] << 8) + dataptr[1];
00000e  784e              LDRB     r6,[r1,#1]
000010  780f              LDRB     r7,[r1,#0]
000012  eb062607          ADD      r6,r6,r7,LSL #8
000016  b2b2              UXTH     r2,r6
;;;292        sum += t;
000018  1886              ADDS     r6,r0,r2
00001a  b2b0              UXTH     r0,r6
;;;293        if(sum < t) {
00001c  4290              CMP      r0,r2
00001e  da01              BGE      |L1.36|
;;;294          sum++;		/* carry */
000020  1c46              ADDS     r6,r0,#1
000022  b2b0              UXTH     r0,r6
                  |L1.36|
;;;295        }
;;;296        dataptr += 2;
000024  1c89              ADDS     r1,r1,#2
                  |L1.38|
000026  42a9              CMP      r1,r5                 ;290
000028  d3f1              BCC      |L1.14|
;;;297      }
;;;298      
;;;299      if(dataptr == last_byte) {
00002a  42a9              CMP      r1,r5
00002c  d10a              BNE      |L1.68|
;;;300        t = (dataptr[0] << 8) + 0;
00002e  780e              LDRB     r6,[r1,#0]
000030  2700              MOVS     r7,#0
000032  eb072606          ADD      r6,r7,r6,LSL #8
000036  b2b2              UXTH     r2,r6
;;;301        sum += t;
000038  1886              ADDS     r6,r0,r2
00003a  b2b0              UXTH     r0,r6
;;;302        if(sum < t) {
00003c  4290              CMP      r0,r2
00003e  da01              BGE      |L1.68|
;;;303          sum++;		/* carry */
000040  1c46              ADDS     r6,r0,#1
000042  b2b0              UXTH     r0,r6
                  |L1.68|
;;;304        }
;;;305      }
;;;306    
;;;307      /* Return sum in host byte order. */
;;;308      return sum;
;;;309    }
000044  bdf0              POP      {r4-r7,pc}
;;;310    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.htons||, CODE, READONLY, ALIGN=1

                  htons PROC
;;;2025   u16_t
;;;2026   htons(u16_t val)
000000  4601              MOV      r1,r0
;;;2027   {
;;;2028     return HTONS(val);
000002  0208              LSLS     r0,r1,#8
000004  ea402021          ORR      r0,r0,r1,ASR #8
000008  b280              UXTH     r0,r0
;;;2029   }
00000a  4770              BX       lr
;;;2030   /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.uip_add32||, CODE, READONLY, ALIGN=2

                  uip_add32 PROC
;;;249    void
;;;250    uip_add32(u8_t *op32, u16_t op16)
000000  78c2              LDRB     r2,[r0,#3]
;;;251    {
;;;252      uip_acc32[3] = op32[3] + (op16 & 0xff);
000002  440a              ADD      r2,r2,r1
000004  4b19              LDR      r3,|L3.108|
000006  70da              STRB     r2,[r3,#3]
;;;253      uip_acc32[2] = op32[2] + (op16 >> 8);
000008  7882              LDRB     r2,[r0,#2]
00000a  eb022221          ADD      r2,r2,r1,ASR #8
00000e  709a              STRB     r2,[r3,#2]
;;;254      uip_acc32[1] = op32[1];
000010  7842              LDRB     r2,[r0,#1]
000012  705a              STRB     r2,[r3,#1]
;;;255      uip_acc32[0] = op32[0];
000014  7802              LDRB     r2,[r0,#0]
000016  701a              STRB     r2,[r3,#0]
;;;256      
;;;257      if(uip_acc32[2] < (op16 >> 8)) {
000018  461a              MOV      r2,r3
00001a  7892              LDRB     r2,[r2,#2]  ; uip_acc32
00001c  ebb22f21          CMP      r2,r1,ASR #8
000020  da0a              BGE      |L3.56|
;;;258        ++uip_acc32[1];
000022  461a              MOV      r2,r3
000024  7852              LDRB     r2,[r2,#1]  ; uip_acc32
000026  1c52              ADDS     r2,r2,#1
000028  705a              STRB     r2,[r3,#1]
;;;259        if(uip_acc32[1] == 0) {
00002a  461a              MOV      r2,r3
00002c  7852              LDRB     r2,[r2,#1]  ; uip_acc32
00002e  b91a              CBNZ     r2,|L3.56|
;;;260          ++uip_acc32[0];
000030  461a              MOV      r2,r3
000032  7812              LDRB     r2,[r2,#0]  ; uip_acc32
000034  1c52              ADDS     r2,r2,#1
000036  701a              STRB     r2,[r3,#0]
                  |L3.56|
;;;261        }
;;;262      }
;;;263      
;;;264      
;;;265      if(uip_acc32[3] < (op16 & 0xff)) {
000038  4a0c              LDR      r2,|L3.108|
00003a  78d2              LDRB     r2,[r2,#3]  ; uip_acc32
00003c  b2cb              UXTB     r3,r1
00003e  429a              CMP      r2,r3
000040  da12              BGE      |L3.104|
;;;266        ++uip_acc32[2];
000042  4a0a              LDR      r2,|L3.108|
000044  7892              LDRB     r2,[r2,#2]  ; uip_acc32
000046  1c52              ADDS     r2,r2,#1
000048  4b08              LDR      r3,|L3.108|
00004a  709a              STRB     r2,[r3,#2]
;;;267        if(uip_acc32[2] == 0) {
00004c  461a              MOV      r2,r3
00004e  7892              LDRB     r2,[r2,#2]  ; uip_acc32
000050  b952              CBNZ     r2,|L3.104|
;;;268          ++uip_acc32[1];
000052  461a              MOV      r2,r3
000054  7852              LDRB     r2,[r2,#1]  ; uip_acc32
000056  1c52              ADDS     r2,r2,#1
000058  705a              STRB     r2,[r3,#1]
;;;269          if(uip_acc32[1] == 0) {
00005a  461a              MOV      r2,r3
00005c  7852              LDRB     r2,[r2,#1]  ; uip_acc32
00005e  b91a              CBNZ     r2,|L3.104|
;;;270    	++uip_acc32[0];
000060  461a              MOV      r2,r3
000062  7812              LDRB     r2,[r2,#0]  ; uip_acc32
000064  1c52              ADDS     r2,r2,#1
000066  701a              STRB     r2,[r3,#0]
                  |L3.104|
;;;271          }
;;;272        }
;;;273      }
;;;274    }
000068  4770              BX       lr
;;;275    
                          ENDP

00006a  0000              DCW      0x0000
                  |L3.108|
                          DCD      uip_acc32

                          AREA ||i.uip_add_rcv_nxt||, CODE, READONLY, ALIGN=2

                  uip_add_rcv_nxt PROC
;;;672    static void
;;;673    uip_add_rcv_nxt(u16_t n)
000000  b510              PUSH     {r4,lr}
;;;674    {
000002  4604              MOV      r4,r0
;;;675      uip_add32(uip_conn->rcv_nxt, n);
000004  4621              MOV      r1,r4
000006  480d              LDR      r0,|L4.60|
000008  6800              LDR      r0,[r0,#0]  ; uip_conn
00000a  3008              ADDS     r0,r0,#8
00000c  f7fffffe          BL       uip_add32
;;;676      uip_conn->rcv_nxt[0] = uip_acc32[0];
000010  480b              LDR      r0,|L4.64|
000012  7800              LDRB     r0,[r0,#0]  ; uip_acc32
000014  4909              LDR      r1,|L4.60|
000016  6809              LDR      r1,[r1,#0]  ; uip_conn
000018  7208              STRB     r0,[r1,#8]
;;;677      uip_conn->rcv_nxt[1] = uip_acc32[1];
00001a  4809              LDR      r0,|L4.64|
00001c  7841              LDRB     r1,[r0,#1]  ; uip_acc32
00001e  4807              LDR      r0,|L4.60|
000020  6800              LDR      r0,[r0,#0]  ; uip_conn
000022  7241              STRB     r1,[r0,#9]
;;;678      uip_conn->rcv_nxt[2] = uip_acc32[2];
000024  4806              LDR      r0,|L4.64|
000026  7881              LDRB     r1,[r0,#2]  ; uip_acc32
000028  4804              LDR      r0,|L4.60|
00002a  6800              LDR      r0,[r0,#0]  ; uip_conn
00002c  7281              STRB     r1,[r0,#0xa]
;;;679      uip_conn->rcv_nxt[3] = uip_acc32[3];
00002e  4804              LDR      r0,|L4.64|
000030  78c1              LDRB     r1,[r0,#3]  ; uip_acc32
000032  4802              LDR      r0,|L4.60|
000034  6800              LDR      r0,[r0,#0]  ; uip_conn
000036  72c1              STRB     r1,[r0,#0xb]
;;;680    }
000038  bd10              POP      {r4,pc}
;;;681    /*---------------------------------------------------------------------------*/
                          ENDP

00003a  0000              DCW      0x0000
                  |L4.60|
                          DCD      uip_conn
                  |L4.64|
                          DCD      uip_acc32

                          AREA ||i.uip_chksum||, CODE, READONLY, ALIGN=1

                  uip_chksum PROC
;;;311    u16_t
;;;312    uip_chksum(u16_t *data, u16_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;313    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;314      return htons(chksum(0, (u8_t *)data, len));
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       chksum
000010  4606              MOV      r6,r0
000012  f7fffffe          BL       htons
;;;315    }
000016  bd70              POP      {r4-r6,pc}
;;;316    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.uip_connect||, CODE, READONLY, ALIGN=2

                  uip_connect PROC
;;;407    struct uip_conn *
;;;408    uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
000000  b530              PUSH     {r4,r5,lr}
;;;409    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;410      register struct uip_conn *conn, *cconn;
;;;411      
;;;412      /* Find an unused local port. */
;;;413     again:
000006  bf00              NOP      
                  |L6.8|
;;;414      ++lastport;
000008  483d              LDR      r0,|L6.256|
00000a  8800              LDRH     r0,[r0,#0]  ; lastport
00000c  1c40              ADDS     r0,r0,#1
00000e  493c              LDR      r1,|L6.256|
000010  8008              STRH     r0,[r1,#0]
;;;415    
;;;416      if(lastport >= 32000) {
000012  4608              MOV      r0,r1
000014  8800              LDRH     r0,[r0,#0]  ; lastport
000016  f5b04ffa          CMP      r0,#0x7d00
00001a  db02              BLT      |L6.34|
;;;417        lastport = 4096;
00001c  f44f5080          MOV      r0,#0x1000
000020  8008              STRH     r0,[r1,#0]
                  |L6.34|
;;;418      }
;;;419    
;;;420      /* Check if this port is already in use, and if so try to find
;;;421         another one. */
;;;422      for(c = 0; c < UIP_CONNS; ++c) {
000022  2000              MOVS     r0,#0
000024  4937              LDR      r1,|L6.260|
000026  7008              STRB     r0,[r1,#0]
000028  e015              B        |L6.86|
                  |L6.42|
;;;423        conn = &uip_conns[c];
00002a  4836              LDR      r0,|L6.260|
00002c  7800              LDRB     r0,[r0,#0]  ; c
00002e  eb000080          ADD      r0,r0,r0,LSL #2
000032  4935              LDR      r1,|L6.264|
000034  eb0102c0          ADD      r2,r1,r0,LSL #3
;;;424        if(conn->tcpstateflags != UIP_CLOSED &&
000038  7e50              LDRB     r0,[r2,#0x19]
00003a  b138              CBZ      r0,|L6.76|
;;;425           conn->lport == htons(lastport)) {
00003c  4830              LDR      r0,|L6.256|
00003e  8800              LDRH     r0,[r0,#0]  ; lastport
000040  f7fffffe          BL       htons
000044  8891              LDRH     r1,[r2,#4]
000046  4288              CMP      r0,r1
000048  d100              BNE      |L6.76|
;;;426          goto again;
00004a  e7dd              B        |L6.8|
                  |L6.76|
00004c  482d              LDR      r0,|L6.260|
00004e  7800              LDRB     r0,[r0,#0]            ;422  ; c
000050  1c40              ADDS     r0,r0,#1              ;422
000052  492c              LDR      r1,|L6.260|
000054  7008              STRB     r0,[r1,#0]            ;422
                  |L6.86|
000056  482b              LDR      r0,|L6.260|
000058  7800              LDRB     r0,[r0,#0]            ;422  ; c
00005a  2828              CMP      r0,#0x28              ;422
00005c  dbe5              BLT      |L6.42|
;;;427        }
;;;428      }
;;;429    
;;;430      conn = 0;
00005e  2200              MOVS     r2,#0
;;;431      for(c = 0; c < UIP_CONNS; ++c) {
000060  2000              MOVS     r0,#0
000062  4928              LDR      r1,|L6.260|
000064  7008              STRB     r0,[r1,#0]
000066  e018              B        |L6.154|
                  |L6.104|
;;;432        cconn = &uip_conns[c];
000068  4826              LDR      r0,|L6.260|
00006a  7800              LDRB     r0,[r0,#0]  ; c
00006c  eb000080          ADD      r0,r0,r0,LSL #2
000070  4925              LDR      r1,|L6.264|
000072  eb0103c0          ADD      r3,r1,r0,LSL #3
;;;433        if(cconn->tcpstateflags == UIP_CLOSED) {
000076  7e58              LDRB     r0,[r3,#0x19]
000078  b908              CBNZ     r0,|L6.126|
;;;434          conn = cconn;
00007a  461a              MOV      r2,r3
;;;435          break;
00007c  e011              B        |L6.162|
                  |L6.126|
;;;436        }
;;;437        if(cconn->tcpstateflags == UIP_TIME_WAIT) {
00007e  7e58              LDRB     r0,[r3,#0x19]
000080  2807              CMP      r0,#7
000082  d105              BNE      |L6.144|
;;;438          if(conn == 0 ||
000084  b11a              CBZ      r2,|L6.142|
;;;439    	 cconn->timer > conn->timer) {
000086  7e98              LDRB     r0,[r3,#0x1a]
000088  7e91              LDRB     r1,[r2,#0x1a]
00008a  4288              CMP      r0,r1
00008c  dd00              BLE      |L6.144|
                  |L6.142|
;;;440    	conn = cconn;
00008e  461a              MOV      r2,r3
                  |L6.144|
000090  481c              LDR      r0,|L6.260|
000092  7800              LDRB     r0,[r0,#0]            ;431  ; c
000094  1c40              ADDS     r0,r0,#1              ;431
000096  491b              LDR      r1,|L6.260|
000098  7008              STRB     r0,[r1,#0]            ;431
                  |L6.154|
00009a  481a              LDR      r0,|L6.260|
00009c  7800              LDRB     r0,[r0,#0]            ;431  ; c
00009e  2828              CMP      r0,#0x28              ;431
0000a0  dbe2              BLT      |L6.104|
                  |L6.162|
0000a2  bf00              NOP                            ;435
;;;441          }
;;;442        }
;;;443      }
;;;444    
;;;445      if(conn == 0) {
0000a4  b90a              CBNZ     r2,|L6.170|
;;;446        return 0;
0000a6  2000              MOVS     r0,#0
                  |L6.168|
;;;447      }
;;;448      
;;;449      conn->tcpstateflags = UIP_SYN_SENT;
;;;450    
;;;451      conn->snd_nxt[0] = iss[0];
;;;452      conn->snd_nxt[1] = iss[1];
;;;453      conn->snd_nxt[2] = iss[2];
;;;454      conn->snd_nxt[3] = iss[3];
;;;455    
;;;456      conn->initialmss = conn->mss = UIP_TCP_MSS;
;;;457      
;;;458      conn->len = 1;   /* TCP length of the SYN is one. */
;;;459      conn->nrtx = 0;
;;;460      conn->timer = 1; /* Send the SYN next time around. */
;;;461      conn->rto = UIP_RTO;
;;;462      conn->sa = 0;
;;;463      conn->sv = 16;   /* Initial value of the RTT variance. */
;;;464      conn->lport = htons(lastport);
;;;465      conn->rport = rport;
;;;466      uip_ipaddr_copy(&conn->ripaddr, ripaddr);
;;;467      
;;;468      return conn;
;;;469    }
0000a8  bd30              POP      {r4,r5,pc}
                  |L6.170|
0000aa  2002              MOVS     r0,#2                 ;449
0000ac  7650              STRB     r0,[r2,#0x19]         ;449
0000ae  4817              LDR      r0,|L6.268|
0000b0  7800              LDRB     r0,[r0,#0]            ;451  ; iss
0000b2  7310              STRB     r0,[r2,#0xc]          ;451
0000b4  4815              LDR      r0,|L6.268|
0000b6  7841              LDRB     r1,[r0,#1]            ;452  ; iss
0000b8  7351              STRB     r1,[r2,#0xd]          ;452
0000ba  7881              LDRB     r1,[r0,#2]            ;453  ; iss
0000bc  7391              STRB     r1,[r2,#0xe]          ;453
0000be  78c1              LDRB     r1,[r0,#3]            ;454  ; iss
0000c0  73d1              STRB     r1,[r2,#0xf]          ;454
0000c2  f64070ca          MOV      r0,#0xfca             ;456
0000c6  8250              STRH     r0,[r2,#0x12]         ;456
0000c8  8290              STRH     r0,[r2,#0x14]         ;456
0000ca  2001              MOVS     r0,#1                 ;458
0000cc  8210              STRH     r0,[r2,#0x10]         ;458
0000ce  2000              MOVS     r0,#0                 ;459
0000d0  76d0              STRB     r0,[r2,#0x1b]         ;459
0000d2  2001              MOVS     r0,#1                 ;460
0000d4  7690              STRB     r0,[r2,#0x1a]         ;460
0000d6  2003              MOVS     r0,#3                 ;461
0000d8  7610              STRB     r0,[r2,#0x18]         ;461
0000da  2000              MOVS     r0,#0                 ;462
0000dc  7590              STRB     r0,[r2,#0x16]         ;462
0000de  2010              MOVS     r0,#0x10              ;463
0000e0  75d0              STRB     r0,[r2,#0x17]         ;463
0000e2  4807              LDR      r0,|L6.256|
0000e4  8800              LDRH     r0,[r0,#0]            ;464  ; lastport
0000e6  f7fffffe          BL       htons
0000ea  8090              STRH     r0,[r2,#4]            ;464
0000ec  80d5              STRH     r5,[r2,#6]            ;465
0000ee  bf00              NOP                            ;466
0000f0  8820              LDRH     r0,[r4,#0]            ;466
0000f2  8010              STRH     r0,[r2,#0]            ;466
0000f4  8860              LDRH     r0,[r4,#2]            ;466
0000f6  8050              STRH     r0,[r2,#2]            ;466
0000f8  bf00              NOP                            ;466
0000fa  4610              MOV      r0,r2                 ;468
0000fc  e7d4              B        |L6.168|
;;;470    #endif /* UIP_ACTIVE_OPEN */
                          ENDP

0000fe  0000              DCW      0x0000
                  |L6.256|
                          DCD      lastport
                  |L6.260|
                          DCD      c
                  |L6.264|
                          DCD      uip_conns
                  |L6.268|
                          DCD      iss

                          AREA ||i.uip_init||, CODE, READONLY, ALIGN=2

                  uip_init PROC
;;;379    void
;;;380    uip_init(void)
000000  2000              MOVS     r0,#0
;;;381    {
;;;382      for(c = 0; c < UIP_LISTENPORTS; ++c) {
000002  4921              LDR      r1,|L7.136|
000004  7008              STRB     r0,[r1,#0]
000006  e00a              B        |L7.30|
                  |L7.8|
;;;383        uip_listenports[c] = 0;
000008  2000              MOVS     r0,#0
00000a  4920              LDR      r1,|L7.140|
00000c  4a1e              LDR      r2,|L7.136|
00000e  7812              LDRB     r2,[r2,#0]  ; c
000010  f8210012          STRH     r0,[r1,r2,LSL #1]
000014  481c              LDR      r0,|L7.136|
000016  7800              LDRB     r0,[r0,#0]            ;382  ; c
000018  1c40              ADDS     r0,r0,#1              ;382
00001a  491b              LDR      r1,|L7.136|
00001c  7008              STRB     r0,[r1,#0]            ;382
                  |L7.30|
00001e  481a              LDR      r0,|L7.136|
000020  7800              LDRB     r0,[r0,#0]            ;382  ; c
000022  2828              CMP      r0,#0x28              ;382
000024  dbf0              BLT      |L7.8|
;;;384      }
;;;385      for(c = 0; c < UIP_CONNS; ++c) {
000026  2000              MOVS     r0,#0
000028  4917              LDR      r1,|L7.136|
00002a  7008              STRB     r0,[r1,#0]
00002c  e00d              B        |L7.74|
                  |L7.46|
;;;386        uip_conns[c].tcpstateflags = UIP_CLOSED;
00002e  2000              MOVS     r0,#0
000030  4915              LDR      r1,|L7.136|
000032  7809              LDRB     r1,[r1,#0]  ; c
000034  eb010181          ADD      r1,r1,r1,LSL #2
000038  4a15              LDR      r2,|L7.144|
00003a  eb0201c1          ADD      r1,r2,r1,LSL #3
00003e  7648              STRB     r0,[r1,#0x19]
000040  4811              LDR      r0,|L7.136|
000042  7800              LDRB     r0,[r0,#0]            ;385  ; c
000044  1c40              ADDS     r0,r0,#1              ;385
000046  4910              LDR      r1,|L7.136|
000048  7008              STRB     r0,[r1,#0]            ;385
                  |L7.74|
00004a  480f              LDR      r0,|L7.136|
00004c  7800              LDRB     r0,[r0,#0]            ;385  ; c
00004e  2828              CMP      r0,#0x28              ;385
000050  dbed              BLT      |L7.46|
;;;387      }
;;;388    #if UIP_ACTIVE_OPEN
;;;389      lastport = 1024;
000052  f44f6080          MOV      r0,#0x400
000056  490f              LDR      r1,|L7.148|
000058  8008              STRH     r0,[r1,#0]
;;;390    #endif /* UIP_ACTIVE_OPEN */
;;;391    
;;;392    #if UIP_UDP
;;;393      for(c = 0; c < UIP_UDP_CONNS; ++c) {
00005a  2000              MOVS     r0,#0
00005c  490a              LDR      r1,|L7.136|
00005e  7008              STRB     r0,[r1,#0]
000060  e00d              B        |L7.126|
                  |L7.98|
;;;394        uip_udp_conns[c].lport = 0;
000062  2000              MOVS     r0,#0
000064  4908              LDR      r1,|L7.136|
000066  7809              LDRB     r1,[r1,#0]  ; c
000068  eb010181          ADD      r1,r1,r1,LSL #2
00006c  4a0a              LDR      r2,|L7.152|
00006e  eb020141          ADD      r1,r2,r1,LSL #1
000072  8088              STRH     r0,[r1,#4]
000074  4804              LDR      r0,|L7.136|
000076  7800              LDRB     r0,[r0,#0]            ;393  ; c
000078  1c40              ADDS     r0,r0,#1              ;393
00007a  4903              LDR      r1,|L7.136|
00007c  7008              STRB     r0,[r1,#0]            ;393
                  |L7.126|
00007e  4802              LDR      r0,|L7.136|
000080  7800              LDRB     r0,[r0,#0]            ;393  ; c
000082  280a              CMP      r0,#0xa               ;393
000084  dbed              BLT      |L7.98|
;;;395      }
;;;396    #endif /* UIP_UDP */
;;;397      
;;;398    
;;;399      /* IPv4 initialization. */
;;;400    #if UIP_FIXEDADDR == 0
;;;401      /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
;;;402    #endif /* UIP_FIXEDADDR */
;;;403    
;;;404    }
000086  4770              BX       lr
;;;405    /*---------------------------------------------------------------------------*/
                          ENDP

                  |L7.136|
                          DCD      c
                  |L7.140|
                          DCD      uip_listenports
                  |L7.144|
                          DCD      uip_conns
                  |L7.148|
                          DCD      lastport
                  |L7.152|
                          DCD      uip_udp_conns

                          AREA ||i.uip_ipchksum||, CODE, READONLY, ALIGN=2

                  uip_ipchksum PROC
;;;318    u16_t
;;;319    uip_ipchksum(void)
000000  b510              PUSH     {r4,lr}
;;;320    {
;;;321      u16_t sum;
;;;322    
;;;323      sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
000002  2214              MOVS     r2,#0x14
000004  4906              LDR      r1,|L8.32|
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       chksum
00000c  4604              MOV      r4,r0
;;;324      DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
;;;325      return (sum == 0) ? 0xffff : htons(sum);
00000e  b914              CBNZ     r4,|L8.22|
000010  f64f70ff          MOV      r0,#0xffff
                  |L8.20|
;;;326    }
000014  bd10              POP      {r4,pc}
                  |L8.22|
000016  4620              MOV      r0,r4                 ;325
000018  f7fffffe          BL       htons
00001c  e7fa              B        |L8.20|
;;;327    #endif
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      uip_buf+0xe

                          AREA ||i.uip_listen||, CODE, READONLY, ALIGN=2

                  uip_listen PROC
;;;529    void
;;;530    uip_listen(u16_t port)
000000  2100              MOVS     r1,#0
;;;531    {
;;;532      for(c = 0; c < UIP_LISTENPORTS; ++c) {
000002  4a0d              LDR      r2,|L9.56|
000004  7011              STRB     r1,[r2,#0]
000006  e010              B        |L9.42|
                  |L9.8|
;;;533        if(uip_listenports[c] == 0) {
000008  490c              LDR      r1,|L9.60|
00000a  4a0b              LDR      r2,|L9.56|
00000c  7812              LDRB     r2,[r2,#0]  ; c
00000e  f8311012          LDRH     r1,[r1,r2,LSL #1]
000012  b929              CBNZ     r1,|L9.32|
;;;534          uip_listenports[c] = port;
000014  4909              LDR      r1,|L9.60|
000016  4a08              LDR      r2,|L9.56|
000018  7812              LDRB     r2,[r2,#0]  ; c
00001a  f8210012          STRH     r0,[r1,r2,LSL #1]
                  |L9.30|
;;;535          return;
;;;536        }
;;;537      }
;;;538    }
00001e  4770              BX       lr
                  |L9.32|
000020  4905              LDR      r1,|L9.56|
000022  7809              LDRB     r1,[r1,#0]            ;532  ; c
000024  1c49              ADDS     r1,r1,#1              ;532
000026  4a04              LDR      r2,|L9.56|
000028  7011              STRB     r1,[r2,#0]            ;532
                  |L9.42|
00002a  4903              LDR      r1,|L9.56|
00002c  7809              LDRB     r1,[r1,#0]            ;532  ; c
00002e  2928              CMP      r1,#0x28              ;532
000030  dbea              BLT      |L9.8|
000032  bf00              NOP      
000034  e7f3              B        |L9.30|
;;;539    /*---------------------------------------------------------------------------*/
                          ENDP

000036  0000              DCW      0x0000
                  |L9.56|
                          DCD      c
                  |L9.60|
                          DCD      uip_listenports

                          AREA ||i.uip_process||, CODE, READONLY, ALIGN=2

                  uip_process PROC
;;;682    void
;;;683    uip_process(u8_t flag)
000000  b570              PUSH     {r4-r6,lr}
;;;684    {
000002  4605              MOV      r5,r0
;;;685        register struct uip_conn *uip_connr = uip_conn;
000004  48fe              LDR      r0,|L10.1024|
000006  6804              LDR      r4,[r0,#0]  ; uip_conn
;;;686        
;;;687    //================================================================
;;;688    #if UIP_UDP
;;;689        if(flag == UIP_UDP_SEND_CONN)
000008  2d04              CMP      r5,#4
00000a  d100              BNE      |L10.14|
;;;690        {
;;;691            goto udp_send;
00000c  e2b2              B        |L10.1396|
                  |L10.14|
;;;692        }
;;;693    #endif /* UIP_UDP */
;;;694    //================================================================
;;;695     //发送的应用数据   接收的应用数据    buf缓冲区
;;;696        uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
00000e  48fd              LDR      r0,|L10.1028|
000010  49fd              LDR      r1,|L10.1032|
000012  6008              STR      r0,[r1,#0]  ; uip_appdata
000014  49fd              LDR      r1,|L10.1036|
000016  6008              STR      r0,[r1,#0]  ; uip_sappdata
;;;697    
;;;698        
;;;699        
;;;700    //================================================================
;;;701        /* Check if we were invoked because of a poll request for a
;;;702         particular connection. */
;;;703        if(flag == UIP_POLL_REQUEST) 
000018  2d03              CMP      r5,#3
00001a  d10f              BNE      |L10.60|
;;;704        {
;;;705            if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
00001c  7e60              LDRB     r0,[r4,#0x19]
00001e  f000000f          AND      r0,r0,#0xf
000022  2803              CMP      r0,#3
000024  d108              BNE      |L10.56|
;;;706               !uip_outstanding(uip_connr)) 
000026  8a20              LDRH     r0,[r4,#0x10]
000028  b930              CBNZ     r0,|L10.56|
;;;707            {
;;;708                uip_flags = UIP_POLL;
00002a  2008              MOVS     r0,#8
00002c  49f8              LDR      r1,|L10.1040|
00002e  7008              STRB     r0,[r1,#0]
;;;709                UIP_APPCALL();
000030  f7fffffe          BL       tcp_demo_appcall
                  |L10.52|
;;;710                goto appsend;
000034  f000bf5f          B.W      |L10.3830|
                  |L10.56|
;;;711            }
;;;712            goto drop;
000038  f001b8e0          B.W      |L10.4604|
                  |L10.60|
;;;713            /* Check if we were invoked because of the perodic timer fireing. */
;;;714        }
;;;715        else if(flag == UIP_TIMER) 
00003c  2d02              CMP      r5,#2
00003e  d16e              BNE      |L10.286|
;;;716        {
;;;717    #if UIP_REASSEMBLY
;;;718            if(uip_reasstmr != 0) 
;;;719            {
;;;720                --uip_reasstmr;
;;;721            }
;;;722    #endif /* UIP_REASSEMBLY */
;;;723            /* Increase the initial sequence number. */
;;;724            if(++iss[3] == 0) 
000040  48f4              LDR      r0,|L10.1044|
000042  78c0              LDRB     r0,[r0,#3]  ; iss
000044  1c40              ADDS     r0,r0,#1
000046  b2c0              UXTB     r0,r0
000048  49f2              LDR      r1,|L10.1044|
00004a  70c8              STRB     r0,[r1,#3]
00004c  b978              CBNZ     r0,|L10.110|
;;;725            {
;;;726                if(++iss[2] == 0) 
00004e  4608              MOV      r0,r1
000050  7880              LDRB     r0,[r0,#2]  ; iss
000052  1c40              ADDS     r0,r0,#1
000054  b2c0              UXTB     r0,r0
000056  7088              STRB     r0,[r1,#2]
000058  b948              CBNZ     r0,|L10.110|
;;;727                {
;;;728                    if(++iss[1] == 0) 
00005a  4608              MOV      r0,r1
00005c  7840              LDRB     r0,[r0,#1]  ; iss
00005e  1c40              ADDS     r0,r0,#1
000060  b2c0              UXTB     r0,r0
000062  7048              STRB     r0,[r1,#1]
000064  b918              CBNZ     r0,|L10.110|
;;;729                    {
;;;730                        ++iss[0];
000066  4608              MOV      r0,r1
000068  7800              LDRB     r0,[r0,#0]  ; iss
00006a  1c40              ADDS     r0,r0,#1
00006c  7008              STRB     r0,[r1,#0]
                  |L10.110|
;;;731                    }
;;;732                }
;;;733            }
;;;734    
;;;735            /* Reset the length variables. */
;;;736            uip_len = 0;
00006e  2000              MOVS     r0,#0
000070  49e9              LDR      r1,|L10.1048|
000072  8008              STRH     r0,[r1,#0]
;;;737            uip_slen = 0;
000074  49e9              LDR      r1,|L10.1052|
000076  8008              STRH     r0,[r1,#0]
;;;738    
;;;739            /* Check if the connection is in a state in which we simply wait
;;;740            for the connection to time out. If so, we increase the
;;;741            connection's timer and remove the connection if it times
;;;742            out. */
;;;743            if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
000078  7e60              LDRB     r0,[r4,#0x19]
00007a  2807              CMP      r0,#7
00007c  d002              BEQ      |L10.132|
;;;744               uip_connr->tcpstateflags == UIP_FIN_WAIT_2) 
00007e  7e60              LDRB     r0,[r4,#0x19]
000080  2805              CMP      r0,#5
000082  d108              BNE      |L10.150|
                  |L10.132|
;;;745            {
;;;746                ++(uip_connr->timer);
000084  7ea0              LDRB     r0,[r4,#0x1a]
000086  1c40              ADDS     r0,r0,#1
000088  76a0              STRB     r0,[r4,#0x1a]
;;;747                if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) 
00008a  7ea0              LDRB     r0,[r4,#0x1a]
00008c  2878              CMP      r0,#0x78
00008e  d161              BNE      |L10.340|
;;;748                {
;;;749                    uip_connr->tcpstateflags = UIP_CLOSED;
000090  2000              MOVS     r0,#0
000092  7660              STRB     r0,[r4,#0x19]
000094  e05e              B        |L10.340|
                  |L10.150|
;;;750                }
;;;751            } 
;;;752            else if(uip_connr->tcpstateflags != UIP_CLOSED) 
000096  7e60              LDRB     r0,[r4,#0x19]
000098  2800              CMP      r0,#0
00009a  d05b              BEQ      |L10.340|
;;;753            {
;;;754                /* If the connection has outstanding data, we increase the
;;;755                connection's timer and see if it has reached the RTO value
;;;756                in which case we retransmit. */
;;;757                if(uip_outstanding(uip_connr)) 
00009c  8a20              LDRH     r0,[r4,#0x10]
00009e  2800              CMP      r0,#0
0000a0  d04d              BEQ      |L10.318|
;;;758                {
;;;759                    if(uip_connr->timer-- == 0) 
0000a2  7ea1              LDRB     r1,[r4,#0x1a]
0000a4  1e48              SUBS     r0,r1,#1
0000a6  76a0              STRB     r0,[r4,#0x1a]
0000a8  2900              CMP      r1,#0
0000aa  d153              BNE      |L10.340|
;;;760                    {
;;;761                        if(uip_connr->nrtx == UIP_MAXRTX ||
0000ac  7ee0              LDRB     r0,[r4,#0x1b]
0000ae  2808              CMP      r0,#8
0000b0  d008              BEQ      |L10.196|
;;;762                         ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
0000b2  7e60              LDRB     r0,[r4,#0x19]
0000b4  2802              CMP      r0,#2
0000b6  d002              BEQ      |L10.190|
;;;763                           uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
0000b8  7e60              LDRB     r0,[r4,#0x19]
0000ba  2801              CMP      r0,#1
0000bc  d110              BNE      |L10.224|
                  |L10.190|
;;;764                          uip_connr->nrtx == UIP_MAXSYNRTX)) 
0000be  7ee0              LDRB     r0,[r4,#0x1b]
0000c0  2805              CMP      r0,#5
0000c2  d10d              BNE      |L10.224|
                  |L10.196|
;;;765                        {
;;;766                            uip_connr->tcpstateflags = UIP_CLOSED;
0000c4  2000              MOVS     r0,#0
0000c6  7660              STRB     r0,[r4,#0x19]
;;;767    
;;;768                            /* We call UIP_APPCALL() with uip_flags set to
;;;769                               UIP_TIMEDOUT to inform the application that the
;;;770                               connection has timed out. */
;;;771                            uip_flags = UIP_TIMEDOUT;
0000c8  2080              MOVS     r0,#0x80
0000ca  49d1              LDR      r1,|L10.1040|
0000cc  7008              STRB     r0,[r1,#0]
;;;772                            UIP_APPCALL();
0000ce  f7fffffe          BL       tcp_demo_appcall
;;;773    
;;;774                            /* We also send a reset packet to the remote host. */
;;;775                            BUF->flags = TCP_RST | TCP_ACK;
0000d2  2114              MOVS     r1,#0x14
0000d4  48cb              LDR      r0,|L10.1028|
0000d6  3836              SUBS     r0,r0,#0x36
0000d8  f880102f          STRB     r1,[r0,#0x2f]
;;;776                            goto tcp_send_nodata;
0000dc  f000bfe5          B.W      |L10.4266|
                  |L10.224|
;;;777                        }
;;;778    
;;;779                        /* Exponential backoff. */
;;;780                        uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
0000e0  7ee0              LDRB     r0,[r4,#0x1b]
0000e2  2804              CMP      r0,#4
0000e4  dd01              BLE      |L10.234|
;;;781                                     4:
0000e6  2004              MOVS     r0,#4
0000e8  e000              B        |L10.236|
                  |L10.234|
;;;782                                     uip_connr->nrtx);
0000ea  7ee0              LDRB     r0,[r4,#0x1b]
                  |L10.236|
0000ec  2103              MOVS     r1,#3
0000ee  4081              LSLS     r1,r1,r0
0000f0  76a1              STRB     r1,[r4,#0x1a]
;;;783                        ++(uip_connr->nrtx);
0000f2  7ee0              LDRB     r0,[r4,#0x1b]
0000f4  1c40              ADDS     r0,r0,#1
0000f6  76e0              STRB     r0,[r4,#0x1b]
;;;784              
;;;785                        /* Ok, so we need to retransmit. We do this differently
;;;786                         depending on which state we are in. In ESTABLISHED, we
;;;787                         call upon the application so that it may prepare the
;;;788                         data for the retransmit. In SYN_RCVD, we resend the
;;;789                         SYNACK that we sent earlier and in LAST_ACK we have to
;;;790                         retransmit our FINACK. */
;;;791                        UIP_STAT(++uip_stat.tcp.rexmit);
0000f8  48c9              LDR      r0,|L10.1056|
0000fa  8cc0              LDRH     r0,[r0,#0x26]
0000fc  1c40              ADDS     r0,r0,#1
0000fe  b281              UXTH     r1,r0
000100  48c7              LDR      r0,|L10.1056|
000102  84c1              STRH     r1,[r0,#0x26]
;;;792                        switch(uip_connr->tcpstateflags & UIP_TS_MASK) 
000104  7e60              LDRB     r0,[r4,#0x19]
000106  f000000f          AND      r0,r0,#0xf
00010a  2809              CMP      r0,#9
00010c  d222              BCS      |L10.340|
00010e  e8dff000          TBB      [pc,r0]
000112  2105              DCB      0x21,0x05
000114  070d1321          DCB      0x07,0x0d,0x13,0x21
000118  14211500          DCB      0x14,0x21,0x15,0x00
;;;793                        {
;;;794                            case UIP_SYN_RCVD:
;;;795                                /* In the SYN_RCVD state, we should retransmit our SYNACK. */
;;;796                                goto tcp_send_synack;
00011c  e3eb              B        |L10.2294|
                  |L10.286|
00011e  e01a              B        |L10.342|
;;;797    
;;;798    #if UIP_ACTIVE_OPEN
;;;799                            case UIP_SYN_SENT:
;;;800                                /* In the SYN_SENT state, we retransmit out SYN. */
;;;801                                BUF->flags = 0;
000120  2100              MOVS     r1,#0
000122  48b8              LDR      r0,|L10.1028|
000124  3836              SUBS     r0,r0,#0x36
000126  f880102f          STRB     r1,[r0,#0x2f]
;;;802                                goto tcp_send_syn;
00012a  e3e5              B        |L10.2296|
;;;803    #endif /* UIP_ACTIVE_OPEN */
;;;804                
;;;805                            case UIP_ESTABLISHED:
;;;806                                /* In the ESTABLISHED state, we call upon the application
;;;807                                       to do the actual retransmit after which we jump into
;;;808                                       the code for sending out the packet (the apprexmit
;;;809                                       label). */
;;;810                                uip_flags = UIP_REXMIT;
00012c  2004              MOVS     r0,#4
00012e  49b8              LDR      r1,|L10.1040|
000130  7008              STRB     r0,[r1,#0]
;;;811                                UIP_APPCALL();
000132  f7fffffe          BL       tcp_demo_appcall
;;;812                                goto apprexmit;
000136  e3e0              B        |L10.2298|
;;;813                
;;;814                            case UIP_FIN_WAIT_1:
;;;815                            case UIP_CLOSING:
000138  bf00              NOP      
;;;816                            case UIP_LAST_ACK:
00013a  bf00              NOP      
;;;817                                /* In all these states we should retransmit a FINACK. */
;;;818                                goto tcp_send_finack;
00013c  e3de              B        |L10.2300|
                  |L10.318|
;;;819                
;;;820                        }
;;;821                    }
;;;822                } 
;;;823                else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) 
00013e  7e60              LDRB     r0,[r4,#0x19]
000140  f000000f          AND      r0,r0,#0xf
000144  2803              CMP      r0,#3
000146  d105              BNE      |L10.340|
;;;824                {
;;;825                    /* If there was no need for a retransmission, we poll the
;;;826                    application for new data. */
;;;827                    uip_flags = UIP_POLL;
000148  2008              MOVS     r0,#8
00014a  49b1              LDR      r1,|L10.1040|
00014c  7008              STRB     r0,[r1,#0]
;;;828                    UIP_APPCALL();
00014e  f7fffffe          BL       tcp_demo_appcall
;;;829                    goto appsend;
000152  e76f              B        |L10.52|
                  |L10.340|
;;;830                }
;;;831            }
;;;832            goto drop;
000154  e770              B        |L10.56|
                  |L10.342|
;;;833        }
;;;834    //================================================================    
;;;835    
;;;836        
;;;837        
;;;838    //================================================================    
;;;839    #if UIP_UDP
;;;840        if(flag == UIP_UDP_TIMER) 
000156  2d05              CMP      r5,#5
000158  d118              BNE      |L10.396|
;;;841        {
;;;842            if(uip_udp_conn->lport != 0) 
00015a  48b2              LDR      r0,|L10.1060|
00015c  6800              LDR      r0,[r0,#0]  ; uip_udp_conn
00015e  8880              LDRH     r0,[r0,#4]
000160  b198              CBZ      r0,|L10.394|
;;;843            {
;;;844                uip_conn = NULL;
000162  2000              MOVS     r0,#0
000164  49a6              LDR      r1,|L10.1024|
000166  6008              STR      r0,[r1,#0]  ; uip_conn
;;;845                uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
000168  48a6              LDR      r0,|L10.1028|
00016a  380c              SUBS     r0,r0,#0xc
00016c  49a6              LDR      r1,|L10.1032|
00016e  6008              STR      r0,[r1,#0]  ; uip_appdata
000170  49a6              LDR      r1,|L10.1036|
000172  6008              STR      r0,[r1,#0]  ; uip_sappdata
;;;846                uip_len = uip_slen = 0;
000174  2000              MOVS     r0,#0
000176  49a9              LDR      r1,|L10.1052|
000178  8008              STRH     r0,[r1,#0]
00017a  49a7              LDR      r1,|L10.1048|
00017c  8008              STRH     r0,[r1,#0]
;;;847                uip_flags = UIP_POLL;
00017e  2008              MOVS     r0,#8
000180  49a3              LDR      r1,|L10.1040|
000182  7008              STRB     r0,[r1,#0]
;;;848                UIP_UDP_APPCALL();
000184  f7fffffe          BL       udp_demo_appcall
;;;849                goto udp_send;
000188  e1f4              B        |L10.1396|
                  |L10.394|
;;;850            }
;;;851            else
;;;852            {
;;;853              goto drop;
00018a  e755              B        |L10.56|
                  |L10.396|
;;;854            }
;;;855        }
;;;856    #endif
;;;857    //================================================================    
;;;858    
;;;859        
;;;860        /* This is where the input processing starts. */
;;;861      //   这里IP包的处理正式开始
;;;862        UIP_STAT(++uip_stat.ip.recv);
00018c  48a4              LDR      r0,|L10.1056|
00018e  8840              LDRH     r0,[r0,#2]  ; uip_stat
000190  1c40              ADDS     r0,r0,#1
000192  49a3              LDR      r1,|L10.1056|
000194  8048              STRH     r0,[r1,#2]
;;;863    
;;;864        /* Start of IP input header processing code. */
;;;865      
;;;866    #if UIP_CONF_IPV6
;;;867        /* Check validity of the IP header. */
;;;868        if((BUF->vtc & 0xf0) != 0x60)  
;;;869        {   /* IP version and header length. */
;;;870            UIP_STAT(++uip_stat.ip.drop);
;;;871            UIP_STAT(++uip_stat.ip.vhlerr);
;;;872            UIP_LOG("ipv6: invalid version.");
;;;873            goto drop;
;;;874        }
;;;875    #else /* UIP_CONF_IPV6 */
;;;876        /* Check validity of the IP header. */
;;;877        if(BUF->vhl != 0x45)  
000196  489b              LDR      r0,|L10.1028|
000198  3836              SUBS     r0,r0,#0x36
00019a  7b80              LDRB     r0,[r0,#0xe]  ; uip_buf
00019c  2845              CMP      r0,#0x45
00019e  d00b              BEQ      |L10.440|
;;;878        { /* IP version and header length. */
;;;879            UIP_STAT(++uip_stat.ip.drop);
0001a0  4608              MOV      r0,r1
0001a2  8800              LDRH     r0,[r0,#0]  ; uip_stat
0001a4  1c40              ADDS     r0,r0,#1
0001a6  8008              STRH     r0,[r1,#0]
;;;880            UIP_STAT(++uip_stat.ip.vhlerr);
0001a8  4608              MOV      r0,r1
0001aa  88c0              LDRH     r0,[r0,#6]  ; uip_stat
0001ac  1c40              ADDS     r0,r0,#1
0001ae  80c8              STRH     r0,[r1,#6]
;;;881            UIP_LOG("ip: invalid version or header length.");
0001b0  a09d              ADR      r0,|L10.1064|
0001b2  f7fffffe          BL       uip_log
;;;882            goto drop;
0001b6  e73f              B        |L10.56|
                  |L10.440|
;;;883        }
;;;884    #endif /* UIP_CONF_IPV6 */
;;;885      
;;;886        /* Check the size of the packet. If the size reported to us in
;;;887         uip_len is smaller the size reported in the IP header, we assume
;;;888         that the packet has been corrupted in transit. If the size of
;;;889         uip_len is larger than the size reported in the IP packet header,
;;;890         the packet has been padded and we set uip_len to the correct
;;;891         value.. */
;;;892    
;;;893        if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) 
0001b8  4892              LDR      r0,|L10.1028|
0001ba  3836              SUBS     r0,r0,#0x36
0001bc  7c41              LDRB     r1,[r0,#0x11]
0001be  7c00              LDRB     r0,[r0,#0x10]
0001c0  eb012000          ADD      r0,r1,r0,LSL #8
0001c4  4994              LDR      r1,|L10.1048|
0001c6  8809              LDRH     r1,[r1,#0]  ; uip_len
0001c8  4288              CMP      r0,r1
0001ca  dc08              BGT      |L10.478|
;;;894        {
;;;895            uip_len = (BUF->len[0] << 8) + BUF->len[1];
0001cc  488d              LDR      r0,|L10.1028|
0001ce  3836              SUBS     r0,r0,#0x36
0001d0  7c41              LDRB     r1,[r0,#0x11]
0001d2  7c00              LDRB     r0,[r0,#0x10]
0001d4  eb012000          ADD      r0,r1,r0,LSL #8
0001d8  498f              LDR      r1,|L10.1048|
0001da  8008              STRH     r0,[r1,#0]
0001dc  e003              B        |L10.486|
                  |L10.478|
;;;896    #if UIP_CONF_IPV6
;;;897            uip_len += 40; 
;;;898            /* The length reported in the IPv6 header is the
;;;899              length of the payload that follows the
;;;900              header. However, uIP uses the uip_len variable
;;;901              for holding the size of the entire packet,
;;;902              including the IP header. For IPv4 this is not a
;;;903              problem as the length field in the IPv4 header
;;;904              contains the length of the entire packet. But
;;;905              for IPv6 we need to add the size of the IPv6
;;;906              header (40 bytes). */
;;;907    #endif /* UIP_CONF_IPV6 */
;;;908        } 
;;;909        else 
;;;910        {
;;;911            UIP_LOG("ip: packet shorter than reported in IP header.");
0001de  a09c              ADR      r0,|L10.1104|
0001e0  f7fffffe          BL       uip_log
;;;912            goto drop;
0001e4  e728              B        |L10.56|
                  |L10.486|
;;;913        }
;;;914    
;;;915    #if !UIP_CONF_IPV6
;;;916        /* Check the fragment flag. */
;;;917        if((BUF->ipoffset[0] & 0x3f) != 0 ||
0001e6  4887              LDR      r0,|L10.1028|
0001e8  3836              SUBS     r0,r0,#0x36
0001ea  7d00              LDRB     r0,[r0,#0x14]
0001ec  f000003f          AND      r0,r0,#0x3f
0001f0  b918              CBNZ     r0,|L10.506|
;;;918         BUF->ipoffset[1] != 0) 
0001f2  4884              LDR      r0,|L10.1028|
0001f4  3836              SUBS     r0,r0,#0x36
0001f6  7d40              LDRB     r0,[r0,#0x15]
0001f8  b160              CBZ      r0,|L10.532|
                  |L10.506|
;;;919        {
;;;920    #if UIP_REASSEMBLY
;;;921            uip_len = uip_reass();
;;;922            if(uip_len == 0) 
;;;923            {
;;;924                goto drop;
;;;925            }
;;;926    #else /* UIP_REASSEMBLY */
;;;927            UIP_STAT(++uip_stat.ip.drop);
0001fa  4889              LDR      r0,|L10.1056|
0001fc  8800              LDRH     r0,[r0,#0]  ; uip_stat
0001fe  1c40              ADDS     r0,r0,#1
000200  4987              LDR      r1,|L10.1056|
000202  8008              STRH     r0,[r1,#0]
;;;928            UIP_STAT(++uip_stat.ip.fragerr);
000204  4608              MOV      r0,r1
000206  8980              LDRH     r0,[r0,#0xc]  ; uip_stat
000208  1c40              ADDS     r0,r0,#1
00020a  8188              STRH     r0,[r1,#0xc]
;;;929            UIP_LOG("ip: fragment dropped.");
00020c  a09c              ADR      r0,|L10.1152|
00020e  f7fffffe          BL       uip_log
;;;930            goto drop;
000212  e711              B        |L10.56|
                  |L10.532|
;;;931    #endif /* UIP_REASSEMBLY */
;;;932        }
;;;933    #endif /* UIP_CONF_IPV6 */
;;;934    
;;;935        if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) 
000214  48a0              LDR      r0,|L10.1176|
000216  8800              LDRH     r0,[r0,#0]  ; uip_hostaddr
000218  49a0              LDR      r1,|L10.1180|
00021a  8809              LDRH     r1,[r1,#0]  ; all_zeroes_addr
00021c  4288              CMP      r0,r1
00021e  d105              BNE      |L10.556|
000220  489d              LDR      r0,|L10.1176|
000222  8840              LDRH     r0,[r0,#2]  ; uip_hostaddr
000224  499d              LDR      r1,|L10.1180|
000226  8849              LDRH     r1,[r1,#2]  ; all_zeroes_addr
000228  4288              CMP      r0,r1
00022a  d013              BEQ      |L10.596|
                  |L10.556|
;;;936        {
;;;937            /* If we are configured to use ping IP address configuration and
;;;938               hasn't been assigned an IP address yet, we accept all ICMP
;;;939               packets. */
;;;940    #if UIP_PINGADDRCONF && !UIP_CONF_IPV6
;;;941            if(BUF->proto == UIP_PROTO_ICMP) 
;;;942            {
;;;943                UIP_LOG("ip: possible ping config packet received.");
;;;944                goto icmp_input;
;;;945            } 
;;;946            else 
;;;947            {
;;;948                UIP_LOG("ip: packet dropped since no address assigned.");
;;;949                goto drop;
;;;950            }
;;;951    #endif /* UIP_PINGADDRCONF */
;;;952        } 
;;;953        else 
;;;954        {
;;;955            /* If IP broadcast support is configured, we check for a broadcast
;;;956            UDP packet, which may be destined to us. */
;;;957    #if UIP_BROADCAST
;;;958            DEBUG_PRINTF("UDP IP checksum 0x%04x\n", uip_ipchksum());
;;;959            if(BUF->proto == UIP_PROTO_UDP &&
;;;960                uip_ipaddr_cmp(BUF->destipaddr, all_ones_addr)  
;;;961           /*&&
;;;962    	 uip_ipchksum() == 0xffff*/) 
;;;963            {
;;;964                goto udp_input;
;;;965            }
;;;966    #endif /* UIP_BROADCAST */
;;;967        
;;;968        /* Check if the packet is destined for our IP address. */
;;;969    #if !UIP_CONF_IPV6
;;;970            if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr)) 
00022c  4875              LDR      r0,|L10.1028|
00022e  3836              SUBS     r0,r0,#0x36
000230  8bc0              LDRH     r0,[r0,#0x1e]
000232  4999              LDR      r1,|L10.1176|
000234  8809              LDRH     r1,[r1,#0]  ; uip_hostaddr
000236  4288              CMP      r0,r1
000238  d106              BNE      |L10.584|
00023a  4872              LDR      r0,|L10.1028|
00023c  3836              SUBS     r0,r0,#0x36
00023e  8c00              LDRH     r0,[r0,#0x20]
000240  4995              LDR      r1,|L10.1176|
000242  8849              LDRH     r1,[r1,#2]  ; uip_hostaddr
000244  4288              CMP      r0,r1
000246  d005              BEQ      |L10.596|
                  |L10.584|
;;;971            {
;;;972                UIP_STAT(++uip_stat.ip.drop);
000248  4875              LDR      r0,|L10.1056|
00024a  8800              LDRH     r0,[r0,#0]  ; uip_stat
00024c  1c40              ADDS     r0,r0,#1
00024e  4974              LDR      r1,|L10.1056|
000250  8008              STRH     r0,[r1,#0]
;;;973                goto drop;
000252  e6f1              B        |L10.56|
                  |L10.596|
;;;974            }
;;;975    #else /* UIP_CONF_IPV6 */
;;;976        /* For IPv6, packet reception is a little trickier as we need to
;;;977           make sure that we listen to certain multicast addresses (all
;;;978           hosts multicast address, and the solicited-node multicast
;;;979           address) as well. However, we will cheat here and accept all
;;;980           multicast packets that are sent to the ff02::/16 addresses. */
;;;981            if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr) &&
;;;982                BUF->destipaddr[0] != HTONS(0xff02)) 
;;;983            {
;;;984                UIP_STAT(++uip_stat.ip.drop);
;;;985                goto drop;
;;;986            }
;;;987    #endif /* UIP_CONF_IPV6 */
;;;988        }
;;;989    
;;;990    #if !UIP_CONF_IPV6
;;;991        if(uip_ipchksum() != 0xffff) 
000254  f7fffffe          BL       uip_ipchksum
000258  f64f71ff          MOV      r1,#0xffff
00025c  4288              CMP      r0,r1
00025e  d00c              BEQ      |L10.634|
;;;992        { /* Compute and check the IP header
;;;993    				    checksum. */
;;;994            UIP_STAT(++uip_stat.ip.drop);
000260  486f              LDR      r0,|L10.1056|
000262  8800              LDRH     r0,[r0,#0]  ; uip_stat
000264  1c40              ADDS     r0,r0,#1
000266  496e              LDR      r1,|L10.1056|
000268  8008              STRH     r0,[r1,#0]
;;;995            UIP_STAT(++uip_stat.ip.chkerr);
00026a  4608              MOV      r0,r1
00026c  89c0              LDRH     r0,[r0,#0xe]  ; uip_stat
00026e  1c40              ADDS     r0,r0,#1
000270  81c8              STRH     r0,[r1,#0xe]
;;;996            UIP_LOG("ip: bad checksum.");
000272  a08b              ADR      r0,|L10.1184|
000274  f7fffffe          BL       uip_log
;;;997            goto drop;
000278  e6de              B        |L10.56|
                  |L10.634|
;;;998        }
;;;999    #endif /* UIP_CONF_IPV6 */
;;;1000   
;;;1001       if(BUF->proto == UIP_PROTO_TCP) 
00027a  4862              LDR      r0,|L10.1028|
00027c  3836              SUBS     r0,r0,#0x36
00027e  7dc0              LDRB     r0,[r0,#0x17]
000280  2806              CMP      r0,#6
000282  d100              BNE      |L10.646|
;;;1002       { /* Check for TCP packet. If so,
;;;1003   				       proceed with TCP input
;;;1004   				       processing. */
;;;1005           goto tcp_input;
000284  e1ce              B        |L10.1572|
                  |L10.646|
;;;1006       }
;;;1007   
;;;1008   #if UIP_UDP
;;;1009       if(BUF->proto == UIP_PROTO_UDP) 
000286  485f              LDR      r0,|L10.1028|
000288  3836              SUBS     r0,r0,#0x36
00028a  7dc0              LDRB     r0,[r0,#0x17]
00028c  2811              CMP      r0,#0x11
00028e  d100              BNE      |L10.658|
;;;1010       {
;;;1011           goto udp_input;
000290  e062              B        |L10.856|
                  |L10.658|
;;;1012       }
;;;1013   #endif /* UIP_UDP */
;;;1014   
;;;1015   #if !UIP_CONF_IPV6
;;;1016       /* ICMPv4 processing code follows. */
;;;1017       if(BUF->proto != UIP_PROTO_ICMP) 
000292  485c              LDR      r0,|L10.1028|
000294  3836              SUBS     r0,r0,#0x36
000296  7dc0              LDRB     r0,[r0,#0x17]
000298  2801              CMP      r0,#1
00029a  d00c              BEQ      |L10.694|
;;;1018       { /* We only allow ICMP packets from
;;;1019   					here. */
;;;1020           UIP_STAT(++uip_stat.ip.drop);
00029c  4860              LDR      r0,|L10.1056|
00029e  8800              LDRH     r0,[r0,#0]  ; uip_stat
0002a0  1c40              ADDS     r0,r0,#1
0002a2  495f              LDR      r1,|L10.1056|
0002a4  8008              STRH     r0,[r1,#0]
;;;1021           UIP_STAT(++uip_stat.ip.protoerr);
0002a6  4608              MOV      r0,r1
0002a8  8a00              LDRH     r0,[r0,#0x10]  ; uip_stat
0002aa  1c40              ADDS     r0,r0,#1
0002ac  8208              STRH     r0,[r1,#0x10]
;;;1022           UIP_LOG("ip: neither tcp nor icmp.");
0002ae  a081              ADR      r0,|L10.1204|
0002b0  f7fffffe          BL       uip_log
;;;1023           goto drop;
0002b4  e6c0              B        |L10.56|
                  |L10.694|
;;;1024       }
;;;1025   
;;;1026       
;;;1027       
;;;1028       
;;;1029       
;;;1030   #if UIP_PINGADDRCONF
;;;1031    icmp_input:
;;;1032   #endif /* UIP_PINGADDRCONF */
;;;1033       UIP_STAT(++uip_stat.icmp.recv);
0002b6  485a              LDR      r0,|L10.1056|
0002b8  8a80              LDRH     r0,[r0,#0x14]
0002ba  1c40              ADDS     r0,r0,#1
0002bc  b281              UXTH     r1,r0
0002be  4858              LDR      r0,|L10.1056|
0002c0  8281              STRH     r1,[r0,#0x14]
;;;1034   
;;;1035       /* ICMP echo (i.e., ping) processing. This is simple, we only change
;;;1036        the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
;;;1037        checksum before we return the packet. */
;;;1038       if(ICMPBUF->type != ICMP_ECHO) 
0002c2  4850              LDR      r0,|L10.1028|
0002c4  3836              SUBS     r0,r0,#0x36
0002c6  f8900022          LDRB     r0,[r0,#0x22]
0002ca  2808              CMP      r0,#8
0002cc  d00e              BEQ      |L10.748|
;;;1039       {
;;;1040           UIP_STAT(++uip_stat.icmp.drop);
0002ce  4854              LDR      r0,|L10.1056|
0002d0  8a40              LDRH     r0,[r0,#0x12]  ; uip_stat
0002d2  1c40              ADDS     r0,r0,#1
0002d4  4952              LDR      r1,|L10.1056|
0002d6  8248              STRH     r0,[r1,#0x12]
;;;1041           UIP_STAT(++uip_stat.icmp.typeerr);
0002d8  4608              MOV      r0,r1
0002da  8b00              LDRH     r0,[r0,#0x18]
0002dc  1c40              ADDS     r0,r0,#1
0002de  b281              UXTH     r1,r0
0002e0  484f              LDR      r0,|L10.1056|
0002e2  8301              STRH     r1,[r0,#0x18]
;;;1042           UIP_LOG("icmp: not icmp echo.");
0002e4  a07a              ADR      r0,|L10.1232|
0002e6  f7fffffe          BL       uip_log
;;;1043           goto drop;
0002ea  e6a5              B        |L10.56|
                  |L10.748|
;;;1044       }
;;;1045   
;;;1046       /* If we are configured to use ping IP address assignment, we use
;;;1047        the destination IP address of this ping packet and assign it to
;;;1048        ourself. */
;;;1049   #if UIP_PINGADDRCONF
;;;1050       if((uip_hostaddr[0] | uip_hostaddr[1]) == 0) 
;;;1051       {
;;;1052           uip_hostaddr[0] = BUF->destipaddr[0];
;;;1053           uip_hostaddr[1] = BUF->destipaddr[1];
;;;1054       }
;;;1055   #endif /* UIP_PINGADDRCONF */
;;;1056   
;;;1057       ICMPBUF->type = ICMP_ECHO_REPLY;
0002ec  2100              MOVS     r1,#0
0002ee  4845              LDR      r0,|L10.1028|
0002f0  3836              SUBS     r0,r0,#0x36
0002f2  f8801022          STRB     r1,[r0,#0x22]
;;;1058   
;;;1059       if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) 
0002f6  8c80              LDRH     r0,[r0,#0x24]
0002f8  f64f71f7          MOV      r1,#0xfff7
0002fc  4288              CMP      r0,r1
0002fe  db08              BLT      |L10.786|
;;;1060       {
;;;1061           ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
000300  4840              LDR      r0,|L10.1028|
000302  3836              SUBS     r0,r0,#0x36
000304  8c80              LDRH     r0,[r0,#0x24]
000306  3009              ADDS     r0,r0,#9
000308  b281              UXTH     r1,r0
00030a  483e              LDR      r0,|L10.1028|
00030c  3836              SUBS     r0,r0,#0x36
00030e  8481              STRH     r1,[r0,#0x24]
000310  e007              B        |L10.802|
                  |L10.786|
;;;1062       } else 
;;;1063       {
;;;1064           ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
000312  483c              LDR      r0,|L10.1028|
000314  3836              SUBS     r0,r0,#0x36
000316  8c80              LDRH     r0,[r0,#0x24]
000318  3008              ADDS     r0,r0,#8
00031a  b281              UXTH     r1,r0
00031c  4839              LDR      r0,|L10.1028|
00031e  3836              SUBS     r0,r0,#0x36
000320  8481              STRH     r1,[r0,#0x24]
                  |L10.802|
;;;1065       }
;;;1066   
;;;1067       /* Swap IP addresses. */
;;;1068       uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
000322  bf00              NOP      
000324  4837              LDR      r0,|L10.1028|
000326  3836              SUBS     r0,r0,#0x36
000328  8b41              LDRH     r1,[r0,#0x1a]
00032a  83c1              STRH     r1,[r0,#0x1e]
00032c  8b81              LDRH     r1,[r0,#0x1c]
00032e  8401              STRH     r1,[r0,#0x20]
000330  bf00              NOP      
;;;1069       uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
000332  bf00              NOP      
000334  4858              LDR      r0,|L10.1176|
000336  8801              LDRH     r1,[r0,#0]  ; uip_hostaddr
000338  4832              LDR      r0,|L10.1028|
00033a  3836              SUBS     r0,r0,#0x36
00033c  8341              STRH     r1,[r0,#0x1a]
00033e  4856              LDR      r0,|L10.1176|
000340  8841              LDRH     r1,[r0,#2]  ; uip_hostaddr
000342  4830              LDR      r0,|L10.1028|
000344  3836              SUBS     r0,r0,#0x36
000346  8381              STRH     r1,[r0,#0x1c]
000348  bf00              NOP      
;;;1070   
;;;1071       UIP_STAT(++uip_stat.icmp.sent);
00034a  4835              LDR      r0,|L10.1056|
00034c  8ac0              LDRH     r0,[r0,#0x16]
00034e  1c40              ADDS     r0,r0,#1
000350  b281              UXTH     r1,r0
000352  4833              LDR      r0,|L10.1056|
000354  82c1              STRH     r1,[r0,#0x16]
;;;1072       goto send;
000356  e3fd              B        |L10.2900|
                  |L10.856|
;;;1073   
;;;1074       /* End of IPv4 input header processing code. */
;;;1075   #else /* !UIP_CONF_IPV6 */
;;;1076   
;;;1077       /* This is IPv6 ICMPv6 processing code. */
;;;1078       DEBUG_PRINTF("icmp6_input: length %d\n", uip_len);
;;;1079   
;;;1080       if(BUF->proto != UIP_PROTO_ICMP6) 
;;;1081       { /* We only allow ICMPv6 packets from
;;;1082   					 here. */
;;;1083           UIP_STAT(++uip_stat.ip.drop);
;;;1084           UIP_STAT(++uip_stat.ip.protoerr);
;;;1085           UIP_LOG("ip: neither tcp nor icmp6.");
;;;1086           goto drop;
;;;1087       }
;;;1088   
;;;1089       UIP_STAT(++uip_stat.icmp.recv);
;;;1090   
;;;1091       /* If we get a neighbor solicitation for our address we should send
;;;1092        a neighbor advertisement message back. */
;;;1093       if(ICMPBUF->type == ICMP6_NEIGHBOR_SOLICITATION) 
;;;1094       {
;;;1095           if(uip_ipaddr_cmp(ICMPBUF->icmp6data, uip_hostaddr)) 
;;;1096           {
;;;1097               if(ICMPBUF->options[0] == ICMP6_OPTION_SOURCE_LINK_ADDRESS) 
;;;1098               {
;;;1099                   /* Save the sender's address in our neighbor list. */
;;;1100                   uip_neighbor_add(ICMPBUF->srcipaddr, &(ICMPBUF->options[2]));
;;;1101               }
;;;1102               /* We should now send a neighbor advertisement back to where the
;;;1103               neighbor solicication came from. */
;;;1104               ICMPBUF->type = ICMP6_NEIGHBOR_ADVERTISEMENT;
;;;1105               ICMPBUF->flags = ICMP6_FLAG_S; /* Solicited flag. */
;;;1106         
;;;1107               ICMPBUF->reserved1 = ICMPBUF->reserved2 = ICMPBUF->reserved3 = 0;
;;;1108         
;;;1109               uip_ipaddr_copy(ICMPBUF->destipaddr, ICMPBUF->srcipaddr);
;;;1110               uip_ipaddr_copy(ICMPBUF->srcipaddr, uip_hostaddr);
;;;1111               ICMPBUF->options[0] = ICMP6_OPTION_TARGET_LINK_ADDRESS;
;;;1112               ICMPBUF->options[1] = 1;  /* Options length, 1 = 8 bytes. */
;;;1113               memcpy(&(ICMPBUF->options[2]), &uip_ethaddr, sizeof(uip_ethaddr));
;;;1114               ICMPBUF->icmpchksum = 0;
;;;1115               ICMPBUF->icmpchksum = ~uip_icmp6chksum();
;;;1116               goto send;
;;;1117         
;;;1118           }
;;;1119           goto drop;
;;;1120       } 
;;;1121       else if(ICMPBUF->type == ICMP6_ECHO) 
;;;1122       {
;;;1123           /* ICMP echo (i.e., ping) processing. This is simple, we only
;;;1124           change the ICMP type from ECHO to ECHO_REPLY and update the
;;;1125           ICMP checksum before we return the packet. */
;;;1126   
;;;1127           ICMPBUF->type = ICMP6_ECHO_REPLY;
;;;1128   
;;;1129           uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
;;;1130           uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
;;;1131           ICMPBUF->icmpchksum = 0;
;;;1132           ICMPBUF->icmpchksum = ~uip_icmp6chksum();
;;;1133       
;;;1134           UIP_STAT(++uip_stat.icmp.sent);
;;;1135           goto send;
;;;1136       } 
;;;1137       else 
;;;1138       {
;;;1139           DEBUG_PRINTF("Unknown icmp6 message type %d\n", ICMPBUF->type);
;;;1140           UIP_STAT(++uip_stat.icmp.drop);
;;;1141           UIP_STAT(++uip_stat.icmp.typeerr);
;;;1142           UIP_LOG("icmp: unknown ICMP message.");
;;;1143           goto drop;
;;;1144       }
;;;1145   
;;;1146       /* End of IPv6 ICMP processing. */
;;;1147     
;;;1148   #endif /* !UIP_CONF_IPV6 */
;;;1149   
;;;1150   #if UIP_UDP
;;;1151       /* UDP input processing. */
;;;1152    udp_input:
;;;1153       /* UDP processing is really just a hack. We don't do anything to the
;;;1154        UDP/IP headers, but let the UDP application do all the hard
;;;1155        work. If the application sets uip_slen, it has a packet to
;;;1156        send. */
;;;1157   #if UIP_UDP_CHECKSUMS
;;;1158       uip_len = uip_len - UIP_IPUDPH_LEN;
000358  482f              LDR      r0,|L10.1048|
00035a  8800              LDRH     r0,[r0,#0]  ; uip_len
00035c  381c              SUBS     r0,r0,#0x1c
00035e  492e              LDR      r1,|L10.1048|
000360  8008              STRH     r0,[r1,#0]
;;;1159       uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
000362  4828              LDR      r0,|L10.1028|
000364  380c              SUBS     r0,r0,#0xc
000366  4928              LDR      r1,|L10.1032|
000368  6008              STR      r0,[r1,#0]  ; uip_appdata
;;;1160       if(UDPBUF->udpchksum != 0 && uip_udpchksum() != 0xffff) 
00036a  382a              SUBS     r0,r0,#0x2a
00036c  8d00              LDRH     r0,[r0,#0x28]
00036e  b1a0              CBZ      r0,|L10.922|
000370  f7fffffe          BL       uip_udpchksum
000374  f64f71ff          MOV      r1,#0xffff
000378  4288              CMP      r0,r1
00037a  d00e              BEQ      |L10.922|
;;;1161       {
;;;1162           UIP_STAT(++uip_stat.udp.drop);
00037c  4828              LDR      r0,|L10.1056|
00037e  8d80              LDRH     r0,[r0,#0x2c]  ; uip_stat
000380  1c40              ADDS     r0,r0,#1
000382  4927              LDR      r1,|L10.1056|
000384  8588              STRH     r0,[r1,#0x2c]
;;;1163           UIP_STAT(++uip_stat.udp.chkerr);
000386  4608              MOV      r0,r1
000388  8e40              LDRH     r0,[r0,#0x32]
00038a  1c40              ADDS     r0,r0,#1
00038c  b281              UXTH     r1,r0
00038e  4824              LDR      r0,|L10.1056|
000390  8641              STRH     r1,[r0,#0x32]
;;;1164           UIP_LOG("udp: bad checksum.");
000392  a055              ADR      r0,|L10.1256|
000394  f7fffffe          BL       uip_log
;;;1165           goto drop;
000398  e64e              B        |L10.56|
                  |L10.922|
;;;1166       }
;;;1167   #else /* UIP_UDP_CHECKSUMS */
;;;1168       uip_len = uip_len - UIP_IPUDPH_LEN;
;;;1169   #endif /* UIP_UDP_CHECKSUMS */
;;;1170       /* Demultiplex this UDP packet between the UDP "connections". */
;;;1171       for(uip_udp_conn = &uip_udp_conns[0];
00039a  4858              LDR      r0,|L10.1276|
00039c  4921              LDR      r1,|L10.1060|
00039e  6008              STR      r0,[r1,#0]  ; uip_udp_conn
0003a0  e0cc              B        |L10.1340|
                  |L10.930|
;;;1172         uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
;;;1173         ++uip_udp_conn) 
;;;1174       {
;;;1175           /* If the local UDP port is non-zero, the connection is considered
;;;1176              to be used. If so, the local port number is checked against the
;;;1177              destination port number in the received packet. If the two port
;;;1178              numbers match, the remote port number is checked if the
;;;1179              connection is bound to a remote port. Finally, if the
;;;1180              connection is bound to a remote IP address, the source IP
;;;1181              address of the packet is checked. */
;;;1182           if(uip_udp_conn->lport != 0 &&
0003a2  4820              LDR      r0,|L10.1060|
0003a4  6800              LDR      r0,[r0,#0]  ; uip_udp_conn
0003a6  8880              LDRH     r0,[r0,#4]
0003a8  b340              CBZ      r0,|L10.1020|
;;;1183              UDPBUF->destport == uip_udp_conn->lport &&
0003aa  4816              LDR      r0,|L10.1028|
0003ac  3836              SUBS     r0,r0,#0x36
0003ae  8c80              LDRH     r0,[r0,#0x24]
0003b0  491c              LDR      r1,|L10.1060|
0003b2  6809              LDR      r1,[r1,#0]  ; uip_udp_conn
0003b4  8889              LDRH     r1,[r1,#4]
0003b6  4288              CMP      r0,r1
0003b8  d120              BNE      |L10.1020|
;;;1184              (uip_udp_conn->rport == 0 ||
0003ba  481a              LDR      r0,|L10.1060|
0003bc  6800              LDR      r0,[r0,#0]  ; uip_udp_conn
0003be  88c0              LDRH     r0,[r0,#6]
0003c0  b138              CBZ      r0,|L10.978|
;;;1185               UDPBUF->srcport == uip_udp_conn->rport) &&
0003c2  4810              LDR      r0,|L10.1028|
0003c4  3836              SUBS     r0,r0,#0x36
0003c6  8c40              LDRH     r0,[r0,#0x22]
0003c8  4916              LDR      r1,|L10.1060|
0003ca  6809              LDR      r1,[r1,#0]  ; uip_udp_conn
0003cc  88c9              LDRH     r1,[r1,#6]
0003ce  4288              CMP      r0,r1
0003d0  d114              BNE      |L10.1020|
                  |L10.978|
;;;1186              (uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_zeroes_addr) ||
0003d2  4814              LDR      r0,|L10.1060|
0003d4  6800              LDR      r0,[r0,#0]  ; uip_udp_conn
0003d6  8800              LDRH     r0,[r0,#0]
0003d8  4930              LDR      r1,|L10.1180|
0003da  8809              LDRH     r1,[r1,#0]  ; all_zeroes_addr
0003dc  4288              CMP      r0,r1
0003de  d106              BNE      |L10.1006|
0003e0  4810              LDR      r0,|L10.1060|
0003e2  6800              LDR      r0,[r0,#0]  ; uip_udp_conn
0003e4  8840              LDRH     r0,[r0,#2]
0003e6  492d              LDR      r1,|L10.1180|
0003e8  8849              LDRH     r1,[r1,#2]  ; all_zeroes_addr
0003ea  4288              CMP      r0,r1
0003ec  d007              BEQ      |L10.1022|
                  |L10.1006|
;;;1187           uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_ones_addr) ||
0003ee  480d              LDR      r0,|L10.1060|
0003f0  6800              LDR      r0,[r0,#0]  ; uip_udp_conn
0003f2  8800              LDRH     r0,[r0,#0]
0003f4  4942              LDR      r1,|L10.1280|
0003f6  8809              LDRH     r1,[r1,#0]  ; all_ones_addr
0003f8  4288              CMP      r0,r1
0003fa  e083              B        |L10.1284|
                  |L10.1020|
0003fc  e099              B        |L10.1330|
                  |L10.1022|
0003fe  e097              B        |L10.1328|
                  |L10.1024|
                          DCD      uip_conn
                  |L10.1028|
                          DCD      uip_buf+0x36
                  |L10.1032|
                          DCD      uip_appdata
                  |L10.1036|
                          DCD      uip_sappdata
                  |L10.1040|
                          DCD      uip_flags
                  |L10.1044|
                          DCD      iss
                  |L10.1048|
                          DCD      uip_len
                  |L10.1052|
                          DCD      uip_slen
                  |L10.1056|
                          DCD      uip_stat
                  |L10.1060|
                          DCD      uip_udp_conn
                  |L10.1064|
000428  69703a20          DCB      "ip: invalid version or header length.",0
00042c  696e7661
000430  6c696420
000434  76657273
000438  696f6e20
00043c  6f722068
000440  65616465
000444  72206c65
000448  6e677468
00044c  2e00    
00044e  00                DCB      0
00044f  00                DCB      0
                  |L10.1104|
000450  69703a20          DCB      "ip: packet shorter than reported in IP header.",0
000454  7061636b
000458  65742073
00045c  686f7274
000460  65722074
000464  68616e20
000468  7265706f
00046c  72746564
000470  20696e20
000474  49502068
000478  65616465
00047c  722e00  
00047f  00                DCB      0
                  |L10.1152|
000480  69703a20          DCB      "ip: fragment dropped.",0
000484  66726167
000488  6d656e74
00048c  2064726f
000490  70706564
000494  2e00    
000496  00                DCB      0
000497  00                DCB      0
                  |L10.1176|
                          DCD      uip_hostaddr
                  |L10.1180|
                          DCD      all_zeroes_addr
                  |L10.1184|
0004a0  69703a20          DCB      "ip: bad checksum.",0
0004a4  62616420
0004a8  63686563
0004ac  6b73756d
0004b0  2e00    
0004b2  00                DCB      0
0004b3  00                DCB      0
                  |L10.1204|
0004b4  69703a20          DCB      "ip: neither tcp nor icmp.",0
0004b8  6e656974
0004bc  68657220
0004c0  74637020
0004c4  6e6f7220
0004c8  69636d70
0004cc  2e00    
0004ce  00                DCB      0
0004cf  00                DCB      0
                  |L10.1232|
0004d0  69636d70          DCB      "icmp: not icmp echo.",0
0004d4  3a206e6f
0004d8  74206963
0004dc  6d702065
0004e0  63686f2e
0004e4  00      
0004e5  00                DCB      0
0004e6  00                DCB      0
0004e7  00                DCB      0
                  |L10.1256|
0004e8  7564703a          DCB      "udp: bad checksum.",0
0004ec  20626164
0004f0  20636865
0004f4  636b7375
0004f8  6d2e00  
0004fb  00                DCB      0
                  |L10.1276|
                          DCD      uip_udp_conns
                  |L10.1280|
                          DCD      all_ones_addr
                  |L10.1284|
000504  d106              BNE      |L10.1300|
000506  48fe              LDR      r0,|L10.2304|
000508  6800              LDR      r0,[r0,#0]  ; uip_udp_conn
00050a  8840              LDRH     r0,[r0,#2]
00050c  49fd              LDR      r1,|L10.2308|
00050e  8849              LDRH     r1,[r1,#2]  ; all_ones_addr
000510  4288              CMP      r0,r1
000512  d00d              BEQ      |L10.1328|
                  |L10.1300|
;;;1188           uip_ipaddr_cmp(BUF->srcipaddr, uip_udp_conn->ripaddr))) 
000514  48fc              LDR      r0,|L10.2312|
000516  8b40              LDRH     r0,[r0,#0x1a]
000518  49f9              LDR      r1,|L10.2304|
00051a  6809              LDR      r1,[r1,#0]  ; uip_udp_conn
00051c  8809              LDRH     r1,[r1,#0]
00051e  4288              CMP      r0,r1
000520  d107              BNE      |L10.1330|
000522  48f9              LDR      r0,|L10.2312|
000524  8b80              LDRH     r0,[r0,#0x1c]
000526  49f6              LDR      r1,|L10.2304|
000528  6809              LDR      r1,[r1,#0]  ; uip_udp_conn
00052a  8849              LDRH     r1,[r1,#2]
00052c  4288              CMP      r0,r1
00052e  d100              BNE      |L10.1330|
                  |L10.1328|
;;;1189           {
;;;1190             goto udp_found;
000530  e00e              B        |L10.1360|
                  |L10.1330|
000532  48f3              LDR      r0,|L10.2304|
000534  6800              LDR      r0,[r0,#0]            ;1173  ; uip_udp_conn
000536  300a              ADDS     r0,r0,#0xa            ;1173
000538  49f1              LDR      r1,|L10.2304|
00053a  6008              STR      r0,[r1,#0]            ;1173  ; uip_udp_conn
                  |L10.1340|
00053c  48f0              LDR      r0,|L10.2304|
00053e  6801              LDR      r1,[r0,#0]            ;1172  ; uip_udp_conn
000540  48f2              LDR      r0,|L10.2316|
000542  4281              CMP      r1,r0                 ;1172
000544  f4ffaf2d          BCC      |L10.930|
;;;1191           }
;;;1192       }
;;;1193       UIP_LOG("udp: no matching connection found");
000548  a0f1              ADR      r0,|L10.2320|
00054a  f7fffffe          BL       uip_log
;;;1194       goto drop;
00054e  e573              B        |L10.56|
                  |L10.1360|
;;;1195     
;;;1196    udp_found:
;;;1197       uip_conn = NULL;
000550  2000              MOVS     r0,#0
000552  49f8              LDR      r1,|L10.2356|
000554  6008              STR      r0,[r1,#0]  ; uip_conn
;;;1198       uip_flags = UIP_NEWDATA;
000556  2002              MOVS     r0,#2
000558  49f7              LDR      r1,|L10.2360|
00055a  7008              STRB     r0,[r1,#0]
;;;1199       uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
00055c  48ea              LDR      r0,|L10.2312|
00055e  302a              ADDS     r0,r0,#0x2a
000560  49f6              LDR      r1,|L10.2364|
000562  6008              STR      r0,[r1,#0]  ; uip_appdata
000564  49f6              LDR      r1,|L10.2368|
000566  6008              STR      r0,[r1,#0]  ; uip_sappdata
;;;1200       uip_slen = 0;
000568  2000              MOVS     r0,#0
00056a  49f6              LDR      r1,|L10.2372|
00056c  8008              STRH     r0,[r1,#0]
;;;1201       UIP_UDP_APPCALL();
00056e  f7fffffe          BL       udp_demo_appcall
;;;1202    udp_send:
000572  bf00              NOP      
                  |L10.1396|
;;;1203       if(uip_slen == 0) 
000574  48f3              LDR      r0,|L10.2372|
000576  8800              LDRH     r0,[r0,#0]  ; uip_slen
000578  b900              CBNZ     r0,|L10.1404|
;;;1204       {
;;;1205           goto drop;
00057a  e55d              B        |L10.56|
                  |L10.1404|
;;;1206       }
;;;1207       uip_len = uip_slen + UIP_IPUDPH_LEN;
00057c  48f1              LDR      r0,|L10.2372|
00057e  8800              LDRH     r0,[r0,#0]  ; uip_slen
000580  301c              ADDS     r0,r0,#0x1c
000582  49f1              LDR      r1,|L10.2376|
000584  8008              STRH     r0,[r1,#0]
;;;1208   
;;;1209   #if UIP_CONF_IPV6
;;;1210       /* For IPv6, the IP length field does not include the IPv6 IP header
;;;1211           length. */
;;;1212       BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
;;;1213       BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
;;;1214   #else /* UIP_CONF_IPV6 */
;;;1215       BUF->len[0] = (uip_len >> 8);
000586  4608              MOV      r0,r1
000588  8800              LDRH     r0,[r0,#0]  ; uip_len
00058a  1201              ASRS     r1,r0,#8
00058c  48de              LDR      r0,|L10.2312|
00058e  7401              STRB     r1,[r0,#0x10]
;;;1216       BUF->len[1] = (uip_len & 0xff);
000590  48ed              LDR      r0,|L10.2376|
000592  7801              LDRB     r1,[r0,#0]  ; uip_len
000594  48dc              LDR      r0,|L10.2312|
000596  7441              STRB     r1,[r0,#0x11]
;;;1217   #endif /* UIP_CONF_IPV6 */
;;;1218   
;;;1219       BUF->ttl = uip_udp_conn->ttl;
000598  48d9              LDR      r0,|L10.2304|
00059a  6800              LDR      r0,[r0,#0]  ; uip_udp_conn
00059c  7a01              LDRB     r1,[r0,#8]
00059e  48da              LDR      r0,|L10.2312|
0005a0  7581              STRB     r1,[r0,#0x16]
;;;1220       BUF->proto = UIP_PROTO_UDP;
0005a2  2111              MOVS     r1,#0x11
0005a4  75c1              STRB     r1,[r0,#0x17]
;;;1221   
;;;1222       UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
0005a6  48e7              LDR      r0,|L10.2372|
0005a8  8800              LDRH     r0,[r0,#0]  ; uip_slen
0005aa  3008              ADDS     r0,r0,#8
0005ac  f3c02107          UBFX     r1,r0,#8,#8
0005b0  48e4              LDR      r0,|L10.2372|
0005b2  7800              LDRB     r0,[r0,#0]  ; uip_slen
0005b4  3008              ADDS     r0,r0,#8
0005b6  ea412000          ORR      r0,r1,r0,LSL #8
0005ba  b281              UXTH     r1,r0
0005bc  48d2              LDR      r0,|L10.2312|
0005be  84c1              STRH     r1,[r0,#0x26]
;;;1223       UDPBUF->udpchksum = 0;
0005c0  2100              MOVS     r1,#0
0005c2  8501              STRH     r1,[r0,#0x28]
;;;1224   
;;;1225       BUF->srcport  = uip_udp_conn->lport;
0005c4  48ce              LDR      r0,|L10.2304|
0005c6  6800              LDR      r0,[r0,#0]  ; uip_udp_conn
0005c8  8881              LDRH     r1,[r0,#4]
0005ca  48cf              LDR      r0,|L10.2312|
0005cc  8441              STRH     r1,[r0,#0x22]
;;;1226       BUF->destport = uip_udp_conn->rport;
0005ce  48cc              LDR      r0,|L10.2304|
0005d0  6800              LDR      r0,[r0,#0]  ; uip_udp_conn
0005d2  88c1              LDRH     r1,[r0,#6]
0005d4  48cc              LDR      r0,|L10.2312|
0005d6  8481              STRH     r1,[r0,#0x24]
;;;1227   
;;;1228       uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
0005d8  bf00              NOP      
0005da  48dc              LDR      r0,|L10.2380|
0005dc  8801              LDRH     r1,[r0,#0]  ; uip_hostaddr
0005de  48ca              LDR      r0,|L10.2312|
0005e0  8341              STRH     r1,[r0,#0x1a]
0005e2  48da              LDR      r0,|L10.2380|
0005e4  8841              LDRH     r1,[r0,#2]  ; uip_hostaddr
0005e6  48c8              LDR      r0,|L10.2312|
0005e8  8381              STRH     r1,[r0,#0x1c]
0005ea  bf00              NOP      
;;;1229       uip_ipaddr_copy(BUF->destipaddr, uip_udp_conn->ripaddr);
0005ec  bf00              NOP      
0005ee  48c4              LDR      r0,|L10.2304|
0005f0  6800              LDR      r0,[r0,#0]  ; uip_udp_conn
0005f2  8801              LDRH     r1,[r0,#0]
0005f4  48c4              LDR      r0,|L10.2312|
0005f6  83c1              STRH     r1,[r0,#0x1e]
0005f8  48c1              LDR      r0,|L10.2304|
0005fa  6800              LDR      r0,[r0,#0]  ; uip_udp_conn
0005fc  8841              LDRH     r1,[r0,#2]
0005fe  48c2              LDR      r0,|L10.2312|
000600  8401              STRH     r1,[r0,#0x20]
000602  bf00              NOP      
;;;1230      
;;;1231       uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
000604  3036              ADDS     r0,r0,#0x36
000606  49cd              LDR      r1,|L10.2364|
000608  6008              STR      r0,[r1,#0]  ; uip_appdata
;;;1232   
;;;1233   #if UIP_UDP_CHECKSUMS
;;;1234       /* Calculate UDP checksum. */
;;;1235       UDPBUF->udpchksum = ~(uip_udpchksum());
00060a  f7fffffe          BL       uip_udpchksum
00060e  43c0              MVNS     r0,r0
000610  b281              UXTH     r1,r0
000612  48bd              LDR      r0,|L10.2312|
000614  8501              STRH     r1,[r0,#0x28]
;;;1236       if(UDPBUF->udpchksum == 0) 
000616  8d00              LDRH     r0,[r0,#0x28]
000618  b918              CBNZ     r0,|L10.1570|
;;;1237       {
;;;1238           UDPBUF->udpchksum = 0xffff;
00061a  f64f71ff          MOV      r1,#0xffff
00061e  48ba              LDR      r0,|L10.2312|
000620  8501              STRH     r1,[r0,#0x28]
                  |L10.1570|
;;;1239       }
;;;1240   #endif /* UIP_UDP_CHECKSUMS */
;;;1241     
;;;1242       goto ip_send_nolen;
000622  e3f2              B        |L10.3594|
                  |L10.1572|
;;;1243   #endif /* UIP_UDP */
;;;1244     
;;;1245    /* TCP input processing. */
;;;1246    tcp_input:
;;;1247       UIP_STAT(++uip_stat.tcp.recv);
000624  48ca              LDR      r0,|L10.2384|
000626  8b80              LDRH     r0,[r0,#0x1c]
000628  1c40              ADDS     r0,r0,#1
00062a  b281              UXTH     r1,r0
00062c  48c8              LDR      r0,|L10.2384|
00062e  8381              STRH     r1,[r0,#0x1c]
;;;1248   
;;;1249       /* Start of TCP input header processing code. */
;;;1250     
;;;1251       if(uip_tcpchksum() != 0xffff) 
000630  f7fffffe          BL       uip_tcpchksum
000634  f64f71ff          MOV      r1,#0xffff
000638  4288              CMP      r0,r1
00063a  d00e              BEQ      |L10.1626|
;;;1252       {   /* Compute and check the TCP
;;;1253   				       checksum. */
;;;1254           UIP_STAT(++uip_stat.tcp.drop);
00063c  48c4              LDR      r0,|L10.2384|
00063e  8b40              LDRH     r0,[r0,#0x1a]  ; uip_stat
000640  1c40              ADDS     r0,r0,#1
000642  49c3              LDR      r1,|L10.2384|
000644  8348              STRH     r0,[r1,#0x1a]
;;;1255           UIP_STAT(++uip_stat.tcp.chkerr);
000646  4608              MOV      r0,r1
000648  8c00              LDRH     r0,[r0,#0x20]
00064a  1c40              ADDS     r0,r0,#1
00064c  b281              UXTH     r1,r0
00064e  48c0              LDR      r0,|L10.2384|
000650  8401              STRH     r1,[r0,#0x20]
;;;1256           UIP_LOG("tcp: bad checksum.");
000652  a0c0              ADR      r0,|L10.2388|
000654  f7fffffe          BL       uip_log
;;;1257           goto drop;
000658  e4ee              B        |L10.56|
                  |L10.1626|
;;;1258       }
;;;1259     
;;;1260     
;;;1261       /* Demultiplex this segment. */
;;;1262       /* First check any active connections. */
;;;1263       for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
00065a  4cc3              LDR      r4,|L10.2408|
00065c  e017              B        |L10.1678|
                  |L10.1630|
;;;1264           ++uip_connr) 
;;;1265       {
;;;1266           if(uip_connr->tcpstateflags != UIP_CLOSED &&
00065e  7e60              LDRB     r0,[r4,#0x19]
000660  b1a0              CBZ      r0,|L10.1676|
;;;1267           BUF->destport == uip_connr->lport &&
000662  48a9              LDR      r0,|L10.2312|
000664  8c80              LDRH     r0,[r0,#0x24]
000666  88a1              LDRH     r1,[r4,#4]
000668  4288              CMP      r0,r1
00066a  d10f              BNE      |L10.1676|
;;;1268           BUF->srcport == uip_connr->rport &&
00066c  48a6              LDR      r0,|L10.2312|
00066e  8c40              LDRH     r0,[r0,#0x22]
000670  88e1              LDRH     r1,[r4,#6]
000672  4288              CMP      r0,r1
000674  d10a              BNE      |L10.1676|
;;;1269           uip_ipaddr_cmp(BUF->srcipaddr, uip_connr->ripaddr)) 
000676  48a4              LDR      r0,|L10.2312|
000678  8b40              LDRH     r0,[r0,#0x1a]
00067a  8821              LDRH     r1,[r4,#0]
00067c  4288              CMP      r0,r1
00067e  d105              BNE      |L10.1676|
000680  48a1              LDR      r0,|L10.2312|
000682  8b80              LDRH     r0,[r0,#0x1c]
000684  8861              LDRH     r1,[r4,#2]
000686  4288              CMP      r0,r1
000688  d100              BNE      |L10.1676|
;;;1270           {
;;;1271               goto found;
00068a  e211              B        |L10.2736|
                  |L10.1676|
00068c  3428              ADDS     r4,r4,#0x28           ;1264
                  |L10.1678|
00068e  48b7              LDR      r0,|L10.2412|
000690  4284              CMP      r4,r0                 ;1263
000692  d9e4              BLS      |L10.1630|
;;;1272           }
;;;1273       }
;;;1274   
;;;1275       /* If we didn't find and active connection that expected the packet,
;;;1276        either this packet is an old duplicate, or this is a SYN packet
;;;1277        destined for a connection in LISTEN. If the SYN flag isn't set,
;;;1278        it is an old packet and we send a RST. */
;;;1279       if((BUF->flags & TCP_CTL) != TCP_SYN) 
000694  489c              LDR      r0,|L10.2312|
000696  f890002f          LDRB     r0,[r0,#0x2f]
00069a  f000003f          AND      r0,r0,#0x3f
00069e  2802              CMP      r0,#2
0006a0  d000              BEQ      |L10.1700|
;;;1280       {
;;;1281           goto reset;
0006a2  e021              B        |L10.1768|
                  |L10.1700|
;;;1282       }
;;;1283     
;;;1284       tmp16 = BUF->destport;
0006a4  4898              LDR      r0,|L10.2312|
0006a6  8c80              LDRH     r0,[r0,#0x24]
0006a8  49b1              LDR      r1,|L10.2416|
0006aa  8008              STRH     r0,[r1,#0]
;;;1285       /* Next, check listening connections. */
;;;1286       for(c = 0; c < UIP_LISTENPORTS; ++c) 
0006ac  2000              MOVS     r0,#0
0006ae  49b1              LDR      r1,|L10.2420|
0006b0  7008              STRB     r0,[r1,#0]
0006b2  e00e              B        |L10.1746|
                  |L10.1716|
;;;1287       {
;;;1288           if(tmp16 == uip_listenports[c])
0006b4  48b0              LDR      r0,|L10.2424|
0006b6  49af              LDR      r1,|L10.2420|
0006b8  7809              LDRB     r1,[r1,#0]  ; c
0006ba  f8300011          LDRH     r0,[r0,r1,LSL #1]
0006be  49ac              LDR      r1,|L10.2416|
0006c0  8809              LDRH     r1,[r1,#0]  ; tmp16
0006c2  4288              CMP      r0,r1
0006c4  d100              BNE      |L10.1736|
;;;1289           {
;;;1290               goto found_listen;
0006c6  e09a              B        |L10.2046|
                  |L10.1736|
0006c8  48aa              LDR      r0,|L10.2420|
0006ca  7800              LDRB     r0,[r0,#0]            ;1286  ; c
0006cc  1c40              ADDS     r0,r0,#1              ;1286
0006ce  49a9              LDR      r1,|L10.2420|
0006d0  7008              STRB     r0,[r1,#0]            ;1286
                  |L10.1746|
0006d2  48a8              LDR      r0,|L10.2420|
0006d4  7800              LDRB     r0,[r0,#0]            ;1286  ; c
0006d6  2828              CMP      r0,#0x28              ;1286
0006d8  dbec              BLT      |L10.1716|
;;;1291           }
;;;1292       }
;;;1293     
;;;1294       /* No matching connection found, so we send a RST packet. */
;;;1295       UIP_STAT(++uip_stat.tcp.synrst);
0006da  489d              LDR      r0,|L10.2384|
0006dc  8d40              LDRH     r0,[r0,#0x2a]
0006de  1c40              ADDS     r0,r0,#1
0006e0  b281              UXTH     r1,r0
0006e2  489b              LDR      r0,|L10.2384|
0006e4  8541              STRH     r1,[r0,#0x2a]
;;;1296    reset:
0006e6  bf00              NOP      
                  |L10.1768|
;;;1297   
;;;1298       /* We do not send resets in response to resets. */
;;;1299       if(BUF->flags & TCP_RST) 
0006e8  4887              LDR      r0,|L10.2312|
0006ea  f890002f          LDRB     r0,[r0,#0x2f]
0006ee  f0000004          AND      r0,r0,#4
0006f2  b100              CBZ      r0,|L10.1782|
;;;1300       {
;;;1301           goto drop;
0006f4  e4a0              B        |L10.56|
                  |L10.1782|
;;;1302       }
;;;1303   
;;;1304       UIP_STAT(++uip_stat.tcp.rst);
0006f6  4896              LDR      r0,|L10.2384|
0006f8  8c80              LDRH     r0,[r0,#0x24]
0006fa  1c40              ADDS     r0,r0,#1
0006fc  b281              UXTH     r1,r0
0006fe  4894              LDR      r0,|L10.2384|
000700  8481              STRH     r1,[r0,#0x24]
;;;1305     
;;;1306       BUF->flags = TCP_RST | TCP_ACK;
000702  2114              MOVS     r1,#0x14
000704  4880              LDR      r0,|L10.2312|
000706  f880102f          STRB     r1,[r0,#0x2f]
;;;1307       uip_len = UIP_IPTCPH_LEN;
00070a  2028              MOVS     r0,#0x28
00070c  498e              LDR      r1,|L10.2376|
00070e  8008              STRH     r0,[r1,#0]
;;;1308       BUF->tcpoffset = 5 << 4;
000710  2150              MOVS     r1,#0x50
000712  487d              LDR      r0,|L10.2312|
000714  f880102e          STRB     r1,[r0,#0x2e]
;;;1309   
;;;1310       /* Flip the seqno and ackno fields in the TCP header. */
;;;1311       c = BUF->seqno[3];
000718  f8900029          LDRB     r0,[r0,#0x29]
00071c  4995              LDR      r1,|L10.2420|
00071e  7008              STRB     r0,[r1,#0]
;;;1312       BUF->seqno[3] = BUF->ackno[3];
000720  4879              LDR      r0,|L10.2312|
000722  f890102d          LDRB     r1,[r0,#0x2d]
000726  f8801029          STRB     r1,[r0,#0x29]
;;;1313       BUF->ackno[3] = c;
00072a  4892              LDR      r0,|L10.2420|
00072c  7801              LDRB     r1,[r0,#0]  ; c
00072e  4876              LDR      r0,|L10.2312|
000730  f880102d          STRB     r1,[r0,#0x2d]
;;;1314     
;;;1315       c = BUF->seqno[2];
000734  f8900028          LDRB     r0,[r0,#0x28]
000738  498e              LDR      r1,|L10.2420|
00073a  7008              STRB     r0,[r1,#0]
;;;1316       BUF->seqno[2] = BUF->ackno[2];
00073c  4872              LDR      r0,|L10.2312|
00073e  f890102c          LDRB     r1,[r0,#0x2c]
000742  f8801028          STRB     r1,[r0,#0x28]
;;;1317       BUF->ackno[2] = c;
000746  488b              LDR      r0,|L10.2420|
000748  7801              LDRB     r1,[r0,#0]  ; c
00074a  486f              LDR      r0,|L10.2312|
00074c  f880102c          STRB     r1,[r0,#0x2c]
;;;1318     
;;;1319       c = BUF->seqno[1];
000750  f8900027          LDRB     r0,[r0,#0x27]
000754  4987              LDR      r1,|L10.2420|
000756  7008              STRB     r0,[r1,#0]
;;;1320       BUF->seqno[1] = BUF->ackno[1];
000758  486b              LDR      r0,|L10.2312|
00075a  f890102b          LDRB     r1,[r0,#0x2b]
00075e  f8801027          STRB     r1,[r0,#0x27]
;;;1321       BUF->ackno[1] = c;
000762  4884              LDR      r0,|L10.2420|
000764  7801              LDRB     r1,[r0,#0]  ; c
000766  4868              LDR      r0,|L10.2312|
000768  f880102b          STRB     r1,[r0,#0x2b]
;;;1322     
;;;1323       c = BUF->seqno[0];
00076c  f8900026          LDRB     r0,[r0,#0x26]
000770  4980              LDR      r1,|L10.2420|
000772  7008              STRB     r0,[r1,#0]
;;;1324       BUF->seqno[0] = BUF->ackno[0];
000774  4864              LDR      r0,|L10.2312|
000776  f890102a          LDRB     r1,[r0,#0x2a]
00077a  f8801026          STRB     r1,[r0,#0x26]
;;;1325       BUF->ackno[0] = c;
00077e  487d              LDR      r0,|L10.2420|
000780  7801              LDRB     r1,[r0,#0]  ; c
000782  4861              LDR      r0,|L10.2312|
000784  f880102a          STRB     r1,[r0,#0x2a]
;;;1326   
;;;1327       /* We also have to increase the sequence number we are
;;;1328        acknowledging. If the least significant byte overflowed, we need
;;;1329        to propagate the carry to the other bytes as well. */
;;;1330       if(++BUF->ackno[3] == 0) {
000788  f890002d          LDRB     r0,[r0,#0x2d]
00078c  1c40              ADDS     r0,r0,#1
00078e  b2c1              UXTB     r1,r0
000790  485d              LDR      r0,|L10.2312|
000792  f880102d          STRB     r1,[r0,#0x2d]
000796  b9b1              CBNZ     r1,|L10.1990|
;;;1331           if(++BUF->ackno[2] == 0) {
000798  f890002c          LDRB     r0,[r0,#0x2c]
00079c  1c40              ADDS     r0,r0,#1
00079e  b2c1              UXTB     r1,r0
0007a0  4859              LDR      r0,|L10.2312|
0007a2  f880102c          STRB     r1,[r0,#0x2c]
0007a6  b971              CBNZ     r1,|L10.1990|
;;;1332               if(++BUF->ackno[1] == 0) {
0007a8  f890002b          LDRB     r0,[r0,#0x2b]
0007ac  1c40              ADDS     r0,r0,#1
0007ae  b2c1              UXTB     r1,r0
0007b0  4855              LDR      r0,|L10.2312|
0007b2  f880102b          STRB     r1,[r0,#0x2b]
0007b6  b931              CBNZ     r1,|L10.1990|
;;;1333                   ++BUF->ackno[0];
0007b8  f890002a          LDRB     r0,[r0,#0x2a]
0007bc  1c40              ADDS     r0,r0,#1
0007be  b2c1              UXTB     r1,r0
0007c0  4851              LDR      r0,|L10.2312|
0007c2  f880102a          STRB     r1,[r0,#0x2a]
                  |L10.1990|
;;;1334               }
;;;1335           }
;;;1336       }
;;;1337    
;;;1338       /* Swap port numbers. */
;;;1339       tmp16 = BUF->srcport;
0007c6  4850              LDR      r0,|L10.2312|
0007c8  8c40              LDRH     r0,[r0,#0x22]
0007ca  4969              LDR      r1,|L10.2416|
0007cc  8008              STRH     r0,[r1,#0]
;;;1340       BUF->srcport = BUF->destport;
0007ce  484e              LDR      r0,|L10.2312|
0007d0  8c81              LDRH     r1,[r0,#0x24]
0007d2  8441              STRH     r1,[r0,#0x22]
;;;1341       BUF->destport = tmp16;
0007d4  4866              LDR      r0,|L10.2416|
0007d6  8801              LDRH     r1,[r0,#0]  ; tmp16
0007d8  484b              LDR      r0,|L10.2312|
0007da  8481              STRH     r1,[r0,#0x24]
;;;1342     
;;;1343       /* Swap IP addresses. */
;;;1344       uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
0007dc  bf00              NOP      
0007de  8b41              LDRH     r1,[r0,#0x1a]
0007e0  83c1              STRH     r1,[r0,#0x1e]
0007e2  8b81              LDRH     r1,[r0,#0x1c]
0007e4  8401              STRH     r1,[r0,#0x20]
0007e6  bf00              NOP      
;;;1345       uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
0007e8  bf00              NOP      
0007ea  4858              LDR      r0,|L10.2380|
0007ec  8801              LDRH     r1,[r0,#0]  ; uip_hostaddr
0007ee  4846              LDR      r0,|L10.2312|
0007f0  8341              STRH     r1,[r0,#0x1a]
0007f2  4856              LDR      r0,|L10.2380|
0007f4  8841              LDRH     r1,[r0,#2]  ; uip_hostaddr
0007f6  4844              LDR      r0,|L10.2312|
0007f8  8381              STRH     r1,[r0,#0x1c]
0007fa  bf00              NOP      
;;;1346     
;;;1347       /* And send out the RST packet! */
;;;1348       goto tcp_send_noconn;
0007fc  e3fd              B        |L10.4090|
                  |L10.2046|
;;;1349   
;;;1350       /* This label will be jumped to if we matched the incoming packet
;;;1351        with a connection in LISTEN. In that case, we should create a new
;;;1352        connection and send a SYNACK in return. */
;;;1353    found_listen:
;;;1354       /* First we check if there are any connections avaliable. Unused
;;;1355        connections are kept in the same table as used connections, but
;;;1356        unused ones have the tcpstate set to CLOSED. Also, connections in
;;;1357        TIME_WAIT are kept track of and we'll use the oldest one if no
;;;1358        CLOSED connections are found. Thanks to Eddie C. Dost for a very
;;;1359        nice algorithm for the TIME_WAIT search. */
;;;1360       uip_connr = 0;
0007fe  2400              MOVS     r4,#0
;;;1361       for(c = 0; c < UIP_CONNS; ++c) 
000800  2000              MOVS     r0,#0
000802  495c              LDR      r1,|L10.2420|
000804  7008              STRB     r0,[r1,#0]
000806  e030              B        |L10.2154|
                  |L10.2056|
;;;1362       {
;;;1363           if(uip_conns[c].tcpstateflags == UIP_CLOSED) 
000808  485a              LDR      r0,|L10.2420|
00080a  7800              LDRB     r0,[r0,#0]  ; c
00080c  eb000080          ADD      r0,r0,r0,LSL #2
000810  4955              LDR      r1,|L10.2408|
000812  eb0100c0          ADD      r0,r1,r0,LSL #3
000816  7e40              LDRB     r0,[r0,#0x19]
000818  b930              CBNZ     r0,|L10.2088|
;;;1364           {
;;;1365               uip_connr = &uip_conns[c];
00081a  4856              LDR      r0,|L10.2420|
00081c  7800              LDRB     r0,[r0,#0]  ; c
00081e  eb000080          ADD      r0,r0,r0,LSL #2
000822  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;1366               break;
000826  e024              B        |L10.2162|
                  |L10.2088|
;;;1367           }
;;;1368           if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) 
000828  4852              LDR      r0,|L10.2420|
00082a  7800              LDRB     r0,[r0,#0]  ; c
00082c  eb000080          ADD      r0,r0,r0,LSL #2
000830  494d              LDR      r1,|L10.2408|
000832  eb0100c0          ADD      r0,r1,r0,LSL #3
000836  7e40              LDRB     r0,[r0,#0x19]
000838  2807              CMP      r0,#7
00083a  d111              BNE      |L10.2144|
;;;1369           {
;;;1370               if(uip_connr == 0 ||
00083c  b14c              CBZ      r4,|L10.2130|
;;;1371                   uip_conns[c].timer > uip_connr->timer) 
00083e  484d              LDR      r0,|L10.2420|
000840  7800              LDRB     r0,[r0,#0]  ; c
000842  eb000080          ADD      r0,r0,r0,LSL #2
000846  eb0100c0          ADD      r0,r1,r0,LSL #3
00084a  7e80              LDRB     r0,[r0,#0x1a]
00084c  7ea1              LDRB     r1,[r4,#0x1a]
00084e  4288              CMP      r0,r1
000850  dd06              BLE      |L10.2144|
                  |L10.2130|
;;;1372               {
;;;1373                       uip_connr = &uip_conns[c];
000852  4848              LDR      r0,|L10.2420|
000854  7800              LDRB     r0,[r0,#0]  ; c
000856  eb000080          ADD      r0,r0,r0,LSL #2
00085a  4943              LDR      r1,|L10.2408|
00085c  eb0104c0          ADD      r4,r1,r0,LSL #3
                  |L10.2144|
000860  4844              LDR      r0,|L10.2420|
000862  7800              LDRB     r0,[r0,#0]            ;1361  ; c
000864  1c40              ADDS     r0,r0,#1              ;1361
000866  4943              LDR      r1,|L10.2420|
000868  7008              STRB     r0,[r1,#0]            ;1361
                  |L10.2154|
00086a  4842              LDR      r0,|L10.2420|
00086c  7800              LDRB     r0,[r0,#0]            ;1361  ; c
00086e  2828              CMP      r0,#0x28              ;1361
000870  dbca              BLT      |L10.2056|
                  |L10.2162|
000872  bf00              NOP                            ;1366
;;;1374               }
;;;1375           }
;;;1376       }
;;;1377   
;;;1378       if(uip_connr == 0) 
000874  b94c              CBNZ     r4,|L10.2186|
;;;1379       {
;;;1380           /* All connections are used already, we drop packet and hope that
;;;1381          the remote end will retransmit the packet at a time when we
;;;1382          have more spare connections. */
;;;1383           UIP_STAT(++uip_stat.tcp.syndrop);
000876  4836              LDR      r0,|L10.2384|
000878  8d00              LDRH     r0,[r0,#0x28]
00087a  1c40              ADDS     r0,r0,#1
00087c  b281              UXTH     r1,r0
00087e  4834              LDR      r0,|L10.2384|
000880  8501              STRH     r1,[r0,#0x28]
;;;1384           UIP_LOG("tcp: found no unused connections.");
000882  a03e              ADR      r0,|L10.2428|
000884  f7fffffe          BL       uip_log
;;;1385           goto drop;
000888  e464              B        |L10.340|
                  |L10.2186|
;;;1386       }
;;;1387       uip_conn = uip_connr;
00088a  482a              LDR      r0,|L10.2356|
00088c  6004              STR      r4,[r0,#0]  ; uip_conn
;;;1388     
;;;1389       /* Fill in the necessary fields for the new connection. */
;;;1390       uip_connr->rto = uip_connr->timer = UIP_RTO;
00088e  2003              MOVS     r0,#3
000890  76a0              STRB     r0,[r4,#0x1a]
000892  7620              STRB     r0,[r4,#0x18]
;;;1391       uip_connr->sa = 0;
000894  2000              MOVS     r0,#0
000896  75a0              STRB     r0,[r4,#0x16]
;;;1392       uip_connr->sv = 4;
000898  2004              MOVS     r0,#4
00089a  75e0              STRB     r0,[r4,#0x17]
;;;1393       uip_connr->nrtx = 0;
00089c  2000              MOVS     r0,#0
00089e  76e0              STRB     r0,[r4,#0x1b]
;;;1394       uip_connr->lport = BUF->destport;
0008a0  4819              LDR      r0,|L10.2312|
0008a2  8c80              LDRH     r0,[r0,#0x24]
0008a4  80a0              STRH     r0,[r4,#4]
;;;1395       uip_connr->rport = BUF->srcport;
0008a6  4818              LDR      r0,|L10.2312|
0008a8  8c40              LDRH     r0,[r0,#0x22]
0008aa  80e0              STRH     r0,[r4,#6]
;;;1396       uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
0008ac  bf00              NOP      
0008ae  4816              LDR      r0,|L10.2312|
0008b0  8b40              LDRH     r0,[r0,#0x1a]
0008b2  8020              STRH     r0,[r4,#0]
0008b4  4814              LDR      r0,|L10.2312|
0008b6  8b80              LDRH     r0,[r0,#0x1c]
0008b8  8060              STRH     r0,[r4,#2]
0008ba  bf00              NOP      
;;;1397       uip_connr->tcpstateflags = UIP_SYN_RCVD;
0008bc  2001              MOVS     r0,#1
0008be  7660              STRB     r0,[r4,#0x19]
;;;1398   
;;;1399       uip_connr->snd_nxt[0] = iss[0];
0008c0  4837              LDR      r0,|L10.2464|
0008c2  7800              LDRB     r0,[r0,#0]  ; iss
0008c4  7320              STRB     r0,[r4,#0xc]
;;;1400       uip_connr->snd_nxt[1] = iss[1];
0008c6  4836              LDR      r0,|L10.2464|
0008c8  7841              LDRB     r1,[r0,#1]  ; iss
0008ca  7361              STRB     r1,[r4,#0xd]
;;;1401       uip_connr->snd_nxt[2] = iss[2];
0008cc  7881              LDRB     r1,[r0,#2]  ; iss
0008ce  73a1              STRB     r1,[r4,#0xe]
;;;1402       uip_connr->snd_nxt[3] = iss[3];
0008d0  78c1              LDRB     r1,[r0,#3]  ; iss
0008d2  73e1              STRB     r1,[r4,#0xf]
;;;1403       uip_connr->len = 1;
0008d4  2001              MOVS     r0,#1
0008d6  8220              STRH     r0,[r4,#0x10]
;;;1404   
;;;1405       /* rcv_nxt should be the seqno from the incoming packet + 1. */
;;;1406       uip_connr->rcv_nxt[3] = BUF->seqno[3];
0008d8  480b              LDR      r0,|L10.2312|
0008da  f8901029          LDRB     r1,[r0,#0x29]
0008de  72e1              STRB     r1,[r4,#0xb]
;;;1407       uip_connr->rcv_nxt[2] = BUF->seqno[2];
0008e0  f8901028          LDRB     r1,[r0,#0x28]
0008e4  72a1              STRB     r1,[r4,#0xa]
;;;1408       uip_connr->rcv_nxt[1] = BUF->seqno[1];
0008e6  f8901027          LDRB     r1,[r0,#0x27]
0008ea  7261              STRB     r1,[r4,#9]
;;;1409       uip_connr->rcv_nxt[0] = BUF->seqno[0];
0008ec  f8900026          LDRB     r0,[r0,#0x26]
0008f0  7220              STRB     r0,[r4,#8]
;;;1410       uip_add_rcv_nxt(1);
0008f2  2001              MOVS     r0,#1
0008f4  e056              B        |L10.2468|
                  |L10.2294|
0008f6  e0ba              B        |L10.2670|
                  |L10.2296|
0008f8  e0be              B        |L10.2680|
                  |L10.2298|
0008fa  e33e              B        |L10.3962|
                  |L10.2300|
0008fc  e2a4              B        |L10.3656|
0008fe  0000              DCW      0x0000
                  |L10.2304|
                          DCD      uip_udp_conn
                  |L10.2308|
                          DCD      all_ones_addr
                  |L10.2312|
                          DCD      uip_buf
                  |L10.2316|
                          DCD      uip_udp_conns+0x64
                  |L10.2320|
000910  7564703a          DCB      "udp: no matching connection found",0
000914  206e6f20
000918  6d617463
00091c  68696e67
000920  20636f6e
000924  6e656374
000928  696f6e20
00092c  666f756e
000930  6400    
000932  00                DCB      0
000933  00                DCB      0
                  |L10.2356|
                          DCD      uip_conn
                  |L10.2360|
                          DCD      uip_flags
                  |L10.2364|
                          DCD      uip_appdata
                  |L10.2368|
                          DCD      uip_sappdata
                  |L10.2372|
                          DCD      uip_slen
                  |L10.2376|
                          DCD      uip_len
                  |L10.2380|
                          DCD      uip_hostaddr
                  |L10.2384|
                          DCD      uip_stat
                  |L10.2388|
000954  7463703a          DCB      "tcp: bad checksum.",0
000958  20626164
00095c  20636865
000960  636b7375
000964  6d2e00  
000967  00                DCB      0
                  |L10.2408|
                          DCD      uip_conns
                  |L10.2412|
                          DCD      uip_conns+0x618
                  |L10.2416|
                          DCD      tmp16
                  |L10.2420|
                          DCD      c
                  |L10.2424|
                          DCD      uip_listenports
                  |L10.2428|
00097c  7463703a          DCB      "tcp: found no unused connections.",0
000980  20666f75
000984  6e64206e
000988  6f20756e
00098c  75736564
000990  20636f6e
000994  6e656374
000998  696f6e73
00099c  2e00    
00099e  00                DCB      0
00099f  00                DCB      0
                  |L10.2464|
                          DCD      iss
                  |L10.2468|
0009a4  f7fffffe          BL       uip_add_rcv_nxt
;;;1411   
;;;1412       /* Parse the TCP MSS option, if present. */
;;;1413       if((BUF->tcpoffset & 0xf0) > 0x50) 
0009a8  48f7              LDR      r0,|L10.3464|
0009aa  f890002e          LDRB     r0,[r0,#0x2e]
0009ae  f00000f0          AND      r0,r0,#0xf0
0009b2  2850              CMP      r0,#0x50
0009b4  dd5a              BLE      |L10.2668|
;;;1414       {
;;;1415           for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) 
0009b6  2000              MOVS     r0,#0
0009b8  49f4              LDR      r1,|L10.3468|
0009ba  7008              STRB     r0,[r1,#0]
0009bc  e04a              B        |L10.2644|
                  |L10.2494|
;;;1416           {
;;;1417               opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
0009be  48f3              LDR      r0,|L10.3468|
0009c0  7800              LDRB     r0,[r0,#0]  ; c
0009c2  3036              ADDS     r0,r0,#0x36
0009c4  49f0              LDR      r1,|L10.3464|
0009c6  5c08              LDRB     r0,[r1,r0]
0009c8  49f1              LDR      r1,|L10.3472|
0009ca  7008              STRB     r0,[r1,#0]
;;;1418               if(opt == TCP_OPT_END) 
0009cc  4608              MOV      r0,r1
0009ce  7800              LDRB     r0,[r0,#0]  ; opt
0009d0  b900              CBNZ     r0,|L10.2516|
;;;1419               {
;;;1420               /* End of options. */
;;;1421                   break;
0009d2  e04a              B        |L10.2666|
                  |L10.2516|
;;;1422               } 
;;;1423               else if(opt == TCP_OPT_NOOP) 
0009d4  48ee              LDR      r0,|L10.3472|
0009d6  7800              LDRB     r0,[r0,#0]  ; opt
0009d8  2801              CMP      r0,#1
0009da  d105              BNE      |L10.2536|
;;;1424               {
;;;1425                   ++c;
0009dc  48eb              LDR      r0,|L10.3468|
0009de  7800              LDRB     r0,[r0,#0]  ; c
0009e0  1c40              ADDS     r0,r0,#1
0009e2  49ea              LDR      r1,|L10.3468|
0009e4  7008              STRB     r0,[r1,#0]
0009e6  e035              B        |L10.2644|
                  |L10.2536|
;;;1426               /* NOP option. */
;;;1427               } 
;;;1428               else if(opt == TCP_OPT_MSS &&
0009e8  48e9              LDR      r0,|L10.3472|
0009ea  7800              LDRB     r0,[r0,#0]  ; opt
0009ec  2802              CMP      r0,#2
0009ee  d120              BNE      |L10.2610|
;;;1429                       uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) 
0009f0  48e6              LDR      r0,|L10.3468|
0009f2  7800              LDRB     r0,[r0,#0]  ; c
0009f4  3037              ADDS     r0,r0,#0x37
0009f6  49e4              LDR      r1,|L10.3464|
0009f8  5c08              LDRB     r0,[r1,r0]
0009fa  2804              CMP      r0,#4
0009fc  d119              BNE      |L10.2610|
;;;1430               {
;;;1431                   /* An MSS option with the right option length. */
;;;1432                   tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
0009fe  48e3              LDR      r0,|L10.3468|
000a00  7800              LDRB     r0,[r0,#0]  ; c
000a02  3039              ADDS     r0,r0,#0x39
000a04  5c09              LDRB     r1,[r1,r0]
000a06  48e1              LDR      r0,|L10.3468|
000a08  7800              LDRB     r0,[r0,#0]  ; c
000a0a  3038              ADDS     r0,r0,#0x38
000a0c  4ade              LDR      r2,|L10.3464|
000a0e  5c10              LDRB     r0,[r2,r0]
000a10  ea412000          ORR      r0,r1,r0,LSL #8
000a14  49df              LDR      r1,|L10.3476|
000a16  8008              STRH     r0,[r1,#0]
;;;1433                           (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
;;;1434                   uip_connr->initialmss = uip_connr->mss =
000a18  4608              MOV      r0,r1
000a1a  8800              LDRH     r0,[r0,#0]  ; tmp16
000a1c  f64071ca          MOV      r1,#0xfca
000a20  4288              CMP      r0,r1
000a22  dd01              BLE      |L10.2600|
;;;1435                   tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
000a24  4608              MOV      r0,r1
000a26  e001              B        |L10.2604|
                  |L10.2600|
000a28  48da              LDR      r0,|L10.3476|
000a2a  8800              LDRH     r0,[r0,#0]  ; tmp16
                  |L10.2604|
000a2c  8260              STRH     r0,[r4,#0x12]
000a2e  82a0              STRH     r0,[r4,#0x14]
;;;1436   	
;;;1437                   /* And we are done processing options. */
;;;1438                   break;
000a30  e01b              B        |L10.2666|
                  |L10.2610|
;;;1439               } 
;;;1440               else 
;;;1441               {
;;;1442                   /* All other options have a length field, so that we easily
;;;1443                   can skip past them. */
;;;1444                   if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) 
000a32  48d6              LDR      r0,|L10.3468|
000a34  7800              LDRB     r0,[r0,#0]  ; c
000a36  3037              ADDS     r0,r0,#0x37
000a38  49d3              LDR      r1,|L10.3464|
000a3a  5c08              LDRB     r0,[r1,r0]
000a3c  b900              CBNZ     r0,|L10.2624|
;;;1445                   {
;;;1446                       /* If the length field is zero, the options are malformed
;;;1447                       and we don't process them further. */
;;;1448                       break;
000a3e  e014              B        |L10.2666|
                  |L10.2624|
;;;1449                   }
;;;1450                   c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
000a40  48d2              LDR      r0,|L10.3468|
000a42  7800              LDRB     r0,[r0,#0]  ; c
000a44  3037              ADDS     r0,r0,#0x37
000a46  49d0              LDR      r1,|L10.3464|
000a48  5c08              LDRB     r0,[r1,r0]
000a4a  49d0              LDR      r1,|L10.3468|
000a4c  7809              LDRB     r1,[r1,#0]  ; c
000a4e  4408              ADD      r0,r0,r1
000a50  49ce              LDR      r1,|L10.3468|
000a52  7008              STRB     r0,[r1,#0]
                  |L10.2644|
000a54  48cc              LDR      r0,|L10.3464|
000a56  f890002e          LDRB     r0,[r0,#0x2e]         ;1415
000a5a  2105              MOVS     r1,#5                 ;1415
000a5c  ebc11020          RSB      r0,r1,r0,ASR #4       ;1415
000a60  49ca              LDR      r1,|L10.3468|
000a62  7809              LDRB     r1,[r1,#0]            ;1415  ; c
000a64  ebb10f80          CMP      r1,r0,LSL #2          ;1415
000a68  dba9              BLT      |L10.2494|
                  |L10.2666|
000a6a  bf00              NOP                            ;1421
                  |L10.2668|
;;;1451               }
;;;1452           }
;;;1453       }
;;;1454       /* Our response will be a SYNACK. */
;;;1455   #if UIP_ACTIVE_OPEN
;;;1456    tcp_send_synack:
000a6c  bf00              NOP      
                  |L10.2670|
;;;1457       BUF->flags = TCP_ACK;
000a6e  2110              MOVS     r1,#0x10
000a70  48c5              LDR      r0,|L10.3464|
000a72  f880102f          STRB     r1,[r0,#0x2f]
;;;1458     
;;;1459    tcp_send_syn:
000a76  bf00              NOP      
                  |L10.2680|
;;;1460       BUF->flags |= TCP_SYN;
000a78  48c3              LDR      r0,|L10.3464|
000a7a  f890002f          LDRB     r0,[r0,#0x2f]
000a7e  f0400102          ORR      r1,r0,#2
000a82  48c1              LDR      r0,|L10.3464|
000a84  f880102f          STRB     r1,[r0,#0x2f]
;;;1461   #else /* UIP_ACTIVE_OPEN */
;;;1462       tcp_send_synack:
;;;1463       BUF->flags = TCP_SYN | TCP_ACK;
;;;1464   #endif /* UIP_ACTIVE_OPEN */
;;;1465     
;;;1466       /* We send out the TCP Maximum Segment Size option with our
;;;1467        SYNACK. */
;;;1468       BUF->optdata[0] = TCP_OPT_MSS;
000a88  2102              MOVS     r1,#2
000a8a  f8801036          STRB     r1,[r0,#0x36]
;;;1469       BUF->optdata[1] = TCP_OPT_MSS_LEN;
000a8e  2104              MOVS     r1,#4
000a90  f8801037          STRB     r1,[r0,#0x37]
;;;1470       BUF->optdata[2] = (UIP_TCP_MSS) / 256;
000a94  210f              MOVS     r1,#0xf
000a96  f8801038          STRB     r1,[r0,#0x38]
;;;1471       BUF->optdata[3] = (UIP_TCP_MSS) & 255;
000a9a  21ca              MOVS     r1,#0xca
000a9c  f8801039          STRB     r1,[r0,#0x39]
;;;1472       uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
000aa0  202c              MOVS     r0,#0x2c
000aa2  49bd              LDR      r1,|L10.3480|
000aa4  8008              STRH     r0,[r1,#0]
;;;1473       BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
000aa6  2160              MOVS     r1,#0x60
000aa8  48b7              LDR      r0,|L10.3464|
000aaa  f880102e          STRB     r1,[r0,#0x2e]
;;;1474       goto tcp_send;
000aae  e305              B        |L10.4284|
                  |L10.2736|
;;;1475   
;;;1476       /* This label will be jumped to if we found an active connection. */
;;;1477    found:
;;;1478       uip_conn = uip_connr;
000ab0  48ba              LDR      r0,|L10.3484|
000ab2  6004              STR      r4,[r0,#0]  ; uip_conn
;;;1479       uip_flags = 0;
000ab4  2000              MOVS     r0,#0
000ab6  49ba              LDR      r1,|L10.3488|
000ab8  7008              STRB     r0,[r1,#0]
;;;1480       /* We do a very naive form of TCP reset processing; we just accept
;;;1481        any RST and kill our connection. We should in fact check if the
;;;1482        sequence number of this reset is wihtin our advertised window
;;;1483        before we accept the reset. */
;;;1484       if(BUF->flags & TCP_RST) 
000aba  48b3              LDR      r0,|L10.3464|
000abc  f890002f          LDRB     r0,[r0,#0x2f]
000ac0  f0000004          AND      r0,r0,#4
000ac4  b150              CBZ      r0,|L10.2780|
;;;1485       {
;;;1486           uip_connr->tcpstateflags = UIP_CLOSED;
000ac6  2000              MOVS     r0,#0
000ac8  7660              STRB     r0,[r4,#0x19]
;;;1487           UIP_LOG("tcp: got reset, aborting connection.");
000aca  a0b6              ADR      r0,|L10.3492|
000acc  f7fffffe          BL       uip_log
;;;1488           uip_flags = UIP_ABORT;
000ad0  2020              MOVS     r0,#0x20
000ad2  49b3              LDR      r1,|L10.3488|
000ad4  7008              STRB     r0,[r1,#0]
;;;1489           UIP_APPCALL();
000ad6  f7fffffe          BL       tcp_demo_appcall
;;;1490           goto drop;
000ada  e38f              B        |L10.4604|
                  |L10.2780|
;;;1491       }
;;;1492       /* Calculated the length of the data, if the application has sent
;;;1493        any data to us. */
;;;1494       c = (BUF->tcpoffset >> 4) << 2;
000adc  48aa              LDR      r0,|L10.3464|
000ade  f890002e          LDRB     r0,[r0,#0x2e]
000ae2  1100              ASRS     r0,r0,#4
000ae4  0080              LSLS     r0,r0,#2
000ae6  49a9              LDR      r1,|L10.3468|
000ae8  7008              STRB     r0,[r1,#0]
;;;1495       /* uip_len will contain the length of the actual TCP data. This is
;;;1496        calculated by subtracing the length of the TCP header (in
;;;1497        c) and the length of the IP header (20 bytes). */
;;;1498       uip_len = uip_len - c - UIP_IPH_LEN;
000aea  48ab              LDR      r0,|L10.3480|
000aec  8800              LDRH     r0,[r0,#0]  ; uip_len
000aee  7809              LDRB     r1,[r1,#0]  ; c
000af0  1a40              SUBS     r0,r0,r1
000af2  3814              SUBS     r0,r0,#0x14
000af4  49a8              LDR      r1,|L10.3480|
000af6  8008              STRH     r0,[r1,#0]
;;;1499   
;;;1500       /* First, check if the sequence number of the incoming packet is
;;;1501        what we're expecting next. If not, we send out an ACK with the
;;;1502        correct numbers in. */
;;;1503       if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
000af8  7e60              LDRB     r0,[r4,#0x19]
000afa  f000000f          AND      r0,r0,#0xf
000afe  2802              CMP      r0,#2
000b00  d106              BNE      |L10.2832|
000b02  48a1              LDR      r0,|L10.3464|
000b04  f890002f          LDRB     r0,[r0,#0x2f]
000b08  f000003f          AND      r0,r0,#0x3f
000b0c  2812              CMP      r0,#0x12
000b0e  d024              BEQ      |L10.2906|
                  |L10.2832|
;;;1504           ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) 
;;;1505       {
;;;1506           if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
000b10  48a1              LDR      r0,|L10.3480|
000b12  8800              LDRH     r0,[r0,#0]  ; uip_len
000b14  2800              CMP      r0,#0
000b16  dc05              BGT      |L10.2852|
000b18  489b              LDR      r0,|L10.3464|
000b1a  f890002f          LDRB     r0,[r0,#0x2f]
000b1e  f0000003          AND      r0,r0,#3
000b22  b1d0              CBZ      r0,|L10.2906|
                  |L10.2852|
;;;1507               (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
000b24  4898              LDR      r0,|L10.3464|
000b26  f8900026          LDRB     r0,[r0,#0x26]
000b2a  7a21              LDRB     r1,[r4,#8]
000b2c  4288              CMP      r0,r1
000b2e  d113              BNE      |L10.2904|
;;;1508               BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
000b30  4895              LDR      r0,|L10.3464|
000b32  f8901027          LDRB     r1,[r0,#0x27]
000b36  7a60              LDRB     r0,[r4,#9]
000b38  4281              CMP      r1,r0
000b3a  d10d              BNE      |L10.2904|
;;;1509               BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
000b3c  4892              LDR      r0,|L10.3464|
000b3e  f8901028          LDRB     r1,[r0,#0x28]
000b42  7aa0              LDRB     r0,[r4,#0xa]
000b44  4281              CMP      r1,r0
000b46  d107              BNE      |L10.2904|
;;;1510               BUF->seqno[3] != uip_connr->rcv_nxt[3])) 
000b48  488f              LDR      r0,|L10.3464|
000b4a  f8901029          LDRB     r1,[r0,#0x29]
000b4e  7ae0              LDRB     r0,[r4,#0xb]
000b50  4281              CMP      r1,r0
000b52  e000              B        |L10.2902|
                  |L10.2900|
000b54  e332              B        |L10.4540|
                  |L10.2902|
000b56  d000              BEQ      |L10.2906|
                  |L10.2904|
;;;1511           {
;;;1512               goto tcp_send_ack;
000b58  e2a2              B        |L10.4256|
                  |L10.2906|
;;;1513           }
;;;1514       }
;;;1515   
;;;1516     /* Next, check if the incoming segment acknowledges any outstanding
;;;1517        data. If so, we update the sequence number, reset the length of
;;;1518        the outstanding data, calculate RTT estimations, and reset the
;;;1519        retransmission timer. */
;;;1520       if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) 
000b5a  488b              LDR      r0,|L10.3464|
000b5c  f890002f          LDRB     r0,[r0,#0x2f]
000b60  f0000010          AND      r0,r0,#0x10
000b64  b3f0              CBZ      r0,|L10.3044|
000b66  8a20              LDRH     r0,[r4,#0x10]
000b68  b3e0              CBZ      r0,|L10.3044|
;;;1521       {
;;;1522           uip_add32(uip_connr->snd_nxt, uip_connr->len);
000b6a  8a21              LDRH     r1,[r4,#0x10]
000b6c  f104000c          ADD      r0,r4,#0xc
000b70  f7fffffe          BL       uip_add32
;;;1523   
;;;1524           if(BUF->ackno[0] == uip_acc32[0] &&
000b74  4884              LDR      r0,|L10.3464|
000b76  f890002a          LDRB     r0,[r0,#0x2a]
000b7a  4994              LDR      r1,|L10.3532|
000b7c  7809              LDRB     r1,[r1,#0]  ; uip_acc32
000b7e  4288              CMP      r0,r1
000b80  d145              BNE      |L10.3086|
;;;1525               BUF->ackno[1] == uip_acc32[1] &&
000b82  4881              LDR      r0,|L10.3464|
000b84  f890002b          LDRB     r0,[r0,#0x2b]
000b88  4990              LDR      r1,|L10.3532|
000b8a  7849              LDRB     r1,[r1,#1]  ; uip_acc32
000b8c  4288              CMP      r0,r1
000b8e  d13e              BNE      |L10.3086|
;;;1526               BUF->ackno[2] == uip_acc32[2] &&
000b90  487d              LDR      r0,|L10.3464|
000b92  f890002c          LDRB     r0,[r0,#0x2c]
000b96  498d              LDR      r1,|L10.3532|
000b98  7889              LDRB     r1,[r1,#2]  ; uip_acc32
000b9a  4288              CMP      r0,r1
000b9c  d137              BNE      |L10.3086|
;;;1527               BUF->ackno[3] == uip_acc32[3]) 
000b9e  487a              LDR      r0,|L10.3464|
000ba0  f890002d          LDRB     r0,[r0,#0x2d]
000ba4  4989              LDR      r1,|L10.3532|
000ba6  78c9              LDRB     r1,[r1,#3]  ; uip_acc32
000ba8  4288              CMP      r0,r1
000baa  d130              BNE      |L10.3086|
;;;1528           {
;;;1529               /* Update sequence number. */
;;;1530               uip_connr->snd_nxt[0] = uip_acc32[0];
000bac  4887              LDR      r0,|L10.3532|
000bae  7800              LDRB     r0,[r0,#0]  ; uip_acc32
000bb0  7320              STRB     r0,[r4,#0xc]
;;;1531               uip_connr->snd_nxt[1] = uip_acc32[1];
000bb2  4886              LDR      r0,|L10.3532|
000bb4  7841              LDRB     r1,[r0,#1]  ; uip_acc32
000bb6  7361              STRB     r1,[r4,#0xd]
;;;1532               uip_connr->snd_nxt[2] = uip_acc32[2];
000bb8  7881              LDRB     r1,[r0,#2]  ; uip_acc32
000bba  73a1              STRB     r1,[r4,#0xe]
;;;1533               uip_connr->snd_nxt[3] = uip_acc32[3];
000bbc  78c1              LDRB     r1,[r0,#3]  ; uip_acc32
000bbe  73e1              STRB     r1,[r4,#0xf]
;;;1534   	
;;;1535   
;;;1536               /* Do RTT estimation, unless we have done retransmissions. */
;;;1537               if(uip_connr->nrtx == 0) 
000bc0  7ee0              LDRB     r0,[r4,#0x1b]
000bc2  b9e8              CBNZ     r0,|L10.3072|
;;;1538               {
;;;1539                   signed char m;
;;;1540                   m = uip_connr->rto - uip_connr->timer;
000bc4  7e21              LDRB     r1,[r4,#0x18]
000bc6  7ea2              LDRB     r2,[r4,#0x1a]
000bc8  1a89              SUBS     r1,r1,r2
000bca  b248              SXTB     r0,r1
;;;1541                   /* This is taken directly from VJs original code in his paper */
;;;1542                   m = m - (uip_connr->sa >> 3);
000bcc  7da1              LDRB     r1,[r4,#0x16]
000bce  eba001e1          SUB      r1,r0,r1,ASR #3
000bd2  b248              SXTB     r0,r1
;;;1543                   uip_connr->sa += m;
000bd4  7da1              LDRB     r1,[r4,#0x16]
000bd6  4401              ADD      r1,r1,r0
000bd8  75a1              STRB     r1,[r4,#0x16]
;;;1544                   if(m < 0) 
000bda  2800              CMP      r0,#0
000bdc  da01              BGE      |L10.3042|
;;;1545                   {
;;;1546                       m = -m;
000bde  4241              RSBS     r1,r0,#0
000be0  b248              SXTB     r0,r1
                  |L10.3042|
;;;1547                   }
;;;1548                   m = m - (uip_connr->sv >> 2);
000be2  e000              B        |L10.3046|
                  |L10.3044|
000be4  e013              B        |L10.3086|
                  |L10.3046|
000be6  7de1              LDRB     r1,[r4,#0x17]
000be8  eba001a1          SUB      r1,r0,r1,ASR #2
000bec  b248              SXTB     r0,r1
;;;1549                   uip_connr->sv += m;
000bee  7de1              LDRB     r1,[r4,#0x17]
000bf0  4401              ADD      r1,r1,r0
000bf2  75e1              STRB     r1,[r4,#0x17]
;;;1550                   uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
000bf4  7de1              LDRB     r1,[r4,#0x17]
000bf6  7da2              LDRB     r2,[r4,#0x16]
000bf8  eb0101e2          ADD      r1,r1,r2,ASR #3
000bfc  7621              STRB     r1,[r4,#0x18]
;;;1551               }
000bfe  bf00              NOP      
                  |L10.3072|
;;;1552               /* Set the acknowledged flag. */
;;;1553               uip_flags = UIP_ACKDATA;
000c00  2001              MOVS     r0,#1
000c02  4967              LDR      r1,|L10.3488|
000c04  7008              STRB     r0,[r1,#0]
;;;1554               /* Reset the retransmission timer. */
;;;1555               uip_connr->timer = uip_connr->rto;
000c06  7e20              LDRB     r0,[r4,#0x18]
000c08  76a0              STRB     r0,[r4,#0x1a]
;;;1556   
;;;1557               /* Reset length of outstanding data. */
;;;1558               uip_connr->len = 0;
000c0a  2000              MOVS     r0,#0
000c0c  8220              STRH     r0,[r4,#0x10]
                  |L10.3086|
;;;1559           }
;;;1560       }
;;;1561   
;;;1562       /* Do different things depending on in what state the connection is. */
;;;1563       switch(uip_connr->tcpstateflags & UIP_TS_MASK) 
000c0e  7e60              LDRB     r0,[r4,#0x19]
000c10  f000000f          AND      r0,r0,#0xf
000c14  2809              CMP      r0,#9
000c16  d26a              BCS      |L10.3310|
000c18  e8dff000          TBB      [pc,r0]
000c1c  690525e6          DCB      0x69,0x05,0x25,0xe6
000c20  f6f5f4f3          DCB      0xf6,0xf5,0xf4,0xf3
000c24  b500              DCB      0xb5,0x00
;;;1564       {
;;;1565           /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
;;;1566           implemented, since we force the application to close when the
;;;1567           peer sends a FIN (hence the application goes directly from
;;;1568           ESTABLISHED to LAST_ACK). */
;;;1569           case UIP_SYN_RCVD:
;;;1570               /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
;;;1571                  we are waiting for an ACK that acknowledges the data we sent
;;;1572                  out the last time. Therefore, we want to have the UIP_ACKDATA
;;;1573                  flag set. If so, we enter the ESTABLISHED state. */
;;;1574               if(uip_flags & UIP_ACKDATA) 
000c26  485e              LDR      r0,|L10.3488|
000c28  7800              LDRB     r0,[r0,#0]  ; uip_flags
000c2a  f0000001          AND      r0,r0,#1
000c2e  b1c8              CBZ      r0,|L10.3172|
;;;1575               {
;;;1576                   uip_connr->tcpstateflags = UIP_ESTABLISHED;
000c30  2003              MOVS     r0,#3
000c32  7660              STRB     r0,[r4,#0x19]
;;;1577                   uip_flags = UIP_CONNECTED;
000c34  2040              MOVS     r0,#0x40
000c36  495a              LDR      r1,|L10.3488|
000c38  7008              STRB     r0,[r1,#0]
;;;1578                   uip_connr->len = 0;
000c3a  2000              MOVS     r0,#0
000c3c  8220              STRH     r0,[r4,#0x10]
;;;1579                   if(uip_len > 0) 
000c3e  4856              LDR      r0,|L10.3480|
000c40  8800              LDRH     r0,[r0,#0]  ; uip_len
000c42  2800              CMP      r0,#0
000c44  dd08              BLE      |L10.3160|
;;;1580                   {
;;;1581                       uip_flags |= UIP_NEWDATA;
000c46  4608              MOV      r0,r1
000c48  7800              LDRB     r0,[r0,#0]  ; uip_flags
000c4a  f0400002          ORR      r0,r0,#2
000c4e  7008              STRB     r0,[r1,#0]
;;;1582                       uip_add_rcv_nxt(uip_len);
000c50  4851              LDR      r0,|L10.3480|
000c52  8800              LDRH     r0,[r0,#0]  ; uip_len
000c54  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.3160|
;;;1583                   }
;;;1584                   uip_slen = 0;
000c58  2000              MOVS     r0,#0
000c5a  495d              LDR      r1,|L10.3536|
000c5c  8008              STRH     r0,[r1,#0]
;;;1585                   UIP_APPCALL();
000c5e  f7fffffe          BL       tcp_demo_appcall
;;;1586                   goto appsend;
000c62  e148              B        |L10.3830|
                  |L10.3172|
;;;1587               }
;;;1588               goto drop;
000c64  e2ca              B        |L10.4604|
;;;1589   #if UIP_ACTIVE_OPEN
;;;1590           case UIP_SYN_SENT:
;;;1591       /* In SYN_SENT, we wait for a SYNACK that is sent in response to
;;;1592          our SYN. The rcv_nxt is set to sequence number in the SYNACK
;;;1593          plus one, and we send an ACK. We move into the ESTABLISHED
;;;1594          state. */
;;;1595               if((uip_flags & UIP_ACKDATA) &&
000c66  484e              LDR      r0,|L10.3488|
000c68  7800              LDRB     r0,[r0,#0]  ; uip_flags
000c6a  f0000001          AND      r0,r0,#1
000c6e  b3e8              CBZ      r0,|L10.3308|
;;;1596                   (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) 
000c70  4845              LDR      r0,|L10.3464|
000c72  f890002f          LDRB     r0,[r0,#0x2f]
000c76  f000003f          AND      r0,r0,#0x3f
000c7a  2812              CMP      r0,#0x12
000c7c  d136              BNE      |L10.3308|
;;;1597               {
;;;1598                   /* Parse the TCP MSS option, if present. */
;;;1599                   if((BUF->tcpoffset & 0xf0) > 0x50)
000c7e  4842              LDR      r0,|L10.3464|
000c80  f890002e          LDRB     r0,[r0,#0x2e]
000c84  f00000f0          AND      r0,r0,#0xf0
000c88  2850              CMP      r0,#0x50
000c8a  dd5d              BLE      |L10.3400|
;;;1600                   {
;;;1601                       for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) 
000c8c  2000              MOVS     r0,#0
000c8e  493f              LDR      r1,|L10.3468|
000c90  7008              STRB     r0,[r1,#0]
000c92  e04d              B        |L10.3376|
                  |L10.3220|
;;;1602                       {
;;;1603                           opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
000c94  483d              LDR      r0,|L10.3468|
000c96  7800              LDRB     r0,[r0,#0]  ; c
000c98  3036              ADDS     r0,r0,#0x36
000c9a  493b              LDR      r1,|L10.3464|
000c9c  5c08              LDRB     r0,[r1,r0]
000c9e  493c              LDR      r1,|L10.3472|
000ca0  7008              STRB     r0,[r1,#0]
;;;1604                           if(opt == TCP_OPT_END) 
000ca2  4608              MOV      r0,r1
000ca4  7800              LDRB     r0,[r0,#0]  ; opt
000ca6  b900              CBNZ     r0,|L10.3242|
;;;1605                           {
;;;1606                               /* End of options. */
;;;1607                               break;
000ca8  e04d              B        |L10.3398|
                  |L10.3242|
;;;1608                           } else if(opt == TCP_OPT_NOOP) 
000caa  4839              LDR      r0,|L10.3472|
000cac  7800              LDRB     r0,[r0,#0]  ; opt
000cae  2801              CMP      r0,#1
000cb0  d105              BNE      |L10.3262|
;;;1609                           {
;;;1610                               ++c;
000cb2  4836              LDR      r0,|L10.3468|
000cb4  7800              LDRB     r0,[r0,#0]  ; c
000cb6  1c40              ADDS     r0,r0,#1
000cb8  4934              LDR      r1,|L10.3468|
000cba  7008              STRB     r0,[r1,#0]
000cbc  e038              B        |L10.3376|
                  |L10.3262|
;;;1611                               /* NOP option. */
;;;1612                           } else if(opt == TCP_OPT_MSS &&
000cbe  4834              LDR      r0,|L10.3472|
000cc0  7800              LDRB     r0,[r0,#0]  ; opt
000cc2  2802              CMP      r0,#2
000cc4  d123              BNE      |L10.3342|
;;;1613                               uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) 
000cc6  4831              LDR      r0,|L10.3468|
000cc8  7800              LDRB     r0,[r0,#0]  ; c
000cca  3037              ADDS     r0,r0,#0x37
000ccc  492e              LDR      r1,|L10.3464|
000cce  5c08              LDRB     r0,[r1,r0]
000cd0  2804              CMP      r0,#4
000cd2  d11c              BNE      |L10.3342|
;;;1614                           {
;;;1615                               /* An MSS option with the right option length. */
;;;1616                               tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
000cd4  482d              LDR      r0,|L10.3468|
000cd6  7800              LDRB     r0,[r0,#0]  ; c
000cd8  3039              ADDS     r0,r0,#0x39
000cda  5c09              LDRB     r1,[r1,r0]
000cdc  482b              LDR      r0,|L10.3468|
000cde  7800              LDRB     r0,[r0,#0]  ; c
000ce0  3038              ADDS     r0,r0,#0x38
000ce2  4a29              LDR      r2,|L10.3464|
000ce4  5c10              LDRB     r0,[r2,r0]
000ce6  ea412000          ORR      r0,r1,r0,LSL #8
000cea  e001              B        |L10.3312|
                  |L10.3308|
000cec  e072              B        |L10.3540|
                  |L10.3310|
000cee  e1d5              B        |L10.4252|
                  |L10.3312|
000cf0  4928              LDR      r1,|L10.3476|
000cf2  8008              STRH     r0,[r1,#0]
;;;1617                               uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
;;;1618                               uip_connr->initialmss =
000cf4  4608              MOV      r0,r1
000cf6  8800              LDRH     r0,[r0,#0]  ; tmp16
000cf8  f64071ca          MOV      r1,#0xfca
000cfc  4288              CMP      r0,r1
000cfe  dd01              BLE      |L10.3332|
;;;1619                               uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
000d00  4608              MOV      r0,r1
000d02  e001              B        |L10.3336|
                  |L10.3332|
000d04  4823              LDR      r0,|L10.3476|
000d06  8800              LDRH     r0,[r0,#0]  ; tmp16
                  |L10.3336|
000d08  8260              STRH     r0,[r4,#0x12]
000d0a  82a0              STRH     r0,[r4,#0x14]
;;;1620   
;;;1621                               /* And we are done processing options. */
;;;1622                               break;
000d0c  e01b              B        |L10.3398|
                  |L10.3342|
;;;1623                           }else 
;;;1624                           {
;;;1625                               /* All other options have a length field, so that we easily
;;;1626                               can skip past them. */
;;;1627                               if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) 
000d0e  481f              LDR      r0,|L10.3468|
000d10  7800              LDRB     r0,[r0,#0]  ; c
000d12  3037              ADDS     r0,r0,#0x37
000d14  491c              LDR      r1,|L10.3464|
000d16  5c08              LDRB     r0,[r1,r0]
000d18  b900              CBNZ     r0,|L10.3356|
;;;1628                               {
;;;1629                               /* If the length field is zero, the options are malformed
;;;1630                               and we don't process them further. */
;;;1631                               break;
000d1a  e014              B        |L10.3398|
                  |L10.3356|
;;;1632                               }
;;;1633                               c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
000d1c  481b              LDR      r0,|L10.3468|
000d1e  7800              LDRB     r0,[r0,#0]  ; c
000d20  3037              ADDS     r0,r0,#0x37
000d22  4919              LDR      r1,|L10.3464|
000d24  5c08              LDRB     r0,[r1,r0]
000d26  4919              LDR      r1,|L10.3468|
000d28  7809              LDRB     r1,[r1,#0]  ; c
000d2a  4408              ADD      r0,r0,r1
000d2c  4917              LDR      r1,|L10.3468|
000d2e  7008              STRB     r0,[r1,#0]
                  |L10.3376|
000d30  4815              LDR      r0,|L10.3464|
000d32  f890002e          LDRB     r0,[r0,#0x2e]         ;1601
000d36  2105              MOVS     r1,#5                 ;1601
000d38  ebc11020          RSB      r0,r1,r0,ASR #4       ;1601
000d3c  4913              LDR      r1,|L10.3468|
000d3e  7809              LDRB     r1,[r1,#0]            ;1601  ; c
000d40  ebb10f80          CMP      r1,r0,LSL #2          ;1601
000d44  dba6              BLT      |L10.3220|
                  |L10.3398|
000d46  bf00              NOP                            ;1607
                  |L10.3400|
;;;1634                           }
;;;1635                       }
;;;1636                   }
;;;1637                   uip_connr->tcpstateflags = UIP_ESTABLISHED;
000d48  2003              MOVS     r0,#3
000d4a  7660              STRB     r0,[r4,#0x19]
;;;1638                   uip_connr->rcv_nxt[0] = BUF->seqno[0];
000d4c  480e              LDR      r0,|L10.3464|
000d4e  f8900026          LDRB     r0,[r0,#0x26]
000d52  7220              STRB     r0,[r4,#8]
;;;1639                   uip_connr->rcv_nxt[1] = BUF->seqno[1];
000d54  480c              LDR      r0,|L10.3464|
000d56  f8901027          LDRB     r1,[r0,#0x27]
000d5a  7261              STRB     r1,[r4,#9]
;;;1640                   uip_connr->rcv_nxt[2] = BUF->seqno[2];
000d5c  f8901028          LDRB     r1,[r0,#0x28]
000d60  72a1              STRB     r1,[r4,#0xa]
;;;1641                   uip_connr->rcv_nxt[3] = BUF->seqno[3];
000d62  f8901029          LDRB     r1,[r0,#0x29]
000d66  72e1              STRB     r1,[r4,#0xb]
;;;1642                   uip_add_rcv_nxt(1);
000d68  2001              MOVS     r0,#1
000d6a  f7fffffe          BL       uip_add_rcv_nxt
;;;1643                   uip_flags = UIP_CONNECTED | UIP_NEWDATA;
000d6e  2042              MOVS     r0,#0x42
000d70  490b              LDR      r1,|L10.3488|
000d72  7008              STRB     r0,[r1,#0]
;;;1644                   uip_connr->len = 0;
000d74  2000              MOVS     r0,#0
000d76  8220              STRH     r0,[r4,#0x10]
;;;1645                   uip_len = 0;
000d78  4907              LDR      r1,|L10.3480|
000d7a  8008              STRH     r0,[r1,#0]
;;;1646                   uip_slen = 0;
000d7c  4914              LDR      r1,|L10.3536|
000d7e  8008              STRH     r0,[r1,#0]
;;;1647                   UIP_APPCALL();
000d80  f7fffffe          BL       tcp_demo_appcall
;;;1648                   goto appsend;
000d84  e0b7              B        |L10.3830|
000d86  e11a              B        |L10.4030|
                  |L10.3464|
                          DCD      uip_buf
                  |L10.3468|
                          DCD      c
                  |L10.3472|
                          DCD      opt
                  |L10.3476|
                          DCD      tmp16
                  |L10.3480|
                          DCD      uip_len
                  |L10.3484|
                          DCD      uip_conn
                  |L10.3488|
                          DCD      uip_flags
                  |L10.3492|
000da4  7463703a          DCB      "tcp: got reset, aborting connection.",0
000da8  20676f74
000dac  20726573
000db0  65742c20
000db4  61626f72
000db8  74696e67
000dbc  20636f6e
000dc0  6e656374
000dc4  696f6e2e
000dc8  00      
000dc9  00                DCB      0
000dca  00                DCB      0
000dcb  00                DCB      0
                  |L10.3532|
                          DCD      uip_acc32
                  |L10.3536|
                          DCD      uip_slen
                  |L10.3540|
;;;1649               }
;;;1650               /* Inform the application that the connection failed */
;;;1651               uip_flags = UIP_ABORT;
000dd4  2020              MOVS     r0,#0x20
000dd6  49fe              LDR      r1,|L10.4560|
000dd8  7008              STRB     r0,[r1,#0]
;;;1652               UIP_APPCALL();
000dda  f7fffffe          BL       tcp_demo_appcall
;;;1653               /* The connection is closed after we send the RST */
;;;1654               uip_conn->tcpstateflags = UIP_CLOSED;
000dde  2000              MOVS     r0,#0
000de0  49fc              LDR      r1,|L10.4564|
000de2  6809              LDR      r1,[r1,#0]  ; uip_conn
000de4  7648              STRB     r0,[r1,#0x19]
;;;1655               goto reset;
000de6  e47f              B        |L10.1768|
;;;1656   #endif /* UIP_ACTIVE_OPEN */
;;;1657       
;;;1658           case UIP_ESTABLISHED:
;;;1659           /* In the ESTABLISHED state, we call upon the application to feed
;;;1660           data into the uip_buf. If the UIP_ACKDATA flag is set, the
;;;1661           application should put new data into the buffer, otherwise we are
;;;1662           retransmitting an old segment, and the application should put that
;;;1663           data into the buffer.
;;;1664   
;;;1665           If the incoming packet is a FIN, we should close the connection on
;;;1666           this side as well, and we send out a FIN and enter the LAST_ACK
;;;1667           state. We require that there is no outstanding data; otherwise the
;;;1668           sequence numbers will be screwed up. */
;;;1669   
;;;1670               if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) 
000de8  48fb              LDR      r0,|L10.4568|
000dea  f890002f          LDRB     r0,[r0,#0x2f]
000dee  f0000001          AND      r0,r0,#1
000df2  b370              CBZ      r0,|L10.3666|
000df4  7e60              LDRB     r0,[r4,#0x19]
000df6  f0000010          AND      r0,r0,#0x10
000dfa  bb50              CBNZ     r0,|L10.3666|
;;;1671               {
;;;1672                   if(uip_outstanding(uip_connr)) {
000dfc  8a20              LDRH     r0,[r4,#0x10]
000dfe  b128              CBZ      r0,|L10.3596|
;;;1673                       goto drop;
000e00  e1fc              B        |L10.4604|
000e02  e140              B        |L10.4230|
000e04  e140              B        |L10.4232|
000e06  e11d              B        |L10.4164|
000e08  e0e6              B        |L10.4056|
                  |L10.3594|
000e0a  e1b2              B        |L10.4466|
                  |L10.3596|
;;;1674                   }
;;;1675                   uip_add_rcv_nxt(1 + uip_len);
000e0c  49f3              LDR      r1,|L10.4572|
000e0e  8809              LDRH     r1,[r1,#0]  ; uip_len
000e10  1c49              ADDS     r1,r1,#1
000e12  b288              UXTH     r0,r1
000e14  f7fffffe          BL       uip_add_rcv_nxt
;;;1676                   uip_flags |= UIP_CLOSE;
000e18  48ed              LDR      r0,|L10.4560|
000e1a  7800              LDRB     r0,[r0,#0]  ; uip_flags
000e1c  f0400010          ORR      r0,r0,#0x10
000e20  49eb              LDR      r1,|L10.4560|
000e22  7008              STRB     r0,[r1,#0]
;;;1677                   if(uip_len > 0) {
000e24  48ed              LDR      r0,|L10.4572|
000e26  8800              LDRH     r0,[r0,#0]  ; uip_len
000e28  2800              CMP      r0,#0
000e2a  dd04              BLE      |L10.3638|
;;;1678                       uip_flags |= UIP_NEWDATA;
000e2c  4608              MOV      r0,r1
000e2e  7800              LDRB     r0,[r0,#0]  ; uip_flags
000e30  f0400002          ORR      r0,r0,#2
000e34  7008              STRB     r0,[r1,#0]
                  |L10.3638|
;;;1679                   }
;;;1680                   UIP_APPCALL();
000e36  f7fffffe          BL       tcp_demo_appcall
;;;1681                   uip_connr->len = 1;
000e3a  2001              MOVS     r0,#1
000e3c  8220              STRH     r0,[r4,#0x10]
;;;1682                   uip_connr->tcpstateflags = UIP_LAST_ACK;
000e3e  2008              MOVS     r0,#8
000e40  7660              STRB     r0,[r4,#0x19]
;;;1683                   uip_connr->nrtx = 0;
000e42  2000              MOVS     r0,#0
000e44  76e0              STRB     r0,[r4,#0x1b]
;;;1684       tcp_send_finack:
000e46  bf00              NOP      
                  |L10.3656|
;;;1685                   BUF->flags = TCP_FIN | TCP_ACK;
000e48  2111              MOVS     r1,#0x11
000e4a  48e3              LDR      r0,|L10.4568|
000e4c  f880102f          STRB     r1,[r0,#0x2f]
;;;1686                   goto tcp_send_nodata;
000e50  e12b              B        |L10.4266|
                  |L10.3666|
000e52  e7ff              B        |L10.3668|
                  |L10.3668|
;;;1687               }
;;;1688   
;;;1689               /* Check the URG flag. If this is set, the segment carries urgent
;;;1690                  data that we must pass to the application. */
;;;1691               if((BUF->flags & TCP_URG) != 0) 
000e54  48e0              LDR      r0,|L10.4568|
000e56  f890002f          LDRB     r0,[r0,#0x2f]
000e5a  f0000020          AND      r0,r0,#0x20
000e5e  b1b8              CBZ      r0,|L10.3728|
;;;1692               {
;;;1693   #if UIP_URGDATA > 0
;;;1694                   uip_urglen = (BUF->urgp[0] << 8) | BUF->urgp[1];
;;;1695                   if(uip_urglen > uip_len) {
;;;1696                       /* There is more urgent data in the next segment to come. */
;;;1697                       uip_urglen = uip_len;
;;;1698                   }
;;;1699                   uip_add_rcv_nxt(uip_urglen);
;;;1700                   uip_len -= uip_urglen;
;;;1701                   uip_urgdata = uip_appdata;
;;;1702                   uip_appdata += uip_urglen;
;;;1703               }else 
;;;1704               {
;;;1705                   uip_urglen = 0;
;;;1706   #else /* UIP_URGDATA > 0 */
;;;1707                   uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
000e60  48dd              LDR      r0,|L10.4568|
000e62  f8901035          LDRB     r1,[r0,#0x35]
000e66  f8900034          LDRB     r0,[r0,#0x34]
000e6a  ea412000          ORR      r0,r1,r0,LSL #8
000e6e  49dc              LDR      r1,|L10.4576|
000e70  6809              LDR      r1,[r1,#0]  ; uip_appdata
000e72  4408              ADD      r0,r0,r1
000e74  49da              LDR      r1,|L10.4576|
000e76  6008              STR      r0,[r1,#0]  ; uip_appdata
;;;1708                   uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
000e78  48d7              LDR      r0,|L10.4568|
000e7a  f8901035          LDRB     r1,[r0,#0x35]
000e7e  f8900034          LDRB     r0,[r0,#0x34]
000e82  ea412000          ORR      r0,r1,r0,LSL #8
000e86  49d5              LDR      r1,|L10.4572|
000e88  8809              LDRH     r1,[r1,#0]  ; uip_len
000e8a  1a08              SUBS     r0,r1,r0
000e8c  49d3              LDR      r1,|L10.4572|
000e8e  8008              STRH     r0,[r1,#0]
                  |L10.3728|
;;;1709   #endif /* UIP_URGDATA > 0 */
;;;1710               }
;;;1711   
;;;1712               /* If uip_len > 0 we have TCP data in the packet, and we flag this
;;;1713                  by setting the UIP_NEWDATA flag and update the sequence number
;;;1714                  we acknowledge. If the application has stopped the dataflow
;;;1715                  using uip_stop(), we must not accept any data packets from the
;;;1716                  remote host. */
;;;1717               if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) 
000e90  48d2              LDR      r0,|L10.4572|
000e92  8800              LDRH     r0,[r0,#0]  ; uip_len
000e94  2800              CMP      r0,#0
000e96  dd0d              BLE      |L10.3764|
000e98  7e60              LDRB     r0,[r4,#0x19]
000e9a  f0000010          AND      r0,r0,#0x10
000e9e  b948              CBNZ     r0,|L10.3764|
;;;1718               {
;;;1719                   uip_flags |= UIP_NEWDATA;
000ea0  48cb              LDR      r0,|L10.4560|
000ea2  7800              LDRB     r0,[r0,#0]  ; uip_flags
000ea4  f0400002          ORR      r0,r0,#2
000ea8  49c9              LDR      r1,|L10.4560|
000eaa  7008              STRB     r0,[r1,#0]
;;;1720                   uip_add_rcv_nxt(uip_len);
000eac  48cb              LDR      r0,|L10.4572|
000eae  8800              LDRH     r0,[r0,#0]  ; uip_len
000eb0  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.3764|
;;;1721               }
;;;1722   
;;;1723               /* Check if the available buffer space advertised by the other end
;;;1724                  is smaller than the initial MSS for this connection. If so, we
;;;1725                  set the current MSS to the window size to ensure that the
;;;1726                  application does not send more data than the other end can
;;;1727                  handle.
;;;1728   
;;;1729                  If the remote host advertises a zero window, we set the MSS to
;;;1730                  the initial MSS so that the application will send an entire MSS
;;;1731                  of data. This data will not be acknowledged by the receiver,
;;;1732                  and the application will retransmit it. This is called the
;;;1733                  "persistent timer" and uses the retransmission mechanim.
;;;1734               */
;;;1735               tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
000eb4  48c8              LDR      r0,|L10.4568|
000eb6  f8901031          LDRB     r1,[r0,#0x31]
000eba  f8900030          LDRB     r0,[r0,#0x30]
000ebe  eb012000          ADD      r0,r1,r0,LSL #8
000ec2  49c8              LDR      r1,|L10.4580|
000ec4  8008              STRH     r0,[r1,#0]
;;;1736               if(tmp16 > uip_connr->initialmss ||
000ec6  8aa0              LDRH     r0,[r4,#0x14]
000ec8  8809              LDRH     r1,[r1,#0]  ; tmp16
000eca  4288              CMP      r0,r1
000ecc  db02              BLT      |L10.3796|
;;;1737                   tmp16 == 0) 
000ece  48c5              LDR      r0,|L10.4580|
000ed0  8800              LDRH     r0,[r0,#0]  ; tmp16
000ed2  b910              CBNZ     r0,|L10.3802|
                  |L10.3796|
;;;1738               {
;;;1739                   tmp16 = uip_connr->initialmss;
000ed4  8aa0              LDRH     r0,[r4,#0x14]
000ed6  49c3              LDR      r1,|L10.4580|
000ed8  8008              STRH     r0,[r1,#0]
                  |L10.3802|
;;;1740               }
;;;1741               uip_connr->mss = tmp16;
000eda  48c2              LDR      r0,|L10.4580|
000edc  8800              LDRH     r0,[r0,#0]  ; tmp16
000ede  8260              STRH     r0,[r4,#0x12]
;;;1742   
;;;1743               /* If this packet constitutes an ACK for outstanding data (flagged
;;;1744                  by the UIP_ACKDATA flag, we should call the application since it
;;;1745                  might want to send more data. If the incoming packet had data
;;;1746                  from the peer (as flagged by the UIP_NEWDATA flag), the
;;;1747                  application must also be notified.
;;;1748   
;;;1749                  When the application is called, the global variable uip_len
;;;1750                  contains the length of the incoming data. The application can
;;;1751                  access the incoming data through the global pointer
;;;1752                  uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN
;;;1753                  bytes into the uip_buf array.
;;;1754   
;;;1755                  If the application wishes to send any data, this data should be
;;;1756                  put into the uip_appdata and the length of the data should be
;;;1757                  put into uip_len. If the application don't have any data to
;;;1758                  send, uip_len must be set to 0. */
;;;1759               if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) 
000ee0  48bb              LDR      r0,|L10.4560|
000ee2  7800              LDRB     r0,[r0,#0]  ; uip_flags
000ee4  f0000003          AND      r0,r0,#3
000ee8  b3f0              CBZ      r0,|L10.3944|
;;;1760               {
;;;1761                   uip_slen = 0;
000eea  2000              MOVS     r0,#0
000eec  49be              LDR      r1,|L10.4584|
000eee  8008              STRH     r0,[r1,#0]
;;;1762                   UIP_APPCALL();
000ef0  f7fffffe          BL       tcp_demo_appcall
;;;1763       appsend:
000ef4  bf00              NOP      
                  |L10.3830|
;;;1764         
;;;1765                   if(uip_flags & UIP_ABORT) 
000ef6  48b6              LDR      r0,|L10.4560|
000ef8  7800              LDRB     r0,[r0,#0]  ; uip_flags
000efa  f0000020          AND      r0,r0,#0x20
000efe  b140              CBZ      r0,|L10.3858|
;;;1766                   {
;;;1767                       uip_slen = 0;
000f00  2000              MOVS     r0,#0
000f02  49b9              LDR      r1,|L10.4584|
000f04  8008              STRH     r0,[r1,#0]
;;;1768                       uip_connr->tcpstateflags = UIP_CLOSED;
000f06  7660              STRB     r0,[r4,#0x19]
;;;1769                       BUF->flags = TCP_RST | TCP_ACK;
000f08  2114              MOVS     r1,#0x14
000f0a  48b3              LDR      r0,|L10.4568|
000f0c  f880102f          STRB     r1,[r0,#0x2f]
;;;1770                       goto tcp_send_nodata;
000f10  e0cb              B        |L10.4266|
                  |L10.3858|
;;;1771                   }
;;;1772   
;;;1773                   if(uip_flags & UIP_CLOSE) 
000f12  48af              LDR      r0,|L10.4560|
000f14  7800              LDRB     r0,[r0,#0]  ; uip_flags
000f16  f0000010          AND      r0,r0,#0x10
000f1a  b168              CBZ      r0,|L10.3896|
;;;1774                   {
;;;1775                       uip_slen = 0;
000f1c  2000              MOVS     r0,#0
000f1e  49b2              LDR      r1,|L10.4584|
000f20  8008              STRH     r0,[r1,#0]
;;;1776                       uip_connr->len = 1;
000f22  2001              MOVS     r0,#1
000f24  8220              STRH     r0,[r4,#0x10]
;;;1777                       uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
000f26  2004              MOVS     r0,#4
000f28  7660              STRB     r0,[r4,#0x19]
;;;1778                       uip_connr->nrtx = 0;
000f2a  2000              MOVS     r0,#0
000f2c  76e0              STRB     r0,[r4,#0x1b]
;;;1779                       BUF->flags = TCP_FIN | TCP_ACK;
000f2e  2111              MOVS     r1,#0x11
000f30  48a9              LDR      r0,|L10.4568|
000f32  f880102f          STRB     r1,[r0,#0x2f]
;;;1780                       goto tcp_send_nodata;
000f36  e0b8              B        |L10.4266|
                  |L10.3896|
;;;1781                   }
;;;1782   
;;;1783                   /* If uip_slen > 0, the application has data to be sent. */
;;;1784                   if(uip_slen > 0) 
000f38  48ab              LDR      r0,|L10.4584|
000f3a  8800              LDRH     r0,[r0,#0]  ; uip_slen
000f3c  2800              CMP      r0,#0
000f3e  dd19              BLE      |L10.3956|
;;;1785                   {
;;;1786   
;;;1787                       /* If the connection has acknowledged data, the contents of
;;;1788                          the ->len variable should be discarded. */
;;;1789                       if((uip_flags & UIP_ACKDATA) != 0) {
000f40  48a3              LDR      r0,|L10.4560|
000f42  7800              LDRB     r0,[r0,#0]  ; uip_flags
000f44  f0000001          AND      r0,r0,#1
000f48  b108              CBZ      r0,|L10.3918|
;;;1790                         uip_connr->len = 0;
000f4a  2000              MOVS     r0,#0
000f4c  8220              STRH     r0,[r4,#0x10]
                  |L10.3918|
;;;1791                       }
;;;1792   
;;;1793                       /* If the ->len variable is non-zero the connection has
;;;1794                          already data in transit and cannot send anymore right
;;;1795                          now. */
;;;1796                       if(uip_connr->len == 0) 
000f4e  8a20              LDRH     r0,[r4,#0x10]
000f50  b968              CBNZ     r0,|L10.3950|
;;;1797                       {
;;;1798                           /* The application cannot send more than what is allowed by
;;;1799                            the mss (the minumum of the MSS and the available
;;;1800                            window). */
;;;1801                           if(uip_slen > uip_connr->mss) 
000f52  8a60              LDRH     r0,[r4,#0x12]
000f54  49a4              LDR      r1,|L10.4584|
000f56  8809              LDRH     r1,[r1,#0]  ; uip_slen
000f58  4288              CMP      r0,r1
000f5a  da02              BGE      |L10.3938|
;;;1802                           {
;;;1803                               uip_slen = uip_connr->mss;
000f5c  8a60              LDRH     r0,[r4,#0x12]
000f5e  49a2              LDR      r1,|L10.4584|
000f60  8008              STRH     r0,[r1,#0]
                  |L10.3938|
;;;1804                           }
;;;1805   
;;;1806                           /* Remember how much data we send out now so that we know
;;;1807                            when everything has been acknowledged. */
;;;1808                           uip_connr->len = uip_slen;
000f62  48a1              LDR      r0,|L10.4584|
000f64  8800              LDRH     r0,[r0,#0]  ; uip_slen
000f66  e000              B        |L10.3946|
                  |L10.3944|
000f68  e028              B        |L10.4028|
                  |L10.3946|
000f6a  8220              STRH     r0,[r4,#0x10]
000f6c  e002              B        |L10.3956|
                  |L10.3950|
;;;1809                       }else 
;;;1810                       {
;;;1811   
;;;1812                           /* If the application already had unacknowledged data, we
;;;1813                            make sure that the application does not send (i.e.,
;;;1814                            retransmit) out more than it previously sent out. */
;;;1815                           uip_slen = uip_connr->len;
000f6e  8a20              LDRH     r0,[r4,#0x10]
000f70  499d              LDR      r1,|L10.4584|
000f72  8008              STRH     r0,[r1,#0]
                  |L10.3956|
;;;1816                       }
;;;1817                   }
;;;1818                   uip_connr->nrtx = 0;
000f74  2000              MOVS     r0,#0
000f76  76e0              STRB     r0,[r4,#0x1b]
;;;1819       apprexmit:
000f78  bf00              NOP      
                  |L10.3962|
;;;1820                   uip_appdata = uip_sappdata;
000f7a  489c              LDR      r0,|L10.4588|
000f7c  6800              LDR      r0,[r0,#0]  ; uip_sappdata
000f7e  4998              LDR      r1,|L10.4576|
000f80  6008              STR      r0,[r1,#0]  ; uip_appdata
;;;1821         
;;;1822                   /* If the application has data to be sent, or if the incoming
;;;1823                       packet had new data in it, we must send out a packet. */
;;;1824                   if(uip_slen > 0 && uip_connr->len > 0) 
000f82  4899              LDR      r0,|L10.4584|
000f84  8800              LDRH     r0,[r0,#0]  ; uip_slen
000f86  2800              CMP      r0,#0
000f88  dd0b              BLE      |L10.4002|
000f8a  8a20              LDRH     r0,[r4,#0x10]
000f8c  2800              CMP      r0,#0
000f8e  dd08              BLE      |L10.4002|
;;;1825                   {
;;;1826                       /* Add the length of the IP and TCP headers. */
;;;1827                       uip_len = uip_connr->len + UIP_TCPIP_HLEN;
000f90  8a20              LDRH     r0,[r4,#0x10]
000f92  3028              ADDS     r0,r0,#0x28
000f94  4991              LDR      r1,|L10.4572|
000f96  8008              STRH     r0,[r1,#0]
;;;1828                       /* We always set the ACK flag in response packets. */
;;;1829                       BUF->flags = TCP_ACK | TCP_PSH;
000f98  2118              MOVS     r1,#0x18
000f9a  488f              LDR      r0,|L10.4568|
000f9c  f880102f          STRB     r1,[r0,#0x2f]
;;;1830                       /* Send the packet. */
;;;1831                       goto tcp_send_noopts;
000fa0  e087              B        |L10.4274|
                  |L10.4002|
;;;1832                   }
;;;1833                   /* If there is no data to send, just send out a pure ACK if
;;;1834                   there is newdata. */
;;;1835                   if(uip_flags & UIP_NEWDATA) 
000fa2  488b              LDR      r0,|L10.4560|
000fa4  7800              LDRB     r0,[r0,#0]  ; uip_flags
000fa6  f0000002          AND      r0,r0,#2
000faa  b138              CBZ      r0,|L10.4028|
;;;1836                   {
;;;1837                       uip_len = UIP_TCPIP_HLEN;
000fac  2028              MOVS     r0,#0x28
000fae  498b              LDR      r1,|L10.4572|
000fb0  8008              STRH     r0,[r1,#0]
;;;1838                       BUF->flags = TCP_ACK;
000fb2  2110              MOVS     r1,#0x10
000fb4  4888              LDR      r0,|L10.4568|
000fb6  f880102f          STRB     r1,[r0,#0x2f]
;;;1839                       goto tcp_send_noopts;
000fba  e07a              B        |L10.4274|
                  |L10.4028|
;;;1840                   }
;;;1841               }
;;;1842               goto drop;
000fbc  e11e              B        |L10.4604|
                  |L10.4030|
;;;1843           case UIP_LAST_ACK:
;;;1844               /* We can close this connection if the peer has acknowledged our
;;;1845                  FIN. This is indicated by the UIP_ACKDATA flag. */
;;;1846               if(uip_flags & UIP_ACKDATA) 
000fbe  4884              LDR      r0,|L10.4560|
000fc0  7800              LDRB     r0,[r0,#0]  ; uip_flags
000fc2  f0000001          AND      r0,r0,#1
000fc6  b130              CBZ      r0,|L10.4054|
;;;1847               {
;;;1848                   uip_connr->tcpstateflags = UIP_CLOSED;
000fc8  2000              MOVS     r0,#0
000fca  7660              STRB     r0,[r4,#0x19]
;;;1849                   uip_flags = UIP_CLOSE;
000fcc  2010              MOVS     r0,#0x10
000fce  4980              LDR      r1,|L10.4560|
000fd0  7008              STRB     r0,[r1,#0]
;;;1850                   UIP_APPCALL();
000fd2  f7fffffe          BL       tcp_demo_appcall
                  |L10.4054|
;;;1851               }
;;;1852               break;
000fd6  e061              B        |L10.4252|
                  |L10.4056|
;;;1853       
;;;1854           case UIP_FIN_WAIT_1:
;;;1855               /* The application has closed the connection, but the remote host
;;;1856                   hasn't closed its end yet. Thus we do nothing but wait for a
;;;1857                   FIN from the other side. */
;;;1858               if(uip_len > 0) 
000fd8  4880              LDR      r0,|L10.4572|
000fda  8800              LDRH     r0,[r0,#0]  ; uip_len
000fdc  2800              CMP      r0,#0
000fde  dd03              BLE      |L10.4072|
;;;1859               {
;;;1860                   uip_add_rcv_nxt(uip_len);
000fe0  487e              LDR      r0,|L10.4572|
000fe2  8800              LDRH     r0,[r0,#0]  ; uip_len
000fe4  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.4072|
;;;1861               }
;;;1862               if(BUF->flags & TCP_FIN) {
000fe8  487b              LDR      r0,|L10.4568|
000fea  f890002f          LDRB     r0,[r0,#0x2f]
000fee  f0000001          AND      r0,r0,#1
000ff2  b1b8              CBZ      r0,|L10.4132|
;;;1863                   if(uip_flags & UIP_ACKDATA) 
000ff4  4876              LDR      r0,|L10.4560|
000ff6  7800              LDRB     r0,[r0,#0]  ; uip_flags
000ff8  e000              B        |L10.4092|
                  |L10.4090|
000ffa  e0a1              B        |L10.4416|
                  |L10.4092|
000ffc  f0000001          AND      r0,r0,#1
001000  b128              CBZ      r0,|L10.4110|
;;;1864                   {
;;;1865                       uip_connr->tcpstateflags = UIP_TIME_WAIT;
001002  2007              MOVS     r0,#7
001004  7660              STRB     r0,[r4,#0x19]
;;;1866                       uip_connr->timer = 0;
001006  2000              MOVS     r0,#0
001008  76a0              STRB     r0,[r4,#0x1a]
;;;1867                       uip_connr->len = 0;
00100a  8220              STRH     r0,[r4,#0x10]
00100c  e001              B        |L10.4114|
                  |L10.4110|
;;;1868                   } else {
;;;1869                       uip_connr->tcpstateflags = UIP_CLOSING;
00100e  2006              MOVS     r0,#6
001010  7660              STRB     r0,[r4,#0x19]
                  |L10.4114|
;;;1870                   }
;;;1871                   uip_add_rcv_nxt(1);
001012  2001              MOVS     r0,#1
001014  f7fffffe          BL       uip_add_rcv_nxt
;;;1872                   uip_flags = UIP_CLOSE;
001018  2010              MOVS     r0,#0x10
00101a  496d              LDR      r1,|L10.4560|
00101c  7008              STRB     r0,[r1,#0]
;;;1873                   UIP_APPCALL();
00101e  f7fffffe          BL       tcp_demo_appcall
;;;1874                   goto tcp_send_ack;
001022  e03d              B        |L10.4256|
                  |L10.4132|
;;;1875               } else if(uip_flags & UIP_ACKDATA) 
001024  486a              LDR      r0,|L10.4560|
001026  7800              LDRB     r0,[r0,#0]  ; uip_flags
001028  f0000001          AND      r0,r0,#1
00102c  b120              CBZ      r0,|L10.4152|
;;;1876               {
;;;1877                   uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
00102e  2005              MOVS     r0,#5
001030  7660              STRB     r0,[r4,#0x19]
;;;1878                   uip_connr->len = 0;
001032  2000              MOVS     r0,#0
001034  8220              STRH     r0,[r4,#0x10]
;;;1879                   goto drop;
001036  e0e1              B        |L10.4604|
                  |L10.4152|
;;;1880               }
;;;1881               if(uip_len > 0) 
001038  4868              LDR      r0,|L10.4572|
00103a  8800              LDRH     r0,[r0,#0]  ; uip_len
00103c  2800              CMP      r0,#0
00103e  dd00              BLE      |L10.4162|
;;;1882               {
;;;1883                   goto tcp_send_ack;
001040  e02e              B        |L10.4256|
                  |L10.4162|
;;;1884               }
;;;1885               goto drop;
001042  e0db              B        |L10.4604|
                  |L10.4164|
;;;1886         
;;;1887           case UIP_FIN_WAIT_2:
;;;1888               if(uip_len > 0) 
001044  4865              LDR      r0,|L10.4572|
001046  8800              LDRH     r0,[r0,#0]  ; uip_len
001048  2800              CMP      r0,#0
00104a  dd03              BLE      |L10.4180|
;;;1889               {
;;;1890                   uip_add_rcv_nxt(uip_len);
00104c  4863              LDR      r0,|L10.4572|
00104e  8800              LDRH     r0,[r0,#0]  ; uip_len
001050  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.4180|
;;;1891               }
;;;1892               if(BUF->flags & TCP_FIN) 
001054  4860              LDR      r0,|L10.4568|
001056  f890002f          LDRB     r0,[r0,#0x2f]
00105a  f0000001          AND      r0,r0,#1
00105e  b160              CBZ      r0,|L10.4218|
;;;1893               {
;;;1894                   uip_connr->tcpstateflags = UIP_TIME_WAIT;
001060  2007              MOVS     r0,#7
001062  7660              STRB     r0,[r4,#0x19]
;;;1895                   uip_connr->timer = 0;
001064  2000              MOVS     r0,#0
001066  76a0              STRB     r0,[r4,#0x1a]
;;;1896                   uip_add_rcv_nxt(1);
001068  2001              MOVS     r0,#1
00106a  f7fffffe          BL       uip_add_rcv_nxt
;;;1897                   uip_flags = UIP_CLOSE;
00106e  2010              MOVS     r0,#0x10
001070  4957              LDR      r1,|L10.4560|
001072  7008              STRB     r0,[r1,#0]
;;;1898                   UIP_APPCALL();
001074  f7fffffe          BL       tcp_demo_appcall
;;;1899                   goto tcp_send_ack;
001078  e012              B        |L10.4256|
                  |L10.4218|
;;;1900               }
;;;1901               if(uip_len > 0) 
00107a  4858              LDR      r0,|L10.4572|
00107c  8800              LDRH     r0,[r0,#0]  ; uip_len
00107e  2800              CMP      r0,#0
001080  dd00              BLE      |L10.4228|
;;;1902               {
;;;1903                   goto tcp_send_ack;
001082  e00d              B        |L10.4256|
                  |L10.4228|
;;;1904               }
;;;1905               goto drop;
001084  e0ba              B        |L10.4604|
                  |L10.4230|
;;;1906   
;;;1907           case UIP_TIME_WAIT:
;;;1908               goto tcp_send_ack;
001086  e00b              B        |L10.4256|
                  |L10.4232|
;;;1909       
;;;1910           case UIP_CLOSING:
;;;1911               if(uip_flags & UIP_ACKDATA) {
001088  4851              LDR      r0,|L10.4560|
00108a  7800              LDRB     r0,[r0,#0]  ; uip_flags
00108c  f0000001          AND      r0,r0,#1
001090  b118              CBZ      r0,|L10.4250|
;;;1912                   uip_connr->tcpstateflags = UIP_TIME_WAIT;
001092  2007              MOVS     r0,#7
001094  7660              STRB     r0,[r4,#0x19]
;;;1913                   uip_connr->timer = 0;
001096  2000              MOVS     r0,#0
001098  76a0              STRB     r0,[r4,#0x1a]
                  |L10.4250|
00109a  bf00              NOP                            ;1563
                  |L10.4252|
00109c  bf00              NOP                            ;1852
;;;1914               }
;;;1915       }
;;;1916       goto drop;
00109e  e0ad              B        |L10.4604|
                  |L10.4256|
;;;1917     
;;;1918   
;;;1919       /* We jump here when we are ready to send the packet, and just want
;;;1920        to set the appropriate TCP sequence numbers in the TCP header. */
;;;1921    tcp_send_ack:
;;;1922       BUF->flags = TCP_ACK;
0010a0  2110              MOVS     r1,#0x10
0010a2  484d              LDR      r0,|L10.4568|
0010a4  f880102f          STRB     r1,[r0,#0x2f]
;;;1923    tcp_send_nodata:
0010a8  bf00              NOP      
                  |L10.4266|
;;;1924       uip_len = UIP_IPTCPH_LEN;
0010aa  2028              MOVS     r0,#0x28
0010ac  494b              LDR      r1,|L10.4572|
0010ae  8008              STRH     r0,[r1,#0]
;;;1925    tcp_send_noopts:
0010b0  bf00              NOP      
                  |L10.4274|
;;;1926       BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
0010b2  2150              MOVS     r1,#0x50
0010b4  4848              LDR      r0,|L10.4568|
0010b6  f880102e          STRB     r1,[r0,#0x2e]
;;;1927    tcp_send:
0010ba  bf00              NOP      
                  |L10.4284|
;;;1928       /* We're done with the input processing. We are now ready to send a
;;;1929        reply. Our job is to fill in all the fields of the TCP and IP
;;;1930        headers before calculating the checksum and finally send the
;;;1931        packet. */
;;;1932       BUF->ackno[0] = uip_connr->rcv_nxt[0];
0010bc  7a21              LDRB     r1,[r4,#8]
0010be  4846              LDR      r0,|L10.4568|
0010c0  f880102a          STRB     r1,[r0,#0x2a]
;;;1933       BUF->ackno[1] = uip_connr->rcv_nxt[1];
0010c4  7a61              LDRB     r1,[r4,#9]
0010c6  f880102b          STRB     r1,[r0,#0x2b]
;;;1934       BUF->ackno[2] = uip_connr->rcv_nxt[2];
0010ca  7aa1              LDRB     r1,[r4,#0xa]
0010cc  f880102c          STRB     r1,[r0,#0x2c]
;;;1935       BUF->ackno[3] = uip_connr->rcv_nxt[3];
0010d0  7ae1              LDRB     r1,[r4,#0xb]
0010d2  f880102d          STRB     r1,[r0,#0x2d]
;;;1936     
;;;1937       BUF->seqno[0] = uip_connr->snd_nxt[0];
0010d6  7b21              LDRB     r1,[r4,#0xc]
0010d8  f8801026          STRB     r1,[r0,#0x26]
;;;1938       BUF->seqno[1] = uip_connr->snd_nxt[1];
0010dc  7b61              LDRB     r1,[r4,#0xd]
0010de  f8801027          STRB     r1,[r0,#0x27]
;;;1939       BUF->seqno[2] = uip_connr->snd_nxt[2];
0010e2  7ba1              LDRB     r1,[r4,#0xe]
0010e4  f8801028          STRB     r1,[r0,#0x28]
;;;1940       BUF->seqno[3] = uip_connr->snd_nxt[3];
0010e8  7be1              LDRB     r1,[r4,#0xf]
0010ea  f8801029          STRB     r1,[r0,#0x29]
;;;1941   
;;;1942       BUF->proto = UIP_PROTO_TCP;
0010ee  2106              MOVS     r1,#6
0010f0  75c1              STRB     r1,[r0,#0x17]
;;;1943   
;;;1944       BUF->srcport  = uip_connr->lport;
0010f2  88a1              LDRH     r1,[r4,#4]
0010f4  8441              STRH     r1,[r0,#0x22]
;;;1945       BUF->destport = uip_connr->rport;
0010f6  88e1              LDRH     r1,[r4,#6]
0010f8  8481              STRH     r1,[r0,#0x24]
;;;1946   
;;;1947       uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
0010fa  bf00              NOP      
0010fc  483c              LDR      r0,|L10.4592|
0010fe  8801              LDRH     r1,[r0,#0]  ; uip_hostaddr
001100  4835              LDR      r0,|L10.4568|
001102  8341              STRH     r1,[r0,#0x1a]
001104  483a              LDR      r0,|L10.4592|
001106  8841              LDRH     r1,[r0,#2]  ; uip_hostaddr
001108  4833              LDR      r0,|L10.4568|
00110a  8381              STRH     r1,[r0,#0x1c]
00110c  bf00              NOP      
;;;1948       uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);
00110e  bf00              NOP      
001110  8821              LDRH     r1,[r4,#0]
001112  83c1              STRH     r1,[r0,#0x1e]
001114  8861              LDRH     r1,[r4,#2]
001116  8401              STRH     r1,[r0,#0x20]
001118  bf00              NOP      
;;;1949   
;;;1950       if(uip_connr->tcpstateflags & UIP_STOPPED) 
00111a  7e60              LDRB     r0,[r4,#0x19]
00111c  f0000010          AND      r0,r0,#0x10
001120  b130              CBZ      r0,|L10.4400|
;;;1951       {
;;;1952           /* If the connection has issued uip_stop(), we advertise a zero
;;;1953          window so that the remote host will stop sending data. */
;;;1954           BUF->wnd[0] = BUF->wnd[1] = 0;
001122  2100              MOVS     r1,#0
001124  482c              LDR      r0,|L10.4568|
001126  f8801031          STRB     r1,[r0,#0x31]
00112a  f8801030          STRB     r1,[r0,#0x30]
00112e  e006              B        |L10.4414|
                  |L10.4400|
;;;1955       }else 
;;;1956       {
;;;1957           BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
001130  210f              MOVS     r1,#0xf
001132  4829              LDR      r0,|L10.4568|
001134  f8801030          STRB     r1,[r0,#0x30]
;;;1958           BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
001138  21ca              MOVS     r1,#0xca
00113a  f8801031          STRB     r1,[r0,#0x31]
                  |L10.4414|
;;;1959       }
;;;1960   
;;;1961    tcp_send_noconn:
00113e  bf00              NOP      
                  |L10.4416|
;;;1962       BUF->ttl = UIP_TTL;
001140  2140              MOVS     r1,#0x40
001142  4825              LDR      r0,|L10.4568|
001144  7581              STRB     r1,[r0,#0x16]
;;;1963   #if UIP_CONF_IPV6
;;;1964       /* For IPv6, the IP length field does not include the IPv6 IP header
;;;1965        length. */
;;;1966       BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
;;;1967       BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
;;;1968   #else /* UIP_CONF_IPV6 */
;;;1969       BUF->len[0] = (uip_len >> 8);
001146  4825              LDR      r0,|L10.4572|
001148  8800              LDRH     r0,[r0,#0]  ; uip_len
00114a  1201              ASRS     r1,r0,#8
00114c  4822              LDR      r0,|L10.4568|
00114e  7401              STRB     r1,[r0,#0x10]
;;;1970       BUF->len[1] = (uip_len & 0xff);
001150  4822              LDR      r0,|L10.4572|
001152  7801              LDRB     r1,[r0,#0]  ; uip_len
001154  4820              LDR      r0,|L10.4568|
001156  7441              STRB     r1,[r0,#0x11]
;;;1971   #endif /* UIP_CONF_IPV6 */
;;;1972   
;;;1973       BUF->urgp[0] = BUF->urgp[1] = 0;
001158  2100              MOVS     r1,#0
00115a  f8801035          STRB     r1,[r0,#0x35]
00115e  f8801034          STRB     r1,[r0,#0x34]
;;;1974     
;;;1975       /* Calculate TCP checksum. */
;;;1976       BUF->tcpchksum = 0;
001162  8641              STRH     r1,[r0,#0x32]
;;;1977       BUF->tcpchksum = ~(uip_tcpchksum());
001164  f7fffffe          BL       uip_tcpchksum
001168  43c0              MVNS     r0,r0
00116a  b281              UXTH     r1,r0
00116c  481a              LDR      r0,|L10.4568|
00116e  8641              STRH     r1,[r0,#0x32]
;;;1978   //==================================================================================
;;;1979   
;;;1980   // IP 发射：  这里进入了IP 发射层
;;;1981   #if UIP_UDP
;;;1982    ip_send_nolen:
001170  bf00              NOP      
                  |L10.4466|
;;;1983   #endif
;;;1984   
;;;1985   //1. 到达这里的都是UDP 和 TCP 数据，要在这里进行IP层的封装
;;;1986   
;;;1987   //#if UIP_CONF_IPV6
;;;1988   //  BUF->vtc = 0x60;
;;;1989   //  BUF->tcflow = 0x00;
;;;1990   //  BUF->flow = 0x00;
;;;1991   //#else /* UIP_CONF_IPV6 */
;;;1992   
;;;1993           //此处暂时注释掉IPV6的代码
;;;1994       
;;;1995     //对IP首部的各个字段的值进行赋值
;;;1996       BUF->vhl = 0x45;
001172  2045              MOVS     r0,#0x45
001174  4918              LDR      r1,|L10.4568|
001176  7388              STRB     r0,[r1,#0xe]
;;;1997       BUF->tos = 0;
001178  2100              MOVS     r1,#0
00117a  4817              LDR      r0,|L10.4568|
00117c  73c1              STRB     r1,[r0,#0xf]
;;;1998       BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
00117e  7541              STRB     r1,[r0,#0x15]
001180  7501              STRB     r1,[r0,#0x14]
;;;1999       ++ipid;
001182  481c              LDR      r0,|L10.4596|
001184  8800              LDRH     r0,[r0,#0]  ; ipid
001186  1c40              ADDS     r0,r0,#1
001188  491a              LDR      r1,|L10.4596|
00118a  8008              STRH     r0,[r1,#0]
;;;2000       BUF->ipid[0] = ipid >> 8;
00118c  4608              MOV      r0,r1
00118e  8800              LDRH     r0,[r0,#0]  ; ipid
001190  1201              ASRS     r1,r0,#8
001192  4811              LDR      r0,|L10.4568|
001194  7481              STRB     r1,[r0,#0x12]
;;;2001       BUF->ipid[1] = ipid & 0xff;
001196  4817              LDR      r0,|L10.4596|
001198  7801              LDRB     r1,[r0,#0]  ; ipid
00119a  480f              LDR      r0,|L10.4568|
00119c  74c1              STRB     r1,[r0,#0x13]
;;;2002       /* Calculate IP checksum. */
;;;2003       BUF->ipchksum = 0;
00119e  2100              MOVS     r1,#0
0011a0  8301              STRH     r1,[r0,#0x18]
;;;2004       BUF->ipchksum = ~(uip_ipchksum());
0011a2  f7fffffe          BL       uip_ipchksum
0011a6  43c0              MVNS     r0,r0
0011a8  b281              UXTH     r1,r0
0011aa  480b              LDR      r0,|L10.4568|
0011ac  8301              STRH     r1,[r0,#0x18]
;;;2005       DEBUG_PRINTF("uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum());
;;;2006   //#endif /* UIP_CONF_IPV6 */
;;;2007      
;;;2008       UIP_STAT(++uip_stat.tcp.sent);
0011ae  4812              LDR      r0,|L10.4600|
0011b0  8bc0              LDRH     r0,[r0,#0x1e]
0011b2  1c40              ADDS     r0,r0,#1
0011b4  b281              UXTH     r1,r0
0011b6  4810              LDR      r0,|L10.4600|
0011b8  83c1              STRH     r1,[r0,#0x1e]
;;;2009   //2.凡是到达这里的  封装完毕，进行发送。但是此处并没有硬件发送，而是这个函数返回后立刻调用 ARP 函数添加以太网帧头
;;;2010    send:
0011ba  bf00              NOP      
                  |L10.4540|
;;;2011       DEBUG_PRINTF("Sending packet with length %d (%d)\n", uip_len,
;;;2012   	       (BUF->len[0] << 8) | BUF->len[1]);
;;;2013     
;;;2014       UIP_STAT(++uip_stat.ip.sent);
0011bc  480e              LDR      r0,|L10.4600|
0011be  8880              LDRH     r0,[r0,#4]  ; uip_stat
0011c0  1c40              ADDS     r0,r0,#1
0011c2  490d              LDR      r1,|L10.4600|
0011c4  8088              STRH     r0,[r1,#4]
;;;2015     /* Return and let the caller do the actual transmission. */
;;;2016       uip_flags = 0;
0011c6  2000              MOVS     r0,#0
0011c8  4901              LDR      r1,|L10.4560|
0011ca  7008              STRB     r0,[r1,#0]
;;;2017       return;
;;;2018   //==================================================================================
;;;2019    drop:
;;;2020       uip_len = 0;
;;;2021       uip_flags = 0;
;;;2022       return;
;;;2023   }
0011cc  bd70              POP      {r4-r6,pc}
0011ce  0000              DCW      0x0000
                  |L10.4560|
                          DCD      uip_flags
                  |L10.4564|
                          DCD      uip_conn
                  |L10.4568|
                          DCD      uip_buf
                  |L10.4572|
                          DCD      uip_len
                  |L10.4576|
                          DCD      uip_appdata
                  |L10.4580|
                          DCD      tmp16
                  |L10.4584|
                          DCD      uip_slen
                  |L10.4588|
                          DCD      uip_sappdata
                  |L10.4592|
                          DCD      uip_hostaddr
                  |L10.4596|
                          DCD      ipid
                  |L10.4600|
                          DCD      uip_stat
                  |L10.4604|
0011fc  2000              MOVS     r0,#0                 ;2020
0011fe  4903              LDR      r1,|L10.4620|
001200  8008              STRH     r0,[r1,#0]            ;2020
001202  4903              LDR      r1,|L10.4624|
001204  7008              STRB     r0,[r1,#0]            ;2021
001206  bf00              NOP                            ;2022
001208  bd70              POP      {r4-r6,pc}
;;;2024   /*---------------------------------------------------------------------------*/
                          ENDP

00120a  0000              DCW      0x0000
                  |L10.4620|
                          DCD      uip_len
                  |L10.4624|
                          DCD      uip_flags

                          AREA ||i.uip_send||, CODE, READONLY, ALIGN=2

                  uip_send PROC
;;;2031   void
;;;2032   uip_send(const void *data, int len)
000000  b570              PUSH     {r4-r6,lr}
;;;2033   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2034     if(len > 0) {
000006  2d00              CMP      r5,#0
000008  dd0c              BLE      |L11.36|
;;;2035       uip_slen = len;
00000a  4907              LDR      r1,|L11.40|
00000c  800d              STRH     r5,[r1,#0]
;;;2036       if(data != uip_sappdata) {
00000e  4807              LDR      r0,|L11.44|
000010  6800              LDR      r0,[r0,#0]  ; uip_sappdata
000012  4284              CMP      r4,r0
000014  d006              BEQ      |L11.36|
;;;2037         memcpy(uip_sappdata, (data), uip_slen);
000016  4608              MOV      r0,r1
000018  8802              LDRH     r2,[r0,#0]  ; uip_slen
00001a  4621              MOV      r1,r4
00001c  4803              LDR      r0,|L11.44|
00001e  6800              LDR      r0,[r0,#0]  ; uip_sappdata
000020  f7fffffe          BL       __aeabi_memcpy
                  |L11.36|
;;;2038       }
;;;2039     }
;;;2040   }
000024  bd70              POP      {r4-r6,pc}
;;;2041   /** @} */
                          ENDP

000026  0000              DCW      0x0000
                  |L11.40|
                          DCD      uip_slen
                  |L11.44|
                          DCD      uip_sappdata

                          AREA ||i.uip_setipid||, CODE, READONLY, ALIGN=2

                  uip_setipid PROC
;;;181    
;;;182    void uip_setipid(u16_t id) { ipid = id; }
000000  4901              LDR      r1,|L12.8|
000002  8008              STRH     r0,[r1,#0]
000004  4770              BX       lr
;;;183    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ipid

                          AREA ||i.uip_tcpchksum||, CODE, READONLY, ALIGN=1

                  uip_tcpchksum PROC
;;;364    u16_t
;;;365    uip_tcpchksum(void)
000000  b510              PUSH     {r4,lr}
;;;366    {
;;;367      return upper_layer_chksum(UIP_PROTO_TCP);
000002  2006              MOVS     r0,#6
000004  f7fffffe          BL       upper_layer_chksum
;;;368    }
000008  bd10              POP      {r4,pc}
;;;369    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.uip_udp_new||, CODE, READONLY, ALIGN=2

                  uip_udp_new PROC
;;;473    struct uip_udp_conn_constr *
;;;474    uip_udp_new(uip_ipaddr_t *ripaddr, u16_t rport)
000000  b530              PUSH     {r4,r5,lr}
;;;475    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;476      register struct uip_udp_conn_constr *conn;
;;;477      
;;;478      /* Find an unused local port. */
;;;479     again:
000006  bf00              NOP      
                  |L14.8|
;;;480      ++lastport;
000008  4830              LDR      r0,|L14.204|
00000a  8800              LDRH     r0,[r0,#0]  ; lastport
00000c  1c40              ADDS     r0,r0,#1
00000e  492f              LDR      r1,|L14.204|
000010  8008              STRH     r0,[r1,#0]
;;;481    
;;;482      if(lastport >= 32000) {
000012  4608              MOV      r0,r1
000014  8800              LDRH     r0,[r0,#0]  ; lastport
000016  f5b04ffa          CMP      r0,#0x7d00
00001a  db02              BLT      |L14.34|
;;;483        lastport = 4096;
00001c  f44f5080          MOV      r0,#0x1000
000020  8008              STRH     r0,[r1,#0]
                  |L14.34|
;;;484      }
;;;485      
;;;486      for(c = 0; c < UIP_UDP_CONNS; ++c) {
000022  2000              MOVS     r0,#0
000024  492a              LDR      r1,|L14.208|
000026  7008              STRB     r0,[r1,#0]
000028  e013              B        |L14.82|
                  |L14.42|
;;;487        if(uip_udp_conns[c].lport == htons(lastport)) {
00002a  4828              LDR      r0,|L14.204|
00002c  8800              LDRH     r0,[r0,#0]  ; lastport
00002e  f7fffffe          BL       htons
000032  4927              LDR      r1,|L14.208|
000034  7809              LDRB     r1,[r1,#0]  ; c
000036  eb010181          ADD      r1,r1,r1,LSL #2
00003a  4d26              LDR      r5,|L14.212|
00003c  eb050141          ADD      r1,r5,r1,LSL #1
000040  8889              LDRH     r1,[r1,#4]
000042  4288              CMP      r0,r1
000044  d100              BNE      |L14.72|
;;;488          goto again;
000046  e7df              B        |L14.8|
                  |L14.72|
000048  4821              LDR      r0,|L14.208|
00004a  7800              LDRB     r0,[r0,#0]            ;486  ; c
00004c  1c40              ADDS     r0,r0,#1              ;486
00004e  4920              LDR      r1,|L14.208|
000050  7008              STRB     r0,[r1,#0]            ;486
                  |L14.82|
000052  481f              LDR      r0,|L14.208|
000054  7800              LDRB     r0,[r0,#0]            ;486  ; c
000056  280a              CMP      r0,#0xa               ;486
000058  dbe7              BLT      |L14.42|
;;;489        }
;;;490      }
;;;491    
;;;492    
;;;493      conn = 0;
00005a  2200              MOVS     r2,#0
;;;494      for(c = 0; c < UIP_UDP_CONNS; ++c) {
00005c  2000              MOVS     r0,#0
00005e  491c              LDR      r1,|L14.208|
000060  7008              STRB     r0,[r1,#0]
000062  e014              B        |L14.142|
                  |L14.100|
;;;495        if(uip_udp_conns[c].lport == 0) {
000064  481a              LDR      r0,|L14.208|
000066  7800              LDRB     r0,[r0,#0]  ; c
000068  eb000080          ADD      r0,r0,r0,LSL #2
00006c  4919              LDR      r1,|L14.212|
00006e  eb010040          ADD      r0,r1,r0,LSL #1
000072  8880              LDRH     r0,[r0,#4]
000074  b930              CBNZ     r0,|L14.132|
;;;496          conn = &uip_udp_conns[c];
000076  4816              LDR      r0,|L14.208|
000078  7800              LDRB     r0,[r0,#0]  ; c
00007a  eb000080          ADD      r0,r0,r0,LSL #2
00007e  eb010240          ADD      r2,r1,r0,LSL #1
;;;497          break;
000082  e008              B        |L14.150|
                  |L14.132|
000084  4812              LDR      r0,|L14.208|
000086  7800              LDRB     r0,[r0,#0]            ;494  ; c
000088  1c40              ADDS     r0,r0,#1              ;494
00008a  4911              LDR      r1,|L14.208|
00008c  7008              STRB     r0,[r1,#0]            ;494
                  |L14.142|
00008e  4810              LDR      r0,|L14.208|
000090  7800              LDRB     r0,[r0,#0]            ;494  ; c
000092  280a              CMP      r0,#0xa               ;494
000094  dbe6              BLT      |L14.100|
                  |L14.150|
000096  bf00              NOP      
;;;498        }
;;;499      }
;;;500    
;;;501      if(conn == 0) {
000098  b90a              CBNZ     r2,|L14.158|
;;;502        return 0;
00009a  2000              MOVS     r0,#0
                  |L14.156|
;;;503      }
;;;504      
;;;505      conn->lport = HTONS(lastport);
;;;506      conn->rport = rport;
;;;507      if(ripaddr == NULL) {
;;;508        memset(conn->ripaddr, 0, sizeof(uip_ipaddr_t));
;;;509      } else {
;;;510        uip_ipaddr_copy(&conn->ripaddr, ripaddr);
;;;511      }
;;;512      conn->ttl = UIP_TTL;
;;;513      
;;;514      return conn;
;;;515    }
00009c  bd30              POP      {r4,r5,pc}
                  |L14.158|
00009e  480b              LDR      r0,|L14.204|
0000a0  7800              LDRB     r0,[r0,#0]            ;505  ; lastport
0000a2  0200              LSLS     r0,r0,#8              ;505
0000a4  4909              LDR      r1,|L14.204|
0000a6  8809              LDRH     r1,[r1,#0]            ;505  ; lastport
0000a8  ea402021          ORR      r0,r0,r1,ASR #8       ;505
0000ac  8090              STRH     r0,[r2,#4]            ;505
0000ae  80d4              STRH     r4,[r2,#6]            ;506
0000b0  b913              CBNZ     r3,|L14.184|
0000b2  2000              MOVS     r0,#0                 ;508
0000b4  6010              STR      r0,[r2,#0]            ;508
0000b6  e005              B        |L14.196|
                  |L14.184|
0000b8  bf00              NOP                            ;510
0000ba  8818              LDRH     r0,[r3,#0]            ;510
0000bc  8010              STRH     r0,[r2,#0]            ;510
0000be  8858              LDRH     r0,[r3,#2]            ;510
0000c0  8050              STRH     r0,[r2,#2]            ;510
0000c2  bf00              NOP                            ;510
                  |L14.196|
0000c4  2040              MOVS     r0,#0x40              ;512
0000c6  7210              STRB     r0,[r2,#8]            ;512
0000c8  4610              MOV      r0,r2                 ;514
0000ca  e7e7              B        |L14.156|
;;;516    #endif /* UIP_UDP */
                          ENDP

                  |L14.204|
                          DCD      lastport
                  |L14.208|
                          DCD      c
                  |L14.212|
                          DCD      uip_udp_conns

                          AREA ||i.uip_udpchksum||, CODE, READONLY, ALIGN=1

                  uip_udpchksum PROC
;;;371    u16_t
;;;372    uip_udpchksum(void)
000000  b510              PUSH     {r4,lr}
;;;373    {
;;;374      return upper_layer_chksum(UIP_PROTO_UDP);
000002  2011              MOVS     r0,#0x11
000004  f7fffffe          BL       upper_layer_chksum
;;;375    }
000008  bd10              POP      {r4,pc}
;;;376    #endif /* UIP_UDP_CHECKSUMS */
                          ENDP


                          AREA ||i.uip_unlisten||, CODE, READONLY, ALIGN=2

                  uip_unlisten PROC
;;;518    void
;;;519    uip_unlisten(u16_t port)
000000  2100              MOVS     r1,#0
;;;520    {
;;;521      for(c = 0; c < UIP_LISTENPORTS; ++c) {
000002  4a0e              LDR      r2,|L16.60|
000004  7011              STRB     r1,[r2,#0]
000006  e012              B        |L16.46|
                  |L16.8|
;;;522        if(uip_listenports[c] == port) {
000008  490d              LDR      r1,|L16.64|
00000a  4a0c              LDR      r2,|L16.60|
00000c  7812              LDRB     r2,[r2,#0]  ; c
00000e  f8311012          LDRH     r1,[r1,r2,LSL #1]
000012  4281              CMP      r1,r0
000014  d106              BNE      |L16.36|
;;;523          uip_listenports[c] = 0;
000016  2100              MOVS     r1,#0
000018  4a09              LDR      r2,|L16.64|
00001a  4b08              LDR      r3,|L16.60|
00001c  781b              LDRB     r3,[r3,#0]  ; c
00001e  f8221013          STRH     r1,[r2,r3,LSL #1]
                  |L16.34|
;;;524          return;
;;;525        }
;;;526      }
;;;527    }
000022  4770              BX       lr
                  |L16.36|
000024  4905              LDR      r1,|L16.60|
000026  7809              LDRB     r1,[r1,#0]            ;521  ; c
000028  1c49              ADDS     r1,r1,#1              ;521
00002a  4a04              LDR      r2,|L16.60|
00002c  7011              STRB     r1,[r2,#0]            ;521
                  |L16.46|
00002e  4903              LDR      r1,|L16.60|
000030  7809              LDRB     r1,[r1,#0]            ;521  ; c
000032  2928              CMP      r1,#0x28              ;521
000034  dbe8              BLT      |L16.8|
000036  bf00              NOP      
000038  e7f3              B        |L16.34|
;;;528    /*---------------------------------------------------------------------------*/
                          ENDP

00003a  0000              DCW      0x0000
                  |L16.60|
                          DCD      c
                  |L16.64|
                          DCD      uip_listenports

                          AREA ||i.upper_layer_chksum||, CODE, READONLY, ALIGN=2

                  upper_layer_chksum PROC
;;;329    static u16_t
;;;330    upper_layer_chksum(u8_t proto)
000000  b570              PUSH     {r4-r6,lr}
;;;331    {
000002  4604              MOV      r4,r0
;;;332      u16_t upper_layer_len;
;;;333      u16_t sum;
;;;334      
;;;335    #if UIP_CONF_IPV6
;;;336      upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
;;;337    #else /* UIP_CONF_IPV6 */
;;;338      upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
000004  480f              LDR      r0,|L17.68|
000006  7c41              LDRB     r1,[r0,#0x11]
000008  7c00              LDRB     r0,[r0,#0x10]
00000a  eb012000          ADD      r0,r1,r0,LSL #8
00000e  3814              SUBS     r0,r0,#0x14
000010  b285              UXTH     r5,r0
;;;339    #endif /* UIP_CONF_IPV6 */
;;;340      
;;;341      /* First sum pseudoheader. */
;;;342      
;;;343      /* IP protocol and length fields. This addition cannot carry. */
;;;344      sum = upper_layer_len + proto;
000012  1928              ADDS     r0,r5,r4
000014  b286              UXTH     r6,r0
;;;345      /* Sum IP source and destination addresses. */
;;;346      sum = chksum(sum, (u8_t *)&BUF->srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
000016  2208              MOVS     r2,#8
000018  490a              LDR      r1,|L17.68|
00001a  311a              ADDS     r1,r1,#0x1a
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       chksum
000022  4606              MOV      r6,r0
;;;347    
;;;348      /* Sum TCP header and data. */
;;;349      sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
000024  462a              MOV      r2,r5
000026  4907              LDR      r1,|L17.68|
000028  3122              ADDS     r1,r1,#0x22
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       chksum
000030  4606              MOV      r6,r0
;;;350    	       upper_layer_len);
;;;351        
;;;352      return (sum == 0) ? 0xffff : htons(sum);
000032  b916              CBNZ     r6,|L17.58|
000034  f64f70ff          MOV      r0,#0xffff
                  |L17.56|
;;;353    }
000038  bd70              POP      {r4-r6,pc}
                  |L17.58|
00003a  4630              MOV      r0,r6                 ;352
00003c  f7fffffe          BL       htons
000040  e7fa              B        |L17.56|
;;;354    /*---------------------------------------------------------------------------*/
                          ENDP

000042  0000              DCW      0x0000
                  |L17.68|
                          DCD      uip_buf

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uip_buf
                          %        4100
                  uip_conns
                          %        1600
                  uip_listenports
                          %        80
                  uip_udp_conns
                          %        100
                  uip_stat
                          %        52

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  all_ones_addr
000000  ffffffff          DCW      0xffff,0xffff
                  all_zeroes_addr
000004  00000000          DCW      0x0000,0x0000

                          AREA ||.data||, DATA, ALIGN=2

                  uip_hostaddr
                          DCD      0x00000000
                  uip_draddr
                          DCD      0x00000000
                  uip_netmask
                          DCD      0x00000000
                  uip_ethaddr
00000c  04023500          DCB      0x04,0x02,0x35,0x00
000010  00010000          DCB      0x00,0x01,0x00,0x00
                  uip_appdata
                          DCD      0x00000000
                  uip_sappdata
                          DCD      0x00000000
                  uip_len
00001c  0000              DCB      0x00,0x00
                  uip_slen
00001e  0000              DCB      0x00,0x00
                  uip_flags
000020  00000000          DCB      0x00,0x00,0x00,0x00
                  uip_conn
                          DCD      0x00000000
                  uip_udp_conn
                          DCD      0x00000000
                  ipid
00002c  0000              DCB      0x00,0x00
                  iss
00002e  0000              DCB      0x00,0x00
000030  0000              DCB      0x00,0x00
                  lastport
000032  0000              DCB      0x00,0x00
                  uip_acc32
                          DCD      0x00000000
                  c
000038  00                DCB      0x00
                  opt
000039  00                DCB      0x00
                  tmp16
00003a  0000              DCB      0x00,0x00
